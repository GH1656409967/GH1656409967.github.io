[{"content":"èµ·å›  æœ€è¿‘åœ¨ç”¨éœé¹œæ–‡æ¥·(LXGW WenKai)ï¼Œé…åˆä¸ŠPaperModè¿™ç§å¼ºè°ƒæ–‡å­—çš„ä¸»é¢˜ï¼Œåœ¨è§‚æ„Ÿä¸Šå¾ˆä¸é”™ï¼Œäºæ˜¯å†³å®šè½¬åˆ°Hugoã€‚Hugoçš„æ–‡æ¡£å’Œèµ„æ–™ä¸å¤ªå®¹æ˜“æ‰¾ï¼Œä¸­æ–‡æ”¯æŒä¹Ÿå°‘ï¼Œä¸­é—´é‡åˆ°ä¸å°‘éº»çƒ¦ï¼Œè®°å½•ä¸‹è§£å†³è¿‡ç¨‹ï¼Œç»™é‡åˆ°åŒæ ·é—®é¢˜çš„äººä¸€äº›å‚è€ƒã€‚\nå®‰è£… GOï¼šå®˜ç½‘ä¸‹è½½ï¼Œä¸€é”®å®‰è£…ã€‚ Hugoï¼šGitHubä¸‹è½½ï¼Œæ·»åŠ ç¯å¢ƒå˜é‡ã€‚ 1\u0026gt; hugo version 2hugo v0.114.0-9df2ec7988e5a217a14901cc76c0b7e76b2e9f02+extended windows/amd64 BuildDate=2023-06-19T17:01:43Z VendorInfo=gohugoio ä¸»é¢˜ PaperMod æ‰§è¡Œhugo new site \u0026lt;blog\u0026gt;åˆ›å»ºåšå®¢ç›®å½•ï¼Œç›®å½•ç»“æ„å¦‚ä¸‹ï¼š\n1 archetypes/ # å†…å®¹æ¨¡æ¿æ–‡ä»¶ 2 assets/ # é™æ€èµ„æº 3 content/ # åšå®¢å†…å®¹ 4 data/ 5 layouts/ # ç½‘ç«™ç”Ÿæˆæ¨¡ç‰ˆ 6 public/ # é¡¹ç›®å¯¼å‡ºæ–‡ä»¶ 7 resources/ 8 static/ # é™æ€æ–‡ä»¶ 9 themes/ # ä¸»é¢˜ 10 hugo.toml # é…ç½®æ–‡ä»¶ é»˜è®¤ä¸å¸¦ä¸»é¢˜ï¼Œå¯ä»¥åˆ°Hugoå®˜ç½‘ä¸»é¢˜æ·˜ä¸€æ·˜ã€‚æœ¬æ–‡ä½¿ç”¨PaperModï¼Œå°†ä»£ç ç›´æ¥ä¸‹è½½ä¸‹æ¥ï¼Œæ”¾åˆ°themes/ä¸‹ã€‚å½“ç„¶ä¹Ÿå¯ä»¥git cloneï¼Œä½†æ˜¯themes/.git/å½±å“åšå®¢æºç çš„æäº¤ï¼Œä»¥åŠå¯¹åº”çš„æºç éƒ¨ç½²æ–¹å¼ï¼Œä¹Ÿå¯èƒ½å¯¼è‡´æ–‡æœ«å‡ºç°çš„CSSåŠ è½½å¤±è´¥é—®é¢˜ã€‚\nä½¿ç”¨ hugo server å¯åŠ¨æœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè®¿é—®http://localhost:1313/æŸ¥çœ‹é¡µé¢ã€‚ä½¿ç”¨hugoç”Ÿæˆç½‘é¡µæ–‡ä»¶è‡³publicç›®å½•ã€‚\né…ç½® hugo.tomlï¼ˆå¿…çœ‹ï¼‰ ç«™ç‚¹ç›®å½•çš„é…ç½®ä¼˜å…ˆçº§é«˜ï¼Œä¼šè¦†ç›–ä¸»é¢˜ä¸­çš„é…ç½®ã€‚æ‰€æœ‰åœ¨ä¸»é¢˜æ–‡ä»¶å¤¹ä¸­çš„æ”¹åŠ¨ï¼Œéƒ½å¯ä»¥å…ˆå°†å®ƒå¤åˆ¶åˆ°ç«™ç‚¹ç›®å½•å¯¹åº”æ–‡ä»¶å¤¹ä¸‹ï¼Œå†ä½œå…¶ä»–ä¿®æ”¹ã€‚è¿™æ ·ä¸»é¢˜æ›´æ–°çš„æ—¶å€™ï¼Œè‡ªå®šä¹‰æ”¹åŠ¨å°±ä¸ä¼šä¸¢å¤±ã€‚\né…ç½®æ–‡ä»¶æ”¯æŒ.tomlã€.yamlç­‰ã€‚Hugoæ¨è.tomlï¼Œä½†æ˜¯PaperModæ¨è.yamlã€‚ç½‘ä¸Š.tomlçš„æ¯”è¾ƒå°‘ï¼Œæœ¬æ–‡ä½¿ç”¨è¿™ç§ã€‚é…ç½®é¡¹çš„å…·ä½“å«ä¹‰ï¼Œè¯·æŸ¥é˜…Hugoçš„å®˜æ–¹æ–‡æ¡£å’ŒPaperModçš„é…ç½®wikiã€‚\nä»¥ä¸‹ä¸º/hugo.tomlé…ç½®å‚è€ƒï¼š\n1# baseURL = \u0026#39;http://localhost:1313/\u0026#39; 2baseURL = \u0026#39;https://blog.lordash.de\u0026#39; 3languageCode = \u0026#39;zh-cn\u0026#39; 4title = \u0026#39;ä¼¼æ°´\u0026#39; 5theme = \u0026#39;PaperMod\u0026#39; 6 7cleanDestinationDir = true 8enableEmoji = true # å…è®¸ä½¿ç”¨Emojiè¡¨æƒ… 9enableInlineShortcodes = true # å…è®¸å†…è”çŸ­ç  10enableRobotsTXT = true # å…è®¸çˆ¬è™«æŠ“å–åˆ°æœç´¢å¼•æ“ 11hasCJKLanguage = true # è‡ªåŠ¨æ£€æµ‹æ˜¯å¦åŒ…å«ä¸­æ–‡æ—¥æ–‡éŸ©æ–‡ 12 13# è¯­è¨€è®¾ç½® 14defaultContentLanguage = \u0026#34;zh\u0026#34; 15 16# å•è¯­è¨€ï¼Œå¿…é¡»åœ¨æ­¤å¤„ï¼Œä»¥ä¸‹è®¾ç½®ä¹‹å‰ 17[languages] 18[languages.zh] 19 languageName = \u0026#34;ä¸­æ–‡\u0026#34; 20 21[markup.goldmark.renderer] 22 unsafe = true # htmlæ ‡ç­¾ 23[markup.highlight] 24 codeFences = true # ä»£ç æ¡† 25 guessSyntax = true # çŒœæµ‹ä»£ç ç±»å‹ 26 lineNos = true # æ˜¾ç¤ºè¡Œå· 27 lineNumbersInTable = false # tableåˆ†éš”è¡Œå·ä¸ä»£ç  28 noClasses = true # ä»£ç å—styleè€Œéclass 29 style = \u0026#34;monokai\u0026#34; # é…è‰²æ–¹æ¡ˆ 30 31# èœå•è®¾ç½® 32[[menu.main]] 33 name = \u0026#34;æœç´¢\u0026#34; 34 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 35 weight = 960 36 identifier = \u0026#34;search\u0026#34; 37 url = \u0026#34;/search\u0026#34; 38[[menu.main]] 39 name = \u0026#34;æ–‡ç« \u0026#34; 40 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-list\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 41 weight = 970 42 identifier = \u0026#34;posts\u0026#34; 43 url = \u0026#34;/posts\u0026#34; 44[[menu.main]] 45 name = \u0026#34;ä¸“æ \u0026#34; 46 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-book\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 47 weight = 980 48 identifier = \u0026#34;series\u0026#34; 49 url = \u0026#34;/series\u0026#34; 50[[menu.main]] 51 name = \u0026#34;å‹é“¾\u0026#34; 52 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-link\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 53 weight = 990 54 identifier = \u0026#34;links\u0026#34; 55 url = \u0026#34;/links\u0026#34; 56[[menu.main]] 57 name = \u0026#34;å…³äº\u0026#34; 58 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-info-circle\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 59 weight = 1000 60 identifier = \u0026#34;about\u0026#34; 61 url = \u0026#34;/about\u0026#34; 62 63paginate = 15 # æ¯é¡µæ–‡ç« æ•°é‡ 64[[permalinks]] 65 post = \u0026#34;/posts/:section/:slug/\u0026#34; # é“¾æ¥æ ¼å¼ 66 67# æœç´¢åŠŸèƒ½ 68[outputs] 69 home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] 70 71# ä¸»é¢˜è®¾ç½® 72[params] 73 env = \u0026#34;production\u0026#34; 74 description = \u0026#34;Life is like a boat\u0026#34; 75 author = \u0026#34;Lordash\u0026#34; 76 keywords = [\u0026#34;ä¸­æ–‡åšå®¢\u0026#34;,\u0026#34;ACMç«èµ›é¢˜è§£\u0026#34;,\u0026#34;è®¡ç®—æœºä»£ç ç¼–ç¨‹\u0026#34;,\u0026#34;å…è´¹æŠ€æœ¯åˆ†äº«å­¦ä¹ \u0026#34;] 77 DateFormat = \u0026#34;2006-01-02\u0026#34; 78 ShowCodeCopyButtons = true # ä»£ç å¤åˆ¶æŒ‰é’® 79 ShowFullTextinRSS = true # RSSå±•ç¤ºå…¨æ–‡ 80 defaultTheme = \u0026#34;dark\u0026#34; # é»˜è®¤ä¸»é¢˜é¢œè‰² 81 hideSummary = false # éšè—æ‘˜è¦ 82 showtoc = true # æ˜¾ç¤ºç›®å½• 83 tocopen = true # ç›®å½•é»˜è®¤å±•å¼€ 84 ShowPostNavLinks = true # æ˜¾ç¤ºä¸Šä¸€ç¯‡/ä¸‹ä¸€ç¯‡ 85 ShowBreadCrumbs = true # æ–‡ç« é¡¶éƒ¨é¢åŒ…å±‘å¯¼èˆª 86 # ShowRssButtonInSectionTermList = true 87 comments = true # å±•ç¤ºè¯„è®º 88 hideFooter = false # éšè—é¡µè„šä¿¡æ¯ 89 # ShowAllPagesInArchive = true # 90 91# å·¦ä¸Šè§’æ ‡ç­¾ 92[params.label] 93 text = \u0026#34;Lordash\u0026#39;s blog\u0026#34; 94 # icon = \u0026#34;images/favicon-32x32-.png\u0026#34; 95 # iconHeight = 36 96 97[params.assets] 98 favicon = \u0026#34;images/favicon-16x16-.png\u0026#34; # æµè§ˆå™¨æ ‡ç­¾å›¾æ ‡ 99 favicon16x16 = \u0026#34;images/favicon-16x16-.png\u0026#34; # æµè§ˆå™¨æ ‡ç­¾å›¾æ ‡ 100 favicon32x32 = \u0026#34;images/favicon-32x32-.png\u0026#34; # æµè§ˆå™¨æ ‡ç­¾å›¾æ ‡ 101 disableHLJS = true # ä¸ä½¿ç”¨highlight.js 102 103[params.profileMode] 104 enabled = true # ä¸ªäººä¸»é¡µæ¨¡å¼ 105 title = \u0026#34;ä¼¼æ°´\u0026#34; 106 subtitle = \u0026#34;Life is like a boat\u0026#34; 107 imageUrl = \u0026#34;https://s2.loli.net/2022/06/01/D6SzQ9Uc1dTFbKf.png\u0026#34; 108 imageWidth = \u0026#34;125\u0026#34; 109 imageHeight = \u0026#34;172\u0026#34; 110 111# ä¸»é¡µæŒ‰é’® 112[[params.profileMode.buttons]] 113 name = \u0026#34;æŠ€æœ¯\u0026#34; 114 url = \u0026#34;/posts/tech\u0026#34; 115[[params.profileMode.buttons]] 116 name = \u0026#34;ç”Ÿæ´»\u0026#34; 117 url = \u0026#34;/posts/life\u0026#34; 118 119# ç¤¾äº¤å›¾æ ‡ 120[[params.socialIcons]] 121 name = \u0026#34;github\u0026#34; 122 url = \u0026#34;https://github.com/GH1656409967\u0026#34; 123[[params.socialIcons]] 124 name = \u0026#34;QQ\u0026#34; 125 url = \u0026#34;http://wpa.qq.com/msgrd?v=3\u0026amp;uin=1656409967\u0026amp;site=qq\u0026amp;menu=yes\u0026#34; 126[[params.socialIcons]] 127 name = \u0026#34;neteasecloudmusic\u0026#34; 128 url = \u0026#34;https://music.163.com/#/user/home?id=270121274\u0026#34; 129[[params.socialIcons]] 130 name = \u0026#34;douban\u0026#34; 131 url = \u0026#34;https://www.douban.com/people/Lordash/\u0026#34; 132[[params.socialIcons]] 133 name = \u0026#34;email\u0026#34; 134 url = \u0026#34;mailto:1656409967@qq.com\u0026#34; 135[[params.socialIcons]] 136 name = \u0026#34;RSS\u0026#34; 137 url = \u0026#34;posts/index.xml\u0026#34; 138 139# fuse.jsæ¨¡ç³Šæœç´¢ 140[params.fuseOpts] 141 isCaseSensitive = false # ä¸åŒºåˆ†å¤§å°å†™ 142 shouldSort = true # æœç´¢ç»“æœæ’åº 143 location = 0 144 distance = 1000 145 threshold = 0.4 146 minMatchCharLength = 0 147 keys = [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] 148 149# åˆ†ç±»ç­‰çº§ 150[taxonomies] 151 category = \u0026#34;categories\u0026#34; 152 tag = \u0026#34;tags\u0026#34; 153 series = \u0026#34;series\u0026#34; 154 155# è¯„è®º 156[params.twikoo] 157 version = \u0026#34;1.6.16\u0026#34; 158 159# è®¿å®¢ç»Ÿè®¡ 160[params.busuanzi] 161 enable = true é»˜è®¤ä¸­æ–‡ i18n å…³é”®åœ¨äºä»¥ä¸‹é…ç½®ï¼Œä¸”å¿…é¡»åœ¨å…¶ä»–é…ç½®ä¸Šå±‚ï¼ŒåŒç†å¯ä»¥æ·»åŠ å¤šè¯­è¨€ã€‚\n1# è¯­è¨€è®¾ç½® 2defaultContentLanguage = \u0026#34;zh\u0026#34; 3 4# å•è¯­è¨€ï¼Œå¿…é¡»åœ¨æ­¤å¤„ï¼Œä»¥ä¸‹è®¾ç½®ä¹‹å‰ 5[languages] 6[languages.zh] 7 languageName = \u0026#34;ä¸­æ–‡\u0026#34; è‡ªå®šä¹‰å­—ä½“ æ­£æ–‡é‡‡ç”¨éœé¹œæ–‡æ¥·(LXGW WenKai)ï¼Œä»£ç é‡‡ç”¨Ubuntu Mono derivative Powerlineã€‚åœ¨/layouts/partials/extend_head.htmlä¸­å¼•å…¥\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/lxgwwenkaiscreen.css\u0026#34; media=\u0026#34;print\u0026#34; onload=\u0026#34;this.media=\u0026#39;all\u0026#39;\u0026#34;\u0026gt; åŒæ—¶ï¼Œåœ¨/assets/css/extended/blank.cssä¸­é…ç½®\n1body { 2 font-family: \u0026#34;LXGW WenKai Screen\u0026#34;, sans-serif !important; 3} 4 5.post-content pre, code { 6 font-family: \u0026#39;Ubuntu Mono derivative Powerline\u0026#39;, sans-serif; 7 max-height: 40rem; 8} èœå•æ  èœå•è®¾ç½®ï¼Œæ ¹æ®æƒé‡weightæ’åºã€‚ï¼ˆæŠ˜å èœå•å’Œæ±‰å ¡èœå•ï¼Œæš‚æ—¶æ²¡æœ‰å¥½çš„é€‚é…æ–¹å¼ï¼ŒåŒæ—¶ä¸ªäººæ„Ÿè§‰ä¹Ÿä¸ä¸»é¢˜ä¸åˆï¼Œæç½®ã€‚æœ‰äº†è§£çš„å°ä¼™ä¼´çƒ¦è¯·å‘ŠçŸ¥æˆ‘ä¸€ä¸‹ï¼‰ã€‚\n1# èœå•è®¾ç½® 2[[menu.main]] 3 name = \u0026#34;æœç´¢\u0026#34; 4 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 5 weight = 960 6 identifier = \u0026#34;search\u0026#34; 7 url = \u0026#34;/search\u0026#34; 8[[menu.main]] 9 name = \u0026#34;æ–‡ç« \u0026#34; 10 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-list\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 11 weight = 970 12 identifier = \u0026#34;posts\u0026#34; 13 url = \u0026#34;/posts\u0026#34; 14[[menu.main]] 15 name = \u0026#34;ä¸“æ \u0026#34; 16 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-book\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 17 weight = 980 18 identifier = \u0026#34;series\u0026#34; 19 url = \u0026#34;/series\u0026#34; 20[[menu.main]] 21 name = \u0026#34;å‹é“¾\u0026#34; 22 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-link\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 23 weight = 990 24 identifier = \u0026#34;links\u0026#34; 25 url = \u0026#34;/links\u0026#34; 26[[menu.main]] 27 name = \u0026#34;å…³äº\u0026#34; 28 pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-info-circle\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; 29 weight = 1000 30 identifier = \u0026#34;about\u0026#34; 31 url = \u0026#34;/about\u0026#34; å›¾æ ‡ Font Awesome åœ¨/layouts/partials/extend_head.htmlä¸­å¼•å…¥\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\u0026#34;\u0026gt; æœç´¢åŠŸèƒ½ æ‰§è¡Œhugo new search.mdåˆ›å»ºæœç´¢é¡µé¢ï¼Œä¿®æ”¹front-matter\n1--- 2title: \u0026#34;æœç´¢\u0026#34; 3date: --- 4layout: search 5--- åŒæ—¶å¿…é¡»é…ç½®ä»¥ä¸‹å†…å®¹ï¼Œå‚è€ƒæ–‡æ¡£\n1# æœç´¢åŠŸèƒ½ 2[outputs] 3 home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] ä¾§è¾¹ç›®å½• å‚è€ƒHugoåšå®¢ç›®å½•æ”¾åœ¨ä¾§è¾¹ | PaperModä¸»é¢˜ã€‚ä¿®æ”¹/layouts/partials/toc.htmlä¸ºä»¥ä¸‹å†…å®¹ï¼š\n1{{- $headers := findRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;(.|\\n])+?\u0026lt;/h[1-6]\u0026gt;\u0026#34; .Content -}} 2{{- $has_headers := ge (len $headers) 1 -}} 3{{- if $has_headers -}} 4\u0026lt;aside id=\u0026#34;toc-container\u0026#34; class=\u0026#34;toc-container wide\u0026#34;\u0026gt; 5\u0026lt;div class=\u0026#34;toc\u0026#34;\u0026gt; 6 \u0026lt;details {{if (.Param \u0026#34;TocOpen\u0026#34;) }} open{{ end }}\u0026gt; 7 \u0026lt;summary accesskey=\u0026#34;c\u0026#34; title=\u0026#34;(Alt + C)\u0026#34;\u0026gt; 8 \u0026lt;span class=\u0026#34;details\u0026#34;\u0026gt;{{- i18n \u0026#34;toc\u0026#34; | default \u0026#34;Table of Contents\u0026#34; }}\u0026lt;/span\u0026gt; 9 \u0026lt;/summary\u0026gt; 10 11 \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt; 12 {{- if (.Param \u0026#34;UseHugoToc\u0026#34;) }} 13 {{- .TableOfContents -}} 14 {{- else }} 15 {{- $largest := 6 -}} 16 {{- range $headers -}} 17 {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} 18 {{- $headerLevel := len (seq $headerLevel) -}} 19 {{- if lt $headerLevel $largest -}} 20 {{- $largest = $headerLevel -}} 21 {{- end -}} 22 {{- end -}} 23 24 {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} 25 26 {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice -}} 27 \u0026lt;ul\u0026gt; 28 {{- range seq (sub $firstHeaderLevel $largest) -}} 29 \u0026lt;ul\u0026gt; 30 {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (sub (add $largest .) 1) -}} 31 {{- end -}} 32 {{- range $i, $header := $headers -}} 33 {{- $headerLevel := index (findRE \u0026#34;[1-6]\u0026#34; . 1) 0 -}} 34 {{- $headerLevel := len (seq $headerLevel) -}} 35 36 {{/* get id=\u0026#34;xyz\u0026#34; */}} 37 {{- $id := index (findRE \u0026#34;(id=\\\u0026#34;(.*?)\\\u0026#34;)\u0026#34; $header 9) 0 }} 38 39 {{- /* strip id=\u0026#34;\u0026#34; to leave xyz, no way to get regex capturing groups in hugo */ -}} 40 {{- $cleanedID := replace (replace $id \u0026#34;id=\\\u0026#34;\u0026#34; \u0026#34;\u0026#34;) \u0026#34;\\\u0026#34;\u0026#34; \u0026#34;\u0026#34; }} 41 {{- $header := replaceRE \u0026#34;\u0026lt;h[1-6].*?\u0026gt;((.|\\n])+?)\u0026lt;/h[1-6]\u0026gt;\u0026#34; \u0026#34;$1\u0026#34; $header -}} 42 43 {{- if ne $i 0 -}} 44 {{- $prevHeaderLevel := index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub $i 1)) 1) 0 -}} 45 {{- $prevHeaderLevel := len (seq $prevHeaderLevel) -}} 46 {{- if gt $headerLevel $prevHeaderLevel -}} 47 {{- range seq $prevHeaderLevel (sub $headerLevel 1) -}} 48 \u0026lt;ul\u0026gt; 49 {{/* the first should not be recorded */}} 50 {{- if ne $prevHeaderLevel . -}} 51 {{- $.Scratch.Add \u0026#34;bareul\u0026#34; . -}} 52 {{- end -}} 53 {{- end -}} 54 {{- else -}} 55 \u0026lt;/li\u0026gt; 56 {{- if lt $headerLevel $prevHeaderLevel -}} 57 {{- range seq (sub $prevHeaderLevel 1) -1 $headerLevel -}} 58 {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) . -}} 59 \u0026lt;/ul\u0026gt; 60 {{/* manually do pop item */}} 61 {{- $tmp := $.Scratch.Get \u0026#34;bareul\u0026#34; -}} 62 {{- $.Scratch.Delete \u0026#34;bareul\u0026#34; -}} 63 {{- $.Scratch.Set \u0026#34;bareul\u0026#34; slice}} 64 {{- range seq (sub (len $tmp) 1) -}} 65 {{- $.Scratch.Add \u0026#34;bareul\u0026#34; (index $tmp (sub . 1)) -}} 66 {{- end -}} 67 {{- else -}} 68 \u0026lt;/ul\u0026gt; 69 \u0026lt;/li\u0026gt; 70 {{- end -}} 71 {{- end -}} 72 {{- end -}} 73 {{- end }} 74 \u0026lt;li\u0026gt; 75 \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; 76 {{- else }} 77 \u0026lt;li\u0026gt; 78 \u0026lt;a href=\u0026#34;#{{- $cleanedID -}}\u0026#34; aria-label=\u0026#34;{{- $header | plainify -}}\u0026#34;\u0026gt;{{- $header | safeHTML -}}\u0026lt;/a\u0026gt; 79 {{- end -}} 80 {{- end -}} 81 \u0026lt;!-- {{- $firstHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers 0) 1) 0)) -}} --\u0026gt; 82 {{- $firstHeaderLevel := $largest }} 83 {{- $lastHeaderLevel := len (seq (index (findRE \u0026#34;[1-6]\u0026#34; (index $headers (sub (len $headers) 1)) 1) 0)) }} 84 \u0026lt;/li\u0026gt; 85 {{- range seq (sub $lastHeaderLevel $firstHeaderLevel) -}} 86 {{- if in ($.Scratch.Get \u0026#34;bareul\u0026#34;) (add . $firstHeaderLevel) }} 87 \u0026lt;/ul\u0026gt; 88 {{- else }} 89 \u0026lt;/ul\u0026gt; 90 \u0026lt;/li\u0026gt; 91 {{- end -}} 92 {{- end }} 93 \u0026lt;/ul\u0026gt; 94 {{- end }} 95 \u0026lt;/div\u0026gt; 96 \u0026lt;/details\u0026gt; 97\u0026lt;/div\u0026gt; 98\u0026lt;/aside\u0026gt; 99\u0026lt;script\u0026gt; 100 let activeElement; 101 let elements; 102 window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function (event) { 103 checkTocPosition(); 104 105 elements = document.querySelectorAll(\u0026#39;h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]\u0026#39;); 106 // Make the first header active 107 activeElement = elements[0]; 108 const id = encodeURI(activeElement.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); 109 document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); 110 }, false); 111 112 window.addEventListener(\u0026#39;resize\u0026#39;, function(event) { 113 checkTocPosition(); 114 }, false); 115 116 window.addEventListener(\u0026#39;scroll\u0026#39;, () =\u0026gt; { 117 // Check if there is an object in the top half of the screen or keep the last item active 118 activeElement = Array.from(elements).find((element) =\u0026gt; { 119 if ((getOffsetTop(element) - window.pageYOffset) \u0026gt; 0 \u0026amp;\u0026amp; 120 (getOffsetTop(element) - window.pageYOffset) \u0026lt; window.innerHeight/2) { 121 return element; 122 } 123 }) || activeElement 124 125 elements.forEach(element =\u0026gt; { 126 const id = encodeURI(element.getAttribute(\u0026#39;id\u0026#39;)).toLowerCase(); 127 if (element === activeElement){ 128 document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.add(\u0026#39;active\u0026#39;); 129 } else { 130 document.querySelector(`.inner ul li a[href=\u0026#34;#${id}\u0026#34;]`).classList.remove(\u0026#39;active\u0026#39;); 131 } 132 }) 133 }, false); 134 135 const main = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--article-width\u0026#39;), 10); 136 const toc = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--toc-width\u0026#39;), 10); 137 const gap = parseInt(getComputedStyle(document.body).getPropertyValue(\u0026#39;--gap\u0026#39;), 10); 138 139 function checkTocPosition() { 140 const width = document.body.scrollWidth; 141 142 if (width - main - (toc * 2) - (gap * 4) \u0026gt; 0) { 143 document.getElementById(\u0026#34;toc-container\u0026#34;).classList.add(\u0026#34;wide\u0026#34;); 144 } else { 145 document.getElementById(\u0026#34;toc-container\u0026#34;).classList.remove(\u0026#34;wide\u0026#34;); 146 } 147 } 148 149 function getOffsetTop(element) { 150 if (!element.getClientRects().length) { 151 return 0; 152 } 153 let rect = element.getBoundingClientRect(); 154 let win = element.ownerDocument.defaultView; 155 return rect.top + win.pageYOffset; 156 } 157\u0026lt;/script\u0026gt; 158{{- end }} åœ¨/assets/css/extended/blank.cssä¸­é…ç½®\n1:root { 2 --nav-width: 1380px; 3 --article-width: 720px; 4 --toc-width: 300px; 5} 6 7.toc { 8 margin: 0 2px 40px 2px; 9 border: 1px solid var(--border); 10 background: var(--entry); 11 border-radius: var(--radius); 12 padding: 0.4em; 13} 14 15.toc-container.wide { 16 position: absolute; 17 height: 100%; 18 border-right: 1px solid var(--border); 19 left: calc((var(--toc-width) + var(--gap)) * -1); 20 top: calc(var(--gap) * 2); 21 width: var(--toc-width); 22} 23 24.wide .toc { 25 position: sticky; 26 top: var(--gap); 27 border: unset; 28 background: unset; 29 border-radius: unset; 30 width: 100%; 31 margin: 0 2px 40px 2px; 32} 33 34.toc details summary { 35 cursor: zoom-in; 36 margin-inline-start: 20px; 37 padding: 12px 0; 38} 39 40.toc details[open] summary { 41 font-weight: 500; 42} 43 44.toc-container.wide .toc .inner { 45 margin: 0; 46} 47 48.active { 49 font-size: 110%; 50 font-weight: 600; 51} 52 53.toc ul { 54 list-style-type: circle; 55} 56 57.toc .inner { 58 margin: 0 0 0 20px; 59 padding: 0px 15px 15px 20px; 60 font-size: 16px; 61 62 /*ç›®å½•æ˜¾ç¤ºé«˜åº¦*/ 63 max-height: 83vh; 64 overflow-y: auto; 65} 66 67.toc .inner::-webkit-scrollbar-thumb { 68 /*æ»šåŠ¨æ¡*/ 69 background: var(--border); 70 border: 7px solid var(--theme); 71 border-radius: var(--radius); 72} 73 74.toc li ul { 75 margin-inline-start: calc(var(--gap) * 0.5); 76 list-style-type: none; 77} 78 79.toc li { 80 list-style: none; 81 font-size: 0.95rem; 82 padding-bottom: 5px; 83} 84 85.toc li a:hover { 86 color: var(--secondary); 87} Shortcode å‚è€ƒæ¥å†™ä¸€äº›å¥½ç©çš„ Hugo çŸ­ä»£ç å§ã€‚\nç¼©å†™ æ–°å»º/layouts/shortcodes/abbr.htmlï¼Œå†…å®¹å¦‚ä¸‹ï¼š\n1\u0026lt;abbr title=\u0026#34;{{ .Get \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt;{{ .Get \u0026#34;text\u0026#34; }}\u0026lt;/abbr\u0026gt; ä½¿ç”¨æ–¹æ³•ï¼ˆå»æ‰'#'ï¼‰ï¼š\n1{#{\u0026lt; abbr title=\u0026#34;è¾¾æ‹‰å´©å·´æ–‘å¾—è´è¿ªåœå¤šæ¯”é²ç¿\u0026#34; text=\u0026#34;è¾¾æ‹‰å´©å·´\u0026#34; \u0026gt;}} è¾¾æ‹‰å´©å·´ æŠ˜å  æ–°å»º/layouts/shortcodes/detail.htmlï¼Œå†…å®¹å¦‚ä¸‹ï¼š\n1\u0026lt;details\u0026gt; 2 \u0026lt;summary\u0026gt;{{ (.Get 0) | markdownify }}\u0026lt;/summary\u0026gt; 3 {{ .Inner | markdownify }} 4\u0026lt;/details\u0026gt; ä½¿ç”¨æ–¹æ³•ï¼ˆå»æ‰'#'ï¼‰ï¼š\n1{#{\u0026lt; detail \u0026#34;ç‚¹å‡»å±•å¼€\u0026#34; \u0026gt;}} 2 hello world! 3{#{\u0026lt; /detail \u0026gt;}} ç‚¹å‡»å±•å¼€ hello world! éŸ³ä¹ æ–°å»º/layouts/shortcodes/music.htmlï¼Œå†…å®¹å¦‚ä¸‹ï¼š\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; 2\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt;.dark .aplayer .aplayer-body{background-color:#212121}.dark .aplayer .aplayer-info{border-top-color:#212121}.dark .aplayer.aplayer-withlist .aplayer-info{border-bottom-color:#5c5c5c}.dark .aplayer.aplayer-fixed .aplayer-list{border-color:#5c5c5c}.dark .aplayer .aplayer-info .aplayer-music .aplayer-author,.dark .aplayer .aplayer-info .aplayer-music .aplayer-title{color:#fff}.dark .aplayer .aplayer-info .aplayer-controller .aplayer-time{color:#eee}.dark .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#eee}.dark .aplayer .aplayer-list{background-color:#212121}.dark .aplayer .aplayer-list::-webkit-scrollbar-thumb{background-color:#999}.dark .aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#bbb}.dark .aplayer .aplayer-list li{color:#fff;border-top-color:#666}.dark .aplayer .aplayer-list li:hover{background:#4e4e4e}.dark .aplayer .aplayer-list li.aplayer-list-light{background:#6c6c6c}.dark .aplayer .aplayer-list li .aplayer-list-author,.dark .aplayer .aplayer-list li .aplayer-list-index{color:#ddd}.dark .aplayer .aplayer-lrc{text-shadow:-1px -1px 0 #666}.dark .aplayer .aplayer-lrc:before{background:-moz-linear-gradient(top,#212121 0,rgba(33,33,33,0) 100%);background:-webkit-linear-gradient(top,#212121,rgba(33,33,33,0));background:linear-gradient(180deg,#212121,rgba(33,33,33,0))}.dark .aplayer .aplayer-lrc:after{background:-moz-linear-gradient(top,rgba(33,33,33,0) 0,rgba(33,33,33,.8) 100%);background:-webkit-linear-gradient(top,rgba(33,33,33,0),rgba(33,33,33,.8));background:linear-gradient(180deg,rgba(33,33,33,0),rgba(33,33,33,.8))}.dark .aplayer .aplayer-lrc p{color:#fff}.dark .aplayer .aplayer-miniswitcher{background:#484848}.dark .aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#eee}\u0026lt;/style\u0026gt; 3\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 5 6{{ if .IsNamedParams }} 7 \u0026lt;meting-js 8 id=\u0026#34;{{ .Get \u0026#34;id\u0026#34; }}\u0026#34; 9 server=\u0026#34;{{ .Get \u0026#34;server\u0026#34; }}\u0026#34; 10 type=\u0026#34;{{ .Get \u0026#34;type\u0026#34; }}\u0026#34; 11 fixed=\u0026#34;{{ if .Get \u0026#34;fixed\u0026#34; }}{{ .Get \u0026#34;fixed\u0026#34; }}{{ else }}false{{ end }}\u0026#34; 12 mini=\u0026#34;{{ if .Get \u0026#34;mini\u0026#34; }}{{ .Get \u0026#34;mini\u0026#34; }}{{ else }}false{{ end }}\u0026#34; 13 autoplay=\u0026#34;{{ if .Get \u0026#34;autoplay\u0026#34; }}{{ .Get \u0026#34;autoplay\u0026#34; }}{{ else }}false{{ end }}\u0026#34; 14 loop=\u0026#34;{{ if .Get \u0026#34;loop\u0026#34; }}{{ .Get \u0026#34;loop\u0026#34; }}{{ else }}none{{ end }}\u0026#34; 15 theme=\u0026#34;{{ if .Get \u0026#34;autoplay\u0026#34; }}{{ .Get \u0026#34;autoplay\u0026#34; }}{{ else }}#255579{{ end }}\u0026#34; 16 volume=\u0026#34;{{ if .Get \u0026#34;volume\u0026#34; }}{{ .Get \u0026#34;volume\u0026#34; }}{{ else }}0.6{{ end }}\u0026#34; 17 prelosd=\u0026#34;{{ if .Get \u0026#34;prelosd\u0026#34; }}{{ .Get \u0026#34;prelosd\u0026#34; }}{{ else }}auto{{ end }}\u0026#34; 18 mutex=\u0026#34;{{ if .Get \u0026#34;mutex\u0026#34; }}{{ .Get \u0026#34;mutex\u0026#34; }}{{ else }}true{{ end }}\u0026#34; 19 list-folded=\u0026#34;{{ if .Get \u0026#34;list-folded\u0026#34; }}{{ .Get \u0026#34;list-folded\u0026#34; }}{{ else }}true{{ end }}\u0026#34;\u0026gt; 20 \u0026lt;/meting-js\u0026gt; 21{{ end }} ä½¿ç”¨æ–¹æ³•ï¼ˆå»æ‰'#'ï¼‰ï¼š\n1{#{\u0026lt; music id=\u0026#34;560183743\u0026#34; type=\u0026#34;song\u0026#34; server=\u0026#34;netease\u0026#34; \u0026gt;}} Bilibili æ–°å»º/layouts/shortcodes/bilibili.htmlï¼Œå†…å®¹å¦‚ä¸‹ï¼š\n1{{ $vid := (.Get 0) }} 2{{ $videopage := default 1 (.Get 1) }} 3{{ $basicQuery := querify \u0026#34;page\u0026#34; $videopage \u0026#34;high_quality\u0026#34; 1 \u0026#34;danmaku\u0026#34; 1 \u0026#34;as_wide\u0026#34; 1}} 4{{ $videoQuery := \u0026#34;\u0026#34; }} 5 6{{ if strings.HasPrefix (lower $vid) \u0026#34;av\u0026#34; }} 7 {{ $videoQuery = querify \u0026#34;aid\u0026#34; (strings.TrimPrefix \u0026#34;av\u0026#34; (lower $vid)) }} 8{{ else if strings.HasPrefix (lower $vid) \u0026#34;bv\u0026#34; }} 9 {{ $videoQuery = querify \u0026#34;bvid\u0026#34; $vid }} 10{{ else }} 11 \u0026lt;p\u0026gt;Bilibili è§†é¢‘avå·æˆ–BVå·é”™è¯¯!\u0026lt;/p\u0026gt; 12 \u0026lt;p\u0026gt;å½“å‰è§†é¢‘avæˆ–BVå·:{{ $vid }}, è§†é¢‘åˆ†P:{{ $videopage }}\u0026lt;/p\u0026gt; 13{{ end }} 14 15\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; 16 .video-wrapper { 17 position: relative; 18 overflow: hidden; 19 margin: auto; 20 padding-bottom: 66%; 21 width: 100%; 22 height: 0; 23 text-align: center 24 } 25 26 .video-wrapper iframe { 27 position: absolute; 28 top: 0; 29 left: 0; 30 width: 100%; 31 height: 100% 32 } 33\u0026lt;/style\u0026gt; 34 35\u0026lt;div class=\u0026#34;video-wrapper\u0026#34;\u0026gt; 36 \u0026lt;iframe src=\u0026#34;https://player.bilibili.com/player.html?{{ $basicQuery | safeURL }}\u0026amp;{{ $videoQuery | safeURL }}\u0026#34; 37 scrolling=\u0026#34;no\u0026#34; frameborder=\u0026#34;no\u0026#34; framespacing=\u0026#34;0\u0026#34; allowfullscreen=\u0026#34;true\u0026#34;\u0026gt; 38 \u0026lt;/iframe\u0026gt; 39\u0026lt;/div\u0026gt; ä½¿ç”¨æ–¹æ³•ï¼ˆå»æ‰'#'ï¼‰\n1{#{\u0026lt; bilibili BV1pX4y1R7d6 \u0026gt;}} ä»£ç é«˜äº® Hugoä½¿ç”¨Chromaï¼ŒPaperModä½¿ç”¨highlight.jsï¼Œæœ¬æ–‡é‡‡ç”¨Hugoè‡ªå¸¦æ–¹æ¡ˆã€‚\n1[markup.highlight] 2 codeFences = true # ä»£ç æ¡† 3 guessSyntax = true # çŒœæµ‹ä»£ç ç±»å‹ 4 lineNos = true # æ˜¾ç¤ºè¡Œå· 5 lineNumbersInTable = false # tableåˆ†éš”è¡Œå·ä¸ä»£ç  6 noClasses = true # ä»£ç å—styleè€Œéclass 7 style = \u0026#34;monokai\u0026#34; # é…è‰²æ–¹æ¡ˆ 8 9[params.assets] 10 disableHLJS = true # ä¸ä½¿ç”¨highlight.js æ³¨æ„lineNumbersInTableè®¾ç½®ä¸ºtrueæ—¶ï¼Œé•¿ä»£ç å—çš„è¡Œå·éƒ¨åˆ†ä¼šå‡ºç°å¤šä½™çš„æ»šåŠ¨æ¡ï¼Œå¹¶ä¸”ä¸åŒæ­¥ï¼›è®¾ç½®ä¸ºfalseæ—¶ï¼Œç‚¹å‡»ä»£ç å—çš„å¤åˆ¶æŒ‰é’®åˆä¼šè¿è¡Œå·ä¸€èµ·å¤åˆ¶ã€‚\næœ¬æ–‡å¤„ç†åä¸€ç§æƒ…å†µã€‚åœ¨/layouts/partials/footer.htmlä¸­ï¼Œæ‰¾åˆ°å¯¹äºå¤åˆ¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶çš„ç›‘å¬ï¼Œä¿®æ”¹ifé‡Œé¢çš„å†…å®¹å¦‚ä¸‹ï¼Œä¹Ÿç®—æ˜¯æŠ•æœºå–å·§çš„åŠæ³•äº†ã€‚\n1 copybutton.addEventListener(\u0026#39;click\u0026#39;, (cb) =\u0026gt; { 2 if (\u0026#39;clipboard\u0026#39; in navigator) { 3 // ä¸åŒ…å«æ ·å¼çš„spançš„å†…å®¹æ‹¼æ¥èµ·æ¥ï¼Œä¹Ÿæ˜¯ä»£ç å—çš„å†…å®¹ 4 let x = codeblock.getElementsByTagName(\u0026#34;span\u0026#34;); 5 let noLineNumContent = \u0026#34;\u0026#34;; 6 for (i = 0; i \u0026lt; x.length; i++) { 7 if (x[i].style.display || x[i].style.color); 8 else noLineNumContent += x[i].textContent; 9 } 10 navigator.clipboard.writeText(noLineNumContent); 11 copyingDone(); 12 return; 13 } æ•°å­¦å…¬å¼ KaTeX PaperModæœªæ•´åˆï¼Œä½†æ–‡æ¡£ä¸­æåˆ°äº†åšæ³•ã€‚\næ–°å»º/layouts/partials/math.htmlï¼Œå¤åˆ¶ç²˜è´´KaTeXæä¾›çš„è‡ªåŠ¨æ¸²æŸ“æ¨¡æ¿ï¼š\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css\u0026#34; integrity=\u0026#34;sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 2\u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js\u0026#34; integrity=\u0026#34;sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;script defer src=\u0026#34;https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4\u0026lt;script\u0026gt; 5 document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { 6 renderMathInElement(document.body, { 7 // customised options 8 // â€¢ auto-render specific keys, e.g.: 9 delimiters: [ 10 {left: \u0026#39;$$\u0026#39;, right: \u0026#39;$$\u0026#39;, display: true}, 11 {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, 12 {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}, 13 {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true} 14 ], 15 // â€¢ rendering keys, e.g.: 16 throwOnError : false 17 }); 18 }); 19\u0026lt;/script\u0026gt; ç„¶ååœ¨/layouts/partials/extend_head.htmlä¸­æ·»åŠ ï¼š\n1\u0026lt;!-- KaTeX --\u0026gt; 2{{ if or .Params.math .Site.Params.math }} 3{{ partial \u0026#34;math.html\u0026#34; . }} 4{{ end }} åœ¨éœ€è¦å¼€å¯LaTeXæ¸²æŸ“çš„æ–‡ç« front-matterä¸­æ·»åŠ ï¼š\n1math: true è¯„è®ºç³»ç»Ÿ Twikoo æœ¬æ–‡ä½¿ç”¨Twikooä½œä¸ºè¯„è®ºç³»ç»Ÿï¼Œåå°çš„éƒ¨ç½²å‚è€ƒTwikooæ–‡æ¡£ï¼Œæˆ–æŒ‰ç…§è§†é¢‘æ•™ç¨‹ä¸€æ­¥æ­¥å®Œæˆå³å¯ã€‚\nå‰ç«¯éƒ¨åˆ†å‚è€ƒHugoåšå®¢æ·»åŠ Twikooè¯„è®ºã€‚æ–°å»º/layouts/partials/comments.htmlï¼Œæ·»åŠ ä»¥ä¸‹å†…å®¹ï¼š\n1\u0026lt;div\u0026gt; 2 \u0026lt;div class=\u0026#34;pagination__title\u0026#34;\u0026gt; 3 \u0026lt;span class=\u0026#34;pagination__title-h\u0026#34; style=\u0026#34;font-size: 20px;\u0026#34;\u0026gt;ğŸ’¬è¯„è®º\u0026lt;/span\u0026gt; 4 \u0026lt;hr /\u0026gt; 5 \u0026lt;/div\u0026gt; 6 \u0026lt;div id=\u0026#34;tcomment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 7 \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/twikoo/{{ .Site.Params.twikoo.version }}/twikoo.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 8 \u0026lt;script\u0026gt; 9 twikoo.init({ 10 envId: \u0026#34;\u0026#34;, // è¿™é‡Œå¡«å†™è‡ªå·±çš„envId 11 el: \u0026#34;#tcomment\u0026#34;, 12 lang: \u0026#39;zh-CN\u0026#39;, 13 region: \u0026#39;ap-shanghai\u0026#39;, 14 path: window.TWIKOO_MAGIC_PATH||window.location.pathname, 15 }); 16 \u0026lt;/script\u0026gt; 17\u0026lt;/div\u0026gt; æ·»åŠ é…ç½®\n1# è¯„è®º 2[params.twikoo] 3 version = \u0026#34;1.6.16\u0026#34; # è¿™ä¸ªç‰ˆæœ¬å·è¦è‡ªå·±æ‰‹åŠ¨ä¿®æ”¹ï¼Œå’Œtwikooçš„ç‰ˆæœ¬å·è¦å¯¹å¾—ä¸Š è®¿å®¢ç»Ÿè®¡ busuanzi è®¿å®¢ç»Ÿè®¡é‡‡ç”¨ä¸è’œå­ï¼Œå‚è€ƒHugoæ·»åŠ ä¸è’œå­Busuanziç«™ç‚¹è®¿é—®é‡ä¸é˜…è¯»é‡ç»Ÿè®¡ï¼Œåœ¨/layouts/partials/extend_head.htmlä¸­å¼•å…¥ï¼š\n1\u0026lt;!-- busuanzi --\u0026gt; 2{{- if .Site.Params.busuanzi.enable -}} 3 \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4 \u0026lt;meta name=\u0026#34;referrer\u0026#34; content=\u0026#34;no-referrer-when-downgrade\u0026#34;\u0026gt; 5{{- end -}} ç«™ç‚¹åº•éƒ¨æ˜¾ç¤ºæ€»è®¿é—®é‡ä¸è®¿å®¢æ•°ï¼Œä¿®æ”¹/layouts/partials/footer.htmlï¼Œåœ¨footeræ ‡ç­¾ä¸­æ·»åŠ ï¼š\n1\u0026lt;!-- busuanzi --\u0026gt; 2{{ if .Site.Params.busuanzi.enable -}} 3\u0026lt;span id=\u0026#34;busuanzi_container_site_pv\u0026#34;\u0026gt; 4 \u0026lt;i class=\u0026#34;fa fa-eye\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 5\u0026lt;/span\u0026gt; 6\u0026lt;span id=\u0026#34;busuanzi_container_site_uv\u0026#34;\u0026gt; 7 \u0026lt;i class=\u0026#34;fa fa-user\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 8\u0026lt;/span\u0026gt; 9{{- end -}} æ¯ç¯‡æ–‡ç« é˜…è¯»é‡ï¼Œåœ¨PaperModä¸»é¢˜ä¸­ï¼Œä¿®æ”¹/layouts/partials/post_meta.htmlï¼Œåœ¨æœ«å°¾æ·»åŠ ï¼š\n1\u0026lt;!-- busuanzi --\u0026gt; 2{{ if .Site.Params.busuanzi.enable -}} 3 \u0026amp;nbsp;Â·\u0026amp;nbsp; 4 \u0026lt;span id=\u0026#34;busuanzi_container_page_pv\u0026#34;\u0026gt;æœ¬æ–‡é˜…è¯»é‡\u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;æ¬¡\u0026lt;/span\u0026gt; 5{{- end }} æœ€ååœ¨ç«™ç‚¹é…ç½®ä¸­æ·»åŠ ï¼š\n1# è®¿é—®ç»Ÿè®¡ 2[params.busuanzi] 3 enable = true éƒ¨ç½² ä»¥Vercelä¸ºä¾‹ï¼Œéƒ¨ç½²æ–¹å¼æœ‰è‡³å°‘ä¸¤ç§ã€‚ä¸€ç§æ˜¯ä¸Šä¼ åšå®¢æºç ï¼Œéƒ¨ç½²æ—¶é€‰æ‹©Hugoï¼Œåœ¨çº¿ç”Ÿæˆç½‘é¡µæ–‡ä»¶å¹¶éƒ¨ç½²ï¼›å¦ä¸€ç§åˆ™æ˜¯æœ¬åœ°ç”Ÿæˆç½‘é¡µæ–‡ä»¶ï¼Œéƒ¨ç½²æ—¶é€‰æ‹©Otherï¼Œä¹Ÿå°±æ˜¯GitHub Pagesçš„æ–¹å¼ã€‚æœ¬æ–‡é‡‡ç”¨åè€…ï¼Œå…·ä½“è¿‡ç¨‹ä¸å†èµ˜è¿°ã€‚\nCSSåŠ è½½å¤±è´¥ ä½¿ç”¨ hugo server å¯åŠ¨æœ¬åœ°è°ƒè¯•æœåŠ¡ï¼Œè®¿é—®http://localhost:1313/æ—¶çœ‹èµ·æ¥å¾ˆæ­£å¸¸ï¼Œæ¨é€åˆ°GitHubä¸Šï¼Œä½¿ç”¨GitHub Pagesæˆ–Verceléƒ¨ç½²çš„é¡µé¢å´åŠ è½½ä¸å‡ºCSSã€‚\næŒ‰ä¸‹F12ï¼Œåˆ‡æ¢åˆ°æ§åˆ¶å°ï¼Œå¯ä»¥çœ‹åˆ°æç¤ºå¦‚ä¸‹ã€‚å¤§æ„æ˜¯CSSæ–‡ä»¶çš„SHA-256æ ¡éªŒå¤±è´¥ï¼Œæ‰€ä»¥æ— æ³•åŠ è½½ã€‚\n1Failed to find a valid digest in the \u0026#39;integrity\u0026#39; attribute for resource \u0026#39;https://blog-d1lytax8a-lordash.vercel.app/assets/css/stylesheet.94301bb9792e5b60c04e4187a47605d05c85a2062102b81ada42fe7d0cd0aec1.css\u0026#39; with computed SHA-256 integrity \u0026#39;DtzRH2bXNjGH5kpyxdinsAaB3zwGHAorYyxEe0JoY9I=\u0026#39;. The resource has been blocked. ç®€å•æœç´¢ä¸‹ï¼Œæœ‰è¯´å¯èƒ½çš„åŸå› æ˜¯Cloudflareçš„é€Ÿåº¦/ä¼˜åŒ–/Auto MinifyåŠŸèƒ½æ”¹åŠ¨æ–‡ä»¶å¯¼è‡´ï¼›ä¹Ÿæœ‰ç›´æ¥ä¿®æ”¹/layouts/partials/head.htmlç”Ÿæˆè¿‡ç¨‹ï¼Œå»æ‰integrityçš„ã€‚\nä»¥ä¸Šä¸¤ç§æƒ…å†µï¼Œåœ¨æŠ˜è…¾ Hugo \u0026amp; PaperMod ä¸»é¢˜æ‰¾åˆ°äº†å¥½çš„æ–¹æ³•ï¼š\nCloudflare å…³é—­çš„æ–¹æ³•ï¼šé€Ÿåº¦ - ä¼˜åŒ– - Auto Minifyã€‚ åœ¨ Hugo ä¸­å…³é—­çš„æ–¹æ³•ï¼š 1[params.assets] 2 disableFingerprinting = true æœ¬æ–‡æœªåšä»¥ä¸Šä¿®æ”¹ã€‚åœ¨å¯¹æœ¬åœ°åŠGitHubä¸Šçš„CSSæ–‡ä»¶è¿›è¡ŒSHA-256æ ¡éªŒæ—¶ï¼Œå‘ç°æäº¤GitHubåçš„æ–‡ä»¶å°±å·²ç»ä¸ä¸€è‡´äº†ï¼Œå¯ä»¥çŒœæµ‹æ˜¯Gitæäº¤æ—¶æœ‰æ”¹åŠ¨ï¼Œæ­¤æ—¶ï¼Œå¾ˆå®¹æ˜“å°±è”æƒ³åˆ°è¡Œå°¾åºåˆ—ï¼ˆè¡Œç»“æŸç¬¦ï¼‰çš„é—®é¢˜ã€‚\nå‡è®¾ä½ åœ¨Windowsä¸Šä½¿ç”¨Gitä¸Šä¼ ä»£ç ï¼ŒGitä¼šåœ¨ä½ æäº¤æ—¶è‡ªåŠ¨çš„æŠŠè¡Œç»“æŸç¬¦CRLFè½¬åŒ–æˆLFï¼Œè€Œåœ¨æ‹‰å–ä»£ç æ—¶æŠŠLFè½¬åŒ–æˆCRLFã€‚æŸ¥çœ‹Gité…ç½®ï¼š\n1git config --global -l å…³é—­è‡ªåŠ¨è½¬æ¢è¡Œå°¾åºåˆ—åŠŸèƒ½\n1git config --global core.autocrlf false é‡æ–°æäº¤ç½‘é¡µæ–‡ä»¶ï¼ˆæœ€å¥½æ˜¯å…ˆåˆ é™¤ï¼‰ï¼Œå†æ¬¡éƒ¨ç½²å³å¯ã€‚\n","permalink":"https://blog.lordash.de/posts/configure/ff377f87efdbc8bc/","summary":"èµ·å›  æœ€è¿‘åœ¨ç”¨éœé¹œæ–‡æ¥·(LXGW WenKai)ï¼Œé…åˆä¸ŠPaperModè¿™ç§å¼ºè°ƒæ–‡å­—çš„ä¸»é¢˜ï¼Œåœ¨è§‚æ„Ÿä¸Šå¾ˆä¸é”™ï¼Œäºæ˜¯å†³å®šè½¬åˆ°Hugoã€‚Hugoçš„æ–‡æ¡£","title":"Hugoä»¥åŠPaperModä¸»é¢˜çš„é…ç½®"},{"content":" æ–‡ç« çš„éƒ¨åˆ†å†…å®¹è¢«å¯†ç ä¿æŠ¤ï¼š\n--- DON'T MODIFY THIS LINE --- æ­¤å†…å®¹åŠ å¯† ç‚¹å‡»å±•å¼€ è¡¨é¢ä¸Š\nä¸€çº§æ ‡é¢˜ äºŒçº§æ ‡é¢˜ ä¸‰çº§æ ‡é¢˜ å››çº§æ ‡é¢˜ äº”çº§æ ‡é¢˜ å…­çº§æ ‡é¢˜ This is a test!\nè¿™æ˜¯ä¸€ä¸ªæµ‹è¯•\nMarkdown å­—ä½“ åŠ ç²— æ˜¾ç¤º\nå­—ä½“ åŠ ç²— æ˜¾ç¤º\nå­—ä½“ æ–œä½“ æ˜¾ç¤º\nå­—ä½“ æ–œä½“ æ˜¾ç¤º\nå­—ä½“ åŠ ç²—å¹¶æ–œä½“ æ˜¾ç¤º\nå­—ä½“ åŠ ç²—å¹¶æ–œä½“ æ˜¾ç¤º\nç»„åˆ åŠ ç²—å¹¶æ–œä½“ æ˜¾ç¤º\nå¼•ç”¨\nå¼•ç”¨å¼•ç”¨\nè¿™æ ·æ¥ åˆ é™¤ä¸€æ®µæ–‡æœ¬\næ— åº\næ— åº æ— åº æ— åº\næ— åº\næ— åº æœ‰åº æœ‰åº æœ‰åº æœ‰åº æœ‰åº è¡¨å¤´ è¡¨å¤´ å•å…ƒæ ¼ å•å…ƒæ ¼ å•å…ƒæ ¼ å•å…ƒæ ¼ è¡¨å¤´ è¡¨å¤´ å•å…ƒæ ¼ å•å…ƒæ ¼ å•å…ƒæ ¼ å•å…ƒæ ¼ é¦–é¡µ\né¦–é¡µ: http://localhost:1313/posts/test/#ä¸€çº§æ ‡é¢˜\nLaTeX è¡Œé—´å…¬å¼ $$ a = b * c / d - (e + f) $$\nè¡Œå†…å…¬å¼ $ a = b * c / d - (e + f) $\nä»£ç é«˜äº® C++ 1//#pragma GCC optimize(3,\u0026#34;Ofast\u0026#34;,\u0026#34;inline\u0026#34;) 2#define _CRT_SECURE_NO_WARNINGS 3#include \u0026lt;bits/stdc++.h\u0026gt; 4#include \u0026lt;unordered_map\u0026gt; 5using namespace std; 6 7#define Mid ((l+r)/2) 8#define pb push_back 9#define mp make_pair 10#define ls ((rt)\u0026lt;\u0026lt;1) 11#define rs ((rt)\u0026lt;\u0026lt;1|1) 12#define sq(u) ((u)*(u)) 13#define Abs(u) ((u)\u0026gt;0?(u):-(u)) 14#define ze(u) (Abs(u)\u0026lt;eps) 15#define eq(u, v) (ze((u)-(v))) 16#define Sgn(u) ((u)\u0026gt;eps?1:((u)\u0026lt;-eps?-1:0)) 17typedef long long LL; 18typedef unsigned long long UL; 19typedef double DB; 20const int inf = 0x3f3f3f3f; 21const LL INF = 0x3f3f3f3f3f3f3f3f; 22const DB eps = 1e-8; 23const DB pi = acos(-1.0); 24 25const int N = (int)1e5; 26const int M = (int)4e3; 27const int mxn = N + 5; 28const int mxm = M + 5; 29 30LL ans = 1e18 + 7; 31 32LL SUM(LL a, LL b) 33{ 34 LL cnt = 0; 35 for (a /= b; a; a /= b) cnt += a; 36 return cnt; 37} 38 39LL sum = 0, upperlim = 1; 40 41void test(LL row, LL ld, LL rd) 42{ 43 if (row != upperlim) 44 { 45 LL pos = upperlim \u0026amp; ~(row | ld | rd); 46 while (pos) 47 { 48 long p = pos \u0026amp; -pos; 49 pos -= p; 50 test(row + p, (ld + p) \u0026lt;\u0026lt; 1, (rd + p) \u0026gt;\u0026gt; 1); 51 } 52 } 53 else 54 sum++; 55} 56 57LL f[84] = { 0,1,1,2 }; 58 59void fib() 60{ 61 for (int i = 3; i \u0026lt;= 83; i++) { 62 f[i] = f[i - 1] + f[i - 2]; 63 } 64} 65 66int main() 67{ 68 //int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 69 //int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 70 fib(); 71 72 LL x, m; 73 scanf(\u0026#34;%lld %lld\u0026#34;, \u0026amp;x, \u0026amp;m); 74 75 76 LL v = 1, flag = 0; 77 for (v = 1; v \u0026lt;= 83; v++) { 78 if (x == f[v]) { 79 flag = 1; 80 break; 81 } 82 } 83 84 85 if (flag) { 86 for (LL i = 2; i * i \u0026lt;= m; ++i) 87 { 88 LL cnt = 0; 89 while (m % i == 0)++cnt, m /= i; 90 if (cnt)ans = min(ans, SUM(x, i) / cnt); 91 } 92 if (m \u0026gt; 1)ans = min(ans, SUM(x, m)); 93 printf(\u0026#34;%lld\\n\u0026#34;, ans); 94 return 0; 95 } 96 97 int n = x % min(13LL, m) + 1LL; 98 99 upperlim = (upperlim \u0026lt;\u0026lt; n) - 1; 100 101 test(0, 0, 0); 102 printf(\u0026#34;%lld\\n\u0026#34;, sum); 103 104 return 0; 105} 106 107/* 108 109*/ Java 1package cn.jee.config; 2 3import org.springframework.context.annotation.Bean; 4import org.springframework.context.annotation.Configuration; 5import org.springframework.web.servlet.LocaleResolver; 6import org.springframework.web.servlet.config.annotation.InterceptorRegistry; 7import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; 8import org.springframework.web.servlet.i18n.LocaleChangeInterceptor; 9import org.springframework.web.servlet.i18n.SessionLocaleResolver; 10 11import java.util.Locale; 12 13@Configuration 14public class MyMvcConfiger implements WebMvcConfigurer { 15 @Override 16 public void addInterceptors(InterceptorRegistry registry) { 17 registry.addInterceptor(localeChangeInterceptor()); 18 } 19 20 @Bean 21 public LocaleResolver localeResolver() { 22 SessionLocaleResolver sessionLocaleResolver = new SessionLocaleResolver(); 23 sessionLocaleResolver.setDefaultLocale(Locale.CHINA); 24 return sessionLocaleResolver; 25 } 26 27 @Bean 28 public LocaleChangeInterceptor localeChangeInterceptor() { 29 LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor(); 30 localeChangeInterceptor.setParamName(\u0026#34;lang\u0026#34;); 31 return localeChangeInterceptor; 32 } 33} Python 1#!/usr/bin/python 2# -*- coding: UTF-8 -*- 3import unittest 4 5file = open(\u0026#34;test.txt\u0026#34;, \u0026#34;r+\u0026#34;) 6article = file.read() 7 8@profile 9def count_char_1(): 10 num = 0 11 for line in article: 12 for word in line.split(): 13 num = num + len(word) 14 return num 15 16 17@profile 18def count_char_2(): 19 return sum([len(word) for line in article for word in line.split()]) 20 21 22@profile 23def count_char_3(): 24 return sum(len(word) for line in article for word in line.split()) 25 26 27if __name__ == \u0026#39;__main__\u0026#39;: 28 count_char_1() 29 count_char_2() 30 count_char_3() è¯„è®º","permalink":"https://blog.lordash.de/f/test/","summary":"","title":"Test"},{"content":"1 Vercelé…ç½® è¿›å…¥Vercelå®˜ç½‘ï¼Œç‚¹å‡»å³ä¸Šè§’Sign Upæ³¨å†Œï¼Œé€‰æ‹©Continue with GitHubä½¿ç”¨GitHubè´¦å·æ³¨å†Œã€‚\næ³¨å†Œå®Œæˆåï¼Œä¼šè¿›å…¥æ–°å»ºé¡¹ç›®é¡µé¢ã€‚å¦‚æœæ²¡æœ‰ï¼Œç‚¹å‡»é¡µé¢å·¦ä¸Šè§’è¿›å…¥æ§åˆ¶é¢æ¿ï¼Œç‚¹å‡»Overviewè¿›å…¥æ¦‚è§ˆï¼Œç‚¹å‡»New Projectã€‚\nåœ¨Import Git Repositoryä¸‹é¢çš„é€‰æ‹©æ¡†ä¸­é€‰æ‹©Add GitHub Accountï¼Œåœ¨å¼¹å‡ºæ¥çš„é¡µé¢ä¸­é€‰æ‹©ä¹‹å‰é…ç½®GitHub Pagesç”¨çš„ä»“åº“ï¼Œç„¶åç‚¹å‡»Importã€‚\nå¯¼å…¥å®Œä¼šè‡ªåŠ¨è¿›å…¥éƒ¨ç½²é¡µé¢ï¼Œå¯ä»¥ä¿®æ”¹ä¸€ä¸‹é¡¹ç›®åï¼Œå› ä¸ºä»“åº“ä¸­å·²ç»æ˜¯Hexoç”Ÿæˆçš„é¡µé¢æ–‡ä»¶äº†ï¼Œé¢„è®¾æ¡†æ¶é€‰æ‹©é»˜è®¤çš„Otherå³å¯ã€‚ç›´æ¥ç‚¹å‡»Deployå¼€å§‹éƒ¨ç½²ã€‚\néƒ¨ç½²å®Œæˆï¼ŒVercelä¼šæä¾›å‡ ä¸ª.vercel.appçš„é»˜è®¤åŸŸåè¿›è¡Œè®¿é—®ã€‚\n2 ä½¿ç”¨è‡ªå®šä¹‰åŸŸå å› ä¸ºæˆ‘ç›®å‰ä½¿ç”¨Cloudflareç®¡ç†åŸŸåï¼ˆå‚è€ƒã€é…ç½®ã€‘Win10å°†åŸŸåNameServerä»NameSiloæ›¿æ¢åˆ°Cloudflareï¼‰ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥å°†ä»¥Cloudflareä½œä¸ºä¾‹å­ã€‚\nåœ¨Vercelä¸­è¿›å…¥é¡¹ç›®çš„Settingè®¾ç½®é¡µï¼Œé€‰æ‹©DomainsåŸŸåç®¡ç†ï¼Œå¯ä»¥çœ‹åˆ°å½“å‰é…ç½®çš„è‡ªå®šä¹‰åŸŸåã€‚å…¶ä¸­åŒ…å«äº†Vercelé»˜è®¤ç”Ÿæˆçš„äºŒçº§åŸŸåï¼Œç‚¹å‡»Editå¯ä¿®æ”¹ä¸ºå…¶å®ƒæ— äººå ç”¨çš„.vercel.appåŸŸåï¼Œè¯¦ç»†ä¿¡æ¯å¯ä»¥æŸ¥çœ‹Vercelå®˜æ–¹æ–‡æ¡£ã€‚\næƒ³è¦ä½¿ç”¨å…¶å®ƒè‡ªå®šä¹‰åŸŸåï¼Œåœ¨è¾“å…¥æ¡†ä¸­è¾“å…¥ï¼Œç‚¹å‡»Addæ·»åŠ ã€‚\næ·»åŠ å®Œåï¼Œéœ€è¦éªŒè¯é…ç½®ï¼Œè¿™é‡Œé€‰æ‹©CNAMEæ–¹å¼ã€‚\nç™»å½•Cloudflareï¼Œåœ¨åŸŸåçš„DNSé…ç½®ä¸­ï¼Œé€‰æ‹©æ·»åŠ è®°å½•ï¼Œå¡«å†™ä¹‹å‰Vercelè¦æ±‚çš„è§£æå†…å®¹ã€‚æŒ‰éœ€é€‰æ‹©æ˜¯å¦å¼€å¯Cloudflare CDNã€‚\nå…³é—­Cloudflare CDN Cloudflareæä¾›çš„ä»£ç†æœåŠ¡åœ¨å¤§é™†è®¿é—®é€Ÿåº¦è¿‡æ…¢ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©å…³é—­Cloudflareçš„åå‘åŠ é€ŸæœåŠ¡ã€‚åœ¨Cloudflareçš„DNSè®°å½•é…ç½®ä¸­ï¼Œç‚¹å‡»ç¼–è¾‘ï¼Œå–æ¶ˆä»£ç†çŠ¶æ€ã€‚\nå¼€å¯Cloudflare CDN å›åˆ°Vercelé¡µé¢ï¼Œå¦‚æœä¹‹å‰é…ç½®äº†Cloudflareä»£ç†ï¼Œä¼šå‘ç°è¿˜æ˜¯æœ‰é—®é¢˜ï¼Œç‚¹å‡»Learn MoreæŸ¥çœ‹Vercelå®˜æ–¹æ–‡æ¡£ç»™çš„æç¤ºã€‚\nVercelæ„å»ºé¡¹ç›®æ—¶ï¼Œä½¿ç”¨Let\u0026rsquo;s Encrypté¢å‘SSLè¯ä¹¦ï¼Œä¼šå‘åŸŸå/.well-known/acme-challengeå‘å‡ºHTTPè¯·æ±‚ï¼Œå¦‚æœæ­¤HTTPè¯·æ±‚è¢«Cloudflareé‡å®šå‘åˆ°HTTPSï¼Œåˆ™æ— æ³•ç”Ÿæˆè¯ä¹¦ã€‚\næ‰“å¼€CMDï¼Œè¾“å…¥ä»¥ä¸Šcurlå‘½ä»¤æµ‹è¯•ï¼Œæ³¨æ„æ˜¯HTTPè¯·æ±‚ã€‚å¦‚æœè¿”å›çš„æ˜¯404è¯´æ˜æˆåŠŸï¼Œå¦‚æœæ˜¯3XXé‡å®šå‘ï¼Œé‚£ä¹ˆCloudflareä¼šé˜»æ­¢è®¿é—®æ­¤è·¯ç”±ï¼Œä¸”Vercelä¼šå°†åŸŸåæ ‡è®°ä¸ºæœªé…ç½®ã€‚\n1curl http://your.domain.com/.well-known/acme-challenge -I ä¸€èˆ¬éƒ½æ˜¯3XXé‡å®šå‘ï¼Œéœ€è¦æ·»åŠ ä¾‹å¤–é…ç½®ã€‚æ‰“å¼€Cloudflareï¼Œåœ¨è§„åˆ™ - é¡µé¢è§„åˆ™ä¸­ï¼Œç‚¹å‡»åˆ›å»ºé¡µé¢è§„åˆ™ï¼Œ\nåœ¨URLè¾“å…¥æ¡†ä¸­è¾“å…¥*your.domain/.well-known/*ï¼Œåœ¨é€‰å–è®¾ç½®çš„ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©SSLï¼Œç„¶ååœ¨é€‰æ‹©SSLè®¾ç½®ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©å…³ï¼Œç‚¹å‡»ä¿å­˜å’Œéƒ¨ç½²é¡µé¢è§„åˆ™ã€‚\nå¦‚æœä¾æ—§æ˜¯é…ç½®å¤±è´¥ï¼Œè¯·æ£€æŸ¥Cloudflareçš„é…ç½®ï¼Œåœ¨SSL/TLS - è¾¹ç¼˜è¯ä¹¦ä¸­ï¼Œæ˜¯å¦å¼€å¯äº†å§‹ç»ˆä½¿ç”¨HTTPSï¼Œå¦‚æœæœ‰ï¼Œè¯·å…³é—­ã€‚\nç”Ÿæˆè¯ä¹¦åï¼Œé…ç½®æˆåŠŸ\n3 å…¶å®ƒé—®é¢˜ ERR_TOO_MANY_REDIRECTS æ‰“å¼€é¡µé¢æ—¶ï¼Œæç¤ºERR_TOO_MANY_REDIRECTSé‡å®šå‘æ¬¡æ•°è¿‡å¤šï¼Œè¯·å°è¯•æ¸…é™¤Cookieã€‚ä½†æ˜¯æ¸…é™¤Cookieæ— ç”¨ï¼Œé‡æ–°æ‰“å¼€ä¾æ—§æ˜¯è¿™ä¸ªæç¤ºã€‚\nåœ¨Cloudflareçš„SSL/TLS - æ¦‚è¿°ä¸­ï¼Œå°†æ¨¡å¼æ”¹ä¸ºå®Œå…¨ï¼ˆä¸¥æ ¼ï¼‰æ¨¡å¼ã€‚\n","permalink":"https://blog.lordash.de/posts/configure/abf4cb68b4c20c52/","summary":"1 Vercelé…ç½® è¿›å…¥Vercelå®˜ç½‘ï¼Œç‚¹å‡»å³ä¸Šè§’Sign Upæ³¨å†Œï¼Œé€‰æ‹©Continue with GitHubä½¿ç”¨GitHubè´¦å·æ³¨å†Œã€‚ æ³¨å†Œå®Œæˆåï¼Œ","title":"Win10ä½¿ç”¨Vercelæ‰˜ç®¡Hexoåšå®¢"},{"content":"1 é…ç½® é¦–å…ˆï¼Œéœ€è¦åœ¨NameSiloä¸Šæ³¨å†Œç™»å½•ï¼Œè´­ä¹°å¿ƒä»ªçš„åŸŸåï¼Œç„¶åæ³¨å†Œå¹¶ç™»å½•Cloudflareï¼Œ\nç‚¹å‡»å·¦ä¾§ç½‘ç«™ï¼Œè¿›å…¥ç½‘ç«™ç®¡ç†é¡µé¢ï¼Œç‚¹å‡»æ·»åŠ ç«™ç‚¹ï¼Œ\nåœ¨è¾“å…¥æ‚¨çš„ç«™ç‚¹è¾“å…¥æ¡†å†…å¡«å†™NameSiloä¸Šçš„åŸŸåï¼Œç‚¹å‡»æ·»åŠ ç«™ç‚¹ï¼Œ\né€‰æ‹©æ‚¨çš„è®¡åˆ’ï¼Œä¸€èˆ¬ç”¨æˆ·é€‰æœ€ä¸‹é¢çš„Freeå…è´¹ç‰ˆå°±è¡Œäº†ã€‚é€‰ä¸­å…è´¹é‚£ä¸€æ ï¼Œç„¶åç‚¹å‡»ç»§ç»­æŒ‰é’®ã€‚\næŸ¥çœ‹DNSè®°å½•ï¼Œæˆ‘è¿™ä¸ªåŸŸåå½“å‰æ˜¯æ²¡æœ‰DNSè®°å½•çš„ã€‚æœ‰éœ€è¦æ·»åŠ è®°å½•çš„ï¼Œå¯ä»¥åœ¨è¿™æ·»åŠ ï¼Œä¹Ÿå¯ä»¥å…ˆè·³è¿‡ï¼Œç‚¹å‡»ç»§ç»­æŒ‰é’®ã€‚\næ›´æ¢åç§°æœåŠ¡å™¨ï¼Œè¿™è¾¹éœ€è¦å¤åˆ¶ä¸‹Cloudflareç»™å‡ºçš„NSè®°å½•\næˆ‘ä»¬æ‰“å¼€NameSiloï¼Œç‚¹å‡»ä¸Šé¢çš„Manage My Domainsï¼Œè¿›å…¥åŸŸåç®¡ç†é¡µé¢ï¼Œé€‰ä¸­éœ€è¦æ›´æ¢çš„åŸŸåï¼Œç‚¹å‡»Change NameserversæŒ‰é’®ï¼Œ\nç„¶åæŠŠNSæ›¿æ¢ä¸ºCloudflareç»™å‡ºçš„NSï¼Œä¿å­˜ã€‚è¿™æ—¶å€™å¯ä»¥çœ‹åˆ°åŸŸåçš„Statusæ˜¾ç¤ºProcessing NameServer Updateï¼Œç¨ç­‰å‡ åˆ†é’Ÿï¼Œå°±ä¼šå˜æˆActiveã€‚\nå›åˆ°Cloudflareï¼Œç‚¹å‡»å®Œæˆï¼Œæ£€æŸ¥åç§°æœåŠ¡å™¨ï¼Œç„¶åå¯ä»¥é…ç½®æˆ–è€…è·³è¿‡å¿«é€Ÿå…¥é—¨æŒ‡å—ã€‚ç‚¹å‡»å·¦ä¾§æ¦‚è¿°ï¼Œç‚¹å‡»æ£€æŸ¥åç§°æœåŠ¡å™¨ï¼Œå†æ¬¡æ£€æµ‹ã€‚\nåœ¨ç¡®è®¤æ›´æ¢æˆåŠŸåï¼Œä¼šå‡ºç°ä»¥ä¸‹æç¤º\n","permalink":"https://blog.lordash.de/posts/configure/7f8636440ab49b65/","summary":"1 é…ç½® é¦–å…ˆï¼Œéœ€è¦åœ¨NameSiloä¸Šæ³¨å†Œç™»å½•ï¼Œè´­ä¹°å¿ƒä»ªçš„åŸŸåï¼Œç„¶åæ³¨å†Œå¹¶ç™»å½•Cloudflareï¼Œ ç‚¹å‡»å·¦ä¾§ç½‘ç«™ï¼Œè¿›å…¥ç½‘ç«™ç®¡ç†é¡µé¢ï¼Œç‚¹å‡»æ·»åŠ ç«™","title":"Win10å°†åŸŸåNameServerä»NameSiloæ›¿æ¢åˆ°Cloudflare"},{"content":"1 å®‰è£…NexT v8.0 æ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œä½¿ç”¨gitä¸‹è½½NexTä¸»é¢˜\n1# ä¸‹è½½NexTä¸»é¢˜ 2git clone https://github.com/next-theme/hexo-theme-next themes/next ç„¶åä¿®æ”¹åšå®¢æ ¹ç›®å½•ä¸‹çš„_config.ymlé…ç½®æ–‡ä»¶ï¼Œå°†ä¸»é¢˜è®¾ç½®ä¸ºNexT\n1theme: next ç„¶åé‡æ–°ç”Ÿæˆä¸€ä¸‹åšå®¢ï¼Œæ‰“å¼€æœ¬åœ°æœåŠ¡\n1# æ¸…é™¤ç¼“å­˜ 2hexo clean 3# ç”Ÿæˆé™æ€æ–‡ä»¶ 4hexo generate 5# å¯åŠ¨æœåŠ¡ï¼ˆå¼€å¯è°ƒè¯•ï¼‰ 6hexo server --debug è®¿é—®http://localhost:4000/ï¼ŒæŸ¥çœ‹æ•ˆæœ\n2 é…ç½®ä¿®æ”¹ 2.1 åšå®¢é…ç½® ä»¥ä¸‹é…ç½®ï¼Œéœ€æ·»åŠ è‡³åšå®¢æ ¹ç›®å½•ä¸‹_config.ymlä¸­\nåšå®¢ä¿¡æ¯ 1title: æ ‡é¢˜ 2subtitle: \u0026#39;å­æ ‡é¢˜\u0026#39; 3description: \u0026#39;æè¿°\u0026#39; 4keywords: å…³é”®è¯ 5author: ä½œè€… å¼€å¯ä¸­æ–‡ 1language: zh-CN ä¿®æ”¹æ–‡ç« æ°¸ä¹…é“¾æ¥ æ–‡ç« æ ‡é¢˜å¤§å¤šä½¿ç”¨ä¸­æ–‡ï¼Œä½†æ˜¯URLå¹¶ä¸æ¨èåŒ…å«ä¸­æ–‡ï¼Œä¹Ÿä¸åˆ©äºSEO\n1url: https://gh1656409967.github.io/ 2permalink: posts/:hash/ è‡ªåŠ¨æ£€æµ‹é«˜äº® 1highlight: 2 auto_detect: true 3 tab_replace: \u0026#39; \u0026#39; æ˜¾ç¤ºæ–‡ç« æ•° 1index_generator: 2 per_page: 30 æ¯é¡µé¡µç  1per_page: 30 é»˜è®¤åˆ†ç±» 1default_category: æµ‹è¯• 2.2 ä¸»é¢˜é…ç½® ä»¥ä¸‹é…ç½®ï¼Œéœ€æ·»åŠ è‡³åšå®¢æ ¹ç›®å½•ä¸‹_config.next.ymlä¸­\nåˆ‡æ¢å¸ƒå±€æ–¹æ¡ˆ NexTæä¾›Museã€Mistã€Pisceså’ŒGeminiå››ç§å¸ƒå±€æ–¹æ¡ˆã€‚\n1scheme: Pisces æ·»åŠ å­æ ‡é¢˜ 1index_with_subtitle: true å…³é—­é¡µé¢åº•éƒ¨åšå®¢ä¿¡æ¯ 1footer: 2 powered: false æ·»åŠ è‡ªå®šä¹‰menuèœå• æ ¼å¼ä¸ºKey: /link || iconï¼Œiconå³ä¸ºFont Awesomeæä¾›çš„å›¾æ ‡ã€‚ ä¿®æ”¹ä¸»é¢˜ç›®å½•ä¸‹languages/zh-CN.ymlï¼Œåœ¨menuä¸‹æ·»åŠ å¯¹åº”èœå•çš„ä¸­æ–‡ï¼Œä¾‹å¦‚gallery: ç›¸å†Œï¼Œæ³¨æ„ç»Ÿä¸€ç¼©è¿›ã€‚ åœ¨åšå®¢æ ¹ç›®å½•ï¼Œè¿è¡Œ hexo new page \u0026quot;èœå•\u0026quot;ï¼Œç¼–è¾‘æ–°å»ºçš„ source/èœå•/index.md å³å¯ã€‚ 1menu: 2 about: /about/ || fa fa-user 3 gallery: /gallery/ || fa fa-camera æ·»åŠ ç¤¾äº¤é“¾æ¥ 1social: 2 GitHub: https://github.com/GH1656409967 || fa-brands fa-github 3 QQ: http://wpa.qq.com/msgrd?v=3\u0026amp;uin=1656409967\u0026amp;site=qq\u0026amp;menu=yes || fa-brands fa-qq 4 ç½‘æ˜“äº‘: https://music.163.com/#/user/home?id=270121274 || fa fa-music 5 è±†ç“£: https://www.douban.com/people/215985894/ || fa fa-video-camera æ·»åŠ å‹é“¾ 1links_settings: 2 icon: fa fa-link 3 title: å‹æƒ…é“¾æ¥ 4 layout: inline 5 6links: 7 ã€jaihk662ã€‘: https://blog.csdn.net/jaihk662 8 ã€ä¿¡ä»°.ã€‘: https://blog.csdn.net/haut_ykc 9 ã€SSimpLe_Yã€‘: https://blog.csdn.net/ssimple_y 10 ã€æŸ³å©¼ã®blogã€‘: https://www.liuchuo.net/ 11 ã€liweihangã€‘: https://www.cnblogs.com/liweihang/ 12 ã€ironzã€‘: https://ironz.cn/ 13 ã€Sysipusã€‘: https://runzhaochen.github.io/ 14 ã€Long_henã€‘: https://blog.csdn.net/Long_hen 15 ã€haut_baoã€‘: https://blog.csdn.net/qq_41856950 16 ã€é˜¿æ¸…ã ã€‘: https://aqingya.cn/ ç›®å½•è®¾ç½® å¼€å¯ç›®å½•ï¼Œå…³é—­ç›®å½•è‡ªåŠ¨ç¼–å·ï¼Œå¼€å¯ç›®å½•è‡ªåŠ¨æ¢è¡Œï¼Œå¼€å¯å…¨éƒ¨å±•å¼€\n1toc: 2 enable: true 3 number: false 4 wrap: true 5 expand_all: true å¼€å¯æ–‡ç« ç»“å°¾ç‰ˆæƒå£°æ˜ 1creative_commons: 2 post: true æ–‡ç« ç»“å°¾æ‰“èµ æ·»åŠ æ–‡ç« ç»“å°¾æ‰“èµå›¾ç‰‡ï¼Œå›¾ç‰‡æ”¾è‡³ä¸»é¢˜ç›®å½•çš„source/images/ä¸‹\n1reward_settings: 2 enable: true 3 animation: false 4 5reward: 6 wechatpay: /images/wechatpay.png 7 alipay: /images/thanks.png 8 bitcoin: /images/alipay.png ä¿®æ”¹themes/next/languages/zh-CN.ymlï¼Œæ–‡å­—ä¸å›¾ç‰‡å¯¹åº”\n1reward: 2 wechatpay: å¾®ä¿¡ 3 alipay: æ„Ÿè°¢ 4 bitcoin: æ”¯ä»˜å® ç½‘ç«™å¤´åƒ å›¾ç‰‡æ”¾è‡³ä¸»é¢˜ç›®å½•çš„source/images/ä¸‹\n1avatar: 2 url: /images/avatar.png ç½‘ç«™å›¾æ ‡ å›¾ç‰‡æ”¾è‡³ä¸»é¢˜ç›®å½•çš„source/images/ä¸‹\n1favicon: 2 small: /images/favicon-16x16-.png 3 medium: /images/favicon-32x32-.png è®¾ç½®å­—ä½“ è®¾ç½®å­—ä½“ä¸ºFira Codeå’Œæ€æºé»‘ä½“\n1font: 2 enable: true 3 4 # Uri of fonts host, e.g. https://fonts.googleapis.com (Default). 5 host: 6 7 # Font options: 8 # `external: true` will load this font family from `host` above. 9 # `family: Times New Roman`. Without any quotes. 10 # `size: x.x`. Use `em` as unit. Default: 1 (16px) 11 12 # Global font settings used for all elements inside \u0026lt;body\u0026gt;. 13 global: 14 external: true 15 family: \u0026#39;Fira Code,Noto Sans SC\u0026#39; 16 size: 17 18 # Font settings for site title (.site-title). 19 title: 20 external: true 21 family: \u0026#39;Fira Code,Noto Sans SC\u0026#39; 22 size: 23 24 # Font settings for headlines (\u0026lt;h1\u0026gt; to \u0026lt;h6\u0026gt;). 25 headings: 26 external: true 27 family: \u0026#39;Fira Code,Noto Sans SC\u0026#39; 28 size: 29 30 # Font settings for posts (.post-body). 31 posts: 32 external: true 33 family: \u0026#39;Fira Code,Noto Sans SC\u0026#39; 34 35 # Font settings for \u0026lt;code\u0026gt; and code blocks. 36 codes: 37 external: true 38 family: \u0026#39;Fira Code,Noto Sans SC\u0026#39; è®¾ç½®ä»£ç é«˜äº® 1codeblock: 2 theme: 3 light: atom-one-light ä»£ç ä¸€é”®å¤åˆ¶ 1codeblock: 2 copy_button: 3 enable: true 4 show_result: true åˆ‡æ¢CDN jsdelivrå®¹æ˜“å¯„ï¼Œå¯ä»¥æ¢cdnjsæˆ–è€…unpkg\n1vendors: 2 plugins: unpkg 3 åŠŸèƒ½æ·»åŠ  3.1 å›¾ç‰‡ä¸æ˜¾ç¤º æ­¤å¤„ä»…å¤„ç†æœ¬åœ°å›¾ç‰‡å¼•ç”¨ï¼Œä¸è€ƒè™‘ä½¿ç”¨å›¾åºŠçš„æƒ…å†µ\nä»ä¹‹å‰ç”Ÿæˆçš„é™æ€æ–‡ä»¶ä¸­ï¼Œå¯ä»¥çœ‹åˆ°å›¾ç‰‡æœªä¸Šä¼ è‡³publicç›®å½•ï¼Œä¸”å›¾ç‰‡è·¯å¾„æ˜¯markdownæºæ–‡ä»¶ä¸­çš„ç»å¯¹è·¯å¾„ï¼Œè€Œä¸æ˜¯ç›¸å¯¹è·¯å¾„ã€‚\né¦–å…ˆä¿®æ”¹åšå®¢æ ¹ç›®å½•_config.ymlé…ç½®æ–‡ä»¶ï¼Œå¼€å¯ä¸Šä¼ èµ„æºæ–‡ä»¶å¤¹\n1post_asset_folder: true ç„¶åéœ€è¦å®‰è£…ä¸€ä¸ªå›¾ç‰‡è·¯å¾„è½¬æ¢æ’ä»¶ï¼Œæ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤\n1npm i hexo-asset-image --save ä¿®æ”¹æ­¤æ’ä»¶æºç /node_modules/hexo-asset-image/index.jsï¼Œä¿®æ”¹å†…å®¹å‚çœ‹æ³¨é‡Š\n1 ... 2 3 if(config.post_asset_folder){ 4 var link = data.permalink; 5 var beginPos = getPosition(link, \u0026#39;/\u0026#39;, 3) + 1; 6 /* æ³¨é‡Šä»¥ä¸‹å†…å®¹ 7 var appendLink = \u0026#39;\u0026#39;; 8 // In hexo 3.1.1, the permalink of \u0026#34;about\u0026#34; page is like \u0026#34;.../about/index.html\u0026#34;. 9 // if not with index.html endpos = link.lastIndexOf(\u0026#39;.\u0026#39;) + 1 support hexo-abbrlink 10 if(/.*\\/index\\.html$/.test(link)) { 11 // when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html 12 // image in xxtitle/ will go to xxtitle/index/ 13 appendLink = \u0026#39;index/\u0026#39;; 14 var endPos = link.lastIndexOf(\u0026#39;/\u0026#39;); 15 } 16 else { 17 var endPos = link.lastIndexOf(\u0026#39;.\u0026#39;); 18 } 19 link = link.substring(beginPos, endPos) + \u0026#39;/\u0026#39; + appendLink; 20 */ 21 /* ä¿®æ”¹ä¸ºä¸‹é¢ä¸¤è¡Œ */ 22 var endPos = link.lastIndexOf(\u0026#39;/\u0026#39;) + 1; 23 link = link.substring(beginPos, endPos); 24 25 var toprocess = [\u0026#39;excerpt\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;content\u0026#39;]; 26 27 ... 28 29 // å°†æ‰€æœ‰\u0026#39;src\u0026#39;æ›¿æ¢ä¸º\u0026#39;data-src\u0026#39; 30 $(\u0026#39;img\u0026#39;).each(function(){ 31 if ($(this).attr(\u0026#39;data-src\u0026#39;)){ 32 // For windows style path, we replace \u0026#39;\\\u0026#39; to \u0026#39;/\u0026#39;. 33 var src = $(this).attr(\u0026#39;data-src\u0026#39;).replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;); 34 if(!(/http[s]*.*|\\/\\/.*/.test(src) 35 || /^\\s+\\//.test(src) 36 || /^\\s*\\/uploads|images\\//.test(src))) { 37 ... 38 39 $(this).attr(\u0026#39;data-src\u0026#39;, config.root + link + src); 40 console.info\u0026amp;\u0026amp;console.info(\u0026#34;update link as:--\u0026gt;\u0026#34;+config.root + link + src); 41 } 42 ... æ¸…é™¤ç¼“å­˜ï¼Œé‡æ–°ç”Ÿæˆåšå®¢ï¼Œæ‰“å¼€æœ¬åœ°æœåŠ¡ï¼ŒæŸ¥çœ‹æ•ˆæœ\n3.2 MathJax ä½¿ç”¨MathJaxï¼Œå¼€å¯LaTeXæ•°å­¦å…¬å¼æ”¯æŒã€‚é¦–å…ˆæ›´æ¢è§£æå™¨ï¼Œæ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤\n1# å¸è½½hexo-renderer-marked 2npm uninstall hexo-renderer-marked --save 3# å®‰è£…hexo-renderer-pandoc 4npm install hexo-renderer-pandoc --save ç„¶åå®‰è£…Pandocï¼Œå¹¶ä¸”é…ç½®å¥½ç¯å¢ƒå˜é‡ã€‚åœ¨åšå®¢æ ¹ç›®å½•_config.next.yamlä¸­æ·»åŠ \n1math: 2 mathjax: 3 enable: true ä½¿ç”¨æ—¶éœ€è¦åœ¨æ–‡ç« çš„front-matteré‡Œæ‰“å¼€mathjax: trueï¼Œç®€å•æµ‹è¯•\n1$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$ $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$\n1$$ f(a) = \\frac{1}{2\\pi i} \\oint\\frac{f(z)}{z-a}dz $$ $$ f(a) = \\frac{1}{2\\pi i} \\oint\\frac{f(z)}{z-a}dz $$\n1$$ \\cos(\\theta+\\phi)=\\cos(\\theta)\\cos(\\phi)âˆ’\\sin(\\theta)\\sin(\\phi) $$ $$ \\cos(\\theta+\\phi)=\\cos(\\theta)\\cos(\\phi)âˆ’\\sin(\\theta)\\sin(\\phi) $$\n1$$ \\int_D ({\\nabla\\cdot} F)dV=\\int_{\\partial D} F\\cdot ndS $$ $$ \\int_D ({\\nabla\\cdot} F)dV=\\int_{\\partial D} F\\cdot ndS $$\n1$$ 2\\vec{\\nabla} \\times \\vec{F} = 3 \\left( \\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z} \\right) \\mathbf{i} 4 + \\left( \\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x} \\right) \\mathbf{j} 5 + \\left( \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y} \\right) \\mathbf{k} 6$$ $$ \\vec{\\nabla} \\times \\vec{F} = \\left( \\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z} \\right) \\mathbf{i} + \\left( \\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x} \\right) \\mathbf{j} + \\left( \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y} \\right) \\mathbf{k} $$\n1$$ \\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2} $$ $$ \\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2} $$\n1$$ 2(\\nabla_X Y)^k = X^i (\\nabla_i Y)^k 3 = X^i \\left( \\frac{\\partial Y^k}{\\partial x^i} + \\Gamma_{im}^k Y^m \\right) 4$$ $$ (\\nabla_X Y)^k = X^i (\\nabla_i Y)^k = X^i \\left( \\frac{\\partial Y^k}{\\partial x^i} + \\Gamma_{im}^k Y^m \\right) $$\n3.3 æœç´¢åŠŸèƒ½ å®‰è£…æœç´¢æ’ä»¶\n1npm i hexo-generator-searchdb --save æ‰“å¼€ _config.next.yml ï¼Œæ·»åŠ \n1local_search: 2 enable: true æ‰“å¼€hexoçš„ç«™ç‚¹é…ç½® _config.ymlï¼Œæ·»åŠ \n1search: 2 path: search.json 3 field: post 4 format: html 5 limit: 10000 3.4 ç»Ÿè®¡åŠŸèƒ½ æ˜¾ç¤ºæ–‡ç« å­—æ•°ç»Ÿè®¡ã€é˜…è¯»æ—¶é•¿åŠæ€»å­—æ•°ã€‚é¦–å…ˆå®‰è£…æ’ä»¶\n1npm i hexo-word-counter --save ä¿®æ”¹åšå®¢æ ¹ç›®å½•_config.ymlé…ç½®\n1symbols_count_time: 2 symbols: true 3 time: true 4 total_symbols: true 5 total_time: true 6 exclude_codeblock: true 7 awl: 2 8 wpm: 300 9 suffix: \u0026#34;åˆ†é’Ÿ\u0026#34; ä¿®æ”¹åšå®¢æ ¹ç›®å½•_config.next.ymlä¸»é¢˜é…ç½®\n1symbols_count_time: 2 separated_meta: false 3 item_text_total: true 3.5 ç®€æ˜“ç›¸å†Œ å¾—ç›ŠäºMarkdownå’ŒHTMLæ··ç¼–å¯ä»¥è¢«éƒ¨åˆ†è§£æå™¨è§£æçš„ä¼˜åŠ¿ï¼Œå¯ä»¥ä½¿ç”¨HTML+CSSï¼Œæ·»åŠ ä¸€ä¸ªç®€æ˜“ç›¸å†Œã€‚\næ³¨æ„ï¼šä¹‹å‰ç”±äºä¸ºäº†ä½¿ç”¨MathJaxè€Œæ›´æ¢è§£æå™¨ä¸ºPandocï¼Œå¯¹äºéœ€è¦è§£æraw-htmlçš„æ–‡ç« ï¼Œæ‰€æœ‰æ ‡ç­¾å‰ä¸åº”æœ‰ç©ºæ ¼ï¼Œä¸”å—çº§æ ‡ç­¾å‰åéœ€è¦ç•™å‡ºç©ºè¡Œ\né¦–å…ˆhexo n page galleryï¼Œåˆ›å»ºå›¾åº“ã€‚ä¿®æ”¹å›¾åº“é¡µé¢gallery/index.mdï¼ŒæŒ‰ç…§ä»¥ä¸‹æ ¼å¼æ·»åŠ ç›¸å†Œï¼Œç›¸å†Œå°é¢å›¾ç‰‡æ”¾è‡³gallery/index/ç›®å½•ä¸‹ã€‚\n1\u0026lt;div class=\u0026#34;gallery-list\u0026#34;\u0026gt; 2\u0026lt;div class=\u0026#34;gallery-item\u0026#34;\u0026gt; 3\u0026lt;a href=\u0026#34;ç›¸å†Œ1/\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;gallery/index/ç›¸å†Œ1å°é¢.jpg\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 4\u0026lt;p\u0026gt;-ç›¸å†Œ1-\u0026lt;/p\u0026gt; 5\u0026lt;/div\u0026gt; 6 7\u0026lt;div class=\u0026#34;gallery-item\u0026#34;\u0026gt; 8\u0026lt;a href=\u0026#34;ç›¸å†Œ2/\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;gallery/index/ç›¸å†Œ2å°é¢.jpg\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; 9\u0026lt;p\u0026gt;-ç›¸å†Œ2-\u0026lt;/p\u0026gt; 10\u0026lt;/div\u0026gt; 11\u0026lt;/div\u0026gt; æ–°å»ºç›¸å†Œé¡µé¢gallery/ç›¸å†Œå/index.mdï¼ŒæŒ‰ç…§ä»¥ä¸‹æ ¼å¼æ·»åŠ å›¾ç‰‡ï¼Œå›¾ç‰‡æ”¾è‡³gallery/ç›¸å†Œå/index/ç›®å½•ä¸‹ï¼Œå…¶å®ƒç›¸å†ŒåŒç†ã€‚\n1 2\u0026lt;div class=\u0026#34;img-list\u0026#34;\u0026gt; 3\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡1.png\u0026#34; alt=\u0026#34;å›¾ç‰‡1æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 4\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡2.jpg\u0026#34; alt=\u0026#34;å›¾ç‰‡2æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 5\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡3.png\u0026#34; alt=\u0026#34;å›¾ç‰‡3æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 6\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡4.png\u0026#34; alt=\u0026#34;å›¾ç‰‡4æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 7\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡5.jpg\u0026#34; alt=\u0026#34;å›¾ç‰‡5æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 8\u0026lt;div class=\u0026#34;img-item\u0026#34;\u0026gt;\u0026lt;img data-src=\u0026#34;ç›¸å†Œ1/index/å›¾ç‰‡6.png\u0026#34; alt=\u0026#34;å›¾ç‰‡6æ ‡é¢˜\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 9\u0026lt;/div\u0026gt; åœ¨åšå®¢æ ¹ç›®å½•ä¸‹ _config.next.yml ä¸­æ·»åŠ \n1menu: 2 gallery: /gallery/ || fa fa-camera åœ¨ä¸»é¢˜ç›®å½•ä¸‹ï¼Œä¿®æ”¹å›½é™…åŒ–æ–‡ä»¶languages\\zh-CN.ymlï¼Œæ·»åŠ \n1menu: 2 gallery: ç›¸å†Œ åœ¨åšå®¢æ ¹ç›®å½•ä¸‹ï¼Œæ–°å»ºsource/_data/styles.stylï¼Œæ·»åŠ è‡ªå®šä¹‰æ ·å¼\n1// è‡ªå®šä¹‰ç›¸å†Œ 2.img-list, .gallery-list { 3 gap: 1rem; 4 grid-gap: 1rem; 5 display: grid; 6 grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 7 padding: 1rem; 8 align-items: center; 9 align-content: center; 10 justify-items: center; 11 justify-content: center; 12} 13 14.img-item img, .gallery-item img { 15 width: 250px; 16 height: 200px; 17 object-fit: cover; 18 border: 1px solid rgba(221, 221, 221, 0.5); 19 border-radius: 7px; 20 margin-top: 10px; 21 margin-left: 5px; 22 margin-right: 5px; 23} 24 25.gallery-item p { 26 margin: 0 auto; 27 max-width: 50%; 28 border: 1px solid $black-deep; 29 border-radius: 7px; 30 background: rgba(255, 255, 255, 0.3); 31 box-shadow: 0 8px 20px -8px rgba(0, 0, 0, 0.3); 32 color: $black-deep; 33 text-align: center; 34 font-size: 15px; 35} 36 37@media (max-width: 767px) { 38 .gallery-item p { 39 min-width: 75px; 40 font-size: 13px; 41 } 42} ä¿®æ”¹åšå®¢æ ¹ç›®å½•ä¸‹_config.next.ymlï¼Œå¼•ç”¨è‡ªå®šä¹‰æ ·å¼\n1custom_file_path: 2 style: source/_data/styles.styl 3.6 æ·»åŠ åˆ†ç±»å’Œæ ‡ç­¾ æ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤\n1# æ–°å»ºåˆ†ç±» 2hexo n page categories 3# æ–°å»ºæ ‡ç­¾ 4hexo n page tags ä¿®æ”¹source/categories/index.mdï¼Œåœ¨front-matterä¸­æ·»åŠ \n1--- 2title: åˆ†ç±» 3date: 2022-04-22 16:47:13 4type: \u0026#34;categories\u0026#34; 5--- ä¿®æ”¹source/tags/index.mdï¼Œåœ¨front-matterä¸­æ·»åŠ \n1--- 2title: æ ‡ç­¾ 3date: 2022-04-22 16:47:30 4type: \u0026#34;tags\u0026#34; 5--- 3.7 ä»£ç æŠ˜å  å¼ºæ¨hexoåšå®¢ä»£ç æŠ˜å åŠŸèƒ½\nåœ¨ä¸»é¢˜ç›®å½•ä¸‹ï¼Œæ·»åŠ source/js/code-unfold.jsï¼Œ\n1var CODE_MAX_HEIGHT = 250; 2var containers = []; 3 4// å±•å¼€ 5$(\u0026#39;body\u0026#39;).on(\u0026#39;click\u0026#39;, \u0026#39;.js_unfold_code_btn\u0026#39;, function () { 6 $(this).closest(\u0026#39;.js_highlight_container\u0026#39;).addClass(\u0026#39;on\u0026#39;); 7}); 8// æ”¶èµ· 9$(\u0026#39;body\u0026#39;).on(\u0026#39;click\u0026#39;, \u0026#39;.js_retract_code_btn\u0026#39;, function () { 10 var $container = $(this).closest(\u0026#39;.js_highlight_container\u0026#39;).removeClass(\u0026#39;on\u0026#39;); 11 var winTop = $(window).scrollTop(); 12 var offsetTop = $container.offset().top; 13 $(this).css(\u0026#39;top\u0026#39;, 0); 14 if (winTop \u0026gt; offsetTop) { 15 // è®¾ç½®æ»šåŠ¨æ¡ä½ç½® 16 $(\u0026#39;body, html\u0026#39;).animate({ 17 scrollTop: $container.offset().top - CODE_MAX_HEIGHT 18 }, 600); 19 } 20}); 21// æ»šåŠ¨äº‹ä»¶ï¼Œè§¦å‘åŠ¨ç”»æ•ˆæœ 22$(window).on(\u0026#39;scroll\u0026#39;, function () { 23 var scrollTop = $(window).scrollTop(); 24 var temp = []; 25 for (let i = 0; i \u0026lt; containers.length; i++) { 26 var item = containers[i]; 27 var { 28 $container, 29 height, 30 $hide, 31 hasHorizontalScrollbar 32 } = item; 33 if ($container.closest(\u0026#39;body\u0026#39;).length === 0) { 34 // å¦‚æœ $container å…ƒç´ å·²ç»ä¸åœ¨é¡µé¢ä¸Š, åˆ™åˆ é™¤è¯¥å…ƒç´  35 // é˜²æ­¢pjaxé¡µé¢è·³è½¬ä¹‹åï¼Œå…ƒç´ æœªåˆ é™¤ 36 continue; 37 } 38 temp.push(item); 39 if (!$container.hasClass(\u0026#39;on\u0026#39;)) { 40 continue; 41 } 42 var offsetTop = $container.offset().top; 43 var hideBtnHeight = $hide.outerHeight(); 44 // å‡å»æŒ‰é’®é«˜åº¦ï¼Œå‡å»åº•éƒ¨æ»šåŠ¨æ¡é«˜åº¦ 45 var maxTop = parseInt(height - (hasHorizontalScrollbar ? 17 : 0) - hideBtnHeight); 46 let top = parseInt( 47 Math.min( 48 Math.max(scrollTop - offsetTop, 0), // å¦‚æœå°äº 0 ï¼Œåˆ™å– 0 49 maxTop, // å¦‚æœå¤§äº height ï¼Œåˆ™å– height 50 ) 51 ); 52 // æ ¹æ® sin æ›²çº¿è®¾ç½®\u0026#34;æ”¶èµ·ä»£ç \u0026#34;ä½ç½® 53 var halfHeight = parseInt($(window).height() / 2 * Math.sin((top / maxTop) * 90 * (2 * Math.PI / 360))); 54 $hide.css(\u0026#39;top\u0026#39;, Math.min(top + halfHeight, maxTop)); 55 } 56 containers = temp; 57}); 58 59// æ·»åŠ éšè—å®¹å™¨ 60function addCodeWrap($node) { 61 var $container = $node.wrap(\u0026#39;\u0026lt;div class=\u0026#34;js_highlight_container highlight-container\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;highlight-wrap\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;).closest(\u0026#39;.js_highlight_container\u0026#39;); 62 63 // åº•éƒ¨ \u0026#34;å±•å¼€ä»£ç \u0026#34; ä¸ ä¾§è¾¹æ  \u0026#34;æ”¶èµ·ä»£ç \u0026#34; 64 var $btn = $(` 65 \u0026lt;div class=\u0026#34;highlight-footer\u0026#34;\u0026gt; 66 \u0026lt;a class=\u0026#34;js_unfold_code_btn show-btn\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;å±•å¼€ä»£ç \u0026lt;i class=\u0026#34;fa fa-angle-down\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026lt;/a\u0026gt; 67 \u0026lt;/div\u0026gt; 68 \u0026lt;a class=\u0026#34;js_retract_code_btn hide-btn\u0026#34; href=\u0026#34;javascript:;\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fa fa-angle-up\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;æ”¶èµ·ä»£ç \u0026lt;/a\u0026gt; 69 `); 70 71 $container.append($btn); 72 return $container; 73}; 74 75function codeUnfold() { 76 $(\u0026#39;.highlight\u0026#39;).each(function () { 77 // é˜²æ­¢é‡å¤æ¸²æŸ“ 78 if (this.__render__ === true) { 79 return true; 80 } 81 this.__render__ = true; 82 var $this = $(this); 83 var height = $(this).outerHeight(); 84 if (height \u0026gt; CODE_MAX_HEIGHT) { 85 // æ·»åŠ å±•å¼€\u0026amp;æ”¶èµ·å®¹å™¨ 86 var $container = addCodeWrap($this, height); 87 containers.push({ 88 $container, 89 height, 90 $hide: $container.find(\u0026#39;.js_retract_code_btn\u0026#39;), 91 hasHorizontalScrollbar: this.scrollWidth \u0026gt; this.offsetWidth, 92 }); 93 } 94 }); 95}; åœ¨NexTä¸»é¢˜ä¸­å…¨å±€å¼•ç”¨jQueryï¼Œæˆ–è€…åœ¨_config.next.ymlä¸­å¼€å¯Fancyboxï¼ŒFancyboxä¼šä¾èµ–jQueryï¼Œ\n1fancybox: true å¼•ç”¨code-unfold.jsï¼Œåœ¨ä¸»é¢˜ç›®å½•ä¸‹ï¼Œlayout/_scripts/index.njkçš„æœ€åæ·»åŠ \n1{{- next_js(\u0026#39;code-unfold.js\u0026#39;) }} ä¿®æ”¹ä¸»é¢˜ç›®å½•ä¸‹source/js/next-boot.js\n1NexT.boot.refresh = function() { 2 // æ·»åŠ ä¸€è¡Œä»£ç  3 codeUnfold(); 4 // ... æ‰“å¼€ä¹‹å‰åˆ›å»ºçš„source/_data/styles.stylï¼Œæ·»åŠ \n1// å±•å¼€æ”¶èµ·æ•ˆæœ 2.highlight-container { 3 position: relative; 4 background-color: highlight-background; 5 6 \u0026amp;.on { 7 .highlight-footer { 8 display: none; 9 } 10 11 .hide-btn { 12 display: flex; 13 } 14 15 .highlight-wrap { 16 max-height: none; 17 } 18 } 19 20 .highlight-wrap { 21 overflow: hidden; 22 max-height: 200px; 23 } 24 25 .highlight-footer { 26 position: absolute; 27 bottom: 0; 28 left: 0; 29 width: 100%; 30 height: 60px; 31 background-image: \u0026#39;linear-gradient(-180deg, rgba(255,255,255,0) 0%, %s 65%)\u0026#39; % highlight-background; 32 text-align: center; 33 } 34 35 .show-btn { 36 position: absolute; 37 bottom: 0; 38 left: 50%; 39 padding: 0 0.8em; 40 border-radius: 4px 4px 0; 41 color: #fff; 42 text-align: center; 43 text-decoration: none; 44 font-size: 12px; 45 line-height: 2em; 46 transform: translateX(-50%); 47 48 \u0026amp;:hover { 49 text-decoration: none; 50 } 51 } 52 53 .hide-btn { 54 position: absolute; 55 top: 0; 56 left: -21px; 57 display: none; 58 flex-direction: column; 59 padding: 0.1em 0 0.6em; 60 width: 22px; 61 border-radius: 4px 0 0 4px; 62 background-color: highlight-background; 63 color: #fff; 64 text-align: center; 65 text-decoration: none; 66 font-size: 12px; 67 line-height: 1em; 68 transition: top ease 0.35s; 69 } 70 71 .fa-angle-up, .fa-angle-down { 72 color: #fff; 73 font-style: normal; 74 } 75 76 .fa-angle-up:before { 77 content: \u0026#39;\\f106\u0026#39;; 78 } 79 80 .fa-angle-down:before { 81 margin-left: 0.5em; 82 content: \u0026#39;\\f107\u0026#39;; 83 } 84 85 .js_unfold_code_btn, .js_retract_code_btn { 86 border-bottom: none !important; 87 background: rgba(0, 0, 0, 0.5); 88 89 \u0026amp;:hover { 90 border-bottom-color: none !important; 91 } 92 } 93} 3.8 æŠ˜å å†…å®¹ æ¨èHexo é™æ€åšå®¢æ·»åŠ å¯æŠ˜å å†…å®¹\nåœ¨ä¸»é¢˜ç›®å½•ä¸‹åˆ›å»ºscripts/tags/fold_tag.js\n1/* global hexo */ 2// Usage: {% fold Title %} Something {% endfold %} 3function fold(args, content) { 4 var text = args[0]; 5 if (!text) text = \u0026#34;ç‚¹å‡»æ˜¾ç¤º/éšè—\u0026#34;; 6 return \u0026#39;\u0026lt;div\u0026gt;\u0026lt;div class=\u0026#34;fold_hider\u0026#34;\u0026gt;\u0026lt;div class=\u0026#34;close hider_title\u0026#34;\u0026gt;\u0026#39; + 7 hexo.render.renderSync({ 8 text: text, 9 engine: \u0026#39;markdown\u0026#39; 10 }).replace(/^\u0026lt;p\u0026gt;/, \u0026#39;\u0026#39;).replace(/\u0026lt;\\/p\u0026gt;$/, \u0026#39;\u0026#39;) + 11 \u0026#39;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;fold\u0026#34;\u0026gt;\\n\u0026#39; + 12 hexo.render.renderSync({ 13 text: content, 14 engine: \u0026#39;markdown\u0026#39; 15 }) + 16 \u0026#39;\\n\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;; 17} 18hexo.extend.tag.register(\u0026#39;fold\u0026#39;, fold, { 19 ends: true 20}); åœ¨ä¸»é¢˜ç›®å½•ä¸‹åˆ›å»ºsource/js/fold_action.js\n1$(document).ready(function () { 2 $(document).on(\u0026#39;click\u0026#39;, \u0026#39;.fold_hider\u0026#39;, function () { 3 $(\u0026#39;\u0026gt;.fold\u0026#39;, this.parentNode).slideToggle(); 4 $(\u0026#39;\u0026gt;:first\u0026#39;, this).toggleClass(\u0026#39;open\u0026#39;); 5 }); 6 //é»˜è®¤æƒ…å†µä¸‹æŠ˜å  7 $(\u0026#34;div.fold\u0026#34;).css(\u0026#34;display\u0026#34;, \u0026#34;none\u0026#34;); 8}); æ‰“å¼€ä¹‹å‰åˆ›å»ºçš„source/_data/styles.stylï¼Œæ·»åŠ \n1// toggle hider title 2.hider_title { 3 cursor: pointer; 4 background: #eeeeee; 5} 6 7// toggle indicators 8.close:before { 9 padding-left: 0.5em; 10 padding-right: 0.5em; 11 content: \u0026#39;â–¼\u0026#39;; 12} 13 14.open:before { 15 padding-left: 0.5em; 16 padding-right: 0.5em; 17 content: \u0026#39;â–²\u0026#39;; 18} 19 20// inline code 21p code, .hider_title code { 22 color: #c71585; 23 background: #fffafa; 24 margin: 2px; 25} åœ¨åšå®¢æ ¹ç›®å½•_config.next.ymlä¸­æ·»åŠ \n1custom_file_path: 2 bodyEnd: source/_data/body-end.njk åœ¨åšå®¢æ ¹ç›®å½•ä¸‹åˆ›å»ºsource/_data/body-end.njk\n1{# ä»£ç æŠ˜å  #} 2\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/js/fold_action.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ä½¿ç”¨foldæ ‡ç­¾ï¼Œå¯ä»¥æŠ˜å å†…å®¹\n1{% fold æŠ˜å å†…å®¹ %} 2 Hello World 3{% endfold %} {% fold æŠ˜å å†…å®¹ %} Hello World {% endfold %}\næ³¨æ„ï¼šå¦‚æœå¼€å¯äº†pjaxï¼Œåˆ™éœ€è¦ä¿®æ”¹ä¸»é¢˜ç›®å½•ä¸‹source/js/next-boot.js\n1NexT.boot.refresh = function() { 2 // æ·»åŠ ä¸€è¡Œä»£ç  3 $(\u0026#34;div.fold\u0026#34;).css(\u0026#34;display\u0026#34;, \u0026#34;none\u0026#34;); 4 // ... 3.9 å‹ç¼© æ·»åŠ å®˜æ–¹æ’ä»¶hexo-clean-cssã€hexo-html-minifierå’Œhexo-uglify\n1npm i hexo-clean-css hexo-html-minifier hexo-uglify --save åœ¨åšå®¢æ ¹ç›®å½•_config.ymlä¸­æ·»åŠ \n1uglify: 2 mangle: true 3 # è¿™å„¿ä¸èƒ½ä¸ºç©ºï¼Œä¸ºç©ºä¼šå¯¼è‡´ js æ–‡ä»¶å‹ç¼© 4 # output: 5 # compress: 6 exclude: 7 - \u0026#39;*.min.js\u0026#39; 8 es6: false 9 10clean_css: 11 exclude: 12 - \u0026#39;*.min.css\u0026#39; 13 14html_minifier: 15 collapseBooleanAttributes: true 16 collapseWhitespace: true 17 # Ignore \u0026#39;\u0026lt;!-- more --\u0026gt;\u0026#39; https://hexo.io/docs/tag-plugins#Post-Excerpt 18 ignoreCustomComments: [ !!js/regexp /^\\s*more/] 19 removeComments: true 20 removeEmptyAttributes: true 21 removeScriptTypeAttributes: true 22 removeStyleLinkTypeAttributes: true 23 minifyJS: true 24 minifyCSS: true 3.10 è¯„è®ºç³»ç»Ÿ Gitalkæ˜¯ä¸€ä¸ªåŸºäºGitHub Issueå’ŒPreactå¼€å‘çš„è¯„è®ºæ’ä»¶ã€‚\né¦–å…ˆéœ€è¦å»GitHubæ–°å»ºä¸€ä¸ªä»“åº“ï¼Œç‚¹å‡»Newåˆ›å»º\nç„¶ååˆ›å»ºGitHub Application\nç„¶åç‚¹å‡»Generate a new client secretï¼ŒéªŒè¯GitHubå¯†ç åï¼Œä¿å­˜å¥½Client IDå’ŒClient secrets\nåœ¨åšå®¢æ ¹ç›®å½•ä¸‹_config.next.ymlä¸­æ·»åŠ \n1comments: 2 style: buttons 3 active: gitalk 4 storage: true 5 lazyload: true 6 nav: 7 gitalk: 8 order: -2 9 10gitalk: 11 enable: true 12 github_id: gh1656409967 13 repo: Gitalk 14 client_id: adfg89av4s9bf4s89nsn 15 client_secret: 1561aefeaegadadag5e1a68bbfsnyfsrg4587sr7 16 admin_user: gh1656409967 17 distraction_free_mode: true 18 proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token 19 language: zh-CN ç„¶åæ¯æ¬¡æ–°ç”Ÿæˆæ–‡ç« /é¡µé¢åï¼Œéƒ½éœ€è¦å»æ–‡ç« é¡µåˆå§‹åŒ–Issues\nç‚¹å‡»ä½¿ç”¨GitHubç™»å½•åï¼Œå†ç‚¹å‡»Authorize username\nåˆ·æ–°åå³å¯å¼€å¯è¯„è®º\n3.11 åšæ–‡åŠ å¯† é¦–å…ˆæ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œå®‰è£…hexo-blog-encryptæ’ä»¶\n1npm install hexo-blog-encrypt --save åœ¨éœ€è¦åŠ å¯†çš„æ–‡ç« å¼€å¤´front-matterä¸­æ·»åŠ \n1password: 123456 2abstract: åšæ–‡è¢«åŠ å¯†äº†, è¯·è¾“å…¥å¯†ç æŸ¥çœ‹ã€‚ 3message: æ‚¨å¥½, è¿™é‡Œéœ€è¦å¯†ç ã€‚ 4wrong_pass_message: æŠ±æ­‰, è¿™ä¸ªå¯†ç çœ‹ç€ä¸å¤ªå¯¹, è¯·å†è¯•è¯•ã€‚ æ³¨æ„ï¼ŒFancyboxå¯èƒ½ä¼šä¸åŠ è½½ï¼Œå¤åˆ¶themes\\next\\source\\js\\third-party\\fancybox.jsçš„å†…å®¹ï¼Œæ·»åŠ åˆ°node_modules\\hexo-blog-encrypt\\lib\\hbe.jsä¸­\n1 ... 2 3 // æ·»åŠ å†…å®¹ 4 function refreshfancybox() { 5 document.querySelectorAll(\u0026#39;.post-body :not(a) \u0026gt; img, .post-body \u0026gt; img\u0026#39;).forEach(element =\u0026gt; { 6 const $image = $(element); 7 const imageLink = $image.attr(\u0026#39;data-src\u0026#39;) || $image.attr(\u0026#39;src\u0026#39;); 8 const $imageWrapLink = $image.wrap(`\u0026lt;a class=\u0026#34;fancybox fancybox.image\u0026#34; href=\u0026#34;${imageLink}\u0026#34; itemscope itemtype=\u0026#34;http://schema.org/ImageObject\u0026#34; itemprop=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;`).parent(\u0026#39;a\u0026#39;); 9 if ($image.is(\u0026#39;.post-gallery img\u0026#39;)) { 10 $imageWrapLink.attr(\u0026#39;data-fancybox\u0026#39;, \u0026#39;gallery\u0026#39;).attr(\u0026#39;rel\u0026#39;, \u0026#39;gallery\u0026#39;); 11 } else if ($image.is(\u0026#39;.group-picture img\u0026#39;)) { 12 $imageWrapLink.attr(\u0026#39;data-fancybox\u0026#39;, \u0026#39;group\u0026#39;).attr(\u0026#39;rel\u0026#39;, \u0026#39;group\u0026#39;); 13 } else { 14 $imageWrapLink.attr(\u0026#39;data-fancybox\u0026#39;, \u0026#39;default\u0026#39;).attr(\u0026#39;rel\u0026#39;, \u0026#39;default\u0026#39;); 15 } 16 17 const imageTitle = $image.attr(\u0026#39;title\u0026#39;) || $image.attr(\u0026#39;alt\u0026#39;); 18 if (imageTitle) { 19 // Do not append image-caption if pandoc has already created a figcaption 20 if (!$imageWrapLink.next(\u0026#39;figcaption\u0026#39;).length) { 21 $imageWrapLink.append(`\u0026lt;p class=\u0026#34;image-caption\u0026#34;\u0026gt;${imageTitle}\u0026lt;/p\u0026gt;`); 22 } 23 // Make sure img title tag will show correctly in fancybox 24 $imageWrapLink.attr(\u0026#39;title\u0026#39;, imageTitle).attr(\u0026#39;data-caption\u0026#39;, imageTitle); 25 } 26 }); 27 28 $.fancybox.defaults.hash = false; 29 $(\u0026#39;.fancybox\u0026#39;).fancybox({ 30 loop: true, 31 helpers: { 32 overlay: { 33 locked: false 34 } 35 } 36 }); 37 } 38 39 async function decrypt(decryptKey, iv, hmacKey) { 40 let typedArray = hexToArray(encryptedData); 41 42 const result = await cryptoObj.subtle.decrypt({ 43 \u0026#39;name\u0026#39;: \u0026#39;AES-CBC\u0026#39;, 44 \u0026#39;iv\u0026#39;: iv, 45 }, decryptKey, typedArray.buffer).then(async (result) =\u0026gt; { 46 47 ... 48 49 // æ·»åŠ å†…å®¹ 50 refreshfancybox(); 51 52 return await verifyContent(hmacKey, decoded); 53 }).catch((e) =\u0026gt; { 54 alert(wrongPassMessage); 55 console.log(e); 56 return false; 57 }); 58 59 ... 3.11 aplayeréŸ³ä¹æ’­æ”¾å™¨ é¦–å…ˆæ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œå®‰è£…aplayeræ’ä»¶\n1npm install aplayer --save åœ¨source/_data/body-end.njkæ·»åŠ ä»¥ä¸‹å†…å®¹\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css\u0026#34; integrity=\u0026#34;sha512-CIYsJUa3pr1eoXlZFroEI0mq0UIMUqNouNinjpCkSWo3Bx5NRlQ0OuC6DtEB/bDqUWnzXc1gs2X/g52l36N5iw==\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; referrerpolicy=\u0026#34;no-referrer\u0026#34; /\u0026gt; 2\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js\u0026#34; integrity=\u0026#34;sha512-RWosNnDNw8FxHibJqdFRySIswOUgYhFxnmYO3fp+BgCU7gfo4z0oS7mYFBvaa8qu+axY39BmQOrhW3Tp70XbaQ==\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; referrerpolicy=\u0026#34;no-referrer\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 4 5\u0026lt;script\u0026gt; 6 const ap = new APlayer({ 7 container: document.getElementById(\u0026#39;aplayer\u0026#39;), 8 fixed: true, 9 listFolded: true, 10 lrcType: 3, 11 audio: [ 12 { 13 name: \u0026#39;AVICII UMF2016 Live\u0026#39;, 14 artist: \u0026#39;Avicii\u0026#39;, 15 url: \u0026#39;https://music.163.com/song/media/outer/url?id=440767926.mp3\u0026#39;, 16 cover: \u0026#39;http://p2.music.126.net/kmo__VMOex_fRScv2RXStA==/109951162842392590.jpg\u0026#39;, 17 lrc: \u0026#39;/lyric/AVICII UMF2016 Live.lrc\u0026#39; 18 }, 19 { 20 ... 21 }, 22 ] 23 }); 24\u0026lt;/script\u0026gt; å…¶ä¸­ï¼ŒAPlayer.min.jså’ŒAPlayer.min.csså¯ä»¥ä½¿ç”¨CDNï¼Œä¹Ÿå¯ä»¥åœ¨GitHubä¸Šä¸‹è½½ã€‚é…ç½®å†…å®¹çš„å…·ä½“å«ä¹‰å‚è€ƒAPlayerå®˜æ–¹æ–‡æ¡£ã€‚\nurlåé¢å¡«å†™æ­Œæ›²å¤–é“¾ã€‚æ‰“å¼€ç½‘é¡µç‰ˆç½‘æ˜“äº‘éŸ³ä¹ï¼Œé€‰æ‹©éVIPæ­Œæ›²ï¼Œç‚¹å¼€è‡³æ­Œè¯é¡µé¢ï¼Œå°†åœ°å€æ ä¸­çš„æ­Œæ›²idï¼Œå¤åˆ¶åˆ°https://music.163.com/song/media/outer/url?id=xxxx.mp3å¯¹åº”ä½ç½®ã€‚\ncoveråé¢å¡«å†™å°é¢å›¾ç‰‡é“¾æ¥ã€‚ä»¥edgeä¸ºä¾‹ï¼ŒæŒ‰F12è¿›å…¥æ§åˆ¶å°ï¼Œä½¿ç”¨é€‰æ‹©å…ƒç´ ï¼Œé€‰ä¸­å°é¢ï¼Œåœ¨å¯¹åº”çš„imgæ ‡ç­¾å†…å¤åˆ¶data-srcå±æ€§çš„å€¼ã€‚\nlrcåé¢å¡«å†™æœ¬åœ°ä¿å­˜çš„æ­Œè¯æ–‡ä»¶ã€‚ä»¥edgeä¸ºä¾‹ï¼ŒæŒ‰F12è¿›å…¥æ§åˆ¶å°ï¼Œé€‰æ‹©ç½‘ç»œï¼Œæœç´¢lyricï¼Œç„¶ååˆ·æ–°æ­Œè¯é¡µé¢ï¼Œæ‰¾åˆ°å¯¹åº”çš„æ­Œè¯æ–‡ä»¶ï¼Œlrcå¯¹åº”å¤–æ–‡æ­Œè¯ï¼Œtlyricå¯¹åº”ç¿»è¯‘æ­Œè¯ï¼Œå°†lyricåé¢çš„å€¼å¤åˆ¶åˆ°çš„æœ¬åœ°æ–‡ä»¶ä¸­ï¼Œä»¥.lrcæ ¼å¼ä¿å­˜ï¼Œç„¶åå¼•ç”¨å³å¯ã€‚æˆ‘è¿™é‡Œä¿å­˜åœ¨ä¸»é¢˜ç›®å½•ä¸‹source/lyric/ä¸­ã€‚\næ³¨æ„ï¼šé“¾æ¥è·³è½¬åæ’­æ”¾ä¼šè¢«æ‰“æ–­ï¼Œä½¿ç”¨pjaxå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚\n3.12 è±†ç“£æ’ä»¶ æ³¨æ„ï¼šæ­¤æ–¹æ³•é€‚åˆåƒæˆ‘è¿™æ ·çš„æ‡’äººï¼Œç”±äºhexoå‡çº§è‡³6.1.0åï¼Œä¸å†ä½¿ç”¨ejsç­‰ï¼Œå»ºè®®èƒ½æŠ˜è…¾çš„å¥½å¥½é‡å†™è¿™ä¸ªæ’ä»¶ã€‚\né¦–å…ˆæ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œæ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œå®‰è£…hexo-doubanè±†ç“£æ’ä»¶\n1npm install hexo-douban --save åœ¨åšå®¢æ ¹ç›®å½•_config.ymlä¸­æ·»åŠ \n1douban: 2 user: lordash 3 builtin: false 4 book: 5 title: \u0026#39;This is my book title\u0026#39; 6 quote: \u0026#39;This is my book quote\u0026#39; 7 movie: 8 title: \u0026#39;This is my movie title\u0026#39; 9 quote: \u0026#39;This is my movie quote\u0026#39; 10 timeout: 10000 userè±†ç“£ç”¨æˆ·åï¼Œç™»å½•è±†ç“£ï¼Œç‚¹å‡»ä¸ªäººä¸»é¡µï¼Œåœ°å€æ URLä¸­https://www.douban.com/people/xxxxxx/åçš„xxxxxxå³æ˜¯ä¸ªäººIDã€‚titleé¡µé¢æ ‡é¢˜ï¼Œbuiltinæ˜¯å¦å°†ç”Ÿæˆé¡µé¢åŠŸèƒ½åµŒå…¥hexo gä¸­ï¼Œé»˜è®¤ä¸ºfalseï¼Œquoteæ˜¯é¡µé¢å¼€å¤´çš„ä¸€æ®µè¯ï¼Œtimeoutæ˜¯è±†ç“£æ¥å£è¶…æ—¶æ—¶é—´ï¼Œé»˜è®¤ä¸º10000æ¯«ç§’ï¼Œå¦‚æœåœ¨ä½¿ç”¨æ—¶å‘ç°æŠ¥äº†è¶…æ—¶çš„é”™(ETIMEOUT)å¯ä»¥æŠŠè¿™ä¸ªæ•°æ®è®¾ç½®çš„å¤§ä¸€ç‚¹ã€‚\nç„¶åä¿®æ”¹_config.next.ymlï¼Œæ·»åŠ \n1menu: 2 books: /books/ || fa fa-book 3 movies: /movies/ || fa fa-film ä¿®æ”¹themes\\next\\languages\\zh-CN.ymlï¼Œæ·»åŠ \n1menu: 2 books: ä¹¦ç± 3 movies: å½±éŸ³ ä½¿ç”¨hexo doubanç”Ÿæˆè±†ç“£é¡µé¢ï¼Œå‘½ä»¤è¡Œæç¤º\n1INFO 0 books have been loaded in 858 ms, because you are offline or your network is bad 2INFO 0 movies have been loaded in 1751 ms, because you are offline or your network is bad æ ¹æ®æ‰“å°ï¼Œåœ¨node_modules\\hexo-douban\\lib\\books-generator.jsä¸­æ·»åŠ æ‰“å°\n1... 2var offline = false; 3# æ·»åŠ hexo-logå¼•ç”¨ 4var log = require(\u0026#39;hexo-log\u0026#39;)({ 5 debug: false, 6 silent: false 7}); 8 9var log = require(\u0026#39;hexo-log\u0026#39;)({ 10 debug: false, 11 silent: false 12}); 13 14function resolv(url, timeout, headers) { 15 16 var response = \u0026#39;\u0026#39;; 17 try { 18 response = request(url, { 19 timeout: timeout, 20 dataType: \u0026#39;xml\u0026#39;, 21 headers: headers, 22 }); 23 } catch (err) { 24 # æ‰“å°è¯¦ç»†é”™è¯¯æ—¥å¿— 25 log.error(err); 26 offline = true; 27 } 28 ... å†æ¬¡hexo doubanç”Ÿæˆï¼Œå¯ä»¥çœ‹åˆ°è¯¦ç»†é”™è¯¯æç¤ºï¼Œ\n1ERROR E:\\work\\blog\\node_modules\\urllib-sync\\request.js:44 2 var filepath = path.join(os.tmpDir(), name); 3 ^ 4 5TypeError: os.tmpDir is not a function 6 at E:\\work\\blog\\node_modules\\urllib-sync\\request.js:44:31 7 at done (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:396:5) 8 at E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:628:9 9 at decodeContent (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:469:14) 10 at IncomingMessage.\u0026lt;anonymous\u0026gt; (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:593:7) 11 at IncomingMessage.emit (node:events:538:35) 12 at endReadableNT (node:internal/streams/readable:1345:12) 13 at processTicksAndRejections (node:internal/process/task_queues:83:21) 14 15Error: E:\\work\\blog\\node_modules\\urllib-sync\\request.js:44 16 var filepath = path.join(os.tmpDir(), name); 17 ^ 18 19TypeError: os.tmpDir is not a function 20 at E:\\work\\blog\\node_modules\\urllib-sync\\request.js:44:31 21 at done (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:396:5) 22 at E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:628:9 23 at decodeContent (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:469:14) 24 at IncomingMessage.\u0026lt;anonymous\u0026gt; (E:\\work\\blog\\node_modules\\urllib\\lib\\urllib.js:593:7) 25 at IncomingMessage.emit (node:events:538:35) 26 at endReadableNT (node:internal/streams/readable:1345:12) 27 at processTicksAndRejections (node:internal/process/task_queues:83:21) 28 29 at request (E:\\work\\blog\\node_modules\\urllib-sync\\index.js:44:13) 30 at resolv (E:\\work\\blog\\node_modules\\hexo-douban\\lib\\books-generator.js:25:20) 31 at Hexo.module.exports (E:\\work\\blog\\node_modules\\hexo-douban\\lib\\books-generator.js:134:23) 32 at Hexo.tryCatcher (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) 33 at Hexo.\u0026lt;anonymous\u0026gt; (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\method.js:15:34) 34 at E:\\work\\blog\\node_modules\\hexo\\lib\\hexo\\index.js:407:22 35 at tryCatcher (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) 36 at MappingPromiseArray._promiseFulfilled (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\map.js:68:38) 37 at MappingPromiseArray.PromiseArray._iterate (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\promise_array.js:115:31) 38 at MappingPromiseArray.init (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\promise_array.js:79:10) 39 at MappingPromiseArray._asyncInit (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\map.js:37:10) 40 at _drainQueueStep (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\async.js:97:12) 41 at _drainQueue (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\async.js:86:9) 42 at Async._drainQueues (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\async.js:102:5) 43 at Immediate.Async.drainQueues [as _onImmediate] (E:\\work\\blog\\node_modules\\bluebird\\js\\release\\async.js:15:14) 44 at processImmediate (node:internal/timers:466:21) çœ‹æ¥æ˜¯ç”±äºNode.jså‡çº§åï¼Œos.tmpDir()æ–¹æ³•å¤±æ•ˆå¯¼è‡´ã€‚æˆ‘ä»¬ä½¿ç”¨os.tmpdir()æ›¿æ¢node_modules\\urllib-sync\\request.jsä¸­çš„os.tmpDir()ï¼Œå†æ¬¡ä½¿ç”¨hexo doubanåï¼Œç”ŸæˆæˆåŠŸã€‚\nä½¿ç”¨pjaxï¼Œè¿˜éœ€è¦ä¿®æ”¹node_modules\\hexo-douban\\lib\\templates\\book.ejsï¼Œ\n1/* æ·»åŠ data-pjaxå±æ€§ */ 2\u0026lt;script data-pjax\u0026gt; 3 \u0026lt;% include index.js %\u0026gt; 4 \u0026lt;% include pagination.js %\u0026gt; 5\u0026lt;/script\u0026gt; ","permalink":"https://blog.lordash.de/posts/configure/ad1c5aba78b0afc4/","summary":"1 å®‰è£…NexT v8.0 æ‰“å¼€å‘½ä»¤è¡Œï¼Œè¿›å…¥åšå®¢æ ¹ç›®å½•ï¼Œä½¿ç”¨gitä¸‹è½½NexTä¸»é¢˜ 1# ä¸‹è½½NexTä¸»é¢˜ 2git clone https://github.com/next-theme/hexo-theme-next themes/next ç„¶åä¿®æ”¹åšå®¢æ ¹ç›®å½•ä¸‹çš„_config.yml","title":"Hexoä»¥åŠNexT8ä¸»é¢˜çš„é…ç½®"},{"content":"1 åšå®¢ åšå®¢ï¼ˆblogæˆ–weblogï¼‰æ­£å¼åç§°æ˜¯ç½‘ç»œæ—¥å¿—ã€‚ä¸€ä¸ªå…¸å‹çš„åšå®¢ç»“åˆäº†æ–‡å­—ã€å›¾åƒã€é“¾æ¥ä»¥åŠå…¶å®ƒä¸»é¢˜ç›¸å…³çš„åª’ä½“ï¼ŒåŒæ—¶èƒ½å¤Ÿè®©è¯»è€…ä»¥äº’åŠ¨çš„æ–¹å¼ç•™ä¸‹å»ºè®®å’Œæ„è§ã€‚åšå®¢çš„å†…å®¹åŒ…æ‹¬ä¸“æ³¨åœ¨ç‰¹å®šè¯¾é¢˜ä¸Šçš„è¯„è®ºæˆ–æ–°é—»ï¼Œä»¥åŠä¸ªäººæ€§çš„æ—¥è®°ç­‰ã€‚\nåšå®¢ä¸»è¦å°±æ˜¯ä¸ºäº†å­¦ä¹ å’Œè®°å½•ã€‚å†™ä½œæ˜¯ä¸€ç§äº§å‡ºï¼Œèƒ½å¤Ÿè¾“å‡ºè¡¨è¾¾ã€å·©å›ºæ‰€å­¦ï¼ŒåŒæ—¶æ»¡è¶³åˆ†äº«æ¬²å’Œè¡¨è¾¾æ¬²ã€‚\nå–œæ¬¢å†™Blogçš„äººï¼Œä¼šç»å†ä¸‰ä¸ªé˜¶æ®µã€‚ ç¬¬ä¸€é˜¶æ®µï¼Œåˆšæ¥è§¦Blogï¼Œè§‰å¾—å¾ˆæ–°é²œï¼Œè¯•ç€é€‰æ‹©ä¸€ä¸ªå…è´¹ç©ºé—´æ¥å†™ã€‚ ç¬¬äºŒé˜¶æ®µï¼Œå‘ç°å…è´¹ç©ºé—´é™åˆ¶å¤ªå¤šï¼Œå°±è‡ªå·±è´­ä¹°åŸŸåå’Œç©ºé—´ï¼Œæ­å»ºç‹¬ç«‹åšå®¢ã€‚ ç¬¬ä¸‰é˜¶æ®µï¼Œè§‰å¾—ç‹¬ç«‹åšå®¢çš„ç®¡ç†å¤ªéº»çƒ¦ï¼Œæœ€å¥½åœ¨ä¿ç•™æ§åˆ¶æƒçš„å‰æä¸‹ï¼Œè®©åˆ«äººæ¥ç®¡ï¼Œè‡ªå·±åªè´Ÿè´£å†™æ–‡ç« ã€‚\nå¼•è‡ªé˜®ä¸€å³°\n1.1 å…è´¹åšå®¢ç½‘ç«™ ç¬¬ä¸€é˜¶æ®µæ˜¯æœ€å¸¸è§çš„ï¼Œä¹Ÿæ˜¯å…¥é—¨éœ€æ±‚æœ€ä½çš„ã€‚é€‰æ‹©ä¸€ä¸ªå¯ä»¥å…è´¹å‘å¸ƒåšå®¢çš„ç½‘ç«™ï¼Œæ³¨å†Œç™»å½•åå³å¯å¼€å§‹åˆ›ä½œã€‚æ—©æœŸçš„æœ‰å¤©æ¶¯ã€æ–°æµªç­‰ï¼Œè¿‘æœŸçš„æœ‰ç®€ä¹¦ã€çŸ¥ä¹ã€è±†ç“£ç­‰ã€é¢å‘å¼€å‘è€…çš„æœ‰åšå®¢å›­ã€CSDNã€æ€å¦ã€æ˜é‡‘ç­‰ã€‚\nä¼˜ç‚¹ï¼š\nå…è´¹ å¼€ç®±å³ç”¨ï¼ˆOut of the boxï¼‰ ä¸ç”¨è€ƒè™‘å†…å®¹æ¨å¹¿ ç¼ºç‚¹ï¼š\nä¾èµ–å¹³å°ï¼Œå®¡æ ¸æœºåˆ¶ã€æ•æ„Ÿè¯è¿‡æ»¤ã€é™åˆ¶å‘å¸ƒå†…å®¹ç­‰ ä¸ªæ€§åŒ–ç•Œé¢å®šåˆ¶å·®ï¼ˆåšå®¢å›­é™¤å¤–ï¼‰ å¼¹çª—ã€å¹¿å‘Š éœ€è¦ç™»å½• 1.2 æœåŠ¡å™¨ä¸Šæ­å»ºç‹¬ç«‹åšå®¢ ç¬¬äºŒé˜¶æ®µï¼Œåœ¨ä¸ªäººæœåŠ¡å™¨ä¸Šæ­å»ºç½‘ç«™ã€‚å¦‚æœæ˜¯å»ºç«™å°ç™½ï¼Œæˆ–è€…æ‡’å¾—æŠ˜è…¾ï¼Œå¯ä»¥ä½¿ç”¨å¼€æºçš„åšå®¢ç³»ç»Ÿç®€åŒ–æ­¥éª¤ã€‚ç›®å‰ä¸»æµçš„æœ‰WordPressã€Haloã€Typechoç­‰ã€‚\nä»¥WordPressä¸ºä¾‹ï¼Œè¿™æ˜¯å½“å‰åº”ç”¨æœ€å¹¿æ³›çš„CMSï¼ˆContent Management Systemï¼Œå†…å®¹ç®¡ç†ç³»ç»Ÿï¼‰ï¼Œå®ƒåŸºäºPHPå’ŒMySQLæ•°æ®åº“ï¼Œé…ç½®æ–¹ä¾¿ï¼Œä½œä¸ºå¼€æºé¡¹ç›®ï¼Œæœ‰ç€ä¼˜è´¨çš„ç¤¾åŒºå’Œä¸°å¯Œçš„æ’ä»¶ã€‚\nä¼˜ç‚¹ï¼š\nå®Œå…¨çš„å¯å®šåˆ¶åŒ– å†…å®¹å’Œè§„æ¨¡ä¸å—é™åˆ¶ ç¼ºç‚¹ï¼š\néœ€è¦è´­ä¹°æœåŠ¡å™¨å’ŒåŸŸå éœ€è¦è€ƒè™‘å†…å®¹æ¨å¹¿ï¼Œç½‘ç«™å¤‡æ¡ˆã€æ”¶å½•ä»¥åŠSEOä¼˜åŒ–ç­‰ éœ€è¦å»ºç«™ç›¸å…³çŸ¥è¯† ç»´æŠ¤å®Œå…¨é ä¸ªäºº 1.3 å…è´¹é™æ€ç½‘é¡µæ‰˜ç®¡æœåŠ¡ ç¬¬ä¸‰é˜¶æ®µï¼Œä½¿ç”¨GitHubã€Giteeã€CODINGç­‰æä¾›çš„Pageså…è´¹é™æ€ç½‘é¡µæ‰˜ç®¡æœåŠ¡ã€‚\nGitHub Pagesç›´æ¥ä»GitHubä¸Šçš„ä»£ç ä»“åº“ä¸­è·å–HTMLã€CSSå’ŒJavaScriptæ–‡ä»¶ï¼Œå¯ä»¥é€‰æ‹©é€šè¿‡æ„å»ºè¿‡ç¨‹è¿è¡Œè¿™äº›æ–‡ä»¶ï¼Œå¹¶å‘å¸ƒç½‘ç«™ã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨GitHub Pagesæ¥å±•ç¤ºå¼€æºé¡¹ç›®ï¼Œæ­å»ºåšå®¢ï¼Œæˆ–è€…åˆ†äº«ç®€å†ç­‰ã€‚\nä½ å¯ä»¥ç›´æ¥ä½¿ç”¨HTML+CSS+JSç¼–å†™åšå®¢ï¼Œä½†æ˜¯è¿™æ ·åšï¼Œæ’ç‰ˆè´¹æ—¶è´¹åŠ›ï¼Œå¯¹å‰ç«¯æŠ€æœ¯ä¹Ÿæœ‰ä¸€å®šè¦æ±‚ã€‚ç›®å‰æµè¡Œä½¿ç”¨Markdownæ¥å†™æ–‡æ¡£ï¼Œä¾‹å¦‚GitHubé¡¹ç›®ä¸­çš„README.mdã€‚\nMarkdownæ˜¯ä¸€ç§è½»é‡çº§æ ‡è®°è¯­è¨€ï¼Œä½¿ç”¨çº¯æ–‡æœ¬æ ¼å¼æ¥ç¼–å†™æ–‡æ¡£ï¼Œå¯ä¸HTMLæ··ç¼–ï¼Œè¯­æ³•ç®€æ´ï¼Œè®©åˆ›ä½œè€…èŠ‚çº¦æ’ç‰ˆè€—æ—¶ï¼Œæ›´å¤šåœ°å…³æ³¨å†…å®¹æœ¬èº«ã€‚æ‹“å±•çš„Markdownè¯­æ³•è¿˜æ”¯æŒä»£ç é«˜äº®ã€MathJaxæ•°å­¦å…¬å¼ç­‰ã€‚\nMarkdownçš„ä½¿ç”¨ï¼Œéœ€è¦é…åˆè§£æå™¨ã€‚å°†Markdownè½¬ä¸ºHTMLæ–‡ä»¶çš„æœ€ç®€å•çš„æ–¹æ³•ï¼Œå°±æ˜¯ä½¿ç”¨Markdeepï¼Œå®ƒæ˜¯ä¸€ä¸ªçº¯JSé¡¹ç›®ï¼Œåªéœ€åœ¨å°†ç¼–å†™å¥½çš„Markdownæ–‡ä»¶çš„.mdåç¼€æ”¹æˆ.htmlï¼Œå¹¶ä¸”åœ¨æ–‡ç« é‡Œå¼•ç”¨markdeep.min.jsï¼Œå°±å¯ä»¥åœ¨æµè§ˆå™¨ä¸­è®¿é—®äº†ã€‚\nä½†åšå®¢ä¸åªæœ‰ä¸€ç¯‡æ–‡ç« ï¼Œæƒ³è¦åˆ†ç±»ã€æ ‡ç­¾ã€è¯„è®ºä¹‹ç±»çš„åŠŸèƒ½ï¼Œæ›´æ™®éçš„ï¼Œå¯ä»¥é€‰æ‹©ä½¿ç”¨å¼€æºåšå®¢æ¡†æ¶ï¼Œä¾‹å¦‚Hexoï¼ŒGhostï¼ŒJekyllç­‰ã€‚\nåšå®¢æ¡†æ¶ï¼Œä¹Ÿå¯ä»¥å«åšé™æ€ç½‘ç«™ç”Ÿæˆå™¨ã€‚æ¡†æ¶å¤„ç†åšå®¢æ–‡ç« ï¼Œç”ŸæˆHTMLã€CSSã€JSæ–‡ä»¶ï¼Œé…åˆPagesæœåŠ¡æˆ–è€…éƒ¨ç½²nginxæœåŠ¡å™¨ç­‰ï¼Œå³å¯åœ¨æµè§ˆå™¨ä¸­è®¿é—®ã€‚é™æ€ç½‘ç«™æ²¡æœ‰æœåŠ¡ç«¯å¤„ç†æˆ–è€…æ•°æ®åº“äº¤äº’ï¼Œåˆ©äºä½¿ç”¨CDNï¼ˆContent Delivery Networkå†…å®¹åˆ†å‘ç½‘ç»œï¼‰è¿›è¡Œæ‰©å±•åŠ é€Ÿï¼Œç¼“å­˜ä¸Šæ¯”åŠ¨æ€ç½‘é¡µçš„æ•ˆç‡é«˜ã€‚\nJekyll Hexo Ghost è¯­è¨€ Ruby JS Go ä¼˜åŠ¿ 1.å¼ºå¤§çš„GitHub Pagesæ”¯æŒ\n2.ä¸»é¢˜ä¸ºgemsæ–¹ä¾¿åˆ†å‘ 1.ç›¸å½“å¿«é€Ÿ\n2.åœ¨GitHub Pageséƒ¨ç½²ç®€å•\n3.ä¸­æ–‡æ”¯æŒã€ä¸­æ–‡ç¤¾åŒº 1.é€Ÿåº¦éå¸¸å¿«ï¼Œå¯¹æ„å»ºé€Ÿåº¦åšäº†ä¼˜åŒ–\n2.é¢„ç½®Goæ¨¡ç‰ˆå’Œæ¨¡å¼\n3.æ— éœ€ä¾èµ–ï¼ˆä¸ç”¨å®‰è£…Goï¼Œå› ä¸ºå®ƒæ˜¯ç¼–è¯‘å¥½çš„äºŒè¿›åˆ¶ï¼‰\n4.åŠŸèƒ½å¼ºå¤§çš„å†…å®¹æ¨¡å‹ åŠ£åŠ¿ 1.å½“ç½‘ç«™å†…å®¹ä¸æ–­å¢åŠ åï¼Œ\næ„å»ºé€Ÿåº¦ä¼šæ˜æ˜¾å˜æ…¢ã€‚ 1.æ²¡æœ‰è‹±æ–‡ 1.æ²¡æœ‰å†…ç½®é»˜è®¤ä¸»é¢˜\n2.ä¸»é¢˜ä½¿ç”¨Goæ¨¡ç‰ˆï¼Œæ‰€ä»¥éœ€è¦ç†Ÿæ‚‰Go\n3.ç¼ºå°‘æ‰©å±•æ€§å’Œæ’ä»¶ï¼ˆå› ä¸ºGoæ˜¯ç¼–è¯‘å‹è¯­è¨€ï¼‰ åŠŸèƒ½ 1.Liquidæ¨¡ç‰ˆå¼•æ“\n2.Sassé¢„å¤„ç†CSS\n1.EJSæ¨¡ç‰ˆå¼•æ“\n2.å¯¹äºHTML+CSS+JSéå¸¸å‹å¥½ 1.å›½é™…åŒ–\n2.æ”¯æŒåŠ¨æ€API ä¼˜ç‚¹ï¼š\nå…è´¹ å¯å®šåˆ¶ç¨‹åº¦é«˜ ç¼ºç‚¹ï¼š\nåªæ”¯æŒé™æ€ç½‘é¡µ æ›´æ–°ç½‘é¡µéœ€è¦é‡æ–°ç”Ÿæˆæ•´ä¸ªç½‘ç«™ éœ€è¦è€ƒè™‘å†…å®¹æ¨å¹¿ï¼Œç½‘ç«™å¤‡æ¡ˆã€æ”¶å½•ä»¥åŠSEOä¼˜åŒ–ç­‰ 2 é…ç½® é…ç½®Hexoå‰éœ€è¦è‡ªè¡Œå®‰è£…çš„ç¯å¢ƒï¼š\nNode.js Git 2.1 GitHub Pagesé…ç½® ä½¿ç”¨GitHub PagesæœåŠ¡æ­å»ºè‡ªå·±çš„é™æ€åšå®¢å‰ï¼Œé¦–å…ˆéœ€è¦GitHubè´¦å·ï¼Œæ²¡æœ‰çš„è¯è¯·å…ˆæ³¨å†Œã€‚ç™»å½•ä¹‹åï¼Œç‚¹å‡»Newï¼Œåˆ›å»ºä¸€ä¸ªä»£ç ä»“åº“ï¼ˆrepositoryï¼‰ï¼Œé™¤éæ˜¯æ‰‹å¤´ä¸Šæ­£å¥½æœ‰ä¸ªé—²ç½®çš„åŸŸåï¼Œå¦åˆ™æ›´æ¨èå°†ä»“åº“åè®¾ç½®ä¸ºusername.github.ioï¼Œè¿™æ ·å¯ä»¥é€šè¿‡GitHubæä¾›çš„https://username.github.ioæ¥è®¿é—®ã€‚\nåˆ›å»ºå®Œæˆä¹‹åå¯ä»¥å†™ä¸€ä¸ªHTMLç®€å•æµ‹è¯•ä¸€ä¸‹ï¼Œç‚¹å‡»Add fileï¼Œé€‰æ‹©Create new fileï¼Œå¡«å†™æ–‡ä»¶åå’Œå†…å®¹ï¼Œç„¶åç‚¹å‡»Commit new fileæäº¤ã€‚\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; 5\u0026lt;title\u0026gt;test\u0026lt;/title\u0026gt; 6\u0026lt;/head\u0026gt; 7\u0026lt;body\u0026gt; 8 Hello World. 9\u0026lt;/body\u0026gt; 10\u0026lt;/html\u0026gt; æäº¤åç¨ç­‰å‡ åˆ†é’Ÿï¼Œå¾…GitHubç¼“å­˜æ›´æ–°åï¼Œå°±å¯ä»¥åœ¨æµè§ˆå™¨ä¸­è®¿é—®äº†ã€‚\n2.2 Gitå’ŒSSHé…ç½® å‚è€ƒã€é…ç½®ã€‘Win10é…ç½®Gitå’ŒSSH\n2.3 Hexoé…ç½® åŸºæœ¬é…ç½®è¿‡ç¨‹å¯ä»¥å‚è€ƒHexoå®˜æ–¹æ–‡æ¡£ã€‚\nnpmæ˜¯Node.jsçš„åŒ…ç®¡ç†å·¥å…·ï¼Œç”¨æ¥å®‰è£…ã€ç®¡ç†å’Œåˆ†äº«JavaScriptåŒ…ï¼ŒåŒæ—¶ä¼šè‡ªåŠ¨å¤„ç†å¤šä¸ªåŒ…ä¹‹é—´çš„ä¾èµ–ã€‚æ‰“å¼€å‘½ä»¤è¡Œï¼Œæ‰§è¡Œnpm install -g npmæ›´æ–°npmã€‚\n1# æŸ¥çœ‹npmç‰ˆæœ¬ 2npm -v 3# æ›´æ–°npm 4npm install -g npm 5# æ›´æ–°npmè‡³æŒ‡å®šç‰ˆæœ¬ 6npm install -g npm@8.7.0 å®‰è£…Hexo\n1# å®‰è£…Hexo 2npm install -g hexo-cli cdåˆ°æƒ³è¦åˆ›å»ºçš„åšå®¢ç›®å½•ï¼Œåˆå§‹åŒ–Hexo\n1# åˆå§‹åŒ–Hexo 2hexo init åˆå§‹åŒ–ä¹‹åï¼Œç›®å½•ä¸‹ä¼šå¢åŠ å¦‚ä¸‹å†…å®¹ï¼Œè¯¦ç»†è§£é‡Šå¯ä»¥å‚è€ƒHexoæ–‡æ¡£ã€‚\n1. 2â”œâ”€.github/ # GitHubé…ç½® 3â”œâ”€node_modules/ # åŒ…ç®¡ç†ç›®å½• 4â”œâ”€scaffolds/ # æ¨¡æ¿ç›®å½• 5â”œâ”€source/ # æ–‡ç« ç›®å½• 6â”‚ â””â”€_posts/ 7â”‚ hello-world.md 8â””â”€themes/ # ä¸»é¢˜ç›®å½• 9 .gitignore # å¿½ç•¥æ–‡ä»¶ 10 _config.landscape.yml # ä¸»é¢˜é…ç½®æ–‡ä»¶ 11 _config.yml # å…¨å±€é…ç½®æ–‡ä»¶ 12 package.json # åŒ…é…ç½®æ–‡ä»¶ 13 package-lock.json å°†ç¼–å†™å¥½çš„Markdownåšå®¢ï¼Œæ”¾åœ¨source/_posts/ç›®å½•ä¸‹ï¼ŒHexoé»˜è®¤æœ‰ä¸€ç¯‡æ¬¢è¿åšå®¢hello-world.mdï¼Œé‡Œé¢æœ‰ç®€å•ä»‹ç»å’Œå¿«é€Ÿå…¥é—¨ã€‚æ‰§è¡Œå‘½ä»¤ï¼Œæµ‹è¯•Hexoæœ¬åœ°é…ç½®ã€‚\n1# ç”Ÿæˆåšå®¢ 2hexo generate 3# å¯åŠ¨æœåŠ¡ 4hexo server æ‰“å¼€é“¾æ¥http://localhost:4000/ï¼ŒæŸ¥çœ‹åšå®¢ã€‚\nåœ¨åšå®¢ç›®å½•ä¸‹è¿è¡Œå‘½ä»¤è¡Œï¼Œå®‰è£…hexo-deployer-gitæ’ä»¶ã€‚\n1# å®‰è£…hexo-deployer-gitæ’ä»¶ 2npm install hexo-deployer-git --save çœ‹åˆ°æç¤ºæœ‰é«˜å±æ¼æ´ ï¼Œæˆ‘ä¹Ÿä¸æ˜ç™½æ€ä¹ˆå¤„ç† ï¼ŒæŒ‰ç…§æç¤ºè¾“å…¥npm audit fix --forceä¿®å¤ã€‚\nå›åˆ°GitHubåšå®¢é¡¹ç›®ï¼Œç‚¹å‡»Codeï¼Œé€‰æ‹©SSHï¼Œç‚¹å‡»é“¾æ¥å³ä¾§å›¾æ ‡ï¼Œå°†é“¾æ¥å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚\næ‰“å¼€åšå®¢æ ¹ç›®å½•ä¸‹çš„_config.ymlï¼Œåœ¨deployä¸‹å¡«å†™é…ç½®ï¼Œå°†é“¾æ¥ç²˜è´´åˆ°repositoryå­—æ®µã€‚\n1deploy: 2 type: git 3 repository: git@github.com:GH1656409967/GH1656409967.github.io.git 4 branch: main æ³¨æ„ï¼Œ2020å¹´10æœˆ1æ—¥èµ·ï¼Œåœ¨Githubå¹³å°ä¸Šæ‰€æœ‰æ–°åˆ›å»ºçš„æºä»£ç ä»“åº“çš„é»˜è®¤åˆ†æ”¯è¢«å‘½åä¸º\u0026quot;main\u0026quot;ï¼Œä¸å†æ˜¯åŸå…ˆçš„\u0026quot;master\u0026quot;ã€‚\næµ‹è¯•Hexoè¿œç¨‹éƒ¨ç½²ã€‚å¦‚æœä¹‹å‰SSHè®¾ç½®äº†å¯†ç ï¼Œåˆ™éœ€è¦è¾“å…¥å¯†ç ï¼Œçœ‹åˆ°Deploy doneï¼Œè¯´æ˜éƒ¨ç½²æˆåŠŸã€‚\n1# è¿œç¨‹éƒ¨ç½²ï¼ˆä¸Šä¼ åˆ°GitHubï¼‰ 2hexo deploy æ‰“å¼€GitHubåšå®¢é¡¹ç›®ï¼Œå¯ä»¥çœ‹åˆ°ä»£ç æ–‡ä»¶å·²ç»æ›´æ–°äº†ã€‚å†æ‰“å¼€https://username.github.io/ï¼Œåšå®¢å†…å®¹ä¹ŸåŒæ­¥æ›´æ–°äº†ï¼Œä¸æœ¬åœ°http://localhost:4000/è®¿é—®é¡µé¢ä¸€æ ·ã€‚\n3 æ€»ç»“ è‡³æ­¤ï¼Œä¸€ä¸ªåŸºç¡€çš„ç‹¬ç«‹åšå®¢å·²ç»æ­å»ºå®Œæˆäº†, åœ¨Linuxå’ŒMacä¸Šçš„é…ç½®ï¼Œä¹Ÿåº”è¯¥ç±»ä¼¼ã€‚Hexoæœ‰ä¸°å¯Œçš„æ’ä»¶å’Œç¤¾åŒºèµ„æºï¼Œèƒ½æä¾›æ›´å¤šä¸ªæ€§åŒ–å®šåˆ¶ï¼Œæƒ³è¦æ·»åŠ æ›´å¤šçš„åŠŸèƒ½å¯ä»¥å‚è€ƒæˆ‘çš„æ–‡ç« ã€é…ç½®ã€‘HexoåŠNexTä¸»é¢˜çš„é…ç½®ã€‚\nç”±äºåšå®¢æºæ–‡ä»¶æ˜¯Markdownæ ¼å¼ï¼Œåç»­çš„åšå®¢çš„è¿ç§»ä¹Ÿä¸éº»çƒ¦ã€‚åœ¨è´­ä¹°äº†äº‘æœåŠ¡å™¨åï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨nginxç­‰æœåŠ¡æ›¿æ¢GitHub PagesæœåŠ¡ã€‚\næœ€åï¼Œè¯·ä¿è¯å°†PagesæœåŠ¡ä»…ç”¨äºåšå®¢/é—¨æˆ·/å¼€æºé¡¹ç›®ç½‘ç«™/å¼€æºé¡¹ç›®é™æ€æ•ˆæœæ¼”ç¤ºç”¨é€”ï¼Œè¯·å‹¿ç”¨äºè¿è§„å†…å®¹ï¼ŒåŒ…æ‹¬ä½†ä¸ä»…é™äºï¼š\nå‘å¸ƒè¯±å¯¼åˆ†äº«/è¯±å¯¼å…³æ³¨/è¯±å¯¼ä¸‹è½½/è¯±å¯¼è·³è½¬å†…å®¹ å‘å¸ƒæ¬ºè¯ˆ/è°£è¨€/éªšæ‰°ä¿¡æ¯/å¹¿å‘Šä¿¡æ¯/åƒåœ¾ä¿¡æ¯/ç‰¹æ®Šè¯†åˆ«ç ã€å£ä»¤ç±»ä¿¡æ¯ å‘å¸ƒä½ä¿—å†…å®¹/â€œå®—æ•™æ€§æçŒ®â€åŠç›¸å…³ä¿¡æ¯ å‘å¸ƒä¾µå®³ä»–äººæƒåˆ©/è¿æ³•ç»è¥åŠå¯ç–‘æœåŠ¡ç±»å†…å®¹ å‘å¸ƒå…¶å®ƒè¿åå›½å®¶æ³•å¾‹æ³•è§„çš„å†…å®¹ ","permalink":"https://blog.lordash.de/posts/configure/f6c59ae5f9b3dc94/","summary":"1 åšå®¢ åšå®¢ï¼ˆblogæˆ–weblogï¼‰æ­£å¼åç§°æ˜¯ç½‘ç»œæ—¥å¿—ã€‚ä¸€ä¸ªå…¸å‹çš„åšå®¢ç»“åˆäº†æ–‡å­—ã€å›¾åƒã€é“¾æ¥ä»¥åŠå…¶å®ƒä¸»é¢˜ç›¸å…³çš„åª’ä½“ï¼ŒåŒæ—¶èƒ½å¤Ÿè®©è¯»è€…ä»¥äº’åŠ¨çš„æ–¹","title":"Win10ä½¿ç”¨Hexoå’ŒPagesæœåŠ¡æ­å»ºä¸ªäººåšå®¢"},{"content":"1 Gité…ç½® æ‰“å¼€Git Bashï¼Œé…ç½®ç”¨æˆ·ä¿¡æ¯,\n1# é…ç½®ç”¨æˆ·åå’Œé‚®ç®± 2git config --global user.name \u0026#34;githubç”¨æˆ·å\u0026#34; 3git config --global user.email \u0026#34;githubæ³¨å†Œé‚®ç®±\u0026#34; 2 SSHé…ç½® Gitå’ŒGitHubä¹‹é—´å¯ä»¥é€šè¿‡HTTPSã€SSHã€GitHub CLIç­‰å½¢å¼æ¥è¿æ¥ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨SSHæ–¹å¼è¿æ¥ã€‚\nSSHç™»å½•å®‰å…¨æ€§ç”±éå¯¹ç§°åŠ å¯†ä¿è¯ï¼Œäº§ç”Ÿå¯†é’¥æ—¶ï¼Œä¸€æ¬¡äº§ç”Ÿä¸¤ä¸ªå¯†é’¥ï¼Œä¸€ä¸ªå…¬é’¥ï¼Œä¸€ä¸ªç§é’¥ï¼Œåœ¨Gitä¸­ä¸€èˆ¬å‘½åä¸ºid_rsa.pub, id_rsaã€‚å…¬é’¥æ”¾åˆ°è¿œç¨‹ä¸»æœºï¼Œç§é’¥ä¿å­˜åœ¨æœ¬åœ°ã€‚\nå½“æœ¬åœ°ä¸»æœºéœ€è¦ç™»å½•è¿œç¨‹ä¸»æœºæ—¶ï¼Œâ‘ æœ¬åœ°ä¸»æœºå‘è¿œç¨‹ä¸»æœºå‘é€ä¸€ä¸ªç™»å½•è¯·æ±‚ï¼Œâ‘¡è¿œç¨‹æ”¶åˆ°æ¶ˆæ¯åï¼Œéšæœºç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²å¹¶ç”¨å…¬é’¥åŠ å¯†ï¼Œå‘å›ç»™æœ¬åœ°ã€‚â‘¢æœ¬åœ°æ‹¿åˆ°è¯¥å­—ç¬¦ä¸²ï¼Œç”¨å­˜æ”¾åœ¨æœ¬åœ°çš„ç§é’¥è¿›è¡Œè§£å¯†ï¼Œå†æ¬¡å‘é€åˆ°è¿œç¨‹ï¼Œâ‘£è¿œç¨‹æ¯”å¯¹è¯¥è§£å¯†åçš„å­—ç¬¦ä¸²ä¸æºå­—ç¬¦ä¸²æ˜¯å¦ç­‰åŒï¼Œå¦‚æœç­‰åŒåˆ™è®¤è¯æˆåŠŸã€‚\næ‰§è¡Œä¸‹é¢å‘½ä»¤ç”Ÿæˆsshå¯†é’¥æ–‡ä»¶ï¼Œä¼šæç¤ºä½ æŒ‡å®šä¿å­˜è·¯å¾„ï¼ˆé»˜è®¤æ˜¯C:/Users/å½“å‰ç”¨æˆ·/.ssh/id_rsaï¼‰ï¼Œç„¶åç¡®è®¤å¯†ç ã€‚ä½¿ç”¨é»˜è®¤é…ç½®å¯ä»¥ç›´æ¥å›è½¦è·³è¿‡ï¼Œä½†æ˜¯å¹¶ä¸æ¨èï¼Œå¦‚æœä¹‹å‰ç”Ÿæˆè¿‡å¯†é’¥æ–‡ä»¶ï¼Œä¼šæç¤ºè¦†ç›–ã€‚è¿™è¾¹æŒ‡å®šäº†ä¿å­˜è·¯å¾„ä¸ºC:/Users/å½“å‰ç”¨æˆ·/.ssh/id_rsa.githubã€‚\n1# ç”Ÿæˆ ssh å¯†é’¥ 2ssh-keygen -t rsa -C \u0026#34;githubæ³¨å†Œé‚®ç®±\u0026#34; åœ¨GitHubè®¾ç½®é‡Œç‚¹å‡»New SSH keyæ·»åŠ å…¬é’¥ï¼Œåœ¨Titleä¸­å¡«å†™åç§°ï¼Œæ–¹ä¾¿åŒºåˆ†ï¼Œæ¥ç€ä»¥æ–‡æœ¬æ–¹å¼æ‰“å¼€ä¹‹å‰ç”Ÿæˆçš„.pubå…¬é’¥æ–‡ä»¶ï¼ŒCtrl + Aå…¨é€‰ï¼Œç„¶åå¤åˆ¶å†…å®¹å¹¶ç²˜è´´åˆ°Keyä¸­ï¼Œç‚¹å‡»Add SSH keyï¼Œç¡®è®¤GitHubå¯†ç åï¼Œå®Œæˆé…ç½®ã€‚\nåœ¨é»˜è®¤ä¿å­˜è·¯å¾„C:/Users/å½“å‰ç”¨æˆ·/.ssh/ä¸‹ï¼Œåˆ›å»ºä¸€ä¸ªåä¸ºconfigçš„æ–‡ä»¶ï¼Œè¾“å…¥ä»¥ä¸‹å†…å®¹ï¼ŒIdentityFileåé¢æ˜¯ä¹‹å‰é…ç½®çš„å¯†é’¥çš„è·¯å¾„ã€‚å¦‚æœä¹‹å‰ä¿å­˜è¿‡å…¶å®ƒSSHå¯†é’¥ï¼Œå¯ä»¥ä¾ç…§ç›¸åŒæ ¼å¼è¿›è¡Œé…ç½®ã€‚ç„¶åå›åˆ°Git Bashï¼Œæ‰§è¡Œchmod 600 ~/.ssh/configæ·»åŠ è¯»å†™æƒé™ã€‚\n1# github 2Host github.com 3IdentityFile ~/.ssh/id_rsa.github 4User git æµ‹è¯•é…ç½®ï¼Œå‡ºç°successfully authenticatedè¯´æ˜æˆåŠŸ\n1# æµ‹è¯•é…ç½® 2ssh -T git@github.com å¦‚æœæç¤ºCould not resolve hostname github.com: No address associated with hostnameï¼Œä½¿ç”¨IPAddressæŸ¥è¯¢GitHubçœŸå®IPåœ°å€ï¼Œç„¶åæ·»åŠ åˆ°C:\\Windows\\System32\\drivers\\etc\\hostsæ–‡ä»¶ä¸­ã€‚\n1140.82.114.4 github.com æ¨èä½¿ç”¨114DNSï¼Œå¯ä»¥é¿å…æ­¤æƒ…å†µï¼Œä¹Ÿæ— éœ€æ”¹åŠ¨hostsæ–‡ä»¶ã€‚\n","permalink":"https://blog.lordash.de/posts/configure/bb23eaa4846998e0/","summary":"1 Gité…ç½® æ‰“å¼€Git Bashï¼Œé…ç½®ç”¨æˆ·ä¿¡æ¯, 1# é…ç½®ç”¨æˆ·åå’Œé‚®ç®± 2git config --global user.name \u0026#34;githubç”¨æˆ·å\u0026#34; 3git config --global user.email \u0026#34;github","title":"Win10é…ç½®Gitå’ŒSSH"},{"content":"ç®€ä»‹ å¿«é€Ÿæ’åºç®—æ³•æ˜¯å¯¹å†’æ³¡æ’åºç®—æ³•çš„ä¸€ç§æ”¹è¿›ã€‚å¹³å‡æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦$O(n^2)$ã€‚\nå¿«é€Ÿæ’åºçš„åŸºæœ¬æ€æƒ³ï¼šæ¯è¶Ÿæ’åºé€‰æ‹©ä¸€ä¸ªåŸºå‡†å€¼pivotï¼Œä½¿å¾—å°äºpivotçš„å…ƒç´ å’Œå¤§äºpivotçš„å…ƒç´ åˆ†éš”äºpivotä¸¤ä¾§ï¼Œå³æ¯ä¸€è¶Ÿç¡®å®šäº†ä¸€ä¸ªå…ƒç´ çš„ä½ç½®ã€‚ç„¶åå¯¹åŸºå‡†å€¼ä¸¤ä¾§çš„åŒºé—´è¿›è¡Œé€’å½’ï¼Œä»¥è¾¾åˆ°æ•´ä¸ªåºåˆ—æœ‰åºã€‚\nå¯ä»¥çœ‹å‡ºæ—¶é—´å¤æ‚åº¦ä¸é€’å½’çš„å±‚æ•°ç›¸å…³ï¼Œæå‡æ•ˆç‡çš„å…³é”®å°±åœ¨äºpartitionï¼Œåˆ’åˆ†æ—¶çš„å®ç°ã€‚\nå•è·¯å¿«æ’ æœ€åŸºç¡€çš„å®ç°ç‰ˆæœ¬ï¼Œå‰ååŒæŒ‡é’ˆæ³•ï¼š\n1// å¯¹å·¦é—­å³å¼€åŒºé—´a[l, r)ï¼Œå•è·¯å¿«æ’ï¼Œå‰ååŒæŒ‡é’ˆæ³• 2void quickSort(int *a, int l, int r){ 3 if(l\u0026gt;=r) return; 4 5 int pivot = a[l]; 6 int j = l; 7 for(int i=l+1; i\u0026lt;r; i++){ 8 if(a[i] \u0026lt; pivot) 9 swap(a[++j], a[i]); 10 } 11 swap(a[l], a[j]); 12 13 quickSort(a, l, j); 14 quickSort(a, j+1, r); 15} è¿™ç§æ–¹æ³•æœ‰è®¸å¤šç¼ºé™·ï¼Œä½†èƒœåœ¨ç®€çŸ­ï¼Œè€Œä¸”ç®€å•ä¿®æ”¹å°±å¯ä»¥å˜æˆé“¾è¡¨ç‰ˆæœ¬ï¼š\n1// å•é“¾è¡¨é‡‡ç”¨ç›´æ¥äº¤æ¢æ•°æ®åŒºï¼Œä¿®æ”¹æŒ‡é’ˆçš„è¯æ²¡ä»€ä¹ˆå¥½æƒ³æ³• 2void quickSort(ListNode *head, ListNode *last){ 3 if(head==nullptr || head==last) return; 4 5 int pivot = head-\u0026gt;val; 6 ListNode *pre = head; 7 for(ListNode *cur=head; cur-\u0026gt;next!=last; cur=cur-\u0026gt;next){ 8 if(cur-\u0026gt;next-\u0026gt;val \u0026lt; pivot){ 9 swap(cur-\u0026gt;next-\u0026gt;val, pre-\u0026gt;next-\u0026gt;val); 10 pre = pre-\u0026gt;next; 11 } 12 } 13 swap(head-\u0026gt;val, pre-\u0026gt;val); 14 15 quickSort(head, pre); 16 quickSort(pre-\u0026gt;next, last); 17} åŒè·¯å¿«æ’ å•è·¯å¿«æ’ä¼šä½¿å¾—ä¸åŸºå‡†å€¼pivotç›¸ç­‰çš„å…ƒç´ æ€»æ˜¯å½’ä¸ºä¸€ä¾§ï¼Œå­˜åœ¨å¤§é‡ç›¸åŒå…ƒç´ æ—¶ï¼Œæ—¶é—´å¤æ‚åº¦é€€åŒ–ä¸º$ O(n^2) $ã€‚å·¦å³åŒæŒ‡é’ˆæ³•å¯ä»¥è®©ä¸åŸºå‡†å€¼ç›¸ç­‰çš„å…ƒç´ éšæœºäº¤æ¢è‡³ä¸¤ä¾§ï¼Œä½†æ˜¯è¿˜éœ€å¤„ç†ã€‚\n1// å·¦é—­å³å¼€åŒºé—´a[l, r)ï¼ŒåŒè·¯å¿«æ’ï¼Œå·¦å³åŒæŒ‡é’ˆæ³• 2void quickSort(int *a, int l, int r){ 3 if(l\u0026gt;=r) return; 4 5 int pivot = a[l]; 6 int i=l+1, j=r-1; 7 while(i\u0026lt;=j){ 8 while(a[i]\u0026lt;pivot \u0026amp;\u0026amp; i\u0026lt;r) i++; 9 while(a[j]\u0026gt;pivot \u0026amp;\u0026amp; j\u0026gt;l) j--; 10 if(i\u0026gt;j) break; 11 swap(a[i++], a[j--]); 12 } 13 swap(a[l], a[j]); 14 15 quickSort(a, l, j); 16 quickSort(a, j+1, r); 17} ä¸‰è·¯å¿«æ’ è¦çœŸæ­£ä¼˜åŒ–å­˜åœ¨å¤§é‡ç›¸åŒå…ƒç´ æƒ…å†µä¸‹å¿«æ’çš„æ•ˆç‡æ—¶ï¼Œè¿˜æ˜¯éœ€è¦ä½¿ç”¨ä¸‰è·¯å¿«æ’ï¼Œå°†åºåˆ—åˆ†ä¸ºå°äºpivotçš„ $ [l, lt) $ ï¼Œ ç­‰äºpivotçš„ $ [lt, i] $ ï¼Œ å¤§äºpivotçš„ $ [rt, r) $ ä¸‰éƒ¨åˆ†ã€‚\n1// å·¦é—­å³å¼€åŒºé—´a[l, r)ï¼Œä¸‰è·¯å¿«æ’ 2void quickSort(int *a, int l, int r){ 3 if(l\u0026gt;=r) return; 4 5 int pivot = a[l]; 6 int lt = l, rt = r; 7 for(int i=l+1; i\u0026lt;rt; ){ 8 if(a[i] \u0026lt; pivot) 9 swap(a[i++], a[++lt]); 10 else if(a[i] \u0026gt; pivot) 11 swap(a[i], a[--rt]); 12 else 13 i++; 14 } 15 swap(a[l], a[lt]); 16 17 quickSort(a, l, lt); 18 quickSort(a, rt, r); 19} æ›´å¤šä¼˜åŒ– æ›´å¤šä¼˜åŒ–å°±å¯ä»¥å‚è€ƒSTL::sort()å‡½æ•°çš„å®ç°ã€‚ä¾‹å¦‚ï¼Œ\nåœ¨åŸºå‡†å€¼pivotçš„é€‰å–ä¸­ï¼Œå¦‚æœæ¯æ¬¡é€‰å–çš„æ°å¥½æ˜¯å½“å‰åºåˆ—ä¸­çš„æœ€å¤§æˆ–æœ€å°å…ƒç´ ï¼Œåˆ’åˆ†çš„ç»“æœæ˜¯æœ€åæƒ…å†µï¼Œé€’å½’å±‚æ•°å¤§å¤§ä¸Šå‡ã€‚å¯¹æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨éšæœºé€‰å–æˆ–è€…ä¸‰æ•°å–ä¸­æ³•ã€‚\n1// å·¦é—­å³å¼€åŒºé—´a[l, r)ï¼Œéšæœºé€‰å– 2srand(time(NULL)); 3int pivot = a[rand()%(r-l)+l]; 4 5// å·¦é—­å³å¼€åŒºé—´a[l, r)ï¼Œä¸‰æ•°å–ä¸­æ³• 6int pivot = a[l + (r-l)/2]; 7if(pivot\u0026lt;a[l] \u0026amp;\u0026amp; pivot\u0026lt;a[r]) pivot=min(a[l], a[r]); 8if(pivot\u0026gt;a[l] \u0026amp;\u0026amp; pivot\u0026gt;a[r]) pivot=max(a[l], a[r]); å½“åºåˆ—è¾ƒçŸ­æ—¶(\u0026lt;16)ï¼Œå¯ä»¥é‡‡ç”¨ç›´æ¥æ’å…¥æ’åºï¼Œå‡å°‘é€’å½’æ·±åº¦ã€‚\n1// è¿˜éœ€è¦å…·ä½“å®ç° 2if(r-l \u0026lt; 16){ 3 insertionSort(a, l, r); 4 return; 5} å½“é€’å½’æ¬¡æ•°å¤§äºé™åˆ¶æ—¶ï¼Œé‡‡ç”¨å †æ’åºç­‰ã€‚\nä»£ç  æµ‹è¯•ä»£ç ï¼š\n1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4void showArray(int *a, int n){ 5 for(int i=0; i\u0026lt;n; i++){ 6 printf(\u0026#34;%d \u0026#34;, a[i]); 7 } 8 printf(\u0026#34;\\n\u0026#34;); 9} 10 11// å•è·¯å¿«æ’ï¼Œå‰ååŒæŒ‡é’ˆæ³• 12void quickSort(int *a, int l, int r){ 13 if(l\u0026gt;=r) return; 14 15 int pivot = a[l]; 16 int j = l; 17 for(int i=l+1; i\u0026lt;r; i++){ 18 if(a[i] \u0026lt; pivot) 19 swap(a[++j], a[i]); 20 } 21 swap(a[l], a[j]); 22 23 quickSort(a, l, j); 24 quickSort(a, j+1, r); 25} 26 27// åŒè·¯å¿«æ’ï¼Œå·¦å³åŒæŒ‡é’ˆæ³• 28void quickSort(int *a, int l, int r){ 29 if(l\u0026gt;=r) return; 30 31 int pivot = a[l]; 32 int i=l+1, j=r-1; 33 while(i\u0026lt;=j){ 34 while(a[i]\u0026lt;pivot \u0026amp;\u0026amp; i\u0026lt;r) i++; 35 while(a[j]\u0026gt;pivot \u0026amp;\u0026amp; j\u0026gt;l) j--; 36 if(i\u0026gt;j) break; 37 swap(a[i++], a[j--]); 38 } 39 swap(a[l], a[j]); 40 41 quickSort(a, l, j); 42 quickSort(a, j+1, r); 43} 44 45// ä¸‰è·¯å¿«æ’ 46void quickSort(int *a, int l, int r){ 47 if(l\u0026gt;=r) return; 48 49 int pivot = a[l]; 50 int lt = l, rt = r; 51 for(int i=l+1; i\u0026lt;rt; ){ 52 if(a[i] \u0026lt; pivot) 53 swap(a[i++], a[++lt]); 54 else if(a[i] \u0026gt; pivot) 55 swap(a[i], a[--rt]); 56 else 57 i++; 58 } 59 swap(a[l], a[lt]); 60 61 quickSort(a, l, lt); 62 quickSort(a, rt, r); 63} 64 65struct ListNode { 66 int val; 67 ListNode *next; 68 ListNode(int x) : val(x), next(NULL) {} 69}; 70 71void showList(ListNode *head){ 72 ListNode *p = head; 73 while(p!=nullptr){ 74 printf(\u0026#34;%d \u0026#34;, p-\u0026gt;val); 75 p = p-\u0026gt;next; 76 } 77 printf(\u0026#34;\\n\u0026#34;); 78} 79 80// é“¾è¡¨å¿«æ’ 81void quickSort(ListNode *head, ListNode *last){ 82 if(head==nullptr || head==last) return; 83 84 int pivot = head-\u0026gt;val; 85 ListNode *pre = head; 86 for(ListNode *cur=head; cur-\u0026gt;next!=last; cur=cur-\u0026gt;next){ 87 if(cur-\u0026gt;next-\u0026gt;val \u0026lt; pivot){ 88 swap(cur-\u0026gt;next-\u0026gt;val, pre-\u0026gt;next-\u0026gt;val); 89 pre = pre-\u0026gt;next; 90 } 91 } 92 swap(head-\u0026gt;val, pre-\u0026gt;val); 93 94 quickSort(head, pre); 95 quickSort(pre-\u0026gt;next, last); 96} 97 98int main() 99{ 100 int n = 10; 101 int a[11] = {4,1,7,6,9,2,8,0,3,5}; 102 103 ListNode *h[10]; 104 for(int i=0; i\u0026lt;n; i++){ 105 h[i] = new ListNode(a[i]); 106 if(i) h[i-1]-\u0026gt;next = h[i]; 107 } 108 ListNode *head = h[0]; 109 110 showArray(a, n); 111 quickSort(a, 0, n); 112 showArray(a, n); 113 114 showList(head); 115 quickSort(head, nullptr); 116 showList(head); 117 118 return 0; 119} ","permalink":"https://blog.lordash.de/posts/algorithm/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","summary":"ç®€ä»‹ å¿«é€Ÿæ’åºç®—æ³•æ˜¯å¯¹å†’æ³¡æ’åºç®—æ³•çš„ä¸€ç§æ”¹è¿›ã€‚å¹³å‡æ—¶é—´å¤æ‚åº¦$O(nlogn)$ï¼Œæœ€åæ—¶é—´å¤æ‚åº¦$O(n^2)$ã€‚ å¿«é€Ÿæ’åºçš„åŸºæœ¬æ€æƒ³ï¼šæ¯è¶Ÿæ’åº","title":"å¿«é€Ÿæ’åº"},{"content":"æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—(å‰‘æŒ‡Offer-39) é¢˜é¢ æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œè¯·æ‰¾å‡ºè¿™ä¸ªæ•°å­—ã€‚\nä½ å¯ä»¥å‡è®¾æ•°ç»„æ˜¯éç©ºçš„ï¼Œå¹¶ä¸”ç»™å®šçš„æ•°ç»„æ€»æ˜¯å­˜åœ¨å¤šæ•°å…ƒç´ ã€‚\nç¤ºä¾‹ 1è¾“å…¥: [1, 2, 3, 2, 2, 2, 5, 4, 2] 2è¾“å‡º: 2 é™åˆ¶ 11 \u0026lt;= æ•°ç»„é•¿åº¦ \u0026lt;= 50000 æ€è·¯ æ‘©å°”æŠ•ç¥¨æ³•åŸºäºè¿™æ ·ä¸€ä¸ªäº‹å®ï¼Œå½“ä¸€ä¸ªæ•°çš„é‡å¤æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œæ¯æ¬¡å°†ä¸¤ä¸ªä¸ç›¸åŒçš„æ•°åˆ é™¤ï¼Œæœ€ç»ˆå‰©ä¸‹çš„å°±æ˜¯è¦æ‰¾çš„æ•°ã€‚\nä»£ç  1class Solution { 2public: 3 int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 int num=0, ans=0; 5 for(int x : nums){ 6 if(num==0) ans = x; 7 if(ans == x) num++; 8 else num--; 9 } 10 return ans; 11 } 12}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—(å‰‘æŒ‡Offer-39) é¢˜é¢ æ•°ç»„ä¸­æœ‰ä¸€ä¸ªæ•°å­—å‡ºç°çš„æ¬¡æ•°è¶…è¿‡æ•°ç»„é•¿åº¦çš„ä¸€åŠï¼Œè¯·æ‰¾å‡ºè¿™ä¸ªæ•°å­—ã€‚ ä½ å¯ä»¥å‡è®¾æ•°ç»„æ˜¯éç©ºçš„","title":"å‰‘æŒ‡Offer-39 æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡ä¸€åŠçš„æ•°å­—"},{"content":"å­—ç¬¦ä¸²çš„æ’åˆ—(å‰‘æŒ‡Offer-38) é¢˜é¢ è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰“å°å‡ºè¯¥å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ‰€æœ‰æ’åˆ—ã€‚\nä½ å¯ä»¥ä»¥ä»»æ„é¡ºåºè¿”å›è¿™ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œä½†é‡Œé¢ä¸èƒ½æœ‰é‡å¤å…ƒç´ ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼šs = \u0026#34;abc\u0026#34; 2è¾“å‡ºï¼š[\u0026#34;abc\u0026#34;,\u0026#34;acb\u0026#34;,\u0026#34;bac\u0026#34;,\u0026#34;bca\u0026#34;,\u0026#34;cab\u0026#34;,\u0026#34;cba\u0026#34;] é™åˆ¶ 11 \u0026lt;= s çš„é•¿åº¦ \u0026lt;= 8 æ€è·¯ dfséå†å›æº¯ã€‚\nä»£ç  1class Solution { 2 vector\u0026lt;string\u0026gt; ans; 3 void dfs(string s, string \u0026amp;t, vector\u0026lt;bool\u0026gt; \u0026amp;vis){ 4 if(s.size() == t.size()){ 5 ans.push_back(t); 6 return; 7 } 8 for(int i=0; i\u0026lt;s.size(); i++){ 9 if(vis[i]) continue; 10 if(i \u0026amp;\u0026amp; s[i-1]==s[i] \u0026amp;\u0026amp; !vis[i-1]) continue; 11 t.push_back(s[i]); 12 vis[i] = true; 13 dfs(s, t, vis); 14 vis[i] = false; 15 t.pop_back(); 16 } 17 } 18public: 19 vector\u0026lt;string\u0026gt; permutation(string s) { 20 if(s.size() == 0) return {}; 21 string t = \u0026#34;\u0026#34;; 22 sort(s.begin(), s.end()); 23 vector\u0026lt;bool\u0026gt; vis(s.size()); 24 dfs(s, t, vis); 25 return ans; 26 } 27}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","summary":"å­—ç¬¦ä¸²çš„æ’åˆ—(å‰‘æŒ‡Offer-38) é¢˜é¢ è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰“å°å‡ºè¯¥å­—ç¬¦ä¸²ä¸­å­—ç¬¦çš„æ‰€æœ‰æ’åˆ—ã€‚ ä½ å¯ä»¥ä»¥ä»»æ„é¡ºåºè¿”å›è¿™ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œä½†é‡Œé¢ä¸èƒ½æœ‰é‡å¤","title":"å‰‘æŒ‡Offer-38 å­—ç¬¦ä¸²çš„æ’åˆ—"},{"content":"äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„(å‰‘æŒ‡Offer-34) é¢˜é¢ è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚\nç¤ºä¾‹ ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ target = 22ï¼Œ\n1 5 2 / \\ 3 4 8 4 / / \\ 5 11 13 4 6 / \\ / \\ 7 7 2 5 1 è¿”å›:\n1[ 2 [5,4,11,2], 3 [5,8,4,5] 4] æç¤º èŠ‚ç‚¹æ€»æ•° \u0026lt;= 10000\næ€è·¯ dfséå†å³å¯ï¼Œæ³¨æ„è·¯å¾„æ˜¯æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode() : val(0), left(nullptr), right(nullptr) {} 8 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} 9 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} 10 * }; 11 */ 12class Solution { 13 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ans; 14 vector\u0026lt;int\u0026gt; v; 15 void dfs(TreeNode *rt, int n){ 16 if(rt == nullptr) return; 17 n -= rt-\u0026gt;val; 18 v.push_back(rt-\u0026gt;val); 19 if(n || rt-\u0026gt;left || rt-\u0026gt;right){ 20 dfs(rt-\u0026gt;left, n); 21 dfs(rt-\u0026gt;right, n); 22 }else{ 23 ans.push_back(v); 24 } 25 v.pop_back(); 26 } 27public: 28 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int target) { 29 dfs(root, target); 30 return ans; 31 } 32}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","summary":"äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„(å‰‘æŒ‡Offer-34) é¢˜é¢ è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚ ç¤ºä¾‹ ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ target = 22ï¼Œ","title":"å‰‘æŒ‡Offer-34 äºŒå‰æ ‘ä¸­å’Œä¸ºæŸä¸€å€¼çš„è·¯å¾„"},{"content":"åºåˆ—åŒ–äºŒå‰æ ‘(å‰‘æŒ‡Offer-37) é¢˜é¢ è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚\nç¤ºä¾‹ 1ä½ å¯ä»¥å°†ä»¥ä¸‹äºŒå‰æ ‘ï¼š 2 3 1 4 / \\ 5 2 3 6 / \\ 7 4 5 8 9åºåˆ—åŒ–ä¸º \u0026#34;[1,2,3,null,null,4,5]\u0026#34; æ€è·¯ BFSå±‚åºéå†å³å¯ï¼Œæ³¨æ„ï¼Œå¦‚æœèŠ‚ç‚¹ä¸ºnullï¼Œåˆ™å®ƒçš„å­èŠ‚ç‚¹å°±ä¸è®°å½•ã€‚\nå³\n1 1 2 \\ 3 2 4 / 5 3 è¡¨ç¤ºä¸º[1,null,2,3] è€Œé[1,null,2,null,null,3]\nååºåˆ—åŒ–æ—¶ä¸èƒ½ä½¿ç”¨çˆ¶å­èŠ‚ç‚¹çš„ä¸‹æ ‡å…³ç³»ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Codec { 11public: 12 13 // Encodes a tree to a single string. 14 string serialize(TreeNode* root) { 15 if(root == nullptr) return \u0026#34;[]\u0026#34;; 16 string res = \u0026#34;[\u0026#34;; 17 queue\u0026lt;TreeNode *\u0026gt; q; 18 q.push(root); 19 while(!q.empty()){ 20 TreeNode *t = q.front(); q.pop(); 21 if(t == nullptr){ 22 res += \u0026#34;null,\u0026#34;; 23 }else{ 24 res += to_string(t-\u0026gt;val) + \u0026#34;,\u0026#34;; 25 q.push(t-\u0026gt;left); 26 q.push(t-\u0026gt;right); 27 } 28 } 29 res[res.length()-1] = \u0026#39;]\u0026#39;; 30 return res; 31 } 32 33 // Decodes your encoded data to tree. 34 TreeNode* deserialize(string data) { 35 if(data==\u0026#34;[]\u0026#34;) return nullptr; 36 vector\u0026lt;TreeNode *\u0026gt; v; 37 for(int i=0; i\u0026lt;data.length(); i++){ 38 if(data[i]==\u0026#39;-\u0026#39; || isdigit(data[i])){ 39 int f=1, x=0; 40 if(data[i]==\u0026#39;-\u0026#39;){ 41 f = -1; 42 i++; 43 } 44 for(; isdigit(data[i]); i++){ 45 x = x*10 + (data[i]-\u0026#39;0\u0026#39;); 46 } 47 i--; x *= f; 48 TreeNode *p = new TreeNode(x); 49 v.push_back(p); 50 }else if(data[i]==\u0026#39;n\u0026#39;){ 51 v.push_back(nullptr); 52 i += 3; 53 } 54 } 55 for(int i=0, j=1; i\u0026lt;v.size()\u0026amp;\u0026amp;j\u0026lt;v.size(); i++,j++){ 56 while(v[i]==nullptr) i++; 57 v[i]-\u0026gt;left = v[j++]; 58 v[i]-\u0026gt;right = v[j]; 59 } 60 return v[0]; 61 } 62}; 63 64// Your Codec object will be instantiated and called as such: 65// Codec codec; 66// codec.deserialize(codec.serialize(root)); ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"åºåˆ—åŒ–äºŒå‰æ ‘(å‰‘æŒ‡Offer-37) é¢˜é¢ è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚ ç¤ºä¾‹ 1ä½ å¯ä»¥å°†ä»¥ä¸‹äºŒå‰æ ‘ï¼š 2 3 1 4 / \\ 5 2 3 6 / \\ 7","title":"å‰‘æŒ‡Offer-37 åºåˆ—åŒ–äºŒå‰æ ‘"},{"content":"äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨(å‰‘æŒ‡Offer-36) é¢˜é¢ è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„å¾ªç¯åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„èŠ‚ç‚¹ï¼Œåªèƒ½è°ƒæ•´æ ‘ä¸­èŠ‚ç‚¹æŒ‡é’ˆçš„æŒ‡å‘ã€‚\nä¸ºäº†è®©æ‚¨æ›´å¥½åœ°ç†è§£é—®é¢˜ï¼Œä»¥ä¸‹é¢çš„äºŒå‰æœç´¢æ ‘ä¸ºä¾‹ï¼š\næˆ‘ä»¬å¸Œæœ›å°†è¿™ä¸ªäºŒå‰æœç´¢æ ‘è½¬åŒ–ä¸ºåŒå‘å¾ªç¯é“¾è¡¨ã€‚é“¾è¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå‰é©±å’Œåç»§æŒ‡é’ˆã€‚å¯¹äºåŒå‘å¾ªç¯é“¾è¡¨ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„åç»§æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚\nä¸‹å›¾å±•ç¤ºäº†ä¸Šé¢çš„äºŒå‰æœç´¢æ ‘è½¬åŒ–æˆçš„é“¾è¡¨ã€‚â€œheadâ€ è¡¨ç¤ºæŒ‡å‘é“¾è¡¨ä¸­æœ‰æœ€å°å…ƒç´ çš„èŠ‚ç‚¹ã€‚\nç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å¸Œæœ›å¯ä»¥å°±åœ°å®Œæˆè½¬æ¢æ“ä½œã€‚å½“è½¬åŒ–å®Œæˆä»¥åï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å·¦æŒ‡é’ˆéœ€è¦æŒ‡å‘å‰é©±ï¼Œæ ‘ä¸­èŠ‚ç‚¹çš„å³æŒ‡é’ˆéœ€è¦æŒ‡å‘åç»§ã€‚è¿˜éœ€è¦è¿”å›é“¾è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚\næ€è·¯ äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†ä¸ºé€’å¢åºåˆ—ã€‚\nä»£ç  1/* 2// Definition for a Node. 3class Node { 4public: 5 int val; 6 Node* left; 7 Node* right; 8 9 Node() {} 10 11 Node(int _val) { 12 val = _val; 13 left = NULL; 14 right = NULL; 15 } 16 17 Node(int _val, Node* _left, Node* _right) { 18 val = _val; 19 left = _left; 20 right = _right; 21 } 22}; 23*/ 24class Solution { 25 Node *pre=nullptr, *head=nullptr; 26 void dfs(Node *cur){ 27 if(cur == nullptr) return; 28 dfs(cur-\u0026gt;left); 29 if(pre == nullptr) 30 head = cur; 31 else 32 pre-\u0026gt;right = cur; 33 cur-\u0026gt;left = pre; 34 pre = cur; 35 dfs(cur-\u0026gt;right); 36 } 37public: 38 Node* treeToDoublyList(Node* root) { 39 if(root == nullptr) return nullptr; 40 dfs(root); 41 head-\u0026gt;left = pre; 42 pre-\u0026gt;right = head; 43 return head; 44 } 45}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","summary":"äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨(å‰‘æŒ‡Offer-36) é¢˜é¢ è¾“å…¥ä¸€æ£µäºŒå‰æœç´¢æ ‘ï¼Œå°†è¯¥äºŒå‰æœç´¢æ ‘è½¬æ¢æˆä¸€ä¸ªæ’åºçš„å¾ªç¯åŒå‘é“¾è¡¨ã€‚è¦æ±‚ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„èŠ‚ç‚¹ï¼Œåª","title":"å‰‘æŒ‡Offer-36 äºŒå‰æœç´¢æ ‘ä¸åŒå‘é“¾è¡¨"},{"content":"å¤æ‚é“¾è¡¨çš„å¤åˆ¶(å‰‘æŒ‡Offer-34) é¢˜é¢ è¯·å®ç° copyRandomList å‡½æ•°ï¼Œå¤åˆ¶ä¸€ä¸ªå¤æ‚é“¾è¡¨ã€‚åœ¨å¤æ‚é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†æœ‰ä¸€ä¸ª next æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰ä¸€ä¸ª random æŒ‡é’ˆæŒ‡å‘é“¾è¡¨ä¸­çš„ä»»æ„èŠ‚ç‚¹æˆ–è€… nullã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šhead = [[7,null],[13,0],[11,4],[10,2],[1,0]] 2è¾“å‡ºï¼š[[7,null],[13,0],[11,4],[10,2],[1,0]] ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šhead = [[1,1],[2,1]] 2è¾“å‡ºï¼š[[1,1],[2,1]] ç¤ºä¾‹ 3ï¼š\n1è¾“å…¥ï¼šhead = [[3,null],[3,0],[3,null]] 2è¾“å‡ºï¼š[[3,null],[3,0],[3,null]] ç¤ºä¾‹ 4ï¼š\n1è¾“å…¥ï¼šhead = [] 2è¾“å‡ºï¼š[] 3è§£é‡Šï¼šç»™å®šçš„é“¾è¡¨ä¸ºç©ºï¼ˆç©ºæŒ‡é’ˆï¼‰ï¼Œå› æ­¤è¿”å› nullã€‚ é™åˆ¶ 1 -10000 \u0026lt;= Node.val \u0026lt;= 10000 2 Node.random ä¸ºç©ºï¼ˆnullï¼‰æˆ–æŒ‡å‘é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚ 3 èŠ‚ç‚¹æ•°ç›®ä¸è¶…è¿‡ 1000 ã€‚ æ€è·¯ å¤åˆ¶å„èŠ‚ç‚¹ï¼Œæ„å»ºæ‹¼æ¥é“¾è¡¨: è®¾åŸé“¾è¡¨ä¸º node1 â†’ node2 â†’ â‹¯ï¼Œæ„å»ºçš„æ‹¼æ¥é“¾è¡¨å¦‚ä¸‹æ‰€ç¤ºï¼š node1 â†’ node1new â†’ node2 â†’ node2new â†’ â‹¯\næ„å»ºæ–°é“¾è¡¨å„èŠ‚ç‚¹çš„ random æŒ‡å‘ï¼š å½“è®¿é—®åŸèŠ‚ç‚¹ cur çš„éšæœºæŒ‡å‘èŠ‚ç‚¹ cur.random æ—¶ï¼Œå¯¹åº”æ–°èŠ‚ç‚¹ cur.next çš„éšæœºæŒ‡å‘èŠ‚ç‚¹ä¸º cur.random.next ã€‚\næ‹†åˆ†åŸ / æ–°é“¾è¡¨ï¼š è®¾ç½® pre / cur åˆ†åˆ«æŒ‡å‘åŸ / æ–°é“¾è¡¨å¤´èŠ‚ç‚¹ï¼Œéå†æ‰§è¡Œ pre.next = pre.next.next å’Œ cur.next = cur.next.next å°†ä¸¤é“¾è¡¨æ‹†åˆ†å¼€ã€‚\nè¿”å›æ–°é“¾è¡¨çš„å¤´èŠ‚ç‚¹ res å³å¯ã€‚\nä»£ç  1/* 2// Definition for a Node. 3class Node { 4public: 5 int val; 6 Node* next; 7 Node* random; 8 9 Node(int _val) { 10 val = _val; 11 next = NULL; 12 random = NULL; 13 } 14}; 15*/ 16class Solution { 17public: 18 Node* copyRandomList(Node* head) { 19 if(head == nullptr) return nullptr; 20 Node *cur = head; 21 22 while(cur != nullptr){ 23 Node *t = new Node(cur-\u0026gt;val); 24 t-\u0026gt;next = cur-\u0026gt;next; 25 cur-\u0026gt;next = t; 26 cur = t-\u0026gt;next; 27 } 28 29 cur = head; 30 while(cur != nullptr){ 31 if(cur-\u0026gt;random != nullptr) 32 cur-\u0026gt;next-\u0026gt;random = cur-\u0026gt;random-\u0026gt;next; 33 cur = cur-\u0026gt;next-\u0026gt;next; 34 } 35 36 cur = head-\u0026gt;next; 37 Node *pre = head, *res = head-\u0026gt;next; 38 while(cur-\u0026gt;next != nullptr){ 39 pre-\u0026gt;next = pre-\u0026gt;next-\u0026gt;next; 40 cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; 41 pre = pre-\u0026gt;next; 42 cur = cur-\u0026gt;next; 43 } 44 pre-\u0026gt;next = nullptr; 45 return res; 46 } 47}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","summary":"å¤æ‚é“¾è¡¨çš„å¤åˆ¶(å‰‘æŒ‡Offer-34) é¢˜é¢ è¯·å®ç° copyRandomList å‡½æ•°ï¼Œå¤åˆ¶ä¸€ä¸ªå¤æ‚é“¾è¡¨ã€‚åœ¨å¤æ‚é“¾è¡¨ä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹é™¤äº†æœ‰ä¸€ä¸ª next æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿˜æœ‰ä¸€ä¸ª random æŒ‡","title":"å‰‘æŒ‡Offer-34 å¤æ‚é“¾è¡¨çš„å¤åˆ¶"},{"content":"äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—(å‰‘æŒ‡Offer-33) é¢˜é¢ è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œåˆ¤æ–­è¯¥æ•°ç»„æ˜¯ä¸æ˜¯æŸäºŒå‰æœç´¢æ ‘çš„ååºéå†ç»“æœã€‚å¦‚æœæ˜¯åˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚å‡è®¾è¾“å…¥çš„æ•°ç»„çš„ä»»æ„ä¸¤ä¸ªæ•°å­—éƒ½äº’ä¸ç›¸åŒã€‚\nå‚è€ƒä»¥ä¸‹è¿™é¢—äºŒå‰æœç´¢æ ‘ï¼š\n1 5 2 / \\ 3 2 6 4 / \\ 5 1 3 ç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: [1,6,3,2,5] 2è¾“å‡º: false ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥: [1,3,2,6,5] 2è¾“å‡º: true é™åˆ¶ 1æ•°ç»„é•¿åº¦ \u0026lt;= 1000 æ€è·¯ æŒ‰ç…§åç»­éå†çš„å®ç°æœ€åä¸€ä¸ªå…ƒç´ æ˜¯æ ¹èŠ‚ç‚¹ï¼Œ æ¯”æ ¹èŠ‚ç‚¹çš„å°çš„è¯´æ˜æ˜¯åœ¨å·¦å­æ ‘ï¼Œæ¯”æ ¹èŠ‚ç‚¹å¤§çš„è¯´æ˜åœ¨å³å­æ ‘ã€‚\nä»£ç  1class Solution { 2 bool dfs(vector\u0026lt;int\u0026gt;\u0026amp; postorder, int start, int end){ 3 if(start \u0026gt;= end) return true; 4 5 int p = start; 6 int rootval = postorder[end]; 7 while(postorder[p] \u0026lt; rootval){ 8 ++p; 9 } 10 int leftEnd = p-1; 11 12 while(postorder[p] \u0026gt; rootval){ 13 ++p; 14 } 15 16 return p==end \u0026amp;\u0026amp; dfs(postorder, start, leftEnd) \u0026amp;\u0026amp; dfs(postorder, leftEnd+1, end-1); 17 } 18public: 19 bool verifyPostorder(vector\u0026lt;int\u0026gt;\u0026amp; postorder) { 20 return dfs(postorder, 0, postorder.size()-1); 21 } 22}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","summary":"äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—(å‰‘æŒ‡Offer-33) é¢˜é¢ è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œåˆ¤æ–­è¯¥æ•°ç»„æ˜¯ä¸æ˜¯æŸäºŒå‰æœç´¢æ ‘çš„ååºéå†ç»“æœã€‚å¦‚æœæ˜¯åˆ™è¿”å› trueï¼Œå¦åˆ™","title":"å‰‘æŒ‡Offer-33 äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—"},{"content":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘III(å‰‘æŒ‡Offer-32.3) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»å³åˆ°å·¦çš„é¡ºåºæ‰“å°ï¼Œç¬¬ä¸‰è¡Œå†æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œå…¶ä»–è¡Œä»¥æ­¤ç±»æ¨ã€‚\nä¾‹å¦‚: ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7],\n1 3 2 / \\ 3 9 20 4 / \\ 5 15 7 è¿”å›ï¼š\n1[ 2 [3], 3 [20,9], 4 [15,7] 5] é™åˆ¶ 1èŠ‚ç‚¹æ€»æ•° \u0026lt;= 1000 æ€è·¯ BFSå±‚åºéå†ï¼ŒåŠ ä¸ªæ ‡è®°ï¼Œå½“ä¸€å±‚éå†å®Œæ—¶ï¼Œé˜Ÿåˆ—é‡Œå³æ˜¯ä¸‹ä¸€å±‚ï¼Œä½¿ç”¨q.back()æ›´æ–°æ ‡è®°å³å¯ã€‚\nå†åŠ ä¸ªè¡Œå·åˆ¤æ–­å¥‡å¶ï¼Œå†³å®šæ˜¯å¦reverseå³å¯ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11public: 12 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { 13 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ans; 14 vector\u0026lt;int\u0026gt; row; 15 if(root==NULL) return ans; 16 17 queue\u0026lt;TreeNode *\u0026gt;q; 18 q.push(root); 19 TreeNode *end = root; 20 int line = 0; 21 22 while(!q.empty()){ 23 TreeNode *t = q.front(); q.pop(); 24 row.push_back(t-\u0026gt;val); 25 if(t-\u0026gt;left) 26 q.push(t-\u0026gt;left); 27 if(t-\u0026gt;right) 28 q.push(t-\u0026gt;right); 29 if(t == end){ 30 if(line \u0026amp; 1) 31 reverse(row.begin(), row.end()); 32 ans.push_back(row); 33 line++; 34 row.clear(); 35 end = q.back(); 36 } 37 } 38 return ans; 39 } 40}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-32.3-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91iii/","summary":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘III(å‰‘æŒ‡Offer-32.3) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°æŒ‰ç…§ä¹‹å­—å½¢é¡ºåºæ‰“å°äºŒå‰æ ‘ï¼Œå³ç¬¬ä¸€è¡ŒæŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ï¼Œç¬¬äºŒå±‚æŒ‰ç…§ä»","title":"å‰‘æŒ‡Offer-32.3 ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘III"},{"content":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘II(å‰‘æŒ‡Offer-32.2) é¢˜é¢ ä»ä¸Šåˆ°ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ã€‚\nä¾‹å¦‚: ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7],\n1 3 2 / \\ 3 9 20 4 / \\ 5 15 7 è¿”å›ï¼š\n1[ 2 [3], 3 [9,20], 4 [15,7] 5] é™åˆ¶ 1èŠ‚ç‚¹æ€»æ•° \u0026lt;= 1000 æ€è·¯ BFSå±‚åºéå†ï¼ŒåŠ ä¸ªæ ‡è®°ï¼Œå½“ä¸€å±‚éå†å®Œæ—¶ï¼Œé˜Ÿåˆ—é‡Œå³æ˜¯ä¸‹ä¸€å±‚ï¼Œä½¿ç”¨q.back()æ›´æ–°æ ‡è®°å³å¯ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11public: 12 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { 13 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; ans; 14 vector\u0026lt;int\u0026gt; row; 15 if(root==NULL) return ans; 16 17 queue\u0026lt;TreeNode *\u0026gt;q; 18 q.push(root); 19 TreeNode *end = root; 20 21 while(!q.empty()){ 22 TreeNode *t = q.front(); q.pop(); 23 row.push_back(t-\u0026gt;val); 24 if(t-\u0026gt;left) 25 q.push(t-\u0026gt;left); 26 if(t-\u0026gt;right) 27 q.push(t-\u0026gt;right); 28 if(t == end){ 29 ans.push_back(row); 30 row.clear(); 31 end = q.back(); 32 } 33 } 34 return ans; 35 } 36}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-32.2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91ii/","summary":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘II(å‰‘æŒ‡Offer-32.2) é¢˜é¢ ä»ä¸Šåˆ°ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ã€‚ ä¾‹å¦‚: ç»™å®šäºŒå‰æ ‘:","title":"å‰‘æŒ‡Offer-32.2 ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘II"},{"content":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘(å‰‘æŒ‡Offer-32.1) é¢˜é¢ ä»ä¸Šåˆ°ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ã€‚\nä¾‹å¦‚: ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7],\n1 3 2 / \\ 3 9 20 4 / \\ 5 15 7 è¿”å›ï¼š\n1[3,9,20,15,7] é™åˆ¶ 1èŠ‚ç‚¹æ€»æ•° \u0026lt;= 1000 æ€è·¯ BFSå±‚åºéå†ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11public: 12 vector\u0026lt;int\u0026gt; levelOrder(TreeNode* root) { 13 vector\u0026lt;int\u0026gt; v; 14 if(root==NULL) return v; 15 16 queue\u0026lt;TreeNode *\u0026gt;q; 17 q.push(root); 18 19 while(!q.empty()){ 20 TreeNode *t = q.front(); q.pop(); 21 v.push_back(t-\u0026gt;val); 22 if(t-\u0026gt;left) 23 q.push(t-\u0026gt;left); 24 if(t-\u0026gt;right) 25 q.push(t-\u0026gt;right); 26 } 27 return v; 28 } 29}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-32.1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘(å‰‘æŒ‡Offer-32.1) é¢˜é¢ ä»ä¸Šåˆ°ä¸‹æ‰“å°å‡ºäºŒå‰æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ŒåŒä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰“å°ã€‚ ä¾‹å¦‚: ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7], 1","title":"å‰‘æŒ‡Offer-32.1 ä»ä¸Šåˆ°ä¸‹æ‰“å°äºŒå‰æ ‘"},{"content":"æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—(å‰‘æŒ‡Offer-31) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªæ•´æ•°åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—è¡¨ç¤ºæ ˆçš„å‹å…¥é¡ºåºï¼Œè¯·åˆ¤æ–­ç¬¬äºŒä¸ªåºåˆ—æ˜¯å¦ä¸ºè¯¥æ ˆçš„å¼¹å‡ºé¡ºåºã€‚å‡è®¾å‹å…¥æ ˆçš„æ‰€æœ‰æ•°å­—å‡ä¸ç›¸ç­‰ã€‚ä¾‹å¦‚ï¼Œåºåˆ— {1,2,3,4,5} æ˜¯æŸæ ˆçš„å‹æ ˆåºåˆ—ï¼Œåºåˆ— {4,5,3,2,1} æ˜¯è¯¥å‹æ ˆåºåˆ—å¯¹åº”çš„ä¸€ä¸ªå¼¹å‡ºåºåˆ—ï¼Œä½† {4,3,5,1,2} å°±ä¸å¯èƒ½æ˜¯è¯¥å‹æ ˆåºåˆ—çš„å¼¹å‡ºåºåˆ—ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼špushed = [1,2,3,4,5], popped = [4,5,3,2,1] 2è¾“å‡ºï¼štrue 3è§£é‡Šï¼šæˆ‘ä»¬å¯ä»¥æŒ‰ä»¥ä¸‹é¡ºåºæ‰§è¡Œï¼š 4push(1), push(2), push(3), push(4), pop() -\u0026gt; 4, 5push(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼špushed = [1,2,3,4,5], popped = [4,3,5,1,2] 2è¾“å‡ºï¼šfalse 3è§£é‡Šï¼š1 ä¸èƒ½åœ¨ 2 ä¹‹å‰å¼¹å‡ºã€‚ é™åˆ¶ 10 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 20 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 3pushed æ˜¯ popped çš„æ’åˆ—ã€‚ æ€è·¯ è¾…åŠ©æ ˆæ¨¡æ‹Ÿã€‚\nä»£ç  1class Solution { 2public: 3 bool validateStackSequences(vector\u0026lt;int\u0026gt;\u0026amp; pushed, vector\u0026lt;int\u0026gt;\u0026amp; popped) { 4 stack\u0026lt;int\u0026gt; st; 5 int i=0; 6 for(int x:pushed){ 7 st.push(x); 8 while(!st.empty() \u0026amp;\u0026amp; st.top()==popped[i]){ 9 st.pop(); 10 i++; 11 } 12 } 13 return st.empty(); 14 } 15}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","summary":"æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—(å‰‘æŒ‡Offer-31) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªæ•´æ•°åºåˆ—ï¼Œç¬¬ä¸€ä¸ªåºåˆ—è¡¨ç¤ºæ ˆçš„å‹å…¥é¡ºåºï¼Œè¯·åˆ¤æ–­ç¬¬äºŒä¸ªåºåˆ—æ˜¯å¦ä¸ºè¯¥æ ˆçš„å¼¹å‡ºé¡ºåºã€‚å‡è®¾å‹å…¥æ ˆ","title":"å‰‘æŒ‡Offer-31 æ ˆçš„å‹å…¥ã€å¼¹å‡ºåºåˆ—"},{"content":"åŒ…å«minå‡½æ•°çš„æ ˆ(å‰‘æŒ‡Offer-30) é¢˜é¢ å®šä¹‰æ ˆçš„æ•°æ®ç»“æ„ï¼Œè¯·åœ¨è¯¥ç±»å‹ä¸­å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆçš„æœ€å°å…ƒç´ çš„ min å‡½æ•°åœ¨è¯¥æ ˆä¸­ï¼Œè°ƒç”¨ minã€push åŠ pop çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯ O(1)ã€‚\nç¤ºä¾‹ 1MinStack minStack = new MinStack(); 2minStack.push(-2); 3minStack.push(0); 4minStack.push(-3); 5minStack.min(); --\u0026gt; è¿”å› -3. 6minStack.pop(); 7minStack.top(); --\u0026gt; è¿”å› 0. 8minStack.min(); --\u0026gt; è¿”å› -2. é™åˆ¶ 1å„å‡½æ•°çš„è°ƒç”¨æ€»æ¬¡æ•°ä¸è¶…è¿‡ 20000 æ¬¡ æ€è·¯ é™¤äº†å¸¸è§„çš„æ ˆï¼Œå†ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆï¼Œä»æ ˆé¡¶åˆ°æ ˆåº•é€’å¢\nå¸¸è§„æ ˆå¸¸è§„æ·»åŠ åˆ é™¤å…ƒç´ \nå•è°ƒæ ˆæ ˆé¡¶å…ƒç´ å¤§äºç­‰äºå¾…åŠ å…¥å…ƒç´ æˆ–è€…å•è°ƒæ ˆä¸ºç©ºï¼Œåˆ™å…¥æ ˆï¼›å½“å¸¸è§„æ ˆçš„å‡ºæ ˆå…ƒç´ ç­‰äºå•è°ƒæ ˆçš„æ ˆé¡¶å…ƒç´ ï¼Œå•è°ƒæ ˆå‡ºæ ˆ\nä»£ç  1class MinStack { 2 stack\u0026lt;int\u0026gt; s, t; 3public: 4 /** initialize your data structure here. */ 5 MinStack() { 6 7 } 8 9 void push(int x) { 10 if(t.empty() || t.top() \u0026gt;= x) 11 t.push(x); 12 s.push(x); 13 } 14 15 void pop() { 16 if(t.top() == s.top()) 17 t.pop(); 18 s.pop(); 19 } 20 21 int top() { 22 return s.top(); 23 } 24 25 int min() { 26 return t.top(); 27 } 28}; 29 30/** 31 * Your MinStack object will be instantiated and called as such: 32 * MinStack* obj = new MinStack(); 33 * obj-\u0026gt;push(x); 34 * obj-\u0026gt;pop(); 35 * int param_3 = obj-\u0026gt;top(); 36 * int param_4 = obj-\u0026gt;min(); 37 */ ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","summary":"åŒ…å«minå‡½æ•°çš„æ ˆ(å‰‘æŒ‡Offer-30) é¢˜é¢ å®šä¹‰æ ˆçš„æ•°æ®ç»“æ„ï¼Œè¯·åœ¨è¯¥ç±»å‹ä¸­å®ç°ä¸€ä¸ªèƒ½å¤Ÿå¾—åˆ°æ ˆçš„æœ€å°å…ƒç´ çš„ min å‡½æ•°åœ¨è¯¥æ ˆä¸­ï¼Œè°ƒç”¨ minã€pus","title":"å‰‘æŒ‡Offer-30 åŒ…å«minå‡½æ•°çš„æ ˆ"},{"content":"é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ(å‰‘æŒ‡Offer-29) é¢˜é¢ è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]] 2è¾“å‡ºï¼š[1,2,3,6,9,8,7,4,5] ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šmatrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 2è¾“å‡ºï¼š[1,2,3,4,8,12,11,10,9,5,6,7] é™åˆ¶ 1 0 \u0026lt;= matrix.length \u0026lt;= 100 2 0 \u0026lt;= matrix[i].length \u0026lt;= 100 æ€è·¯ æš´åŠ›æ¨¡æ‹Ÿã€‚\nä»£ç  1class Solution { 2public: 3 vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { 4 if(matrix.empty()) return vector\u0026lt;int\u0026gt;(); 5 vector\u0026lt;int\u0026gt; v; 6 int u=0, d=matrix.size()-1, l=0, r=matrix[0].size()-1; 7 while(1){ 8 for(int i=l; i\u0026lt;=r; i++) v.push_back(matrix[u][i]); 9 if(++u \u0026gt; d) break; 10 11 for(int i=u; i\u0026lt;=d; i++) v.push_back(matrix[i][r]); 12 if(l \u0026gt; --r) break; 13 14 for(int i=r; i\u0026gt;=l; i--) v.push_back(matrix[d][i]); 15 if(u \u0026gt; --d) break; 16 17 for(int i=d; i\u0026gt;=u; i--) v.push_back(matrix[i][l]); 18 if(++l \u0026gt; r) break; 19 } 20 return v; 21 } 22}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","summary":"é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ(å‰‘æŒ‡Offer-29) é¢˜é¢ è¾“å…¥ä¸€ä¸ªçŸ©é˜µï¼ŒæŒ‰ç…§ä»å¤–å‘é‡Œä»¥é¡ºæ—¶é’ˆçš„é¡ºåºä¾æ¬¡æ‰“å°å‡ºæ¯ä¸€ä¸ªæ•°å­—ã€‚ ç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š 1è¾“å…¥ï¼šmatrix = [[1,2,3],[4,5,6],[7,8,9]]","title":"å‰‘æŒ‡Offer-29 é¡ºæ—¶é’ˆæ‰“å°çŸ©é˜µ"},{"content":"å¯¹ç§°çš„äºŒå‰æ ‘(å‰‘æŒ‡Offer-28) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚å¦‚æœä¸€æ£µäºŒå‰æ ‘å’Œå®ƒçš„é•œåƒä¸€æ ·ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¯¹ç§°çš„ã€‚\nä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚\n1 1 2 / \\ 3 2 2 4 / \\ / \\ 5 3 4 4 3 ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:\n1 1 2 / \\ 3 2 2 4 \\ \\ 5 3 3 ç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šroot = [1,2,2,3,4,4,3] 2è¾“å‡ºï¼štrue ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šroot = [1,2,2,null,3,null,3] 2è¾“å‡ºï¼šfalse é™åˆ¶ 10 \u0026lt;= èŠ‚ç‚¹ä¸ªæ•° \u0026lt;= 1000 æ€è·¯ é€’å½’ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11 bool dfs(TreeNode *left, TreeNode *right){ 12 if(left==NULL \u0026amp;\u0026amp; right==NULL) return true; 13 if(left==NULL || right==NULL || left-\u0026gt;val!=right-\u0026gt;val) return false; 14 return dfs(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; dfs(left-\u0026gt;right, right-\u0026gt;left); 15 } 16public: 17 bool isSymmetric(TreeNode* root) { 18 if(root==NULL) return true; 19 return dfs(root-\u0026gt;left, root-\u0026gt;right); 20 } 21}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"å¯¹ç§°çš„äºŒå‰æ ‘(å‰‘æŒ‡Offer-28) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯ä¸æ˜¯å¯¹ç§°çš„ã€‚å¦‚æœä¸€æ£µäºŒå‰æ ‘å’Œå®ƒçš„é•œåƒä¸€æ ·ï¼Œé‚£ä¹ˆå®ƒæ˜¯å¯¹ç§°çš„ã€‚ ä¾‹å¦‚ï¼Œ","title":"å‰‘æŒ‡Offer-28 å¯¹ç§°çš„äºŒå‰æ ‘"},{"content":"äºŒå‰æ ‘çš„é•œåƒ(å‰‘æŒ‡Offer-27) é¢˜é¢ è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯¥å‡½æ•°è¾“å‡ºå®ƒçš„é•œåƒã€‚\nä¾‹å¦‚è¾“å…¥ï¼š\n1 4 2 / \\ 3 2 7 4 / \\ / \\ 51 3 6 9 é•œåƒè¾“å‡ºï¼š\n1 4 2 / \\ 3 7 2 4 / \\ / \\ 59 6 3 1 ç¤ºä¾‹ 1è¾“å…¥ï¼šroot = [4,2,7,1,3,6,9] 2è¾“å‡ºï¼š[4,7,2,9,6,3,1] é™åˆ¶ 10 \u0026lt;= èŠ‚ç‚¹ä¸ªæ•° \u0026lt;= 1000 æ€è·¯ é€’å½’ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11public: 12 TreeNode* mirrorTree(TreeNode* root) { 13 if(root==NULL) return NULL; 14 TreeNode *t = root-\u0026gt;left; 15 root-\u0026gt;left = mirrorTree(root-\u0026gt;right); 16 root-\u0026gt;right = mirrorTree(t); 17 return root; 18 } 19}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","summary":"äºŒå‰æ ‘çš„é•œåƒ(å‰‘æŒ‡Offer-27) é¢˜é¢ è¯·å®Œæˆä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯¥å‡½æ•°è¾“å‡ºå®ƒçš„é•œåƒã€‚ ä¾‹å¦‚è¾“å…¥ï¼š 1 4 2 / \\ 3 2 7 4 / \\ / \\ 51 3 6 9 é•œåƒ","title":"å‰‘æŒ‡Offer-27 äºŒå‰æ ‘çš„é•œåƒ"},{"content":"æ ‘çš„å­ç»“æ„(å‰‘æŒ‡Offer-26) é¢˜é¢ è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aå’ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ã€‚(çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„)\nBæ˜¯Açš„å­ç»“æ„ï¼Œ å³ Aä¸­æœ‰å‡ºç°å’ŒBç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚\nä¾‹å¦‚: ç»™å®šçš„æ ‘ A:\n1 3 2 / \\ 3 4 5 4 / \\ 5 1 2 ç»™å®šçš„æ ‘ Bï¼š\n1 4 2 / 3 1 è¿”å› trueï¼Œå› ä¸º B ä¸ A çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šA = [1,2,3], B = [3,1] 2è¾“å‡ºï¼šfalse ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šA = [3,4,5,1,2], B = [4,1] 2è¾“å‡ºï¼štrue é™åˆ¶ 10 \u0026lt;= èŠ‚ç‚¹ä¸ªæ•° \u0026lt;= 10000 æ€è·¯ é€’å½’ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11 bool equal(TreeNode *A, TreeNode *B){ 12 if(B==NULL) return true; 13 if(A==NULL || A-\u0026gt;val != B-\u0026gt;val) return false; 14 return equal(A-\u0026gt;left, B-\u0026gt;left) \u0026amp;\u0026amp; equal(A-\u0026gt;right, B-\u0026gt;right); 15 } 16public: 17 bool isSubStructure(TreeNode* A, TreeNode* B) { 18 if(A==NULL || B==NULL) return false; 19 return equal(A, B) || isSubStructure(A-\u0026gt;left, B) || isSubStructure(A-\u0026gt;right, B); 20 } 21}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","summary":"æ ‘çš„å­ç»“æ„(å‰‘æŒ‡Offer-26) é¢˜é¢ è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aå’ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ã€‚(çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„) Bæ˜¯Açš„å­ç»“æ„ï¼Œ å³ Aä¸­","title":"å‰‘æŒ‡Offer-26 æ ‘çš„å­ç»“æ„"},{"content":"åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨(å‰‘æŒ‡Offer-25) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªé€’å¢æ’åºçš„é“¾è¡¨ï¼Œåˆå¹¶è¿™ä¸¤ä¸ªé“¾è¡¨å¹¶ä½¿æ–°é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ä»ç„¶æ˜¯é€’å¢æ’åºçš„ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼š1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 2è¾“å‡ºï¼š1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 é™åˆ¶ 10 \u0026lt;= é“¾è¡¨é•¿åº¦ \u0026lt;= 1000 æ€è·¯ é“¾è¡¨åˆå¹¶ï¼Œè®¾ç«‹ä¸€ä¸ªä¼ªå¤´ç»“ç‚¹å¯ä»¥æ–¹ä¾¿ä»£ç ä¹¦å†™ã€‚\nä»£ç  1/** 2 * Definition for singly-linked list. 3 * struct ListNode { 4 * int val; 5 * ListNode *next; 6 * ListNode(int x) : val(x), next(NULL) {} 7 * }; 8 */ 9class Solution { 10public: 11 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { 12 ListNode *head = new ListNode(0); 13 ListNode *p = head; 14 while(l1 \u0026amp;\u0026amp; l2){ 15 if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val){ 16 p-\u0026gt;next = l1; 17 l1 = l1-\u0026gt;next; 18 }else{ 19 p-\u0026gt;next = l2; 20 l2 = l2-\u0026gt;next; 21 } 22 p = p-\u0026gt;next; 23 } 24 p-\u0026gt;next = l1 ? l1 : l2; 25 return head-\u0026gt;next; 26 } 27}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","summary":"åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨(å‰‘æŒ‡Offer-25) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªé€’å¢æ’åºçš„é“¾è¡¨ï¼Œåˆå¹¶è¿™ä¸¤ä¸ªé“¾è¡¨å¹¶ä½¿æ–°é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ä»ç„¶æ˜¯é€’å¢æ’åºçš„ã€‚ ç¤ºä¾‹ 1è¾“å…¥ï¼š1-\u0026g","title":"å‰‘æŒ‡Offer-25 åˆå¹¶ä¸¤ä¸ªæ’åºçš„é“¾è¡¨"},{"content":"åè½¬é“¾è¡¨(å‰‘æŒ‡Offer-24) é¢˜é¢ å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œåè½¬è¯¥é“¾è¡¨å¹¶è¾“å‡ºåè½¬åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚\nç¤ºä¾‹ 1è¾“å…¥: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 2è¾“å‡º: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL é™åˆ¶ 10 \u0026lt;= èŠ‚ç‚¹ä¸ªæ•° \u0026lt;= 5000 æ€è·¯ é“¾è¡¨åŸåœ°è½¬ç½®ã€‚\nä»£ç  1/** 2 * Definition for singly-linked list. 3 * struct ListNode { 4 * int val; 5 * ListNode *next; 6 * ListNode(int x) : val(x), next(NULL) {} 7 * }; 8 */ 9class Solution { 10public: 11 ListNode* reverseList(ListNode* head) { 12 ListNode *h=NULL, *pre=head, *last=head; 13 while(pre){ 14 last = last-\u0026gt;next; 15 pre-\u0026gt;next = h; 16 h = pre; 17 pre = last; 18 } 19 return h; 20 } 21}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"åè½¬é“¾è¡¨(å‰‘æŒ‡Offer-24) é¢˜é¢ å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œåè½¬è¯¥é“¾è¡¨å¹¶è¾“å‡ºåè½¬åé“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ ç¤ºä¾‹ 1è¾“å…¥: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL 2è¾“å‡º: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL é™åˆ¶ 10 \u0026lt;=","title":"å‰‘æŒ‡Offer-24 åè½¬é“¾è¡¨"},{"content":"é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹(å‰‘æŒ‡Offer-22) é¢˜é¢ è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ã€‚ä¸ºäº†ç¬¦åˆå¤§å¤šæ•°äººçš„ä¹ æƒ¯ï¼Œæœ¬é¢˜ä»1å¼€å§‹è®¡æ•°ï¼Œå³é“¾è¡¨çš„å°¾èŠ‚ç‚¹æ˜¯å€’æ•°ç¬¬1ä¸ªèŠ‚ç‚¹ã€‚\nä¾‹å¦‚ï¼Œä¸€ä¸ªé“¾è¡¨æœ‰ 6 ä¸ªèŠ‚ç‚¹ï¼Œä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œå®ƒä»¬çš„å€¼ä¾æ¬¡æ˜¯ 1ã€2ã€3ã€4ã€5ã€6ã€‚è¿™ä¸ªé“¾è¡¨çš„å€’æ•°ç¬¬ 3 ä¸ªèŠ‚ç‚¹æ˜¯å€¼ä¸º 4 çš„èŠ‚ç‚¹ã€‚\nç¤ºä¾‹ 1ç»™å®šä¸€ä¸ªé“¾è¡¨: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, å’Œ k = 2. 2è¿”å›é“¾è¡¨ 4-\u0026gt;5. æ€è·¯ åŒæŒ‡é’ˆï¼Œä½¿å¾—ä¸¤ä¸ªæŒ‡é’ˆé—´éš”ä¸ºkã€‚\nä»£ç  1/** 2 * Definition for singly-linked list. 3 * struct ListNode { 4 * int val; 5 * ListNode *next; 6 * ListNode(int x) : val(x), next(NULL) {} 7 * }; 8 */ 9class Solution { 10public: 11 ListNode* getKthFromEnd(ListNode* head, int k) { 12 ListNode *pre = head, *last = head; 13 for(int i=0; i\u0026lt;k \u0026amp;\u0026amp; last!=NULL; i++){ 14 last = last-\u0026gt;next; 15 } 16 while(last != NULL){ 17 last = last-\u0026gt;next; 18 pre = pre-\u0026gt;next; 19 } 20 return pre; 21 } 22}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹(å‰‘æŒ‡Offer-22) é¢˜é¢ è¾“å…¥ä¸€ä¸ªé“¾è¡¨ï¼Œè¾“å‡ºè¯¥é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ã€‚ä¸ºäº†ç¬¦åˆå¤§å¤šæ•°äººçš„ä¹ æƒ¯ï¼Œæœ¬é¢˜ä»1å¼€å§‹è®¡æ•°ï¼Œå³é“¾è¡¨çš„","title":"å‰‘æŒ‡Offer-22 é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹"},{"content":"è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢(å‰‘æŒ‡Offer-21) é¢˜é¢ è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®ç°ä¸€ä¸ªå‡½æ•°æ¥è°ƒæ•´è¯¥æ•°ç»„ä¸­æ•°å­—çš„é¡ºåºï¼Œä½¿å¾—æ‰€æœ‰å¥‡æ•°ä½äºæ•°ç»„çš„å‰åŠéƒ¨åˆ†ï¼Œæ‰€æœ‰å¶æ•°ä½äºæ•°ç»„çš„ååŠéƒ¨åˆ†ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼šnums = [1,2,3,4] 2è¾“å‡ºï¼š[1,3,2,4] 3æ³¨ï¼š[3,1,2,4] ä¹Ÿæ˜¯æ­£ç¡®çš„ç­”æ¡ˆä¹‹ä¸€ã€‚ é™åˆ¶ 0 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10000 æ€è·¯ å®šä¹‰å¤´æŒ‡é’ˆ leftï¼Œå°¾æŒ‡é’ˆ rightã€‚left ä¸€ç›´å¾€å³ç§»ï¼Œç›´åˆ°å®ƒæŒ‡å‘çš„å€¼ä¸ºå¶æ•°ï¼Œright ä¸€ç›´å¾€å·¦ç§»ï¼Œç›´åˆ°å®ƒæŒ‡å‘çš„å€¼ä¸ºå¥‡æ•°ã€‚äº¤æ¢ nums[left] å’Œ nums[right]ã€‚é‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´åˆ° left==right .\nä»£ç  1class Solution { 2public: 3 vector\u0026lt;int\u0026gt; exchange(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 int l = 0, r = nums.size()-1; 5 while(l \u0026lt; r){ 6 if(nums[l] \u0026amp; 1){ 7 l++; 8 continue; 9 } 10 if(!(nums[r] \u0026amp; 1)){ 11 r--; 12 continue; 13 } 14 swap(nums[l++], nums[r--]); 15 } 16 return nums; 17 } 18}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","summary":"è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢(å‰‘æŒ‡Offer-21) é¢˜é¢ è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œå®ç°ä¸€ä¸ªå‡½æ•°æ¥è°ƒæ•´è¯¥æ•°ç»„ä¸­æ•°å­—çš„é¡ºåºï¼Œä½¿å¾—æ‰€æœ‰å¥‡æ•°ä½äºæ•°ç»„çš„å‰åŠ","title":"å‰‘æŒ‡Offer-21 è°ƒæ•´æ•°ç»„é¡ºåºä½¿å¥‡æ•°ä½äºå¶æ•°å‰é¢"},{"content":"è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²(å‰‘æŒ‡Offer-20) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¡¨ç¤ºæ•°å€¼ï¼ˆåŒ…æ‹¬æ•´æ•°å’Œå°æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²\u0026quot;+100\u0026quot;ã€\u0026ldquo;5e2\u0026rdquo;ã€\u0026quot;-123\u0026quot;ã€\u0026ldquo;3.1416\u0026rdquo;ã€\u0026quot;-1E-16\u0026quot;ã€\u0026ldquo;0123\u0026quot;éƒ½è¡¨ç¤ºæ•°å€¼ï¼Œä½†\u0026quot;12e\u0026rdquo;ã€\u0026ldquo;1a3.14\u0026rdquo;ã€\u0026ldquo;1.2.3\u0026rdquo;ã€\u0026quot;+-5\u0026quot;åŠ\u0026quot;12e+5.4\u0026quot;éƒ½ä¸æ˜¯ã€‚\næ€è·¯ è‡ªåŠ¨æœºã€‚\n![çŠ¶æ€è½¬ç§»](å‰‘æŒ‡Offer-20 è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²/çŠ¶æ€è½¬ç§».png)\nåˆæ³•çš„ç»“æŸçŠ¶æ€æœ‰ 2, 3, 7, 8 ã€‚\nä»£ç  1class Solution { 2public: 3 bool isNumber(string s) { 4 unordered_map\u0026lt;char, int\u0026gt; mp[9]; 5 mp[0][\u0026#39; \u0026#39;]=0; mp[0][\u0026#39;s\u0026#39;]=1; mp[0][\u0026#39;d\u0026#39;]=2; mp[0][\u0026#39;.\u0026#39;]=4; 6 mp[1][\u0026#39;d\u0026#39;]=2; mp[1][\u0026#39;.\u0026#39;]=4; 7 mp[2][\u0026#39;d\u0026#39;]=2; mp[2][\u0026#39;.\u0026#39;]=3; mp[2][\u0026#39;e\u0026#39;]=5; mp[2][\u0026#39; \u0026#39;]=8; 8 mp[3][\u0026#39;d\u0026#39;]=3; mp[3][\u0026#39;e\u0026#39;]=5; mp[3][\u0026#39; \u0026#39;]=8; 9 mp[4][\u0026#39;d\u0026#39;]=3; 10 mp[5][\u0026#39;s\u0026#39;]=6; mp[5][\u0026#39;d\u0026#39;]=7; 11 mp[6][\u0026#39;d\u0026#39;]=7; 12 mp[7][\u0026#39;d\u0026#39;]=7; mp[7][\u0026#39; \u0026#39;]=8; 13 mp[8][\u0026#39; \u0026#39;]=8; 14 15 int p = 0; 16 char t; 17 for(char c:s){ 18 if(\u0026#39;0\u0026#39;\u0026lt;=c \u0026amp;\u0026amp; c\u0026lt;=\u0026#39;9\u0026#39;) t = \u0026#39;d\u0026#39;; 19 else if(c==\u0026#39;+\u0026#39; || c==\u0026#39;-\u0026#39;) t = \u0026#39;s\u0026#39;; 20 else if(c==\u0026#39;e\u0026#39; || c==\u0026#39;E\u0026#39;) t = \u0026#39;e\u0026#39;; 21 else t = c; 22 23 if(mp[p].find(t) == mp[p].end()) return false; 24 p = mp[p][t]; 25 } 26 return (p==2 || p==3 || p==7 || p==8); 27 } 28}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²(å‰‘æŒ‡Offer-20) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦è¡¨ç¤ºæ•°å€¼ï¼ˆåŒ…æ‹¬æ•´æ•°å’Œå°æ•°ï¼‰ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²\u0026quot;+100\u0026q","title":"å‰‘æŒ‡Offer-20 è¡¨ç¤ºæ•°å€¼çš„å­—ç¬¦ä¸²"},{"content":"æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…(å‰‘æŒ‡Offer-19) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…å«'.'å’Œ'*'çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦'.'è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œ'*'è¡¨ç¤ºå®ƒå‰é¢çš„å­—ç¬¦å¯ä»¥å‡ºç°ä»»æ„æ¬¡ï¼ˆå«0æ¬¡ï¼‰ã€‚åœ¨æœ¬é¢˜ä¸­ï¼ŒåŒ¹é…æ˜¯æŒ‡å­—ç¬¦ä¸²çš„æ‰€æœ‰å­—ç¬¦åŒ¹é…æ•´ä¸ªæ¨¡å¼ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²\u0026quot;aaa\u0026quot;ä¸æ¨¡å¼\u0026quot;a.a\u0026quot;å’Œ\u0026quot;ab*ac*a\u0026quot;åŒ¹é…ï¼Œä½†ä¸\u0026quot;aa.a\u0026quot;å’Œ\u0026quot;ab*a\u0026quot;å‡ä¸åŒ¹é…ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: 2s = \u0026#34;aa\u0026#34; 3p = \u0026#34;a\u0026#34; 4è¾“å‡º: false 5è§£é‡Š: \u0026#34;a\u0026#34; æ— æ³•åŒ¹é… \u0026#34;aa\u0026#34; æ•´ä¸ªå­—ç¬¦ä¸²ã€‚ ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥: 2s = \u0026#34;aa\u0026#34; 3p = \u0026#34;a*\u0026#34; 4è¾“å‡º: true 5è§£é‡Š: å› ä¸º \u0026#39;*\u0026#39; ä»£è¡¨å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªå‰é¢çš„é‚£ä¸€ä¸ªå…ƒç´ , åœ¨è¿™é‡Œå‰é¢çš„å…ƒç´ å°±æ˜¯ \u0026#39;a\u0026#39;ã€‚å› æ­¤ï¼Œå­—ç¬¦ä¸² \u0026#34;aa\u0026#34; 6å¯è¢«è§†ä¸º \u0026#39;a\u0026#39; é‡å¤äº†ä¸€æ¬¡ã€‚ ç¤ºä¾‹ 3ï¼š\n1è¾“å…¥: 2s = \u0026#34;ab\u0026#34; 3p = \u0026#34;.*\u0026#34; 4è¾“å‡º: true 5è§£é‡Š: \u0026#34;.*\u0026#34; è¡¨ç¤ºå¯åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªï¼ˆ\u0026#39;*\u0026#39;ï¼‰ä»»æ„å­—ç¬¦ï¼ˆ\u0026#39;.\u0026#39;ï¼‰ã€‚ ç¤ºä¾‹ 4ï¼š\n1è¾“å…¥: 2s = \u0026#34;aab\u0026#34; 3p = \u0026#34;c*a*b\u0026#34; 4è¾“å‡º: true 5è§£é‡Š: å› ä¸º \u0026#39;*\u0026#39; è¡¨ç¤ºé›¶ä¸ªæˆ–å¤šä¸ªï¼Œè¿™é‡Œ \u0026#39;c\u0026#39; ä¸º 0 ä¸ª, \u0026#39;a\u0026#39; è¢«é‡å¤ä¸€æ¬¡ã€‚å› æ­¤å¯ä»¥åŒ¹é…å­—ç¬¦ä¸² \u0026#34;aab\u0026#34;ã€‚ ç¤ºä¾‹ 5ï¼š\n1è¾“å…¥: 2s = \u0026#34;mississippi\u0026#34; 3p = \u0026#34;mis*is*p*.\u0026#34; 4è¾“å‡º: false é™åˆ¶ s å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ã€‚ p å¯èƒ½ä¸ºç©ºï¼Œä¸”åªåŒ…å«ä» a-z çš„å°å†™å­—æ¯ä»¥åŠå­—ç¬¦ . å’Œ *ï¼Œæ— è¿ç»­çš„ '*'ã€‚ æ€è·¯ DPé¢˜ã€‚è¯¦è§jydçš„é¢˜è§£\nåŠ¨æ€è§„åˆ’è§£æï¼š\nçŠ¶æ€å®šä¹‰ï¼š è®¾åŠ¨æ€è§„åˆ’çŸ©é˜µ dp ï¼Œ dp[i][j] ä»£è¡¨å­—ç¬¦ä¸² s çš„å‰ i ä¸ªå­—ç¬¦å’Œ p çš„å‰ j ä¸ªå­—ç¬¦èƒ½å¦åŒ¹é…ã€‚\nè½¬ç§»æ–¹ç¨‹ï¼š éœ€è¦æ³¨æ„ï¼Œç”±äº dp[0][0] ä»£è¡¨çš„æ˜¯ç©ºå­—ç¬¦çš„çŠ¶æ€ï¼Œ å› æ­¤ dp[i][j] å¯¹åº”çš„æ·»åŠ å­—ç¬¦æ˜¯ s[i-1] å’Œ p[j-1] ã€‚\nå½“p[j-1] = '*'æ—¶ï¼Œ dp[i][j] åœ¨å½“ä»¥ä¸‹ä»»ä¸€æƒ…å†µä¸º true æ—¶ç­‰äº true ï¼š\ndp[i][j-2]ï¼š å³å°†å­—ç¬¦ç»„åˆ p[j-2] * çœ‹ä½œå‡ºç° 0 æ¬¡æ—¶ï¼Œèƒ½å¦åŒ¹é…ï¼› dp[i-1][j] ä¸” s[i-1] = p[j-2]: å³è®©å­—ç¬¦ p[j-2] å¤šå‡ºç° 1 æ¬¡æ—¶ï¼Œèƒ½å¦åŒ¹é…ï¼› dp[i-1][j] ä¸” p[j-2] = '.': å³è®©å­—ç¬¦'.'å¤šå‡ºç° 1 æ¬¡æ—¶ï¼Œèƒ½å¦åŒ¹é…ï¼› å½“ p[j-1] != '*' æ—¶ï¼Œ dp[i][j] åœ¨å½“ä»¥ä¸‹ä»»ä¸€æƒ…å†µä¸º true æ—¶ç­‰äº true ï¼š\ndp[i-1][j-1] ä¸” s[i-1] = p[j-1]ï¼š å³è®©å­—ç¬¦ p[j-1] å¤šå‡ºç°ä¸€æ¬¡æ—¶ï¼Œèƒ½å¦åŒ¹é…ï¼› dp[i-1][j-1] ä¸” p[j-1] = '.'ï¼š å³å°†å­—ç¬¦ . çœ‹ä½œå­—ç¬¦ s[i-1] æ—¶ï¼Œèƒ½å¦åŒ¹é…ï¼› åˆå§‹åŒ–ï¼š éœ€è¦å…ˆåˆå§‹åŒ– dp çŸ©é˜µé¦–è¡Œï¼Œä»¥é¿å…çŠ¶æ€è½¬ç§»æ—¶ç´¢å¼•è¶Šç•Œã€‚\ndp[0][0] = trueï¼š ä»£ è¡¨ä¸¤ä¸ªç©ºå­—ç¬¦ä¸²èƒ½å¤ŸåŒ¹é…ã€‚ dp[0][j] = dp[0][j-2] ä¸” p[j-1] = '*'ï¼š é¦–è¡Œ s ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œå› æ­¤å½“ p çš„å¶æ•°ä½ä¸º * æ—¶æ‰èƒ½å¤ŸåŒ¹é…ï¼ˆå³è®© p çš„å¥‡æ•°ä½å‡ºç° 0 æ¬¡ï¼Œä¿æŒ p æ˜¯ç©ºå­—ç¬¦ä¸²ï¼‰ã€‚å› æ­¤ï¼Œå¾ªç¯éå†å­—ç¬¦ä¸² p ï¼Œæ­¥é•¿ä¸º 2ï¼ˆå³åªçœ‹å¶æ•°ä½ï¼‰ã€‚ è¿”å›å€¼ï¼š dp çŸ©é˜µå³ä¸‹è§’å­—ç¬¦ï¼Œä»£è¡¨å­—ç¬¦ä¸² s å’Œ p èƒ½å¦åŒ¹é…ã€‚\nä»£ç  1class Solution { 2public: 3 bool isMatch(string s, string p) { 4 int n=s.size()+1, m=p.size()+1; 5 vector\u0026lt;vector\u0026lt;bool\u0026gt; \u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(m, false)); 6 7 dp[0][0] = true; 8 for(int j=2; j\u0026lt;m; j+=2) 9 dp[0][j] = dp[0][j-2] \u0026amp;\u0026amp; p[j-1]==\u0026#39;*\u0026#39;; 10 11 for(int i=1; i\u0026lt;n; i++){ 12 for(int j=1; j\u0026lt;m; j++){ 13 if(p[j-1] == \u0026#39;*\u0026#39;){ 14 dp[i][j] = dp[i][j-2] || 15 dp[i-1][j] \u0026amp;\u0026amp; s[i-1]==p[j-2] || 16 dp[i-1][j] \u0026amp;\u0026amp; p[j-2]==\u0026#39;.\u0026#39;; 17 }else{ 18 dp[i][j] = dp[i-1][j-1] \u0026amp;\u0026amp; s[i-1]==p[j-1] || 19 dp[i-1][j-1] \u0026amp;\u0026amp; p[j-1]==\u0026#39;.\u0026#39;; 20 } 21 } 22 } 23 return dp[n-1][m-1]; 24 } 25}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","summary":"æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…(å‰‘æŒ‡Offer-19) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ç”¨æ¥åŒ¹é…åŒ…å«'.'å’Œ'*'çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ¨¡å¼ä¸­çš„å­—ç¬¦'.'è¡¨ç¤ºä»»æ„ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œ'*'","title":"å‰‘æŒ‡Offer-19 æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æ‰‹æœºå…ˆåƒ\n","permalink":"https://blog.lordash.de/f/gallery/cookbook/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æ‰‹æœºå…ˆåƒ","title":"èœè°±"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ Be water, my friend.\n","permalink":"https://blog.lordash.de/f/gallery/workout/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ Be water, my friend.","title":"é”»ç‚¼"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ MuseScore 3å·²ç»ä¸‹è½½å¥½äº†ï¼Œç­‰æˆ‘æ¬è¿å¥½å§\n","permalink":"https://blog.lordash.de/f/gallery/score/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ MuseScore 3å·²ç»ä¸‹è½½å¥½äº†ï¼Œç­‰æˆ‘æ¬è¿å¥½å§","title":"æ›²è°±"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ å­¦å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€\n","permalink":"https://blog.lordash.de/f/gallery/award/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ å­¦å¦‚é€†æ°´è¡ŒèˆŸï¼Œä¸è¿›åˆ™é€€","title":"è¯ä¹¦"},{"content":"åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹(å‰‘æŒ‡Offer-18) é¢˜é¢ ç»™å®šå•å‘é“¾è¡¨çš„å¤´æŒ‡é’ˆå’Œä¸€ä¸ªè¦åˆ é™¤çš„èŠ‚ç‚¹çš„å€¼ï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°åˆ é™¤è¯¥èŠ‚ç‚¹ã€‚\nè¿”å›åˆ é™¤åçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚\n**æ³¨æ„ï¼š**æ­¤é¢˜å¯¹æ¯”åŸé¢˜æœ‰æ”¹åŠ¨\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: head = [4,5,1,9], val = 5 2è¾“å‡º: [4,1,9] 3è§£é‡Š: ç»™å®šä½ é“¾è¡¨ä¸­å€¼ä¸º 5 çš„ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨äº†ä½ çš„å‡½æ•°ä¹‹åï¼Œè¯¥é“¾è¡¨åº”å˜ä¸º 4 -\u0026gt; 1 -\u0026gt; 9. ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥: head = [4,5,1,9], val = 1 2è¾“å‡º: [4,5,9] 3è§£é‡Š: ç»™å®šä½ é“¾è¡¨ä¸­å€¼ä¸º 1 çš„ç¬¬ä¸‰ä¸ªèŠ‚ç‚¹ï¼Œé‚£ä¹ˆåœ¨è°ƒç”¨äº†ä½ çš„å‡½æ•°ä¹‹åï¼Œè¯¥é“¾è¡¨åº”å˜ä¸º 4 -\u0026gt; 5 -\u0026gt; 9. é™åˆ¶ é¢˜ç›®ä¿è¯é“¾è¡¨ä¸­èŠ‚ç‚¹çš„å€¼äº’ä¸ç›¸åŒ è‹¥ä½¿ç”¨ C æˆ– C++ è¯­è¨€ï¼Œä½ ä¸éœ€è¦ free æˆ– delete è¢«åˆ é™¤çš„èŠ‚ç‚¹ æ€è·¯ ç®€ç®€å•å•åˆ é™¤èŠ‚ç‚¹ã€‚\nä»£ç  1/** 2 * Definition for singly-linked list. 3 * struct ListNode { 4 * int val; 5 * ListNode *next; 6 * ListNode(int x) : val(x), next(NULL) {} 7 * }; 8 */ 9class Solution { 10public: 11 ListNode* deleteNode(ListNode* head, int val) { 12 if(head-\u0026gt;val == val) return head-\u0026gt;next; 13 ListNode *p = head; 14 while(p-\u0026gt;next){ 15 if(p-\u0026gt;next-\u0026gt;val == val){ 16 p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; 17 break; 18 } 19 p = p-\u0026gt;next; 20 } 21 return head; 22 } 23}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹(å‰‘æŒ‡Offer-18) é¢˜é¢ ç»™å®šå•å‘é“¾è¡¨çš„å¤´æŒ‡é’ˆå’Œä¸€ä¸ªè¦åˆ é™¤çš„èŠ‚ç‚¹çš„å€¼ï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°åˆ é™¤è¯¥èŠ‚ç‚¹ã€‚ è¿”å›åˆ é™¤åçš„é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚ **","title":"å‰‘æŒ‡Offer-18 åˆ é™¤é“¾è¡¨çš„èŠ‚ç‚¹"},{"content":"æ‰“å°ä»1åˆ°æœ€å¤§çš„nä½æ•°(å‰‘æŒ‡Offer-17) é¢˜é¢ è¾“å…¥æ•°å­— nï¼ŒæŒ‰é¡ºåºæ‰“å°å‡ºä» 1 åˆ°æœ€å¤§çš„ n ä½åè¿›åˆ¶æ•°ã€‚æ¯”å¦‚è¾“å…¥ 3ï¼Œåˆ™æ‰“å°å‡º 1ã€2ã€3 ä¸€ç›´åˆ°æœ€å¤§çš„ 3 ä½æ•° 999ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: n = 1 2è¾“å‡º: [1,2,3,4,5,6,7,8,9] é™åˆ¶ ç”¨è¿”å›ä¸€ä¸ªæ•´æ•°åˆ—è¡¨æ¥ä»£æ›¿æ‰“å° n ä¸ºæ­£æ•´æ•° æ€è·¯ ç®€ç®€å•å•forå¾ªç¯ã€‚\nä»£ç  1class Solution { 2 int pow(int a, int b){ 3 int res = 1; 4 while(b){ 5 if(b\u0026amp;1) res*=a; 6 a *= a; 7 b \u0026gt;\u0026gt;= 1; 8 } 9 return res; 10 } 11public: 12 vector\u0026lt;int\u0026gt; printNumbers(int n) { 13 int last = pow(10,n)-1; 14 vector\u0026lt;int\u0026gt; ans(last); 15 for(int i=0; i\u0026lt;last; i++){ 16 ans[i] = i+1; 17 } 18 return ans; 19 } 20}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","summary":"æ‰“å°ä»1åˆ°æœ€å¤§çš„nä½æ•°(å‰‘æŒ‡Offer-17) é¢˜é¢ è¾“å…¥æ•°å­— nï¼ŒæŒ‰é¡ºåºæ‰“å°å‡ºä» 1 åˆ°æœ€å¤§çš„ n ä½åè¿›åˆ¶æ•°ã€‚æ¯”å¦‚è¾“å…¥ 3ï¼Œåˆ™æ‰“å°å‡º 1ã€2ã€3 ä¸€ç›´åˆ°æœ€å¤§","title":"å‰‘æŒ‡Offer-17 æ‰“å°ä»1åˆ°æœ€å¤§çš„nä½æ•°"},{"content":"äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(å‰‘æŒ‡Offer-16) é¢˜é¢ å®ç° pow(x, n) ï¼Œå³è®¡ç®— x çš„ n æ¬¡å¹‚å‡½æ•°ï¼ˆå³ï¼Œxnï¼‰ã€‚ä¸å¾—ä½¿ç”¨åº“å‡½æ•°ï¼ŒåŒæ—¶ä¸éœ€è¦è€ƒè™‘å¤§æ•°é—®é¢˜ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šx = 2.00000, n = 10 2è¾“å‡ºï¼š1024.00000 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šx = 2.10000, n = 3 2è¾“å‡ºï¼š9.26100 ç¤ºä¾‹ 3ï¼š\n1è¾“å…¥ï¼šx = 2.00000, n = -2 2è¾“å‡ºï¼š0.25000 3è§£é‡Šï¼š2-2 = 1/22 = 1/4 = 0.25 é™åˆ¶ -100.0 \u0026lt; x \u0026lt; 100.0 -2^31 \u0026lt;= n \u0026lt;= 2^31-1 -10^4 \u0026lt;= x^n \u0026lt;= 10^4 æ€è·¯ ç®€ç®€å•å•å¿«é€Ÿå¹‚ã€‚\nä»£ç  1class Solution { 2public: 3 double myPow(double x, int n) { 4 double res = 1.0; 5 long long m = n; 6 if(m\u0026lt;0){ 7 m=-m; x=1.0/x; 8 } 9 while(m){ 10 if(m\u0026amp;1) 11 res = res*x; 12 x = x*x; 13 m \u0026gt;\u0026gt;= 1; 14 } 15 return res; 16 } 17}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","summary":"äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(å‰‘æŒ‡Offer-16) é¢˜é¢ å®ç° pow(x, n) ï¼Œå³è®¡ç®— x çš„ n æ¬¡å¹‚å‡½æ•°ï¼ˆå³ï¼Œxnï¼‰ã€‚ä¸å¾—ä½¿ç”¨åº“å‡½æ•°ï¼ŒåŒæ—¶ä¸éœ€è¦è€ƒè™‘å¤§æ•°é—®é¢˜ã€‚ ç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š","title":"å‰‘æŒ‡Offer-16 æ•°å€¼çš„æ•´æ•°æ¬¡æ–¹"},{"content":"äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(å‰‘æŒ‡Offer-15) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼ˆä»¥äºŒè¿›åˆ¶ä¸²å½¢å¼ï¼‰ï¼Œè¾“å‡ºè¯¥æ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼ŒæŠŠ 9 è¡¨ç¤ºæˆäºŒè¿›åˆ¶æ˜¯ 1001ï¼Œæœ‰ 2 ä½æ˜¯ 1ã€‚å› æ­¤ï¼Œå¦‚æœè¾“å…¥ 9ï¼Œåˆ™è¯¥å‡½æ•°è¾“å‡º 2ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼š00000000000000000000000000001011 2è¾“å‡ºï¼š3 3è§£é‡Šï¼šè¾“å…¥çš„äºŒè¿›åˆ¶ä¸² 00000000000000000000000000001011 ä¸­ï¼Œå…±æœ‰ä¸‰ä½ä¸º \u0026#39;1\u0026#39;ã€‚ ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼š00000000000000000000000010000000 2è¾“å‡ºï¼š1 3è§£é‡Šï¼šè¾“å…¥çš„äºŒè¿›åˆ¶ä¸² 00000000000000000000000010000000 ä¸­ï¼Œå…±æœ‰ä¸€ä½ä¸º \u0026#39;1\u0026#39;ã€‚ ç¤ºä¾‹ 3ï¼š\n1 è¾“å…¥ï¼š11111111111111111111111111111101 2 è¾“å‡ºï¼š31 3 è§£é‡Šï¼šè¾“å…¥çš„äºŒè¿›åˆ¶ä¸² 11111111111111111111111111111101 ä¸­ï¼Œå…±æœ‰ 31 ä½ä¸º \u0026#39;1\u0026#39;ã€‚ é™åˆ¶ 1è¾“å…¥å¿…é¡»æ˜¯é•¿åº¦ä¸º 32 çš„ äºŒè¿›åˆ¶ä¸² ã€‚ æ€è·¯ n \u0026amp;= (n-1) ä½¿næœ€åä¸€ä½1å˜æˆ0ã€‚\nä»£ç  1class Solution { 2public: 3 int hammingWeight(uint32_t n) { 4 int res = 0; 5 while(n){ 6 res ++; 7 n \u0026amp;= n-1; 8 } 9 return res; 10 } 11}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","summary":"äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°(å‰‘æŒ‡Offer-15) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼ˆä»¥äºŒè¿›åˆ¶ä¸²å½¢å¼ï¼‰ï¼Œè¾“å‡ºè¯¥æ•°äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼ŒæŠŠ 9 è¡¨ç¤ºæˆäºŒ","title":"å‰‘æŒ‡Offer-15 äºŒè¿›åˆ¶ä¸­1çš„ä¸ªæ•°"},{"content":"å‰ªç»³å­II(å‰‘æŒ‡Offer-14.2) é¢˜é¢ ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn\u0026gt;1å¹¶ä¸”m\u0026gt;1ï¼‰ï¼Œæ¯æ®µç»³å­çš„é•¿åº¦è®°ä¸º k[0],k[1]...k[m-1] ã€‚è¯·é—® k[0]*k[1]*...*k[m-1] å¯èƒ½çš„æœ€å¤§ä¹˜ç§¯æ˜¯å¤šå°‘ï¼Ÿä¾‹å¦‚ï¼Œå½“ç»³å­çš„é•¿åº¦æ˜¯8æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå‰ªæˆé•¿åº¦åˆ†åˆ«ä¸º2ã€3ã€3çš„ä¸‰æ®µï¼Œæ­¤æ—¶å¾—åˆ°çš„æœ€å¤§ä¹˜ç§¯æ˜¯18ã€‚\nç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7ï¼ˆ1000000007ï¼‰ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: 2 2è¾“å‡º: 1 3è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥: 10 2è¾“å‡º: 36 3è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36 é™åˆ¶ 12 \u0026lt;= n \u0026lt;= 1000 æ€è·¯ åŒä¸Šé¢˜ï¼Œå–ä¸ªæ¨¡ã€‚\nä»£ç  1class Solution { 2 long long fpow(long long a, long long b, long long mod){ 3 long long res = 1; 4 while(b){ 5 if(b\u0026amp;1) 6 res = res * a % mod; 7 a = a * a % mod; 8 b \u0026gt;\u0026gt;= 1; 9 } 10 return res % mod; 11 } 12public: 13 int cuttingRope(int n) { 14 if(n \u0026lt;= 3) return n-1; 15 int mod = 1000000007; 16 if(n % 3 == 0) return fpow(3, n/3, mod) % mod; 17 if(n % 3 == 1) return fpow(3, n/3-1, mod) * 4 % mod; 18 return fpow(3, n/3, mod) * 2 % mod; 19 } 20}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-14.2-%E5%89%AA%E7%BB%B3%E5%AD%90ii/","summary":"å‰ªç»³å­II(å‰‘æŒ‡Offer-14.2) é¢˜é¢ ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn\u0026gt;1å¹¶ä¸”m\u0026gt;1ï¼‰","title":"å‰‘æŒ‡Offer-14.2 å‰ªç»³å­II"},{"content":"å‰ªç»³å­(å‰‘æŒ‡Offer-14.1) é¢˜é¢ ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn\u0026gt;1å¹¶ä¸”m\u0026gt;1ï¼‰ï¼Œæ¯æ®µç»³å­çš„é•¿åº¦è®°ä¸º k[0],k[1]...k[m-1] ã€‚è¯·é—® k[0]*k[1]*...*k[m-1] å¯èƒ½çš„æœ€å¤§ä¹˜ç§¯æ˜¯å¤šå°‘ï¼Ÿä¾‹å¦‚ï¼Œå½“ç»³å­çš„é•¿åº¦æ˜¯8æ—¶ï¼Œæˆ‘ä»¬æŠŠå®ƒå‰ªæˆé•¿åº¦åˆ†åˆ«ä¸º2ã€3ã€3çš„ä¸‰æ®µï¼Œæ­¤æ—¶å¾—åˆ°çš„æœ€å¤§ä¹˜ç§¯æ˜¯18ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥: 2 2è¾“å‡º: 1 3è§£é‡Š: 2 = 1 + 1, 1 Ã— 1 = 1 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥: 10 2è¾“å‡º: 36 3è§£é‡Š: 10 = 3 + 3 + 4, 3 Ã— 3 Ã— 4 = 36 é™åˆ¶ 12 \u0026lt;= n \u0026lt;= 58 æ€è·¯ å°½é‡åˆ†æˆé•¿åº¦ä¸º3çš„æ®µï¼Œè¯æ˜æ€è·¯\nä»£ç  1class Solution { 2 long long fpow(long long a, long long b){ 3 long long res = 1; 4 while(b){ 5 if(b\u0026amp;1) 6 res *= a; 7 a *= a; 8 b \u0026gt;\u0026gt;= 1; 9 } 10 return res; 11 } 12public: 13 int cuttingRope(int n) { 14 if(n \u0026lt;= 3) return n-1; 15 if(n % 3 == 0) return fpow(3, n/3); 16 if(n % 3 == 1) return fpow(3, n/3-1)*4; 17 return fpow(3, n/3)*2; 18 } 19}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-14.1-%E5%89%AA%E7%BB%B3%E5%AD%90/","summary":"å‰ªç»³å­(å‰‘æŒ‡Offer-14.1) é¢˜é¢ ç»™ä½ ä¸€æ ¹é•¿åº¦ä¸º n çš„ç»³å­ï¼Œè¯·æŠŠç»³å­å‰ªæˆæ•´æ•°é•¿åº¦çš„ m æ®µï¼ˆmã€néƒ½æ˜¯æ•´æ•°ï¼Œn\u0026gt;1å¹¶ä¸”m\u0026gt;1ï¼‰ï¼Œæ¯","title":"å‰‘æŒ‡Offer-14.1 å‰ªç»³å­"},{"content":"æœºå™¨äººçš„è¿åŠ¨èŒƒå›´(å‰‘æŒ‡Offer-13) é¢˜é¢ åœ°ä¸Šæœ‰ä¸€ä¸ªmè¡Œnåˆ—çš„æ–¹æ ¼ï¼Œä»åæ ‡ [0,0] åˆ°åæ ‡ [m-1,n-1] ã€‚ä¸€ä¸ªæœºå™¨äººä»åæ ‡ [0, 0] çš„æ ¼å­å¼€å§‹ç§»åŠ¨ï¼Œå®ƒæ¯æ¬¡å¯ä»¥å‘å·¦ã€å³ã€ä¸Šã€ä¸‹ç§»åŠ¨ä¸€æ ¼ï¼ˆä¸èƒ½ç§»åŠ¨åˆ°æ–¹æ ¼å¤–ï¼‰ï¼Œä¹Ÿä¸èƒ½è¿›å…¥è¡Œåæ ‡å’Œåˆ—åæ ‡çš„æ•°ä½ä¹‹å’Œå¤§äºkçš„æ ¼å­ã€‚ä¾‹å¦‚ï¼Œå½“kä¸º18æ—¶ï¼Œæœºå™¨äººèƒ½å¤Ÿè¿›å…¥æ–¹æ ¼ [35, 37] ï¼Œå› ä¸º3+5+3+7=18ã€‚ä½†å®ƒä¸èƒ½è¿›å…¥æ–¹æ ¼ [35, 38]ï¼Œå› ä¸º3+5+3+8=19ã€‚è¯·é—®è¯¥æœºå™¨äººèƒ½å¤Ÿåˆ°è¾¾å¤šå°‘ä¸ªæ ¼å­ï¼Ÿ\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šm = 2, n = 3, k = 1 2è¾“å‡ºï¼š3 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šm = 2, n = 3, k = 1 2è¾“å‡ºï¼š3 é™åˆ¶ 1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20 æ€è·¯ BFSå³å¯\nä»£ç  1class Solution { 2public: 3 int movingCount(int m, int n, int k) { 4 if(!k) return 1; 5 vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; vis(m, vector\u0026lt;int\u0026gt;(n, 0)); 6 7 queue\u0026lt;pair\u0026lt;int,int\u0026gt; \u0026gt; q; 8 q.push({0,0}); 9 10 int dx[2] = {0, 1}, dy[2] = {1, 0}; 11 int ans = vis[0][0] = 1; 12 13 while(!q.empty()){ 14 auto [x, y] = q.front(); 15 q.pop(); 16 17 for(int i=0; i\u0026lt;2; i++){ 18 int tx = dx[i]+x, ty = dy[i]+y; 19 if(tx\u0026lt;0 || tx\u0026gt;=m || ty\u0026lt;0 || ty\u0026gt;=n || vis[tx][ty] || get(tx)+get(ty)\u0026gt;k) 20 continue; 21 q.push({tx, ty}); 22 vis[tx][ty] = 1; 23 ans++; 24 } 25 } 26 return ans; 27 } 28private: 29 int get(int x){ 30 int t = 0; 31 while(x){ 32 t += x % 10; 33 x /= 10; 34 } 35 return t; 36 } 37}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","summary":"æœºå™¨äººçš„è¿åŠ¨èŒƒå›´(å‰‘æŒ‡Offer-13) é¢˜é¢ åœ°ä¸Šæœ‰ä¸€ä¸ªmè¡Œnåˆ—çš„æ–¹æ ¼ï¼Œä»åæ ‡ [0,0] åˆ°åæ ‡ [m-1,n-1] ã€‚ä¸€ä¸ªæœºå™¨äººä»åæ ‡ [0, 0] çš„æ ¼å­å¼€å§‹ç§»åŠ¨ï¼Œå®ƒæ¯æ¬¡å¯ä»¥å‘å·¦ã€","title":"å‰‘æŒ‡Offer-13 æœºå™¨äººçš„è¿åŠ¨èŒƒå›´"},{"content":"çŸ©é˜µä¸­çš„è·¯å¾„(å‰‘æŒ‡Offer-12) é¢˜é¢ è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚è·¯å¾„å¯ä»¥ä»çŸ©é˜µä¸­çš„ä»»æ„ä¸€æ ¼å¼€å§‹ï¼Œæ¯ä¸€æ­¥å¯ä»¥åœ¨çŸ©é˜µä¸­å‘å·¦ã€å³ã€ä¸Šã€ä¸‹ç§»åŠ¨ä¸€æ ¼ã€‚å¦‚æœä¸€æ¡è·¯å¾„ç»è¿‡äº†çŸ©é˜µçš„æŸä¸€æ ¼ï¼Œé‚£ä¹ˆè¯¥è·¯å¾„ä¸èƒ½å†æ¬¡è¿›å…¥è¯¥æ ¼å­ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸‹é¢çš„3Ã—4çš„çŸ©é˜µä¸­åŒ…å«ä¸€æ¡å­—ç¬¦ä¸²â€œbfceâ€çš„è·¯å¾„ï¼ˆè·¯å¾„ä¸­çš„å­—æ¯ç”¨åŠ ç²—æ ‡å‡ºï¼‰ã€‚\n[[a,b,c,e], [s,f,c,s], [a,d,e,e]]\nä½†çŸ©é˜µä¸­ä¸åŒ…å«å­—ç¬¦ä¸²â€œabfbâ€çš„è·¯å¾„ï¼Œå› ä¸ºå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦bå æ®äº†çŸ©é˜µä¸­çš„ç¬¬ä¸€è¡Œç¬¬äºŒä¸ªæ ¼å­ä¹‹åï¼Œè·¯å¾„ä¸èƒ½å†æ¬¡è¿›å…¥è¿™ä¸ªæ ¼å­ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šboard = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCCED\u0026#34; 2è¾“å‡ºï¼štrue ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šboard = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;]], word = \u0026#34;abcd\u0026#34; 2è¾“å‡ºï¼šfalse é™åˆ¶ 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 æ€è·¯ dfså³å¯ã€‚\nä»£ç  1class Solution { 2public: 3 bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { 4 n = board.size(); 5 if(n \u0026lt;= 0) return false; 6 7 m = board[0].size(); 8 if(m \u0026lt;= 0) return false; 9 10 for(int i=0; i\u0026lt;n; i++){ 11 for(int j=0; j\u0026lt;m; j++){ 12 if(dfs(board, word, i, j, 0)) 13 return true; 14 } 15 } 16 return false; 17 } 18private: 19 int n, m; 20 bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word, int i, int j, int k){ 21 if(i\u0026lt;0 || i\u0026gt;=n || j\u0026lt;0 || j\u0026gt;=m || board[i][j]!=word[k]) return false; 22 if(k == word.size()-1) return true; 23 24 board[i][j] = \u0026#39;\\0\u0026#39;; 25 bool ans = dfs(board, word, i+1, j, k+1) || dfs(board, word, i, j+1, k+1) || 26 dfs(board, word, i-1, j, k+1) || dfs(board, word, i, j-1, k+1); 27 board[i][j] = word[k]; 28 return ans; 29 } 30}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","summary":"çŸ©é˜µä¸­çš„è·¯å¾„(å‰‘æŒ‡Offer-12) é¢˜é¢ è¯·è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨æ¥åˆ¤æ–­åœ¨ä¸€ä¸ªçŸ©é˜µä¸­æ˜¯å¦å­˜åœ¨ä¸€æ¡åŒ…å«æŸå­—ç¬¦ä¸²æ‰€æœ‰å­—ç¬¦çš„è·¯å¾„ã€‚è·¯å¾„å¯ä»¥ä»çŸ©é˜µä¸­çš„ä»»æ„ä¸€","title":"å‰‘æŒ‡Offer-12 çŸ©é˜µä¸­çš„è·¯å¾„"},{"content":"æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—(å‰‘æŒ‡Offer-11) é¢˜é¢ æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚è¾“å…¥ä¸€ä¸ªé€’å¢æ’åºçš„æ•°ç»„çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¾“å‡ºæ—‹è½¬æ•°ç»„çš„æœ€å°å…ƒç´ ã€‚ä¾‹å¦‚ï¼Œæ•°ç»„[3,4,5,1,2] ä¸º[1,2,3,4,5] çš„ä¸€ä¸ªæ—‹è½¬ï¼Œè¯¥æ•°ç»„çš„æœ€å°å€¼ä¸º1ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼š[3,4,5,1,2] 2è¾“å‡ºï¼š1 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼š[2,2,2,0,1] 2è¾“å‡ºï¼š0 é™åˆ¶ æ— \næ€è·¯ äºŒåˆ†ï¼Œnumbers[mid]ä¸numbers[r]æ¯”è¾ƒã€‚\næ— æ³•ä¸å·¦ç«¯ç‚¹æ¯”è¾ƒè¿›è¡ŒäºŒåˆ†ï¼Œå½“i=0, j=4, mid=2æ—¶ï¼Œä»¥ä¸‹æƒ…å†µéƒ½æœ‰ numbers[mid] \u0026gt; numbers[l]ï¼Œè€Œç»“æœä¸åŒã€‚ [1,2,3,4,5]ï¼Œ ç­”æ¡ˆx=0åœ¨midå·¦ä¾§ã€‚ [3,4,5,1,2] ï¼Œç­”æ¡ˆx=1åœ¨midå³ä¾§ã€‚\nä»£ç  1class Solution { 2public: 3 int minArray(vector\u0026lt;int\u0026gt;\u0026amp; numbers) { 4 int l = 0, r = numbers.size()-1; 5 while(l \u0026lt; r){ 6 int mid = (l + r) / 2; 7 if(numbers[mid] \u0026lt; numbers[r]){ 8 r = mid; 9 }else if(numbers[mid] \u0026gt; numbers[r]){ 10 l = mid + 1; 11 }else{ 12 r = r - 1; 13 } 14 } 15 return numbers[l]; 16 } 17}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","summary":"æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—(å‰‘æŒ‡Offer-11) é¢˜é¢ æŠŠä¸€ä¸ªæ•°ç»„æœ€å¼€å§‹çš„è‹¥å¹²ä¸ªå…ƒç´ æ¬åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ•°ç»„çš„æ—‹è½¬ã€‚è¾“å…¥ä¸€ä¸ªé€’å¢æ’åºçš„æ•°ç»„çš„ä¸€ä¸ª","title":"å‰‘æŒ‡Offer-11 æ—‹è½¬æ•°ç»„çš„æœ€å°æ•°å­—"},{"content":"é’è›™è·³å°é˜¶é—®é¢˜(å‰‘æŒ‡Offer-10.2) é¢˜é¢ ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§å°é˜¶ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ª n çº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ã€‚\nç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7ï¼ˆ1000000007ï¼‰ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šn = 2 2è¾“å‡ºï¼š2 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šn = 7 2è¾“å‡ºï¼š21 ç¤ºä¾‹ 3ï¼š\n1è¾“å…¥ï¼šn = 0 2è¾“å‡ºï¼š1 é™åˆ¶ 10 \u0026lt;= n \u0026lt;= 100 æ€è·¯ åŒã€é¢˜è§£ã€‘å‰‘æŒ‡Offer-10.1 æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œåˆå§‹å€¼ä¸åŒï¼Œç®€å•Fibonaccié€’æ¨ã€‚\nä»£ç  1class Solution { 2public: 3 int numWays(int n) { 4 int a[105] = {1, 1, 2}; 5 for(int i=3; i\u0026lt;=100; i++) 6 a[i] = (a[i-1] + a[i-2]) % 1000000007; 7 return a[n]; 8 } 9}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-10.2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","summary":"é’è›™è·³å°é˜¶é—®é¢˜(å‰‘æŒ‡Offer-10.2) é¢˜é¢ ä¸€åªé’è›™ä¸€æ¬¡å¯ä»¥è·³ä¸Š1çº§å°é˜¶ï¼Œä¹Ÿå¯ä»¥è·³ä¸Š2çº§å°é˜¶ã€‚æ±‚è¯¥é’è›™è·³ä¸Šä¸€ä¸ª n çº§çš„å°é˜¶æ€»å…±æœ‰å¤šå°‘ç§è·³æ³•ã€‚","title":"å‰‘æŒ‡Offer-10.2 é’è›™è·³å°é˜¶é—®é¢˜"},{"content":"æ–æ³¢é‚£å¥‘æ•°åˆ—(å‰‘æŒ‡Offer-10.1) é¢˜é¢ å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ n ï¼Œæ±‚æ–æ³¢é‚£å¥‘ï¼ˆFibonacciï¼‰æ•°åˆ—çš„ç¬¬ n é¡¹ï¼ˆå³ F(N)ï¼‰ã€‚æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å®šä¹‰å¦‚ä¸‹ï¼š\n1F(0) = 0, F(1) = 1 2F(N) = F(N - 1) + F(N - 2), å…¶ä¸­ N \u0026gt; 1. æ–æ³¢é‚£å¥‘æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œä¹‹åçš„æ–æ³¢é‚£å¥‘æ•°å°±æ˜¯ç”±ä¹‹å‰çš„ä¸¤æ•°ç›¸åŠ è€Œå¾—å‡ºã€‚\nç­”æ¡ˆéœ€è¦å–æ¨¡ 1e9+7ï¼ˆ1000000007ï¼‰ï¼Œå¦‚è®¡ç®—åˆå§‹ç»“æœä¸ºï¼š1000000008ï¼Œè¯·è¿”å› 1ã€‚\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼šn = 2 2è¾“å‡ºï¼š1 ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼šn = 5 2è¾“å‡ºï¼š5 é™åˆ¶ 10 \u0026lt;= n \u0026lt;= 100 æ€è·¯ ç®€å•Fibonaccié€’æ¨ã€‚\nä»£ç  1class Solution { 2public: 3 int fib(int n) { 4 int a[105] = {0, 1, 1}; 5 for(int i=3; i\u0026lt;=100; i++) 6 a[i] = (a[i-1] + a[i-2]) % 1000000007; 7 return a[n]; 8 } 9}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-10.1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","summary":"æ–æ³¢é‚£å¥‘æ•°åˆ—(å‰‘æŒ‡Offer-10.1) é¢˜é¢ å†™ä¸€ä¸ªå‡½æ•°ï¼Œè¾“å…¥ n ï¼Œæ±‚æ–æ³¢é‚£å¥‘ï¼ˆFibonacciï¼‰æ•°åˆ—çš„ç¬¬ n é¡¹ï¼ˆå³ F(N)ï¼‰ã€‚æ–æ³¢é‚£å¥‘æ•°åˆ—çš„å®š","title":"å‰‘æŒ‡Offer-10.1 æ–æ³¢é‚£å¥‘æ•°åˆ—"},{"content":"ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—(å‰‘æŒ‡Offer-09) é¢˜é¢ ç”¨ä¸¤ä¸ªæ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—ã€‚é˜Ÿåˆ—çš„å£°æ˜å¦‚ä¸‹ï¼Œè¯·å®ç°å®ƒçš„ä¸¤ä¸ªå‡½æ•° appendTail å’Œ deleteHead ï¼Œåˆ†åˆ«å®Œæˆåœ¨é˜Ÿåˆ—å°¾éƒ¨æ’å…¥æ•´æ•°å’Œåœ¨é˜Ÿåˆ—å¤´éƒ¨åˆ é™¤æ•´æ•°çš„åŠŸèƒ½ã€‚(è‹¥é˜Ÿåˆ—ä¸­æ²¡æœ‰å…ƒç´ ï¼ŒdeleteHead æ“ä½œè¿”å› -1 )\nç¤ºä¾‹ ç¤ºä¾‹ 1ï¼š\n1è¾“å…¥ï¼š 2[\u0026#34;CQueue\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;deleteHead\u0026#34;] 3[[],[3],[],[]] 4è¾“å‡ºï¼š[null,null,3,-1] ç¤ºä¾‹ 2ï¼š\n1è¾“å…¥ï¼š 2[\u0026#34;CQueue\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;deleteHead\u0026#34;] 3[[],[],[5],[2],[],[]] 4è¾“å‡ºï¼š[null,-1,null,null,5,2] é™åˆ¶ 11 \u0026lt;= values \u0026lt;= 10000 2æœ€å¤šä¼šå¯¹ appendTailã€deleteHead è¿›è¡Œ 10000 æ¬¡è°ƒç”¨ æ€è·¯ ä½¿ç”¨ä¸¤ä¸ªæ ˆæ¨¡æ‹Ÿé˜Ÿåˆ—ï¼Œst1åªè´Ÿè´£ç»´æŠ¤æ’å…¥ï¼Œå½“éœ€è¦åˆ é™¤æ—¶ï¼Œä¸ºäº†ç»´æŠ¤é˜Ÿåˆ—çš„å…ˆå…¥å…ˆå‡ºï¼Œéœ€è¦å…ˆå°†st1é‡Œçš„æ•°æ®å€’å…¥ç©ºçš„st2ï¼Œæ­¤æ—¶st2çš„æ ˆé¡¶ç›¸å½“äºé˜Ÿåˆ—å¤´ã€‚æ³¨æ„st2æœªç©ºæ—¶ï¼Œä¸å¯å€’å…¥st1çš„æ•°æ®ï¼Œä¼šæ‰“ä¹±é¡ºåºï¼Œåº”å½“ç›´æ¥å¼¹å‡ºã€‚\nä»£ç  1class CQueue { 2public: 3 stack\u0026lt;int\u0026gt; st1, st2; 4 CQueue() { 5 while(!st1.empty()) st1.pop(); 6 while(!st2.empty()) st2.pop(); 7 } 8 9 void appendTail(int value) { 10 st1.push(value); 11 } 12 13 int deleteHead() { 14 if(st2.empty()){ 15 while(!st1.empty()){ 16 st2.push(st1.top()); 17 st1.pop(); 18 } 19 } 20 if(!st2.empty()){ 21 int ans = st2.top(); 22 st2.pop(); 23 return ans; 24 }else{ 25 return -1; 26 } 27 } 28}; 29 30/** 31 * Your CQueue object will be instantiated and called as such: 32 * CQueue* obj = new CQueue(); 33 * obj-\u0026gt;appendTail(value); 34 * int param_2 = obj-\u0026gt;deleteHead(); 35 */ ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","summary":"ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—(å‰‘æŒ‡Offer-09) é¢˜é¢ ç”¨ä¸¤ä¸ªæ ˆå®ç°ä¸€ä¸ªé˜Ÿåˆ—ã€‚é˜Ÿåˆ—çš„å£°æ˜å¦‚ä¸‹ï¼Œè¯·å®ç°å®ƒçš„ä¸¤ä¸ªå‡½æ•° appendTail å’Œ deleteHead ï¼Œåˆ†åˆ«å®Œæˆåœ¨é˜Ÿåˆ—å°¾éƒ¨æ’å…¥æ•´æ•°å’Œåœ¨é˜Ÿ","title":"å‰‘æŒ‡Offer-09 ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—"},{"content":"é‡å»ºäºŒå‰æ ‘(å‰‘æŒ‡Offer-07) é¢˜é¢ è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤çš„æ•°å­—ã€‚\nç¤ºä¾‹ ä¾‹å¦‚ï¼Œç»™å‡º\n1å‰åºéå† preorder = [3,9,20,15,7] 2ä¸­åºéå† inorder = [9,3,15,20,7] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š\n3 / \\ 9 20 / \\ 15 7 é™åˆ¶ 10 \u0026lt;= èŠ‚ç‚¹ä¸ªæ•° \u0026lt;= 5000 æ€è·¯ ç»å…¸é¢˜ï¼Œç»™å‡ºå…ˆåºä¸­åºå»ºæ ‘ã€‚\nä»£ç  1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode(int x) : val(x), left(NULL), right(NULL) {} 8 * }; 9 */ 10class Solution { 11public: 12 TreeNode* solve(int l, int r, int rt, vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder){ 13 if(l \u0026gt; r) return NULL; 14 int i=l; 15 while(inorder[i]!=preorder[rt]) i++; 16 TreeNode *p = new TreeNode(preorder[rt]); 17 p-\u0026gt;left = solve(l, i-1, rt+1, preorder, inorder); 18 p-\u0026gt;right = solve(i+1, r, rt+1+i-l, preorder, inorder); 19 return p; 20 } 21 TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { 22 if(preorder.size() == 0) return NULL; 23 return solve(0, preorder.size()-1, 0, preorder, inorder); 24 } 25}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"é‡å»ºäºŒå‰æ ‘(å‰‘æŒ‡Offer-07) é¢˜é¢ è¾“å…¥æŸäºŒå‰æ ‘çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœï¼Œè¯·é‡å»ºè¯¥äºŒå‰æ ‘ã€‚å‡è®¾è¾“å…¥çš„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¸­éƒ½ä¸å«é‡å¤","title":"å‰‘æŒ‡Offer-07 é‡å»ºäºŒå‰æ ‘"},{"content":"ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨(å‰‘æŒ‡Offer-06) é¢˜é¢ è¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œä»å°¾åˆ°å¤´åè¿‡æ¥è¿”å›æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆç”¨æ•°ç»„è¿”å›ï¼‰ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼šhead = [1,3,2] 2è¾“å‡ºï¼š[2,3,1] é™åˆ¶ 10 \u0026lt;= é“¾è¡¨é•¿åº¦ \u0026lt;= 10000 æ€è·¯ ç®€å•éå†é“¾è¡¨ï¼Œç„¶åreverseä¸€ä¸‹å°±å¥½ã€‚\nä»£ç  1/** 2 * Definition for singly-linked list. 3 * struct ListNode { 4 * int val; 5 * ListNode *next; 6 * ListNode(int x) : val(x), next(NULL) {} 7 * }; 8 */ 9class Solution { 10public: 11 vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { 12 vector\u0026lt;int\u0026gt; v; 13 ListNode *p = head; 14 15 while(p != NULL){ 16 v.push_back(p-\u0026gt;val); 17 p = p-\u0026gt;next; 18 } 19 20 reverse(v.begin(), v.end()); 21 return v; 22 } 23}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","summary":"ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨(å‰‘æŒ‡Offer-06) é¢˜é¢ è¾“å…¥ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ï¼Œä»å°¾åˆ°å¤´åè¿‡æ¥è¿”å›æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆç”¨æ•°ç»„è¿”å›ï¼‰ã€‚ ç¤ºä¾‹ 1è¾“å…¥ï¼šhead = [1,3,2] 2è¾“","title":"å‰‘æŒ‡Offer-06 ä»å°¾åˆ°å¤´æ‰“å°é“¾è¡¨"},{"content":"æ›¿æ¢ç©ºæ ¼(å‰‘æŒ‡Offer-05) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼ŒæŠŠå­—ç¬¦ä¸² s ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆ\u0026quot;%20\u0026quot;ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼šs = \u0026#34;We are happy.\u0026#34; 2è¾“å‡ºï¼š\u0026#34;We%20are%20happy.\u0026#34; é™åˆ¶ 10 \u0026lt;= s çš„é•¿åº¦ \u0026lt;= 10000 æ€è·¯ resizeä¸€ä¸‹ï¼Œç„¶ååŒæŒ‡é’ˆé€†åºéå†ã€‚\nä»£ç  1class Solution { 2public: 3 string replaceSpace(string s) { 4 int count = 0, len = s.size(); 5 for (char c : s) 6 count += (c == \u0026#39; \u0026#39;); 7 8 s.resize(len + 2 * count); 9 10 for(int i=len-1, j=s.size()-1; i\u0026lt;j; i--, j--) { 11 if (s[i] != \u0026#39; \u0026#39;) 12 s[j] = s[i]; 13 else { 14 s[j-2]=\u0026#39;%\u0026#39;, s[j-1]=\u0026#39;2\u0026#39;, s[j]=\u0026#39;0\u0026#39;; 15 j -= 2; 16 } 17 } 18 return s; 19 } 20}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","summary":"æ›¿æ¢ç©ºæ ¼(å‰‘æŒ‡Offer-05) é¢˜é¢ è¯·å®ç°ä¸€ä¸ªå‡½æ•°ï¼ŒæŠŠå­—ç¬¦ä¸² s ä¸­çš„æ¯ä¸ªç©ºæ ¼æ›¿æ¢æˆ\u0026quot;%20\u0026quot;ã€‚ ç¤ºä¾‹ 1è¾“å…¥ï¼šs = \u0026#34;We are happy.\u0026#34; 2è¾“å‡º","title":"å‰‘æŒ‡Offer-05 æ›¿æ¢ç©ºæ ¼"},{"content":"äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾(å‰‘æŒ‡Offer-04) é¢˜é¢ åœ¨ä¸€ä¸ª n * m çš„äºŒç»´æ•°ç»„ä¸­ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»å·¦åˆ°å³é€’å¢çš„é¡ºåºæ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹é€’å¢çš„é¡ºåºæ’åºã€‚è¯·å®Œæˆä¸€ä¸ªé«˜æ•ˆçš„å‡½æ•°ï¼Œè¾“å…¥è¿™æ ·çš„ä¸€ä¸ªäºŒç»´æ•°ç»„å’Œä¸€ä¸ªæ•´æ•°ï¼Œåˆ¤æ–­æ•°ç»„ä¸­æ˜¯å¦å«æœ‰è¯¥æ•´æ•°ã€‚\nç¤ºä¾‹ ç°æœ‰çŸ©é˜µ matrix å¦‚ä¸‹ï¼š\n1[ 2 [1, 4, 7, 11, 15], 3 [2, 5, 8, 12, 19], 4 [3, 6, 9, 16, 22], 5 [10, 13, 14, 17, 24], 6 [18, 21, 23, 26, 30] 7] ç»™å®š target = 5ï¼Œè¿”å› trueã€‚\nç»™å®š target = 20ï¼Œè¿”å› falseã€‚\né™åˆ¶ 10 \u0026lt;= n \u0026lt;= 1000 20 \u0026lt;= m \u0026lt;= 1000 æ€è·¯ ä»å³ä¸Šè‡³å·¦ä¸‹æ‰¾ï¼ˆæˆ–å·¦ä¸‹è‡³å³ä¸Šï¼‰ï¼Œæ¯æ¬¡éƒ½èƒ½ä½¿æŸ¥æ‰¾èŒƒå›´å‡å°‘ä¸€è¡Œæˆ–ä¸€åˆ—ã€‚æ—¶é—´å¤æ‚åº¦O(n+m)ã€‚\nä»£ç  1class Solution { 2public: 3 bool findNumberIn2DArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { 4 int n = matrix.size(); 5 if(n\u0026lt;=0) return false; 6 int m = matrix[0].size(); 7 if(m\u0026lt;=0) return false; 8 9 int i=0, j=m-1; 10 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026gt;=0) { 11 if(matrix[i][j] \u0026lt; target) 12 i++; 13 else if(matrix[i][j] \u0026gt; target) 14 j--; 15 else 16 return true; 17 } 18 return false; 19 } 20}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","summary":"äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾(å‰‘æŒ‡Offer-04) é¢˜é¢ åœ¨ä¸€ä¸ª n * m çš„äºŒç»´æ•°ç»„ä¸­ï¼Œæ¯ä¸€è¡Œéƒ½æŒ‰ç…§ä»å·¦åˆ°å³é€’å¢çš„é¡ºåºæ’åºï¼Œæ¯ä¸€åˆ—éƒ½æŒ‰ç…§ä»ä¸Šåˆ°ä¸‹é€’å¢çš„é¡ºåºæ’åº","title":"å‰‘æŒ‡Offer-04 äºŒç»´æ•°ç»„ä¸­çš„æŸ¥æ‰¾"},{"content":"æ•°ç»„ä¸­é‡å¤çš„æ•°å­—(å‰‘æŒ‡Offer-03) é¢˜é¢ æ‰¾å‡ºæ•°ç»„ä¸­é‡å¤çš„æ•°å­—ã€‚\nåœ¨ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ nums é‡Œçš„æ‰€æœ‰æ•°å­—éƒ½åœ¨ 0ï½n-1 çš„èŒƒå›´å†…ã€‚æ•°ç»„ä¸­æŸäº›æ•°å­—æ˜¯é‡å¤çš„ï¼Œä½†ä¸çŸ¥é“æœ‰å‡ ä¸ªæ•°å­—é‡å¤äº†ï¼Œä¹Ÿä¸çŸ¥é“æ¯ä¸ªæ•°å­—é‡å¤äº†å‡ æ¬¡ã€‚è¯·æ‰¾å‡ºæ•°ç»„ä¸­ä»»æ„ä¸€ä¸ªé‡å¤çš„æ•°å­—ã€‚\nç¤ºä¾‹ 1è¾“å…¥ï¼š[2, 3, 1, 0, 2, 5, 3] 2è¾“å‡ºï¼š2 æˆ– 3 é™åˆ¶ 12 \u0026lt;= n \u0026lt;= 100000 æ€è·¯ å“ˆå¸Œè¡¨\nä»£ç  1class Solution { 2public: 3 int a[100010] = {0}; 4 int findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 5 int n = nums.size(); 6 for(int i=0; i\u0026lt;n; i++) { 7 if(a[nums[i]]++) 8 return(nums[i]); 9 } 10 return -1; 11 } 12}; ","permalink":"https://blog.lordash.de/posts/solution/%E5%89%91%E6%8C%87offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"æ•°ç»„ä¸­é‡å¤çš„æ•°å­—(å‰‘æŒ‡Offer-03) é¢˜é¢ æ‰¾å‡ºæ•°ç»„ä¸­é‡å¤çš„æ•°å­—ã€‚ åœ¨ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•°ç»„ nums é‡Œçš„æ‰€æœ‰æ•°å­—éƒ½åœ¨ 0ï½n-1 çš„èŒƒå›´å†…ã€‚æ•°ç»„ä¸­æŸäº›æ•°å­—æ˜¯","title":"å‰‘æŒ‡Offer-03 æ•°ç»„ä¸­é‡å¤çš„æ•°å­—"},{"content":"Radix(PATA-1010) é¢˜é¢ Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number.\nNow for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given.\nè¾“å…¥ Each input file contains one test case. Each case occupies a line which contains 4 positive integers:\n1N1 N2 tag radix Here N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set { 0-9, a-z } where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number radix is the radix of N1 if tag is 1, or of N2 if tag is 2.\nè¾“å‡º For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print Impossible. If the solution is not unique, output the smallest possible radix.\næ ·ä¾‹è¾“å…¥1 16 110 1 10 æ ·ä¾‹è¾“å‡º1 12 æ ·ä¾‹è¾“å…¥2 11 ab 1 2 æ ·ä¾‹è¾“å‡º2 1Impossible æç¤º æ— \næ€è·¯ äºŒåˆ†ã€‚\nä»£ç  1const int inf = 0x3f3f3f3f; 2const int mxn = 1e6 + 5; 3 4char a[mxn], b[mxn]; 5 6LL getnum(char *s, LL r){ 7 LL ans = 0; 8 for(; *s; s++) 9 ans = ans * r + (*s - (*s \u0026lt;= \u0026#39;9\u0026#39; ? \u0026#39;0\u0026#39; : \u0026#39;a\u0026#39;-10)); 10 return ans; 11} 12 13LL getans(char *s, char *t, LL r){ 14 char mx = *max_element(t, t+strlen(t)); 15 LL l = mx - (mx \u0026lt;= \u0026#39;9\u0026#39; ? \u0026#39;0\u0026#39; : \u0026#39;a\u0026#39;-10) + 1; 16 LL f=0, at = getnum(s, r); r = max(l, at); 17 while(l \u0026lt;= r){ 18 LL m = (l + r) / 2; 19 LL bt = getnum(t, m); 20 if(bt \u0026lt; 0 || bt \u0026gt; at){ 21 r = m - 1; 22 }else if(at == bt){ 23 f = m; 24 break; 25 }else{ 26 l = m + 1; 27 } 28 } 29 return f; 30} 31 32int main() 33{ 34 LL t, r; 35 scanf(\u0026#34;%s %s %lld %lld\u0026#34;, a, b, \u0026amp;t, \u0026amp;r); 36 LL f = (t==1) ? getans(a, b, r) : getans(b, a, r); 37 if(f){ 38 printf(\u0026#34;%lld\\n\u0026#34;, f); 39 }else{ 40 printf(\u0026#34;Impossible\\n\u0026#34;); 41 } 42 43 return 0; 44} ","permalink":"https://blog.lordash.de/posts/solution/pata-1010-radix/","summary":"Radix(PATA-1010) é¢˜é¢ Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is yes, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. è¾“å…¥ Each input file","title":"PATA-1010 Radix"},{"content":"Product of Polynomials(PATA-1009) é¢˜é¢ This time, you are supposed to find AÃ—B where A and B are two polynomials.\nè¾“å…¥ Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\nK N1 aN1 N2 aN2 \u0026hellip; NK aNK\nwhere K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,â‹¯,K) are the exponents and coefficients, respectively. It is given that 1â‰¤Kâ‰¤10, 0â‰¤NK\u0026lt;â‹¯\u0026lt;N2\u0026lt;N1â‰¤1000.\nè¾“å‡º For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.\næ ·ä¾‹è¾“å…¥ 12 1 2.4 0 3.2 22 2 1.5 1 0.5 æ ·ä¾‹è¾“å‡º 13 3 3.6 2 6.0 1 1.6 æç¤º æ— \næ€è·¯ ç±»ä¼¼ã€é¢˜è§£ã€‘PATA-1002 A+B for Polynomialsï¼Œä¿®æ”¹ä¸€ä¸‹ã€‚æ°´é¢˜ã€‚\nä»£ç  1#define Sg(u) ((u)\u0026gt;eps?1:((u)\u0026lt;-eps?-1:0)) 2#define Abs(u) (Sg(u)\u0026gt;=0?(u):-(u)) 3#define Ze(u) (!Sg(u)) 4#define Eq(u,v) (Ze((u)-(v))) 5const double eps = 1e-6; 6double a[2005], b[2005]; 7 8int main() 9{ 10 int an; scanf(\u0026#34;%d\u0026#34;, \u0026amp;an); 11 for(int i=0; i\u0026lt;an; i++){ 12 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 13 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;b[n]); 14 } 15 16 int bn; scanf(\u0026#34;%d\u0026#34;, \u0026amp;bn); 17 for(int i=0; i\u0026lt;bn; i++){ 18 int n; double x; 19 scanf(\u0026#34;%d %lf\u0026#34;, \u0026amp;n, \u0026amp;x); 20 for(int j=0; j\u0026lt;=2000; j++) 21 if(Sg(b[j])) 22 a[n+j] += x * b[j]; 23 } 24 25 int ans = 0; 26 for(int i=2000; i\u0026gt;=0; i--){ 27 if(Sg(a[i])) 28 ans++; 29 } 30 printf(\u0026#34;%d\u0026#34;, ans); 31 32 for(int i=2000; i\u0026gt;=0; i--){ 33 if(Sg(a[i])) 34 printf(\u0026#34; %d %.1lf\u0026#34;, i, a[i]); 35 } 36 printf(\u0026#34;\\n\u0026#34;); 37 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/pata-1009-product-of-polynomials/","summary":"Product of Polynomials(PATA-1009) é¢˜é¢ This time, you are supposed to find AÃ—B where A and B are two polynomials. è¾“å…¥ Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 \u0026hellip; NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=","title":"PATA-1009 Product of Polynomials"},{"content":"Elevator(PATA-1008) é¢˜é¢ The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.\nFor a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.\nè¾“å…¥ Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100.\nè¾“å‡º For each test case, print the total time on a single line.\næ ·ä¾‹è¾“å…¥ 13 2 3 1 æ ·ä¾‹è¾“å‡º 141 æç¤º æ— \næ€è·¯ ç”µæ¢¯åˆå§‹åœ¨0å±‚ï¼Œæ¯ä¸Šå‡ä¸€å±‚èŠ±è´¹6sï¼Œä¸‹é™ä¸€å±‚èŠ±è´¹4sï¼Œåœç•™èŠ±è´¹5sï¼Œç»™ä½ è¦åœçš„æ¥¼å±‚åºåˆ—ï¼Œæ±‚æ€»è€—æ—¶ã€‚æ°´é¢˜ã€‚\nä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 5 int ans = 0, l = 0, t; 6 for(int i=0; i\u0026lt;n; i++){ 7 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 8 if(t \u0026gt; l){ 9 ans += (t-l) * 6 + 5; 10 }else{ 11 ans += (l-t) * 4 + 5; 12 } 13 l = t; 14 } 15 printf(\u0026#34;%d\\n\u0026#34;, ans); 16 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/pata-1008-elevator/","summary":"Elevator(PATA-1008) é¢˜é¢ The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list,","title":"PATA-1008 Elevator"},{"content":"Maximum Subsequence Sum(PATA-1007) é¢˜é¢ Given a sequence of K integers { N1, N2, \u0026hellip;, NK }. A continuous subsequence is defined to be { Ni, Ni+1, \u0026hellip;, Nj } where 1â‰¤iâ‰¤jâ‰¤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.\nNow you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.\nè¾“å…¥ Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (â‰¤10000). The second line contains K numbers, separated by a space.\nè¾“å‡º For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.\næ ·ä¾‹è¾“å…¥ 110 2-10 1 2 3 4 -5 -23 3 7 -21 æ ·ä¾‹è¾“å‡º 110 1 4 æç¤º æ— \næ€è·¯ åŸºç¡€DPï¼Œæœ€å¤§å­åˆ—å’Œã€‚\nä»£ç  1const int mxn = 1e4 + 5; 2int a[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 int ans=-1, t=0, tl=0, l, r; 9 for(int i=0; i\u0026lt;n; i++){ 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 t += a[i]; 12 if(t \u0026lt; 0){ 13 t = 0; 14 tl = i+1; 15 }else if(t \u0026gt; ans){ 16 ans = t; 17 l = tl; 18 r = i; 19 } 20 } 21 if(ans \u0026lt; 0) 22 ans = 0, l = 0, r = n-1; 23 printf(\u0026#34;%d %d %d\\n\u0026#34;, ans, a[l], a[r]); 24 25 return 0; 26} ","permalink":"https://blog.lordash.de/posts/solution/pata-1007-maximum-subsequence-sum/","summary":"Maximum Subsequence Sum(PATA-1007) é¢˜é¢ Given a sequence of K integers { N1, N2, \u0026hellip;, NK }. A continuous subsequence is defined to be { Ni, Ni+1, \u0026hellip;, Nj } where 1â‰¤iâ‰¤jâ‰¤K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is","title":"PATA-1007 Maximum Subsequence Sum"},{"content":"Sign In and Sign Out(PATA-1006) é¢˜é¢ At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in\u0026rsquo;s and out\u0026rsquo;s, you are supposed to find the ones who have unlocked and locked the door on that day.\nè¾“å…¥ Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format:\n1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters.\nè¾“å‡º For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space.\nNote: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment.\næ ·ä¾‹è¾“å…¥ 13 2CS301111 15:30:28 17:00:10 3SC3021234 08:00:00 11:25:25 4CS301133 21:45:00 21:58:40 æ ·ä¾‹è¾“å‡º 1SC3021234 CS301133 æç¤º æ— \næ€è·¯ æ¯”å¤§å°çš„æ°´é¢˜ã€‚REå°±æ˜¯æ•°ç»„å¼€å°äº†ã€‚\nä»£ç  1char name[20], in[10], out[10]; 2char locked[20]=\u0026#34;\u0026#34;, unlock[20]=\u0026#34;\u0026#34;, mx[10]=\u0026#34;00:00:00\u0026#34;, mi[10]=\u0026#34;99:99:99\u0026#34;; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 for(int i=0; i\u0026lt;n; i++){ 8 scanf(\u0026#34;%s %s %s\u0026#34;, name, in, out); 9 if(strcmp(mi, in) \u0026gt; 0){ 10 strcpy(mi, in); 11 strcpy(unlock, name); 12 } 13 if(strcmp(mx, out) \u0026lt; 0){ 14 strcpy(mx, out); 15 strcpy(locked, name); 16 } 17 } 18 19 printf(\u0026#34;%s %s\\n\u0026#34;, unlock, locked); 20 return 0; 21} ","permalink":"https://blog.lordash.de/posts/solution/pata-1006-sign-in-and-sign-out/","summary":"Sign In and Sign Out(PATA-1006) é¢˜é¢ At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in\u0026rsquo;s and out\u0026rsquo;s, you are supposed to find the ones who have unlocked and locked the door on that day. è¾“å…¥ Each input file contains one test","title":"PATA-1006 Sign In and Sign Out"},{"content":"Spell It Right(PATA-1005) é¢˜é¢ Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English.\nè¾“å…¥ Each input file contains one test case. Each case occupies one line which contains an N (â‰¤10^100).\nè¾“å‡º For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line.\næ ·ä¾‹è¾“å…¥ 112345 æ ·ä¾‹è¾“å‡º 1one five æç¤º æ— \næ€è·¯ æ°´é¢˜ï¼Œæ¯ä¸€ä½åŠ èµ·æ¥è¾“å‡ºå³å¯ã€‚\nä»£ç  1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4char s[mxn], p[][10] = { 5 \u0026#34;zero\u0026#34;, \u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;, \u0026#34;four\u0026#34;, \u0026#34;five\u0026#34;, \u0026#34;six\u0026#34;, \u0026#34;seven\u0026#34;, \u0026#34;eight\u0026#34;, \u0026#34;nine\u0026#34; 6}; 7 8int main() 9{ 10 scanf(\u0026#34;%s\u0026#34;, s); 11 int n = strlen(s), ans = 0; 12 13 for(int i=0; i\u0026lt;n; i++){ 14 ans += s[i]-\u0026#39;0\u0026#39;; 15 } 16 sprintf(s, \u0026#34;%d\u0026#34;, ans); 17 n = strlen(s); 18 19 for(int i=0; i\u0026lt;n; i++){ 20 if(i) printf(\u0026#34; \u0026#34;); 21 printf(\u0026#34;%s\u0026#34;, p[s[i]-\u0026#39;0\u0026#39;]); 22 } 23 printf(\u0026#34;\\n\u0026#34;); 24 return 0; 25} ","permalink":"https://blog.lordash.de/posts/solution/pata-1005-spell-it-right/","summary":"Spell It Right(PATA-1005) é¢˜é¢ Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. è¾“å…¥ Each input file contains one test case. Each case occupies one line which contains an N (â‰¤10^100). è¾“å‡º For each test case, output in one line","title":"PATA-1005 Spell It Right"},{"content":"Counting Leaves(PATA-1004) é¢˜é¢ A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.\nè¾“å…¥ Each input file contains one test case. Each case starts with a line containing 0\u0026lt;N\u0026lt;100, the number of nodes in a tree, and M (\u0026lt;N), the number of non-leaf nodes. Then M lines follow, each in the format:\n1ID K ID[1] ID[2] ... ID[K] where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID\u0026rsquo;s of its children. For the sake of simplicity, let us fix the root ID to be 01.\nThe input ends with N being 0. That case must NOT be processed.\nè¾“å‡º For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.\nThe sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output 0 1 in a line.\næ ·ä¾‹è¾“å…¥ 12 1 201 1 02 æ ·ä¾‹è¾“å‡º 10 1 æç¤º æ— \næ€è·¯ ç»™ä½ ä¸€æ£µæ ‘ï¼Œæ±‚æ¯ä¸€å±‚å¶å­èŠ‚ç‚¹çš„ä¸ªæ•°ã€‚\nå¼€ä¸ªæ•°ç»„ä¿å­˜ï¼Œç„¶ådfsä¸€ä¸‹ï¼Œåˆ°å¶å­èŠ‚ç‚¹å°±åŠ ä¸€ã€‚\nä»£ç  1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4vector\u0026lt;int\u0026gt; a[mxn]; 5int num[mxn]; 6 7void dfs(int rt, int \u0026amp;d, int h){ 8 d = max(d, h); 9 if(a[rt].size() == 0){ 10 num[h]++; 11 return ; 12 } 13 for(int i=0; i\u0026lt;a[rt].size(); i++){ 14 dfs(a[rt][i], d, h+1); 15 } 16} 17 18int main() 19{ 20 int n, m; 21 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 22 23 for(int i=0; i\u0026lt;m; i++){ 24 int f, k, s; 25 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;f, \u0026amp;k); 26 while(k--){ 27 scanf(\u0026#34;%d\u0026#34;, \u0026amp;s); 28 a[f].push_back(s); 29 } 30 } 31 int d = 0; 32 dfs(1, d, 0); 33 34 for(int i=0; i\u0026lt;=d; i++){ 35 if(i) printf(\u0026#34; \u0026#34;); 36 printf(\u0026#34;%d\u0026#34;, num[i]); 37 } 38 printf(\u0026#34;\\n\u0026#34;); 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/solution/pata-1004-counting-leaves/","summary":"Counting Leaves(PATA-1004) é¢˜é¢ A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child. è¾“å…¥ Each input file contains one test case. Each case starts with a line containing 0\u0026lt;N\u0026lt;100, the number of nodes in a tree, and M (\u0026lt;N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2]","title":"PATA-1004 Counting Leaves"},{"content":"Emergency(PATA-1003) é¢˜é¢ As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.\nè¾“å…¥ Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (â‰¤500) - the number of cities (and the cities are numbered from 0 to Nâˆ’1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.\nè¾“å‡º For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.\næ ·ä¾‹è¾“å…¥ 15 6 0 2 21 2 1 5 3 30 1 1 40 2 2 50 3 1 61 2 1 72 4 1 83 4 1 æ ·ä¾‹è¾“å‡º 12 4 æç¤º æ— \næ€è·¯ ç»™ä½ ä¸€ä¸ªè¿é€šå›¾ï¼ŒåŠå…¶ç‚¹æƒå’Œè¾¹æƒã€‚æ±‚èµ·ç‚¹c1åˆ°ç»ˆç‚¹c2çš„æœ€çŸ­è·¯å¾„æ•°é‡ï¼Œä»¥åŠæœ€çŸ­è·¯å¾„ä¸Šç‚¹æƒæœ€å¤§å’Œã€‚\nè·‘Dijkstraï¼Œåœ¨$dis[u]+w \\le dis[v]$çš„æ—¶å€™ï¼Œåˆ†ç±»è®¨è®ºï¼Œæ›´æ–°æœ€çŸ­è·¯å¾„æ•°é‡å’Œç‚¹æƒæœ€å¤§å’Œã€‚\nä»£ç  1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4struct E { 5 int to, next, w; 6}e[mxn]; 7 8int H[mxn], tot; 9 10void add(int from, int to, int w){ 11 e[tot] = {to, H[from], w}; 12 H[from] = tot++; 13} 14 15void graph_init(int n) 16{ 17 for(int i=0; i\u0026lt;n; i++) 18 H[i] = -1; 19 tot = 0; 20} 21 22int dis[mxn], num[mxn], man[mxn]; 23bool vis[mxn]; 24priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; q; 25 26int t[mxn]; 27 28void dijkstra_init(int n) 29{ 30 for(int i=0; i\u0026lt;n; i++){ 31 dis[i] = inf; 32 man[i] = vis[i] = 0; 33 } 34} 35 36void dijkstra(int s, int n) 37{ 38 num[s] = 1; man[s] = t[s]; 39 q.push({dis[s]=0, s}); 40 while(!q.empty()){ 41 int u = q.top().second; q.pop(); 42 if(vis[u]) continue; 43 vis[u] = 1; 44 for(int i=H[u]; ~i; i=e[i].next){ 45 int v=e[i].to, w=e[i].w; 46 if(!vis[v] \u0026amp;\u0026amp; dis[u]+w \u0026lt; dis[v]){ 47 dis[v] = dis[u]+w; 48 q.push({dis[v], v}); 49 num[v] = num[u]; 50 man[v] = max(man[v], man[u]+t[v]); 51 } 52 else if(!vis[v] \u0026amp;\u0026amp; dis[u]+w == dis[v]){ 53 num[v] += num[u]; 54 man[v] = max(man[v], man[u]+t[v]); 55 } 56 } 57 } 58} 59 60int main() 61{ 62 int n, m, c1, c2; 63 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;c1, \u0026amp;c2); 64 65 for(int i=0; i\u0026lt;n; i++) 66 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[i]); 67 68 graph_init(n); 69 for(int i=0; i\u0026lt;m; i++){ 70 int u, v, w; 71 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 72 add(u, v, w); 73 add(v, u, w); 74 } 75 76 dijkstra_init(n); 77 dijkstra(c1, n); 78 79 printf(\u0026#34;%d %d\\n\u0026#34;, num[c2], man[c2]); 80 return 0; 81} ","permalink":"https://blog.lordash.de/posts/solution/pata-1003-emergency/","summary":"Emergency(PATA-1003) é¢˜é¢ As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to","title":"PATA-1003 Emergency"},{"content":"ç®€ä»‹ Johnsonç®—æ³•æ˜¯æ±‚è§£å¤šæºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ“ä½œæ˜¯re-weightï¼Œé€‚ç”¨äºä¸åŒ…å«è´Ÿç¯ï¼ˆè´Ÿæƒå›è·¯ï¼‰çš„å›¾ã€‚æ—¶é—´å¤æ‚åº¦$O(nm+nmlogm)$ã€‚\nJohnsonç®—æ³• å…¨æºæœ€çŸ­è·¯å¸¸ç”¨æ–¹æ³•æ˜¯Floydç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦$O(n^{3})$ã€‚å½“ç„¶æˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹æ¯ä¸ªé¡¶ç‚¹è·‘å•æºæœ€çŸ­è·¯ã€‚å¦‚æœå¯¹æ¯ä¸ªé¡¶ç‚¹æ±‚ä¸€æ¬¡Bellman-Fordç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(n^{2}m)$ï¼Œä¼¼ä¹ä¸å¦‚Floydç®—æ³•ã€‚å¦‚æœæ˜¯å¯¹æ¯ä¸ªé¡¶ç‚¹æ±‚ä¸€æ¬¡Dijkstraç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(nm+nmlogm)$ï¼Œçœ‹èµ·æ¥ä¼˜äºFloydç®—æ³•äº†ã€‚ä½†æ˜¯å¦‚ä½•å»é™¤è´Ÿè¾¹æƒçš„å½±å“å‘¢ï¼Ÿ\nè€ƒè™‘ä¸€ä¸‹ç›´æ¥æŠŠæ‰€æœ‰è¾¹æƒåŠ ä¸ªæ­£æ•°ï¼Œä½†æ˜¯æ˜¾ç„¶ä¸æ»¡è¶³åŸå›¾æ€§è´¨äº†ï¼š\nè¿™é‡Œæå‡ºä¸€ä¸ªre-weightæ“ä½œï¼Œé¦–å…ˆåŠ ä¸Šä¸€ä¸ªæºç‚¹ï¼Œå¹¶ä½¿å…¶ä¸æ‰€æœ‰é¡¶ç‚¹è¿é€šï¼Œæ–°è¾¹æƒèµ‹å€¼ä¸º0ï¼Œå¦‚ä¸‹å›¾ï¼š\nç„¶åä»¥æ–°åŠ é¡¶ç‚¹ä¸ºæºï¼Œè·‘Bellman-Fordç®—æ³•ï¼Œæ±‚å‡ºåˆ°å…¶å®ƒé¡¶ç‚¹çš„æœ€çŸ­è·¯ï¼š\nè®°å½•ä¸‹æœ€çŸ­è·¯å¾„é•¿åº¦h[] = {0, -3, 0, 0}ï¼Œåˆ é™¤åˆšåˆšæ–°å¢åŠ çš„ç»“ç‚¹ã€‚ç„¶åå¯¹åŸå›¾è¾¹æƒè¿›è¡Œå¤„ç†ï¼Œä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ›´æ–°è¾¹æƒï¼š$w\u0026rsquo;(u, v) = w(u, v) + (h[u] - h[v])$ã€‚\nè¿™æ—¶ï¼Œè´Ÿè¾¹æƒçš„å½±å“å°±è¢«æ¶ˆé™¤äº†ï¼Œå¯ä»¥æ„‰å¿«çš„ä½¿ç”¨Dijkstraç®—æ³•äº†ã€‚ï¼ˆæ‡’ä¸€ä¸‹ï¼Œæ­£ç¡®æ€§è¯·è‡ªè¡Œè¯æ˜ï¼‰ã€‚\næ¨¡æ¿ 1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4struct E { 5 int to, next, w; 6} e[mxn]; 7 8int H[mxn], tot; 9 10void add(int from, int to, int w) { 11 e[tot] = {to, H[from], w}; 12 H[from] = tot++; 13} 14 15void graph_init(int n) 16{ 17 for(int i=1; i\u0026lt;=n; i++) 18 H[i] = -1; 19 tot = 0; 20} 21 22int h[mxn], num[mxn]; 23bool vis[mxn]; 24queue\u0026lt;int\u0026gt; q; 25 26void spfa_init(int n) 27{ 28 for(int i=1; i\u0026lt;=n; i++){ 29 h[i] = inf; 30 num[i] = 0; 31 } 32} 33 34int spfa(int s, int n) 35{ 36 h[s] = 0; q.push(s); 37 num[s] = vis[s] = 1; 38 while(!q.empty()) 39 { 40 int u = q.front(); q.pop(); vis[u] = 0; 41 for(int i=H[u]; ~i; i=e[i].next){ 42 int v = e[i].to, w = e[i].w; 43 if(h[u]+w \u0026lt; h[v]){ 44 h[v] = h[u]+w; 45 if(!vis[v]){ 46 q.push(v), vis[v] = 1; 47 if(++num[v] \u0026gt; n) return -1; 48 } 49 } 50 } 51 } 52 return 0; 53} 54 55int dis[mxn]; 56priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; pq; 57 58void dijkstra_init(int n) 59{ 60 for(int i=1; i\u0026lt;=n; i++){ 61 vis[i] = 0; 62 dis[i] = inf; 63 } 64} 65 66void dijkstra(int s, int n) 67{ 68 pq.push({dis[s]=0, s}); 69 while(!pq.empty()){ 70 int u = pq.top().second; pq.pop(); 71 if(vis[u]) continue; 72 vis[u] = 1; 73 for(int i=H[u]; ~i; i=e[i].next){ 74 int v=e[i].to, w=e[i].w; 75 if(!vis[v] \u0026amp;\u0026amp; dis[u]+w \u0026lt; dis[v]){ 76 dis[v] = dis[u]+w; 77 pq.push({dis[v], v}); 78 } 79 } 80 } 81} 82 83int DIS[mxn][mxn]; 84 85int main() 86{ 87 int n, m; 88 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 89 graph_init(n); 90 91 for(int i=1; i\u0026lt;=m; i++) 92 { 93 int u, v, w; 94 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 95 add(u, v, w); 96 } 97 98 for(int i=1; i\u0026lt;=n; i++) 99 add(0, i, 0); 100 101 spfa_init(n); 102 if(spfa(0, n) == -1) 103 { 104 printf(\u0026#34;åŒ…å«è´Ÿæƒå›è·¯\\n\u0026#34;); 105 } 106 else 107 { 108 for(int u=1; u\u0026lt;=n; u++){ 109 for(int i=H[u]; ~i; i=e[i].next){ 110 e[i].w += h[u] - h[e[i].to]; 111 } 112 } 113 114 for(int i=1; i\u0026lt;=n; i++){ 115 dijkstra_init(n); 116 dijkstra(i, n); 117 for(int j=1; j\u0026lt;=n; j++){ 118 DIS[i][j] = dis[j] - h[i] + h[j]; 119 printf(\u0026#34;%d \u0026#34;, DIS[i][j]); 120 } 121 printf(\u0026#34;\\n\u0026#34;); 122 } 123 } 124 125 return 0; 126} 127 128 129/* 130Sample Input: 131 1324 5 1331 2 -3 1342 3 2 1351 4 3 1362 3 4 1373 4 1 138 139 140Sample Output: 141 1420 -3 -1 0 1431061109570 0 2 3 1441061109568 1061109565 0 1 1451061109567 1061109564 1061109566 0 146 147*/ ","permalink":"https://blog.lordash.de/posts/algorithm/johnson/","summary":"ç®€ä»‹ Johnsonç®—æ³•æ˜¯æ±‚è§£å¤šæºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ“ä½œæ˜¯re-weightï¼Œé€‚ç”¨äºä¸åŒ…å«è´Ÿç¯ï¼ˆè´Ÿæƒå›è·¯ï¼‰çš„å›¾ã€‚æ—¶é—´å¤æ‚åº¦$O(nm+nm","title":"Johnson"},{"content":"ç®€ä»‹ Floyd-Warshallç®—æ³•æ˜¯æ±‚è§£å¤šæºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯åŠ¨æ€è§„åˆ’ï¼Œé€‚ç”¨äºä¸åŒ…å«è´Ÿç¯ï¼ˆè´Ÿæƒå›è·¯ï¼‰çš„å›¾ã€‚æ—¶é—´å¤æ‚åº¦$O(n^{3})$ï¼Œç©ºé—´å¤æ‚åº¦$O(n^{2})$ã€‚\nFloyd-Warshallç®—æ³• å¯¹äºä»»ä½•ä¸€ä¸ªç‚¹è€Œè¨€ï¼Œiåˆ°jçš„æœ€çŸ­è·ç¦»ä¸å¤–ä¹iåˆ°jç»è¿‡kå’Œä¸ç»è¿‡kä¸¤ç§å¯èƒ½ï¼Œæ‰€ä»¥å¯ä»¥ä»¤$k=1,2,3,\\ldots,n$ï¼Œæ£€æŸ¥$dis(i, j)$ä¸$dis(i, k)+dis(k, j)$çš„å¤§å°ï¼Œåœ¨æ­¤$dis(i, k)$ä¸$dis(k, j)$åˆ†åˆ«æ˜¯ç›®å‰ä¸ºæ­¢æ‰€çŸ¥çš„iåˆ°kä¸kåˆ°jçš„æœ€çŸ­è·ç¦»ï¼Œå› æ­¤$dis(i, k)+dis(k, j)$å°±æ˜¯iåˆ°jç»è¿‡kçš„æœ€çŸ­è·ç¦»ã€‚\næ‰€ä»¥ï¼Œè‹¥æœ‰$dis(i, j) \\gt dis(i, k)+dis(k, j)$ï¼Œå°±è¡¨ç¤ºä»iå‡ºå‘ç»è¿‡kå†åˆ°jçš„è·ç¦»è¦æ¯”åŸæ¥çš„iåˆ°jè·ç¦»çŸ­ï¼Œè‡ªç„¶æŠŠiåˆ°jçš„è·ç¦»$dis(i, j)$æ›´æ–°ä¸º$dis(i, k)+dis(k, j)$ï¼Œæ›´æ–°å®Œå$dis(i, j)$å°±æ˜¯ç›®å‰çš„iåˆ°jçš„æœ€çŸ­è·ç¦»ã€‚é‡å¤è¿™ä¸€è¿‡ç¨‹ï¼Œæœ€åå½“éå†å®Œkæ—¶ï¼Œ$dis(i, j)$é‡Œé¢å­˜æ”¾çš„å°±æ˜¯iåˆ°jä¹‹é—´çš„æœ€çŸ­è·ç¦»äº†ã€‚\næˆ‘ä»¬å®šä¹‰æ•°ç»„$dp[k][x][y]$è¡¨ç¤ºåªå…è®¸ç»è¿‡ç»“ç‚¹1åˆ°kï¼Œç»“ç‚¹xåˆ°ç»“ç‚¹yçš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±æ˜¯$dp[k][x][y] = min(dp[k-1][x][y], dp[k-1][x][k]+dp[k-1][k][y])$ï¼Œå¯ä»¥å‘ç°ç¬¬ä¸€ç»´æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œäºæ˜¯ç›´æ¥æ”¹æˆ$dp[x][y] = min(dp[x][y], dp[x][k]+dp[k][y])$ã€‚\nä»£ç å®ç°å¾ˆç®€å•ï¼Œä¸è¿‡è¦æ³¨æ„å¾ªç¯çš„åµŒå¥—å¾ªåºï¼Œkä½œä¸ºé˜¶æ®µï¼Œæšä¸¾æ—¶çš„å¾ªç¯è¦æ”¾åœ¨æœ€å¤–å±‚ï¼š\n1void floyd(int n) 2{ 3 for(int k=1; k\u0026lt;=n; k++) 4 for(int i=1; i\u0026lt;=n; i++) 5 for(int j=1; j\u0026lt;=n; j++) 6 g[i][j] = min(g[i][j], g[i][k]+g[k][j]); 7} *ä¼ é€’é—­åŒ… Floydç®—æ³•ä¸ä»…å¯ä»¥æ±‚æœ€çŸ­è·¯ï¼Œä¹Ÿå¯ä»¥ç»´æŠ¤å…³ç³»æ±‚ä¼ é€’é—­åŒ…ã€‚å»ºç«‹é‚»æ¥çŸ©é˜µ$f[i][j]$è¡¨ç¤ºiå’Œjæ˜¯å¦æœ‰å…³ç³»ï¼Œè·‘ä¸€éfloydï¼Œç„¶åæ£€æŸ¥$f[i][j]\u0026amp;f[j][i]$æ˜¯å¦ä¸º1ã€‚ä¸‹é¢ç»™å‡ºbitsetä¼˜åŒ–ç‰ˆæœ¬ï¼Œæ—¶é—´å¤æ‚åº¦$O(\\frac{n^{3}}{w})$ã€‚\n1// std::bitset\u0026lt;SIZ\u0026gt; f[SIZ]; 2void floyd(int n) 3{ 4 for(int k=1; k\u0026lt;=n; k++) 5 for(int i=1; i\u0026lt;=n; i++) 6 if(f[i][k]) f[i] = f[i] | f[k]; 7} æ¨¡æ¿ 1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4int g[mxn][mxn], pre[mxn][mxn]; 5 6void graph_init(int n) 7{ 8 for(int i=1; i\u0026lt;=n; i++){ 9 for(int j=1; j\u0026lt;=n; j++) 10 g[i][j] = inf; 11 g[i][i] = 0; 12 } 13} 14 15void floyd_init(int n) 16{ 17 for(int i=1; i\u0026lt;=n; i++){ 18 for(int j=1; j\u0026lt;= n; j++){ 19 pre[i][j] = (g[i][j]==inf ? -1 : j); 20 } 21 } 22} 23 24void floyd(int n) 25{ 26 for(int k=1; k\u0026lt;=n; k++) 27 for(int i=1; i\u0026lt;=n; i++) 28 for(int j=1; j\u0026lt;=n; j++){ 29 if(g[i][k]+g[k][j] \u0026lt; g[i][j]){ 30 g[i][j] = g[i][k]+g[k][j]; 31 pre[i][j] = pre[i][k]; 32 } 33 } 34} 35 36int main() 37{ 38 int n, m; 39 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 40 graph_init(n); 41 42 for(int i=0; i\u0026lt;m; i++) 43 { 44 int u, v, w; 45 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 46 g[u][v] = w; 47 } 48 floyd_init(n); 49 floyd(n); 50 51 for(int i=1; i\u0026lt;=n; i++){ 52 for(int j=1; j\u0026lt;=n; j++) 53 printf(\u0026#34;%d \u0026#34;, g[i][j]); 54 printf(\u0026#34;\\n\u0026#34;); 55 } 56 57 for(int i=1; i\u0026lt;=n; i++){ 58 for(int j=1; j\u0026lt;=n; j++) 59 printf(\u0026#34;%d \u0026#34;, pre[i][j]); 60 printf(\u0026#34;\\n\u0026#34;); 61 } 62 63 return 0; 64} 65 66/* 67Sample Input: 68 694 5 701 2 2 711 3 4 722 4 1 733 2 1 743 4 8 75 76Sample Output: 77 780 2 4 3 791061109567 0 1061109567 1 801061109567 1 0 2 811061109567 1061109567 1061109567 0 821 2 3 2 83-1 2 -1 4 84-1 2 3 2 85-1 -1 -1 4 86 87*/ ","permalink":"https://blog.lordash.de/posts/algorithm/floyd/","summary":"ç®€ä»‹ Floyd-Warshallç®—æ³•æ˜¯æ±‚è§£å¤šæºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯åŠ¨æ€è§„åˆ’ï¼Œé€‚ç”¨äºä¸åŒ…å«è´Ÿç¯ï¼ˆè´Ÿæƒå›è·¯ï¼‰çš„å›¾ã€‚æ—¶é—´å¤æ‚åº¦$O(n^{","title":"Floyd-Warshall"},{"content":"ç®€ä»‹ Bellman-Fordç®—æ³•æ˜¯æ±‚è§£å•æºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œé€‚ç”¨äºå¯åŒ…å«è´Ÿè¾¹æƒçš„æœ‰å‘å’Œæ— å‘å›¾ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯å¦åŒ…å«è´Ÿç¯ï¼ˆæ³¨æ„ï¼Œå¦‚æœæ˜¯åŒ…å«è´Ÿæƒå›è·¯åˆ™ä¸å­˜åœ¨æœ€çŸ­è·¯é—®é¢˜ï¼‰ã€‚æ—¶é—´å¤æ‚åº¦$O(nm)$ã€‚\nBellman-Fordç®—æ³• å› ä¸ºæœ€çŸ­è·¯å¾„ä¸Šæœ€å¤šæœ‰n-1æ¡è¾¹ï¼Œæ‰€ä»¥Bellman-Fordç®—æ³•æœ€å¤šæœ‰n-1ä¸ªé˜¶æ®µã€‚åœ¨æ¯ä¸€ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å¯¹æ¯ä¸€æ¡è¾¹éƒ½è¦æ‰§è¡Œæ¾å¼›æ“ä½œã€‚å…¶å®æ¯å®æ–½ä¸€æ¬¡æ¾å¼›æ“ä½œï¼Œå°±ä¼šæœ‰ä¸€äº›é¡¶ç‚¹å·²ç»æ±‚å¾—å…¶æœ€çŸ­è·¯ï¼Œå³è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯çš„â€œä¼°è®¡å€¼â€å˜ä¸ºâ€œç¡®å®šå€¼â€ã€‚æ­¤åè¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯çš„å€¼å°±ä¼šä¸€ç›´ä¿æŒä¸å˜ï¼Œä¸å†å—åç»­æ¾å¼›æ“ä½œçš„å½±å“(ä½†æ˜¯ï¼Œæ¯æ¬¡è¿˜æ˜¯ä¼šåˆ¤æ–­æ˜¯å¦éœ€è¦æ¾å¼›)ã€‚åœ¨å‰kä¸ªé˜¶æ®µç»“æŸåï¼Œå°±å·²ç»æ‰¾å‡ºäº†ä»æºç‚¹å‡ºå‘â€œæœ€å¤šç»è¿‡kæ¡è¾¹â€åˆ°è¾¾å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯ã€‚ç›´åˆ°è¿›è¡Œå®Œn-1ä¸ªé˜¶æ®µåï¼Œä¾¿å¾—å‡ºäº†æœ€å¤šç»è¿‡n-1æ¡è¾¹çš„æœ€çŸ­è·¯ã€‚\næ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š\n1int bellman(int s, int n, int m) 2{ 3 dis[s] = 0; 4 for(int k=1; k\u0026lt;n; k++){ 5 for(int i=1; i\u0026lt;=m; i++){ 6 dis[v[i]] = min(dis[v[i]], dis[u[i]]+w[i]); 7 } 8 } 9 return 0; 10} å¦‚æœåœ¨n-1æ¬¡æ¾å¼›ä¹‹åï¼Œè¿˜æœ‰å¯ä»¥è¿›è¡Œæ¾å¼›çš„è¾¹ï¼Œé‚£ä¹ˆå°±å­˜åœ¨è´Ÿç¯ï¼ˆè´Ÿæƒå›è·¯ï¼‰ï¼š\n1int bellman(int s, int n, int m) 2{ 3 dis[s] = 0; 4 for(int k=1; k\u0026lt;n; k++){ 5 for(int i=1; i\u0026lt;=m; i++){ 6 if(dis[u[i]]+w[i] \u0026lt; dis[v[i]]){ 7 dis[v[i]] = dis[u[i]]+w[i]; 8 pre[v[i]] = u[i]; 9 } 10 } 11 } 12 for(int i=1; i\u0026lt;=m; i++){ 13 if(dis[u[i]]+w[i] \u0026lt; dis[v[i]]){ 14 return -1; 15 } 16 } 17 return 0; 18} SPFA SPFAæ˜¯Bellman-Fordç®—æ³•çš„é˜Ÿåˆ—ä¼˜åŒ–ï¼Œæ ¸å¿ƒæ€æƒ³ï¼Œåªæœ‰é‚£äº›åœ¨å‰ä¸€éæ¾å¼›ä¸­æ”¹å˜äº†è·ç¦»ä¼°è®¡å€¼çš„ç‚¹ï¼Œæ‰å¯èƒ½å¼•èµ·å®ƒä»¬çš„é‚»æ¥ç‚¹çš„è·ç¦»ä¼°è®¡å€¼çš„æ”¹å˜ã€‚ä¸ºä»€ä¹ˆé˜Ÿåˆ—ä¸ºç©ºå°±ä¸æ”¹å˜äº†å‘¢ï¼Ÿå°±æ˜¯å› ä¸ºè¦åˆ°ä¸‹ä¸€ç‚¹å¿…é¡»ç»è¿‡å®ƒçš„å‰ä¸€ä¸ªé‚»æ¥ç‚¹ã€‚\nè®¾ç«‹ä¸€ä¸ªå…ˆè¿›å…ˆå‡ºçš„é˜Ÿåˆ—qç”¨æ¥ä¿å­˜å¾…ä¼˜åŒ–çš„ç»“ç‚¹ï¼Œä¼˜åŒ–æ—¶æ¯æ¬¡å–å‡ºé˜Ÿé¦–ç»“ç‚¹uï¼Œå¹¶ä¸”ç”¨uç‚¹å½“å‰çš„æœ€çŸ­è·¯å¾„ä¼°è®¡å€¼å¯¹ç¦»å¼€uç‚¹æ‰€æŒ‡å‘çš„ç»“ç‚¹vè¿›è¡Œæ¾å¼›æ“ä½œï¼Œå¦‚æœvç‚¹çš„æœ€çŸ­è·¯å¾„ä¼°è®¡å€¼æœ‰æ‰€è°ƒæ•´ï¼Œä¸”vç‚¹ä¸åœ¨å½“å‰çš„é˜Ÿåˆ—ä¸­ï¼Œå°±å°†vç‚¹æ”¾å…¥é˜Ÿå°¾ã€‚è¿™æ ·ä¸æ–­ä»é˜Ÿåˆ—ä¸­å–å‡ºç»“ç‚¹æ¥è¿›è¡Œæ¾å¼›æ“ä½œï¼Œç›´è‡³é˜Ÿåˆ—ç©ºä¸ºæ­¢ã€‚\næ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š\n1int spfa(int s, int n) 2{ 3 dis[s] = 0; vis[s] = 1; q.push(s); 4 while(!q.empty()) 5 { 6 int u = q.front(); q.pop(); vis[u] = 0; 7 for(int i=H[u]; ~i; i=e[i].next){ 8 int v = e[i].to, w = e[i].w; 9 if(dis[u]+w \u0026lt; dis[v]){ 10 dis[v] = dis[u]+w; 11 if(!vis[v]) q.push(v), vis[v] = 1; 12 } 13 } 14 } 15 return 0; 16} å…¶å®ƒä¼˜åŒ– é™¤äº†é˜Ÿåˆ—ä¼˜åŒ–ï¼ˆSPFAï¼‰ä¹‹å¤–ï¼ŒBellman-Ford è¿˜æœ‰å…¶ä»–å½¢å¼çš„ä¼˜åŒ–ï¼Œè¿™äº›ä¼˜åŒ–åœ¨éƒ¨åˆ†å›¾ä¸Šæ•ˆæœæ˜æ˜¾ï¼Œä½†åœ¨æŸäº›ç‰¹æ®Šå›¾ä¸Šï¼Œæœ€åå¤æ‚åº¦å¯èƒ½è¾¾åˆ°æŒ‡æ•°çº§ã€‚\nå †ä¼˜åŒ–ï¼šå°†é˜Ÿåˆ—æ¢æˆå †ï¼Œä¸ Dijkstra çš„åŒºåˆ«æ˜¯å…è®¸ä¸€ä¸ªç‚¹å¤šæ¬¡å…¥é˜Ÿã€‚åœ¨æœ‰è´Ÿæƒè¾¹çš„å›¾å¯èƒ½è¢«å¡æˆæŒ‡æ•°çº§å¤æ‚åº¦ã€‚ æ ˆä¼˜åŒ–ï¼šå°†é˜Ÿåˆ—æ¢æˆæ ˆï¼ˆå³å°†åŸæ¥çš„ BFS è¿‡ç¨‹å˜æˆ DFSï¼‰ï¼Œåœ¨å¯»æ‰¾è´Ÿç¯æ—¶å¯èƒ½å…·æœ‰æ›´é«˜æ•ˆç‡ï¼Œä½†æœ€åæ—¶é—´å¤æ‚åº¦ä»ç„¶ä¸ºæŒ‡æ•°çº§ã€‚ LLL ä¼˜åŒ–ï¼šå°†æ™®é€šé˜Ÿåˆ—æ¢æˆåŒç«¯é˜Ÿåˆ—ï¼Œæ¯æ¬¡å°†å…¥é˜Ÿç»“ç‚¹è·ç¦»å’Œé˜Ÿå†…è·ç¦»å¹³å‡å€¼æ¯”è¾ƒï¼Œå¦‚æœæ›´å¤§åˆ™æ’å…¥è‡³é˜Ÿå°¾ï¼Œå¦åˆ™æ’å…¥é˜Ÿé¦–ã€‚ SLF ä¼˜åŒ–ï¼šå°†æ™®é€šé˜Ÿåˆ—æ¢æˆåŒç«¯é˜Ÿåˆ—ï¼Œæ¯æ¬¡å°†å…¥é˜Ÿç»“ç‚¹è·ç¦»å’Œé˜Ÿé¦–æ¯”è¾ƒï¼Œå¦‚æœæ›´å¤§åˆ™æ’å…¥è‡³é˜Ÿå°¾ï¼Œå¦åˆ™æ’å…¥é˜Ÿé¦–ã€‚ æ›´å¤šä¼˜åŒ–ä»¥åŠé’ˆå¯¹è¿™äº›ä¼˜åŒ–çš„ Hack æ–¹æ³•ï¼Œå¯ä»¥çœ‹ fstqwq åœ¨çŸ¥ä¹ä¸Šçš„å›ç­” ã€‚\næ¨¡æ¿ Bellman-Fordç®—æ³•ï¼š\n1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4int u[mxn], v[mxn], w[mxn]; 5int dis[mxn], pre[mxn]; 6 7void bellman_init(int n) 8{ 9 for(int i=1; i\u0026lt;=n; i++){ 10 dis[i] = inf; 11 pre[i] = 0; 12 } 13} 14 15int bellman(int s, int n, int m) 16{ 17 int k=0, f=1; dis[s] = 0; 18 while(f) 19 { 20 if(++k \u0026gt; n) return -1; 21 f = 0; 22 for(int i=1; i\u0026lt;=m; i++){ 23 if(dis[u[i]]+w[i] \u0026lt; dis[v[i]]){ 24 dis[v[i]] = dis[u[i]]+w[i]; 25 pre[v[i]] = u[i]; 26 f = 1; 27 } 28 } 29 } 30 return 0; 31} 32 33int main() 34{ 35 int n, m; 36 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 37 38 for(int i=1; i\u0026lt;=m; i++) 39 { 40 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u[i], \u0026amp;v[i], \u0026amp;w[i]); 41 } 42 43 bellman_init(n); 44 if(bellman(1, n, m) == -1) 45 { 46 printf(\u0026#34;åŒ…å«è´Ÿæƒå›è·¯\\n\u0026#34;); 47 } 48 else 49 { 50 for(int i=1; i\u0026lt;=n; i++) 51 printf(\u0026#34;%d \u0026#34;, dis[i]); 52 printf(\u0026#34;\\n\u0026#34;); 53 54 for(int i=1; i\u0026lt;=n; i++) 55 printf(\u0026#34;%d \u0026#34;, pre[i]); 56 printf(\u0026#34;\\n\u0026#34;); 57 } 58 59 return 0; 60} 61 62/* 63Sample Input: 64 654 5 661 2 2 671 3 4 682 4 1 693 2 1 703 4 8 71 72 73Sample Output: 74 750 2 4 3 760 1 1 2 77 78*/ SPFAï¼š\n1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4struct E { 5 int to, next, w; 6} e[mxn]; 7 8int H[mxn], tot; 9 10void add(int from, int to, int w) { 11 e[tot] = {to, H[from], w}; 12 H[from] = tot++; 13} 14 15void graph_init(int n) 16{ 17 for(int i=1; i\u0026lt;=n; i++) 18 H[i] = -1; 19 tot = 0; 20} 21 22int dis[mxn], pre[mxn], num[mxn]; 23bool vis[mxn]; 24queue\u0026lt;int\u0026gt; q; 25 26void spfa_init(int n) 27{ 28 for(int i=1; i\u0026lt;=n; i++){ 29 dis[i] = inf; 30 num[i] = pre[i] = 0; 31 } 32} 33 34int spfa(int s, int n) 35{ 36 dis[s] = 0; q.push(s); 37 num[s] = vis[s] = 1; 38 while(!q.empty()) 39 { 40 int u = q.front(); q.pop(); vis[u] = 0; 41 for(int i=H[u]; ~i; i=e[i].next){ 42 int v = e[i].to, w = e[i].w; 43 if(dis[u]+w \u0026lt; dis[v]){ 44 dis[v] = dis[u]+w; 45 pre[v] = u; 46 if(!vis[v]){ 47 q.push(v), vis[v] = 1; 48 if(++num[v] \u0026gt; n) return -1; 49 } 50 } 51 } 52 } 53 return 0; 54} 55 56int main() 57{ 58 int n, m; 59 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 60 graph_init(n); 61 62 for(int i=1; i\u0026lt;=m; i++) 63 { 64 int u, v, w; 65 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 66 add(u, v, w); 67 } 68 69 spfa_init(n); 70 if(spfa(1, n) == -1) 71 { 72 printf(\u0026#34;åŒ…å«è´Ÿæƒå›è·¯\\n\u0026#34;); 73 } 74 else 75 { 76 for(int i=1; i\u0026lt;=n; i++) 77 printf(\u0026#34;%d \u0026#34;, dis[i]); 78 printf(\u0026#34;\\n\u0026#34;); 79 80 for(int i=1; i\u0026lt;=n; i++) 81 printf(\u0026#34;%d \u0026#34;, pre[i]); 82 printf(\u0026#34;\\n\u0026#34;); 83 } 84 85 return 0; 86} 87 88 89/* 90Sample Input: 91 924 5 931 2 2 941 3 4 952 4 1 963 2 1 973 4 8 98 99 100Sample Output: 101 1020 2 4 3 1030 1 1 2 104 105*/ ","permalink":"https://blog.lordash.de/posts/algorithm/bellman-ford/","summary":"ç®€ä»‹ Bellman-Fordç®—æ³•æ˜¯æ±‚è§£å•æºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œé€‚ç”¨äºå¯åŒ…å«è´Ÿè¾¹æƒçš„æœ‰å‘å’Œæ— å‘å›¾ï¼Œå¯ä»¥åˆ¤æ–­æ˜¯å¦åŒ…å«è´Ÿç¯ï¼ˆæ³¨æ„ï¼Œå¦‚æœæ˜¯åŒ…å«è´Ÿæƒå›è·¯","title":"Bellman-Ford"},{"content":"ç®€ä»‹ Dijkstraç®—æ³•æ˜¯æ±‚è§£å•æºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯è´ªå¿ƒï¼Œåªé€‚ç”¨äºè¾¹æƒä¸ºæ­£çš„æ— å‘å’Œæœ‰å‘å›¾ã€‚åŸå¤æ‚åº¦$O(n^{2})$ï¼Œä¼˜åŒ–åæ—¶é—´å¤æ‚åº¦èƒ½åˆ°$O(mlog_{m})$ã€‚\nDijkstraç®—æ³• é¦–å…ˆæˆ‘ä»¬æ¥çœ‹è¿™ä¸ªè´ªå¿ƒæ€§è´¨ï¼š\nä»èµ·ç‚¹uåˆ°ç»ˆç‚¹vçš„æœ€çŸ­è·¯å¾„ï¼Œä¸€å®šæ˜¯ä»èµ·ç‚¹uåˆ°è¿™æ¡æœ€çŸ­è·¯å¾„ä¸Šç»è¿‡çš„ç‚¹wçš„æœ€çŸ­è·¯å¾„ã€‚\nå¯ä»¥ç”¨åè¯æ³•è¯æ˜ï¼Œå‡è®¾$dis(u, w)$æ˜¯èµ·ç‚¹uåˆ°ç»ˆç‚¹væœ€çŸ­è·¯å¾„ä¸Šçš„èµ·ç‚¹uåˆ°é€”ç»ç‚¹wçš„è·ç¦»ã€‚è‹¥å­˜åœ¨ä¸æ˜¯æœ€çŸ­è·¯å¾„ä¸Šçš„$dis\u0026rsquo;(u, w) \u0026lt; dis(u, w)$ï¼Œé‚£ä¹ˆå¯ä»¥å¾—å‡º$dis\u0026rsquo;(u, w)+dis(w, v) \u0026lt; dis(u, w)+dis(w, v)$ï¼Œå³å­˜åœ¨ä»èµ·ç‚¹uåˆ°ç»ˆç‚¹vçš„æ›´çŸ­çš„è·¯å¾„ï¼Œä¸å‡è®¾çŸ›ç›¾ã€‚\nå¯ä»¥æ ¹æ®è¿™ä¸ªæ€§è´¨å¾—åˆ°è´ªå¿ƒæ€è·¯ï¼Œä½†æ˜¯è¿™ä¸ªæ€§è´¨åŸºäºä¸€ä¸ªå‰æï¼š\nå¯¹äºèµ·ç‚¹uçš„æœ€çŸ­é‚»æ¥è¾¹uwï¼Œä»uåˆ°wä¸å¯èƒ½å­˜åœ¨æ¯”$dis(u, w)$æ›´çŸ­çš„è·¯å¾„ã€‚å› ä¸ºuwå·²ç»æ˜¯æœ€çŸ­çš„äº†ï¼Œä»å…¶å®ƒè·¯å¾„èµ°çš„è¯å¿…ç„¶ç»è¿‡æ¯”uwæ›´é•¿çš„è·¯å¾„ã€‚\nè€Œè¿™ä¹Ÿæ˜¯Dijkstraä¸èƒ½å¤„ç†è´Ÿè¾¹æƒçš„åŸå› ï¼Œå¦‚æœæœ‰è´Ÿè¾¹æƒåˆ™æ— æ³•æ»¡è¶³å‰æã€‚å¯ä»¥çœ‹ä¸‹å›¾è‡ªè¡Œç†è§£ï¼š\né‚£ä¹ˆï¼Œä¾æ®è¿™ä¸ªè´ªå¿ƒæ€§è´¨å¾—åˆ°æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ä»ç°çŸ¥çš„æœ€çŸ­è·¯å¾„å¼€å§‹ï¼Œå»æ›´æ–°èµ·ç‚¹åˆ°å…¶å®ƒç‚¹çš„è·ç¦»ï¼Œå†æ›´æ–°å·²çŸ¥çš„æœ€çŸ­è·¯ï¼Œé‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œéå†å®Œæ‰€æœ‰çš„ç‚¹ä¹‹åï¼Œå°±èƒ½å¾—åˆ°èµ·ç‚¹åˆ°å…¶å®ƒç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚è¯¦ç»†è¿‡ç¨‹å¦‚ä¸‹ï¼š\nå°†èµ·ç‚¹åŠ å…¥å·²ç»ç¡®å®šæœ€çŸ­è·¯çš„é›†åˆSï¼Œå…¶å®ƒç‚¹åˆ™å±äºæœªç¡®å®šçš„é›†åˆV-S=Tã€‚ æ›´æ–°åˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»dis[i]ã€‚ é€‰å–æœªè®¿é—®çš„æœ€å°çš„dis ï¼Œæ ‡è®°å¹¶åŠ å…¥å·²ç»ç¡®å®šæœ€çŸ­è·¯çš„é›†åˆSï¼Œæ­¤æ—¶çš„dis å°±æ˜¯xåˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚ å†ä¾æ®$ dis[y]=min(dis[y], dis +{è¾¹æƒå€¼}w [y]) $ï¼Œæ›´æ–°é›†åˆTä¸­ä¸xç›¸é‚»çš„ç‚¹yåˆ°èµ·ç‚¹çš„æœ€çŸ­è·ç¦»dis[y]ã€‚è¿™ä¸ªæ“ä½œå«åšæ¾å¼›æ“ä½œï¼ˆrelaxï¼‰ï¼Œæ›´æ–°è¿‡åå½“å‰çš„ä¸ç­‰å¼çº¦æŸ$ dis[y] $ç›¸å¯¹äº$ dis+w [y] $å·²ç»ä¸æ˜¯æœ€â€œç´§â€çš„çº¦æŸäº†ï¼Œä¸‹ä¸€æ¬¡æ›´æ–°dis[y]æ—¶å°±ä¸éœ€è¦æ£€æŸ¥è¿™ä¸ªçº¦æŸäº†ï¼Œå³åŸçº¦æŸè¢«â€œæ¾å¼›â€äº†ã€‚ é‡å¤3ï¼Œ4æ­¥éª¤ç›´åˆ°ç›®æ ‡ç‚¹åŠ å…¥é›†åˆï¼Œæ­¤æ—¶ç›®æ ‡ç‚¹å¯¹åº”çš„dis[v]å°±æ˜¯æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚ é‚»æ¥çŸ©é˜µå­˜å›¾ï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š\n1void dijkstra(int s, int n) 2{ 3 dis[s] = 0; 4 for(int i=1; i\u0026lt;=n; i++) 5 { 6 int x = 0; 7 for(int j=1; j\u0026lt;=n; j++) 8 if(!vis[j] \u0026amp;\u0026amp; (x==0 || dis[j]\u0026lt;dis[x])) x = j; 9 10 vis[x] = 1; 11 for(int j=1; j\u0026lt;=n; j++) 12 dis[j] = min(dis[j], dis[x]+g[x][j]); 13 } 14} ä¼˜åŒ– æ—¶é—´å¤æ‚åº¦åˆ†æï¼Œåªåˆ†æé›†åˆæ“ä½œï¼Œnæ¬¡delete-minï¼Œmæ¬¡decrease-keyã€‚\nå¦‚æœç”¨æš´åŠ›ï¼š$O(n^{2}+m)$ã€‚ å¦‚æœç”¨å †ï¼š$O(mlog_{n})$ã€‚ å¦‚æœç”¨priority_queueï¼š$O(mlog_{m})$ã€‚ å¦‚æœç”¨çº¿æ®µæ ‘ï¼ˆZKWçº¿æ®µæ ‘ï¼‰ï¼š$O(mlog_{n}+n)=O(mlog_{n})$ã€‚ å¦‚æœç”¨Fibonacciå †ï¼š$O(nlog_{n}+m)$ã€‚ å¦‚æœä½¿ç”¨priority_queueï¼Œæ— æ³•åˆ é™¤æŸä¸€ä¸ªæ—§çš„ç»“ç‚¹ï¼Œåªèƒ½æ’å…¥ä¸€ä¸ªæƒå€¼æ›´å°çš„ç›¸åŒç¼–å·ç»“ç‚¹ï¼Œè¿™æ ·æ“ä½œå¯¼è‡´å †ä¸­å…ƒç´ æ˜¯$O(m)$çš„ã€‚\nä¸‹é¢ç»™å‡ºä½¿ç”¨é‚»æ¥è¡¨åŠpriority_queueçš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œå³ä¼˜åŒ–äº†å­˜å›¾æ–¹å¼ä»¥åŠå¯»æ‰¾æœªè®¿é—®çš„æœ€å°disç»“ç‚¹è¿‡ç¨‹ã€‚ä»£ç å¦‚ä¸‹ï¼š\n1void dijkstra(int s, int n) 2{ 3 q.push({dis[s]=0, s}); 4 while(!q.empty()){ 5 int u = q.top().second; q.pop(); 6 if(vis[u]) continue; 7 vis[u] = 1; 8 for(int i=H[u]; ~i; i=e[i].next){ 9 int v=e[i].to, w=e[i].w; 10 if(!vis[v] \u0026amp;\u0026amp; dis[u]+w \u0026lt; dis[v]){ 11 dis[v] = dis[u]+w; 12 pre[v] = u; 13 q.push({dis[v], v}); 14 } 15 } 16 } 17} æ¨¡æ¿ åŸå§‹ç‰ˆæœ¬ï¼š\n1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4int g[mxn][mxn]; 5 6void graph_init(int n) 7{ 8 for(int i=1; i\u0026lt;=n; i++){ 9 for(int j=1; j\u0026lt;=n; j++) 10 g[i][j] = inf; 11 g[i][i] = 0; 12 } 13} 14 15int dis[mxn], pre[mxn]; 16bool vis[mxn]; 17 18void dijkstra_init(int n) 19{ 20 for(int i=1; i\u0026lt;=n; i++){ 21 vis[i] = pre[i] = 0; 22 dis[i] = inf; 23 } 24} 25 26void dijkstra(int s, int n) 27{ 28 dis[s] = 0; 29 for(int i=1; i\u0026lt;=n; i++) 30 { 31 int x = 0; 32 for(int j=1; j\u0026lt;=n; j++) 33 if(!vis[j] \u0026amp;\u0026amp; (x==0 || dis[j]\u0026lt;dis[x])) x = j; 34 35 vis[x] = 1; 36 for(int j=1; j\u0026lt;=n; j++){ 37 if(!vis[j] \u0026amp;\u0026amp; dis[x]+g[x][j] \u0026lt; dis[j]){ 38 dis[j] = dis[x]+g[x][j]; 39 pre[j] = x; 40 } 41 } 42 } 43} 44 45int main() 46{ 47 int n, m; 48 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 49 graph_init(n); 50 51 for(int i=0; i\u0026lt;m; i++) 52 { 53 int u, v, w; 54 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 55 g[u][v] = w; 56 } 57 dijkstra_init(n); 58 dijkstra(1, n); 59 60 for(int i=1; i\u0026lt;=n; i++) 61 printf(\u0026#34;%d \u0026#34;, dis[i]); 62 printf(\u0026#34;\\n\u0026#34;); 63 64 for(int i=n; i; i=pre[i]) 65 printf(\u0026#34;%d \u0026#34;, i); 66 printf(\u0026#34;\\n\u0026#34;); 67 68 return 0; 69} 70 71/* 72Sample Input: 73 744 5 751 2 2 761 3 4 772 4 1 783 2 1 793 4 8 80 81Sample Output: 82 830 2 4 3 844 2 1 85 86*/ ä¼˜åŒ–ç‰ˆæœ¬ï¼š\n1const int inf = 0x3f3f3f3f; 2const int mxn = 1e3 + 5; 3 4struct E { 5 int to, next, w; 6} e[mxn]; 7 8int H[mxn], tot; 9 10void add(int from, int to, int w) { 11 e[tot] = {to, H[from], w}; 12 H[from] = tot++; 13} 14 15void graph_init(int n) 16{ 17 for(int i=1; i\u0026lt;=n; i++) 18 H[i] = -1; 19 tot = 0; 20} 21 22int dis[mxn], pre[mxn]; 23bool vis[mxn]; 24priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt;, greater\u0026lt;pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; q; 25 26void dijkstra_init(int n) 27{ 28 for(int i=1; i\u0026lt;=n; i++){ 29 vis[i] = pre[i] = 0; 30 dis[i] = inf; 31 } 32} 33 34void dijkstra(int s, int n) 35{ 36 q.push({dis[s]=0, s}); 37 while(!q.empty()){ 38 int u = q.top().second; q.pop(); 39 if(vis[u]) continue; 40 vis[u] = 1; 41 for(int i=H[u]; ~i; i=e[i].next){ 42 int v=e[i].to, w=e[i].w; 43 if(!vis[v] \u0026amp;\u0026amp; dis[u]+w \u0026lt; dis[v]){ 44 dis[v] = dis[u]+w; 45 pre[v] = u; 46 q.push({dis[v], v}); 47 } 48 } 49 } 50} 51 52int main() 53{ 54 int n, m; 55 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 56 graph_init(n); 57 58 for(int i=0; i\u0026lt;m; i++) 59 { 60 int u, v, w; 61 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 62 add(u, v, w); 63 } 64 dijkstra_init(n); 65 dijkstra(1, n); 66 67 for(int i=1; i\u0026lt;=n; i++) 68 printf(\u0026#34;%d \u0026#34;, dis[i]); 69 printf(\u0026#34;\\n\u0026#34;); 70 71 for(int i=n; i; i=pre[i]) 72 printf(\u0026#34;%d \u0026#34;, i); 73 printf(\u0026#34;\\n\u0026#34;); 74 75 return 0; 76} 77 78/* 79Sample Input: 80 814 5 821 2 2 831 3 4 842 4 1 853 2 1 863 4 8 87 88Sample Output: 89 900 2 4 3 914 2 1 92 93*/ ","permalink":"https://blog.lordash.de/posts/algorithm/dijkstra/","summary":"ç®€ä»‹ Dijkstraç®—æ³•æ˜¯æ±‚è§£å•æºæœ€çŸ­è·¯çš„ç®—æ³•ä¹‹ä¸€ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯è´ªå¿ƒï¼Œåªé€‚ç”¨äºè¾¹æƒä¸ºæ­£çš„æ— å‘å’Œæœ‰å‘å›¾ã€‚åŸå¤æ‚åº¦$O(n^{2})$ï¼Œä¼˜åŒ–åæ—¶é—´","title":"Dijkstra"},{"content":"A+B for Polynomials(PATA-1002) é¢˜é¢ This time, you are supposed to find A+B where A and B are two polynomials.\nè¾“å…¥ Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:\nK N1 aN1 N2 aN2 \u0026hellip; NK aNK\nwhere K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,â‹¯,K) are the exponents and coefficients, respectively. It is given that 1â‰¤Kâ‰¤10ï¼Œ0â‰¤NK\u0026lt;â‹¯\u0026lt;N2\u0026lt;N1â‰¤1000.\nè¾“å‡º For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.\næ ·ä¾‹è¾“å…¥ 12 1 2.4 0 3.2 22 2 1.5 1 0.5 æ ·ä¾‹è¾“å‡º 13 2 1.5 1 2.9 0 3.2 æç¤º æ— \næ€è·¯ ä»£ç  1#define Sg(u) ((u)\u0026gt;eps?1:((u)\u0026lt;-eps?-1:0)) 2#define Abs(u) (Sg(u)\u0026gt;=0?(u):-(u)) 3#define Ze(u) (!Sg(u)) 4#define Eq(u,v) (Ze((u)-(v))) 5const double eps = 1e-6; 6double a[1005]; 7 8int main() 9{ 10 int an; scanf(\u0026#34;%d\u0026#34;, \u0026amp;an); 11 for(int i=0; i\u0026lt;an; i++){ 12 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 13 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[n]); 14 } 15 16 int bn; scanf(\u0026#34;%d\u0026#34;, \u0026amp;bn); 17 for(int i=0; i\u0026lt;bn; i++){ 18 int n; double x; 19 scanf(\u0026#34;%d %lf\u0026#34;, \u0026amp;n, \u0026amp;x); 20 a[n] += x; 21 } 22 23 int ans = 0; 24 for(int i=1000; i\u0026gt;=0; i--){ 25 if(Sg(a[i])) 26 ans++; 27 } 28 printf(\u0026#34;%d\u0026#34;, ans); 29 30 for(int i=1000; i\u0026gt;=0; i--){ 31 if(Sg(a[i])) 32 printf(\u0026#34; %d %.1lf\u0026#34;, i, a[i]); 33 } 34 printf(\u0026#34;\\n\u0026#34;); 35 36 return 0; 37} ","permalink":"https://blog.lordash.de/posts/solution/pata-1002-a+b-for-polynomials/","summary":"A+B for Polynomials(PATA-1002) é¢˜é¢ This time, you are supposed to find A+B where A and B are two polynomials. è¾“å…¥ Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 \u0026hellip; NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,","title":"PATA-1002 A+B for Polynomials"},{"content":"A+B Format(PATA-1001) é¢˜é¢ Calculate a+b and output the sum in standard format \u0026ndash; that is, the digits must be separated into groups of three by commas (unless there are less than four digits).\nè¾“å…¥ Each input file contains one test case. Each case contains a pair of integers a and b where âˆ’10^6â‰¤a,bâ‰¤10^6. The numbers are separated by a space.\nè¾“å‡º For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.\næ ·ä¾‹è¾“å…¥ 1-1000000 9 æ ·ä¾‹è¾“å‡º 1-999,991 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int a, b; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); 4 char s[20]; sprintf(s, \u0026#34;%d\u0026#34;, a+b); 5 int len=strlen(s), f=(a+b\u0026lt;0), st, num; 6 if(f){ 7 st = (len-2)%3+1; 8 num = (len-2)/3; 9 }else{ 10 st = (len-1)%3; 11 num = (len-1)/3; 12 } 13 for(int i=0; i\u0026lt;len; i++){ 14 printf(\u0026#34;%c\u0026#34;, s[i]); 15 if(num \u0026amp;\u0026amp; i==st){ 16 printf(\u0026#34;,\u0026#34;); 17 num--, st+=3; 18 } 19 } 20 return 0; 21} ","permalink":"https://blog.lordash.de/posts/solution/pata-1001-a+b-format/","summary":"A+B Format(PATA-1001) é¢˜é¢ Calculate a+b and output the sum in standard format \u0026ndash; that is, the digits must be separated into groups of three by commas (unless there are less than four digits). è¾“å…¥ Each input file contains one test case. Each case contains a pair of integers a and b where âˆ’10^6â‰¤a,bâ‰¤10^6. The","title":"PATA-1001 A+B Format"},{"content":"Theme Section(HDU-4763) é¢˜é¢ It\u0026rsquo;s time for music! A lot of popular musicians are invited to join us in the music festival. Each of them will play one of their representative songs. To make the programs more interesting and challenging, the hosts are going to add some constraints to the rhythm of the songs, i.e., each song is required to have a \u0026rsquo;theme section\u0026rsquo;. The theme section shall be played at the beginning, the middle, and the end of each song. More specifically, given a theme section E, the song will be in the format of \u0026lsquo;EAEBE\u0026rsquo;, where section A and section B could have arbitrary number of notes. Note that there are 26 types of notes, denoted by lower case letters \u0026lsquo;a\u0026rsquo; - \u0026lsquo;z\u0026rsquo;.\nTo get well prepared for the festival, the hosts want to know the maximum possible length of the theme section of each song. Can you help us?\nè¾“å…¥ The integer N in the first line denotes the total number of songs in the festival. Each of the following N lines consists of one string, indicating the notes of the i-th (1 \u0026lt;= i \u0026lt;= N) song. The length of the string will not exceed 10^6.\nè¾“å‡º There will be N lines in the output, where the i-th line denotes the maximum possible length of the theme section of the i-th song.\næ ·ä¾‹è¾“å…¥ 15 2xy 3abc 4aaa 5aaaaba 6aaxoaaaaa æ ·ä¾‹è¾“å‡º 10 20 31 41 52 æç¤º æ— \næ€è·¯ æ ‡è®°ç¬¬ä¸€ä¸ªEçš„ç»“å°¾ï¼Œæšä¸¾ç¬¬äºŒä¸ªEï¼Œæ»¡è¶³æ¡ä»¶çš„æ±‚ä¸ªmaxå³å¯ã€‚æ•°æ®æœ‰ç‚¹æ°´ã€‚\nä»£ç  1char t[mxn]; 2int nxt[mxn], vis[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 23 while(T--) 24 { 25 scanf(\u0026#34;%s\u0026#34;, t); 26 int n = strlen(t); 27 for(int i=0; i\u0026lt;n; i++) vis[i] = 0; 28 getnxt(t, n); 29 30 for(int i=n; i\u0026gt;0; i=nxt[i]){ 31 if(3*i\u0026lt;=n) 32 vis[i] = 1; 33 } 34 35 int ans=0; 36 for(int i=n-1; i\u0026gt;1; i--) { 37 for(int j=i; j\u0026gt;0; j=nxt[j]) { 38 if(vis[j] \u0026amp;\u0026amp; 2*j\u0026lt;=i \u0026amp;\u0026amp; i+j\u0026lt;=n) { 39 ans = max(ans, j); 40 break; 41 } 42 } 43 } 44 printf(\u0026#34;%d\\n\u0026#34;, ans); 45 } 46 return 0; 47} ","permalink":"https://blog.lordash.de/posts/solution/hdu-4763-theme-section/","summary":"Theme Section(HDU-4763) é¢˜é¢ It\u0026rsquo;s time for music! A lot of popular musicians are invited to join us in the music festival. Each of them will play one of their representative songs. To make the programs more interesting and challenging, the hosts are going to add some constraints to the rhythm of the songs, i.e., each song is required to have a \u0026rsquo;theme section\u0026rsquo;. The theme section shall be played","title":"HDU-4763 Theme Section"},{"content":"Wow! Such Doge!(HDU-4847) é¢˜é¢ Chen, Adrian (November 7, 2013). â€œDoge Is An Ac- tually Good Internet Meme. Wow.â€. Gawker. Retrieved November 22, 2013.\nDoge is an Internet meme that became popular in 2013. The meme typically con- sists of a picture of a Shiba Inu dog ac- companied by multicolored text in Comic Sans MS font in the foreground. The text, representing a kind of internal monologue, is deliberately written in broken English, and usually contains the word â€œwowâ€ and the phrases â€œsuch xâ€, â€œmuch xâ€, â€œmany xâ€, â€œvery xâ€ and â€œso xâ€. Kabosu, the Shiba Inu featured in the original meme, was first pictured in a 2010 blog post by Atsuko Sato, a Japanese kindergarten teacher. Afterwards, varia- tions of the pictures using overlaid Comic Sans text were posted from a Tumblr blog, Shiba Confessions. However, the use of the intentionally misspelled â€œdogeâ€ dates back to June 2005, when it was mentioned in an episode of Homestar Runners puppet series. In August 2013, images of the meme were spammed on Redditâ€™s r/MURICA subreddit by 4chanâ€™s random imageboard, /b/. A search of the term doge on Google Trends shows an explosion of popularity occurring in October 2013, and more so in the following month. By November 2013, the meme had become widespread on the Internet. Google later created a Doge Easter egg: when doge meme was entered into the YouTube search bar, all of the siteâ€™s text would be displayed in colorful Comic Sans, similar to the kind used by the meme. The meme was ranked #12 on MTVâ€™s list of â€œ50 Things Pop Culture Had Us Giving Thanks Forâ€ in 2013. Io9 compared the internal dialog of the Shiba Inu dogs to lolcat-speak. The image most commonly associated with the meme is of a female Shiba Inu named Kabosu, taken from a Japanese blog documenting the dogâ€™s daily activities. The spelling of doge has several variants, leading to debate on its actual pronunciation. On December 13, Doge was named the â€œtop memeâ€ of 2013 by Know Your Meme. In December 2013, the Dogecoin was introduced as a new cryptocurrency, making it the first cryptocurrency to be based on an Internet meme; the viral phenomenon, along with usage of the Comic Sans MS typeface, gave it â€œthe Internet density of a large starâ€ according to Medium writer Quinn Norton. In late December 2013, members of the U.S. Congress produced material in the memeâ€™s style. Huffington Post commented that Doge was â€œkilledâ€ because of the Congress membersâ€™ usage of the meme. By early 2014, Dogeâ€™s popularity was sustained by internet communities on social media, accompanied by the rapid growth and acceptance of Dogecoin. In April 2014, Doge experienced a second major media resurgence due to revelations of the Dogecoin communityâ€™s intent to sponsor Josh Wise in NASCAR and place a picture of the Shiba Inu on his vehicle.\nâ€”â€” Doge (meme). (2014, May 18). In Wikipedia, The Free Encyclopedia. Retrieved 02:00, May 22, 2014, from http://en.wikipedia.org/w/index.php?title=Doge_(meme)\u0026amp;oldid=609040691\nNow, Doge wants to know how many words â€œdogeâ€ are there in a given article. Would you like to help Doge solve this problem?\nè¾“å…¥ An article that Doge wants to know. The size of the article does not exceed 64KB. The article contains only ASCII characters.\nè¾“å‡º Please output the number of word â€œdogeâ€ (case-insensitive). Refer to the samples for more details.\næ ·ä¾‹è¾“å…¥ 1adoge 2cutedo 3yourge 4blownDoge 5lovelyDooge 6Wow! Such Dooooooooooooooge!!! 7D0ge 8dOge DOGE 9dogedoge æ ·ä¾‹è¾“å‡º 16 æç¤º æ— \næ€è·¯ å¯ä»¥ç”¨KMPã€‚\nä»£ç  1char s[mxn], t[] = \u0026#34;doge\u0026#34;; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 ans++; 29 j = 0; 30 // return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 return ans; 36 // return -1; 37} 38 39int main() 40{ 41 int ans = 0; 42 getnxt(t, 4); 43 while(fgets(s, mxn, stdin)) 44 { 45 int n = strlen(s); 46 for(int i=0; i\u0026lt;n; i++) s[i] = tolower(s[i]); 47 ans += KMP(s, t, n, 4); 48 } 49 printf(\u0026#34;%d\\n\u0026#34;, ans); 50 return 0; 51} ","permalink":"https://blog.lordash.de/posts/solution/hdu-4847-wow-such-doge/","summary":"Wow! Such Doge!(HDU-4847) é¢˜é¢ Chen, Adrian (November 7, 2013). â€œDoge Is An Ac- tually Good Internet Meme. Wow.â€. Gawker. Retrieved November 22, 2013. Doge is an Internet meme that became popular in 2013. The meme typically con- sists of a picture of a Shiba Inu dog ac- companied by multicolored text in Comic Sans MS font in the foreground. The","title":"HDU-4847 Wow! Such Doge!"},{"content":"æœ€é•¿å›æ–‡(HDU-3068) é¢˜é¢ ç»™å‡ºä¸€ä¸ªåªç”±å°å†™è‹±æ–‡å­—ç¬¦a,b,c\u0026hellip;y,zç»„æˆçš„å­—ç¬¦ä¸²S,æ±‚Sä¸­æœ€é•¿å›æ–‡ä¸²çš„é•¿åº¦. å›æ–‡å°±æ˜¯æ­£åè¯»éƒ½æ˜¯ä¸€æ ·çš„å­—ç¬¦ä¸²,å¦‚aba, abbaç­‰\nè¾“å…¥ è¾“å…¥æœ‰å¤šç»„case,ä¸è¶…è¿‡120ç»„,æ¯ç»„è¾“å…¥ä¸ºä¸€è¡Œå°å†™è‹±æ–‡å­—ç¬¦a,b,c\u0026hellip;y,zç»„æˆçš„å­—ç¬¦ä¸²S ä¸¤ç»„caseä¹‹é—´ç”±ç©ºè¡Œéš”å¼€(è¯¥ç©ºè¡Œä¸ç”¨å¤„ç†) å­—ç¬¦ä¸²é•¿åº¦len \u0026lt;= 110000\nè¾“å‡º æ¯ä¸€è¡Œä¸€ä¸ªæ•´æ•°x,å¯¹åº”ä¸€ç»„case,è¡¨ç¤ºè¯¥ç»„caseçš„å­—ç¬¦ä¸²ä¸­æ‰€åŒ…å«çš„æœ€é•¿å›æ–‡é•¿åº¦.\næ ·ä¾‹è¾“å…¥ 1aaaa 2 3abab æ ·ä¾‹è¾“å‡º 14 23 æç¤º æ— \næ€è·¯ Manacheræ¨¡æ¿é¢˜ã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int p[mxn]; 3 4int manacher_init(char *s, char *t, int n) 5{ 6 int j = 2; t[0] = \u0026#39;$\u0026#39;, t[1] = \u0026#39;#\u0026#39;; 7 for (int i=0; i\u0026lt;n; i++) 8 { 9 t[j++] = s[i]; 10 t[j++] = \u0026#39;#\u0026#39;; 11 } 12 t[j] = \u0026#39;\\0\u0026#39;; 13 return j; 14} 15 16int manacher(char *t, int *p, int n) 17{ 18 int id = 0, mx = 0, ans = 0; 19 for (int i=1; i\u0026lt;=n; i++) 20 { 21 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 22 23 while (t[i+p[i]] == t[i-p[i]]) p[i]++; // ä¸­å¿ƒæ‰©å±• 24 25 if (mx \u0026lt; i+p[i]) 26 mx = i+p[i], id = i; 27 28 ans = max(ans, p[i]); 29 } 30 return ans-1; 31} 32 33int main() 34{ 35 while(~scanf(\u0026#34;%s\u0026#34;, s)) 36 { 37 int n = manacher_init(s, t, strlen(s)); 38 printf(\u0026#34;%d\\n\u0026#34;, manacher(t, p, n)); 39 } 40 41 return 0; 42} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3068-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/","summary":"æœ€é•¿å›æ–‡(HDU-3068) é¢˜é¢ ç»™å‡ºä¸€ä¸ªåªç”±å°å†™è‹±æ–‡å­—ç¬¦a,b,c\u0026hellip;y,zç»„æˆçš„å­—ç¬¦ä¸²S,æ±‚Sä¸­æœ€é•¿å›æ–‡ä¸²çš„é•¿åº¦. å›æ–‡å°±æ˜¯æ­£å","title":"HDU-3068 æœ€é•¿å›æ–‡"},{"content":"Girls\u0026rsquo; research(HDU-3294) é¢˜é¢ One day, sailormoon girls are so delighted that they intend to research about palindromic strings. Operation contains two steps: First step: girls will write a long string (only contains lower case) on the paper. For example, \u0026ldquo;abcde\u0026rdquo;, but \u0026lsquo;a\u0026rsquo; inside is not the real \u0026lsquo;a\u0026rsquo;, that means if we define the \u0026lsquo;b\u0026rsquo; is the real \u0026lsquo;a\u0026rsquo;, then we can infer that \u0026lsquo;c\u0026rsquo; is the real \u0026lsquo;b\u0026rsquo;, \u0026rsquo;d\u0026rsquo; is the real \u0026lsquo;c\u0026rsquo; â€¦â€¦, \u0026lsquo;a\u0026rsquo; is the real \u0026lsquo;z\u0026rsquo;. According to this, string \u0026ldquo;abcde\u0026rdquo; changes to \u0026ldquo;bcdef\u0026rdquo;. Second step: girls will find out the longest palindromic string in the given string, the length of palindromic string must be equal or more than 2.\nè¾“å…¥ Input contains multiple cases. Each case contains two parts, a character and a string, they are separated by one space, the character representing the real \u0026lsquo;a\u0026rsquo; is and the length of the string will not exceed 200000.All input must be lowercase. If the length of string is len, it is marked from 0 to len-1.\nè¾“å‡º Please execute the operation following the two steps. If you find one, output the start position and end position of palindromic string in a line, next line output the real palindromic string, or output \u0026ldquo;No solution!\u0026rdquo;. If there are several answers available, please choose the string which first appears.\næ ·ä¾‹è¾“å…¥ 1b babd 2a abcd æ ·ä¾‹è¾“å‡º 10 2 2aza 3No solution! æç¤º æ— \næ€è·¯ Manacherï¼Œå­—ç¬¦ç½®æ¢ä¸å½±å“å›æ–‡æ€§è´¨ï¼Œå…ˆæ±‚å‡ºæœ€é•¿å›æ–‡å­ä¸²é•¿åº¦å’Œèµ·ç‚¹ï¼Œè¾“å‡ºçš„æ—¶å€™æ›¿æ¢ä¸€ä¸‹å³å¯ã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int p[mxn], l; 3 4int manacher_init(char *s, char *t, int n) 5{ 6 int j = 2; 7 t[0] = -2, t[1] = -1; 8 9 for (int i = 0; i \u0026lt; n; i++) 10 { 11 t[j++] = s[i]; 12 t[j++] = -1; 13 } 14 t[j] = -3; 15 return j; 16} 17 18int manacher(char *t, int *p, int n) 19{ 20 int id = 0, mx = 0, ans = 0; 21 for (int i = 1; i \u0026lt;= n; i++) 22 { 23 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 24 25 while (t[i+p[i]] == t[i-p[i]]) p[i]++; 26 27 if (mx \u0026lt; i+p[i]) 28 mx = i+p[i], id = i; 29 30 if(ans \u0026lt; p[i]){ 31 ans = p[i]; 32 l = (i-p[i])/2; 33 } 34 } 35 return ans-1; 36} 37 38int main() 39{ 40 char c; 41 while(~scanf(\u0026#34; %c %s\u0026#34;, \u0026amp;c, s)) 42 { 43 int n = manacher_init(s, t, strlen(s)); 44 int ans = manacher(t, p, n); 45 if(ans\u0026gt;2){ 46 printf(\u0026#34;%d %d\\n\u0026#34;, l, l+ans-1); 47 for(int i=0; i\u0026lt;ans; i++){ 48 printf(\u0026#34;%c\u0026#34;, (s[i+l]-c+26)%26+\u0026#39;a\u0026#39;); 49 } 50 printf(\u0026#34;\\n\u0026#34;); 51 }else{ 52 printf(\u0026#34;No solution!\\n\u0026#34;); 53 } 54 } 55 return 0; 56} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3294-girls-research/","summary":"Girls\u0026rsquo; research(HDU-3294) é¢˜é¢ One day, sailormoon girls are so delighted that they intend to research about palindromic strings. Operation contains two steps: First step: girls will write a long string (only contains lower case) on the paper. For example, \u0026ldquo;abcde\u0026rdquo;, but \u0026lsquo;a\u0026rsquo; inside is not the real \u0026lsquo;a\u0026rsquo;, that means if we define the \u0026lsquo;b\u0026rsquo; is the real \u0026lsquo;a\u0026rsquo;, then we can infer that \u0026lsquo;c\u0026rsquo; is the real \u0026lsquo;b\u0026rsquo;,","title":"HDU-3294 Girls' research"},{"content":"å‰å“¥ç³»åˆ—æ•…äº‹-å®Œç¾é˜Ÿå½¢II(HDU-4513) é¢˜é¢ å‰å“¥åˆæƒ³å‡ºäº†ä¸€ä¸ªæ–°çš„å®Œç¾é˜Ÿå½¢æ¸¸æˆï¼ å‡è®¾æœ‰nä¸ªäººæŒ‰é¡ºåºç«™åœ¨ä»–çš„é¢å‰ï¼Œä»–ä»¬çš„èº«é«˜åˆ†åˆ«æ˜¯h[1], h[2] \u0026hellip; h[n]ï¼Œå‰å“¥å¸Œæœ›ä»ä¸­æŒ‘å‡ºä¸€äº›äººï¼Œè®©è¿™äº›äººå½¢æˆä¸€ä¸ªæ–°çš„é˜Ÿå½¢ï¼Œæ–°çš„é˜Ÿå½¢è‹¥æ»¡è¶³ä»¥ä¸‹ä¸‰ç‚¹è¦æ±‚ï¼Œåˆ™å°±æ˜¯æ–°çš„å®Œç¾é˜Ÿå½¢ï¼š\n1ã€æŒ‘å‡ºçš„äººä¿æŒåŸé˜Ÿå½¢çš„ç›¸å¯¹é¡ºåºä¸å˜ï¼Œä¸”å¿…é¡»éƒ½æ˜¯åœ¨åŸé˜Ÿå½¢ä¸­è¿ç»­çš„ï¼› 2ã€å·¦å³å¯¹ç§°ï¼Œå‡è®¾æœ‰mä¸ªäººå½¢æˆæ–°çš„é˜Ÿå½¢ï¼Œåˆ™ç¬¬1ä¸ªäººå’Œç¬¬mä¸ªäººèº«é«˜ç›¸åŒï¼Œç¬¬2ä¸ªäººå’Œç¬¬m-1ä¸ªäººèº«é«˜ç›¸åŒï¼Œä¾æ­¤ç±»æ¨ï¼Œå½“ç„¶å¦‚æœmæ˜¯å¥‡æ•°ï¼Œä¸­é—´é‚£ä¸ªäººå¯ä»¥ä»»æ„ï¼› 3ã€ä»å·¦åˆ°ä¸­é—´é‚£ä¸ªäººï¼Œèº«é«˜éœ€ä¿è¯ä¸ä¸‹é™ï¼Œå¦‚æœç”¨Hè¡¨ç¤ºæ–°é˜Ÿå½¢çš„é«˜åº¦ï¼Œåˆ™H[1] \u0026lt;= H[2] \u0026lt;= H[3] \u0026hellip;. \u0026lt;= H[mid]ã€‚\nç°åœ¨å‰å“¥æƒ³çŸ¥é“ï¼šæœ€å¤šèƒ½é€‰å‡ºå¤šå°‘äººç»„æˆæ–°çš„å®Œç¾é˜Ÿå½¢å‘¢ï¼Ÿ\nè¾“å…¥ è¾“å…¥æ•°æ®ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°Tï¼Œè¡¨ç¤ºæ€»å…±æœ‰Tç»„æµ‹è¯•æ•°æ®(T \u0026lt;= 20)ï¼› æ¯ç»„æ•°æ®é¦–å…ˆæ˜¯ä¸€ä¸ªæ•´æ•°n(1 \u0026lt;= n \u0026lt;= 100000)ï¼Œè¡¨ç¤ºåŸå…ˆé˜Ÿå½¢çš„äººæ•°ï¼Œæ¥ä¸‹æ¥ä¸€è¡Œè¾“å…¥nä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåŸé˜Ÿå½¢ä»å·¦åˆ°å³ç«™çš„äººçš„èº«é«˜ï¼ˆ50 \u0026lt;= h \u0026lt;= 250ï¼Œä¸æ’é™¤ç‰¹åˆ«çŸ®å°å’Œé«˜å¤§çš„ï¼‰ã€‚\nè¾“å‡º è¯·è¾“å‡ºèƒ½ç»„æˆå®Œç¾é˜Ÿå½¢çš„æœ€å¤šäººæ•°ï¼Œæ¯ç»„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 12 23 351 52 51 44 551 52 52 51 æ ·ä¾‹è¾“å‡º 13 24 æç¤º æ— \næ€è·¯ Manacherï¼Œä¸­å¿ƒæ‰©å±•çš„æ—¶å€™åˆ¤æ–­ä¸€ä¸‹æ¡ä»¶å³å¯ã€‚\nä»£ç  1int s[mxn], t[mxn]; 2int p[mxn]; 3 4int manacher_init(int *s, int *t, int n) 5{ 6 int j = 2; 7 t[0] = -2, t[1] = -1; 8 9 for (int i = 0; i \u0026lt; n; i++) 10 { 11 t[j++] = s[i]; 12 t[j++] = -1; 13 } 14 t[j] = -3; 15 return j; 16} 17 18int manacher(int *t, int *p, int n) 19{ 20 int id = 0, mx = 0, ans = 0; 21 for (int i = 1; i \u0026lt;= n; i++) 22 { 23 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 24 25 while (t[i+p[i]] == t[i-p[i]]){ 26 if(t[i+p[i]-2] \u0026lt; t[i+p[i]]) break; 27 p[i]++; 28 } 29 30 if (mx \u0026lt; i+p[i]) 31 mx = i+p[i], id = i; 32 33 ans = max(ans, p[i]); 34 } 35 return ans-1; 36} 37 38int main() 39{ 40 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 41 while(T--) 42 { 43 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 44 for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); 45 n = manacher_init(s, t, n); 46 printf(\u0026#34;%d\\n\u0026#34;, manacher(t, p, n)); 47 } 48 return 0; 49} ","permalink":"https://blog.lordash.de/posts/solution/hdu-4513-%E5%90%89%E5%93%A5%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B-%E5%AE%8C%E7%BE%8E%E9%98%9F%E5%BD%A2ii/","summary":"å‰å“¥ç³»åˆ—æ•…äº‹-å®Œç¾é˜Ÿå½¢II(HDU-4513) é¢˜é¢ å‰å“¥åˆæƒ³å‡ºäº†ä¸€ä¸ªæ–°çš„å®Œç¾é˜Ÿå½¢æ¸¸æˆï¼ å‡è®¾æœ‰nä¸ªäººæŒ‰é¡ºåºç«™åœ¨ä»–çš„é¢å‰ï¼Œä»–ä»¬çš„èº«é«˜åˆ†åˆ«æ˜¯h[1]","title":"HDU-4513 å‰å“¥ç³»åˆ—æ•…äº‹-å®Œç¾é˜Ÿå½¢II"},{"content":"Finding Palindromes(POJ-3376) é¢˜é¢ A word is called a palindrome if we read from right to left is as same as we read from left to right. For example, \u0026ldquo;dad\u0026rdquo;, \u0026ldquo;eye\u0026rdquo; and \u0026ldquo;racecar\u0026rdquo; are all palindromes, but \u0026ldquo;odd\u0026rdquo;, \u0026ldquo;see\u0026rdquo; and \u0026ldquo;orange\u0026rdquo; are not palindromes.\nGiven n strings, you can generate n Ã— n pairs of them and concatenate the pairs into single words. The task is to count how many of the so generated words are palindromes.\nè¾“å…¥ The first line of input file contains the number of strings n. The following n lines describe each string:\nThe i+1-th line contains the length of the i-th string li, then a single space and a string of li small letters of English alphabet.\nYou can assume that the total length of all strings will not exceed 2,000,000. Two strings in different line may be the same.\nè¾“å‡º Print out only one integer, the number of palindromes.\næ ·ä¾‹è¾“å…¥ 13 21 a 32 ab 42 ba æ ·ä¾‹è¾“å‡º 15 æç¤º The 5 palindromes are: aa aba aba abba baab\næ€è·¯ æŠŠæ‰€æœ‰æ­£ä¸²éƒ½åŠ è¿›ä¸€æ£µTrieï¼Œç„¶åç”¨æ¯ä¸ªä¸²çš„é€†ä¸²å»è·‘Trieï¼Œæ­¤æ—¶ä¼šå‡ºç°ä»¥ä¸‹æƒ…å†µï¼š\nåŒ¹é…å®Œæˆï¼Œé‚£ä¹ˆå°±è¯´æ˜å­˜åœ¨ä¸€ä¸ªæ­£ä¸²çš„å‰ç¼€æ˜¯è¿™ä¸ªé€†ä¸²ã€‚å¦‚æœå‰©ä½™çš„é€†ä¸²å›æ–‡ï¼Œé‚£ä¹ˆèƒ½å½¢æˆå›æ–‡ã€‚ åŒ¹é…å¤±è´¥ï¼ŒTrieæœªç»“æŸï¼Œè¯´æ˜ä¸èƒ½æ„æˆå›æ–‡ã€‚ Trieå·²ç»è·‘åˆ°å¶å­èŠ‚ç‚¹ï¼ŒåŒ¹é…æœªç»“æŸï¼Œé‚£ä¹ˆå¦‚æœæ­£ä¸²å‰©ä½™éƒ¨åˆ†å›æ–‡ï¼Œé‚£ä¹ˆèƒ½å½¢æˆå›æ–‡ã€‚ ç”¨æ‰©å±•KMPå¤„ç†å‡ºä¸€ä¸ªä¸²çš„æ¯ä¸ªåç¼€æ˜¯ä¸æ˜¯å›æ–‡ä¸²ï¼Œæ–¹æ³•æ˜¯ç”¨è¯¥ä¸²å’Œå…¶é€†ä¸²ä»…ç”¨æ‰©å±•KMPåŒ¹é…ï¼Œå¦‚æœex[i]=ï¼ˆä»iåˆ°æœ«å°¾çš„é•¿åº¦ï¼‰ï¼Œé‚£ä¹ˆè¯´æ˜ä»iåˆ°æœ«å°¾çš„åç¼€æ˜¯å›æ–‡çš„ã€‚\nä»£ç  1char s[mxn], t[mxn], rev[mxn]; 2int nxt[mxn], extend[mxn]; 3int tree[mxn][26], exist[mxn], cnt = 0; 4int len[mxn], val[mxn]; 5LL ans = 0; 6 7void getnxt(char* t, int m) 8{ 9 int a, p; nxt[0] = m; 10 for (int i=1, j=-1; i\u0026lt;m; i++, j--) 11 { 12 if (j\u0026lt;0 || i+nxt[i-a] \u0026gt;= p) 13 { 14 if (j\u0026lt;0) p = i, j = 0; 15 while (p\u0026lt;m \u0026amp;\u0026amp; t[p]==t[j]) p++, j++; 16 nxt[i] = j, a = i; 17 } else 18 nxt[i] = nxt[i-a]; 19 } 20} 21 22void exKMP(char* s, char* t, int n, int m) 23{ 24 int a, p; 25 for (int i=0, j=-1; i\u0026lt;n; i++, j--) //jå³ç­‰äºpä¸içš„è·ç¦»ï¼Œå…¶ä½œç”¨æ˜¯åˆ¤æ–­iæ˜¯å¦å¤§äºpï¼ˆå¦‚æœj\u0026lt;0ï¼Œåˆ™iå¤§äºpï¼‰ 26 { 27 if (j\u0026lt;0 || i+nxt[i-a] \u0026gt;= p) 28 { 29 if (j\u0026lt;0) p = i, j = 0; //å¦‚æœiå¤§äºp 30 while (p\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;m \u0026amp;\u0026amp; s[p]==t[j]) p++, j++; 31 extend[i] = j, a = i; 32 } else 33 extend[i] = nxt[i-a]; 34 } 35} 36 37void insert(char *s, int n) 38{ 39 int p = 0; 40 for (int i=0; i\u0026lt;n; i++) 41 { 42 int c = s[i] - \u0026#39;a\u0026#39;; 43 if (!tree[p][c]) tree[p][c] = ++cnt; 44 p = tree[p][c]; 45 val[p] += (i+1\u0026lt;n \u0026amp;\u0026amp; extend[i+1]==n-i-1) ? 1 : 0; 46 } 47 exist[p]++; 48} 49 50int search(char *s, int n) 51{ 52 int p = 0; 53 for (int i=0; i\u0026lt;n; i++) 54 { 55 int c = s[i] - \u0026#39;a\u0026#39;; 56 if (!tree[p][c]) return 0; 57 p = tree[p][c]; 58 ans += (exist[p] \u0026amp;\u0026amp; (i+1\u0026gt;=n || extend[i+1]==n-i-1)) ? exist[p] : 0; 59 } 60 ans += val[p]; 61 return exist[p]; 62} 63 64int main() 65{ 66 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 67 int st = 0; 68 for(int i=0; i\u0026lt;n; i++){ 69 scanf(\u0026#34;%d %s\u0026#34;, \u0026amp;len[i], s+st); 70 for(int j=0; j\u0026lt;len[i]; j++) 71 rev[j] = s[st+len[i]-j-1]; 72 getnxt(rev, len[i]); 73 exKMP(s+st, rev, len[i], len[i]); 74 insert(s+st, len[i]); 75 st += len[i]; 76 } 77 ans = st = 0; 78 for(int i=0; i\u0026lt;n; i++){ 79 for(int j=0; j\u0026lt;len[i]; j++) 80 rev[j] = s[st+len[i]-j-1]; 81 getnxt(s+st, len[i]); 82 exKMP(rev, s+st, len[i], len[i]); 83 search(rev, len[i]); 84 st += len[i]; 85 } 86 printf(\u0026#34;%lld\\n\u0026#34;, ans); 87 return 0; 88} ","permalink":"https://blog.lordash.de/posts/solution/poj-3376-finding-palindromes/","summary":"Finding Palindromes(POJ-3376) é¢˜é¢ A word is called a palindrome if we read from right to left is as same as we read from left to right. For example, \u0026ldquo;dad\u0026rdquo;, \u0026ldquo;eye\u0026rdquo; and \u0026ldquo;racecar\u0026rdquo; are all palindromes, but \u0026ldquo;odd\u0026rdquo;, \u0026ldquo;see\u0026rdquo; and \u0026ldquo;orange\u0026rdquo; are not palindromes. Given n strings, you can generate n Ã— n pairs of them and concatenate the pairs into single words. The task is to count how many","title":"POJ-3376 Finding Palindromes"},{"content":"Palindrome(POJ-3974) é¢˜é¢ Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, \u0026ldquo;Can you propose an efficient algorithm to find the length of the largest palindrome in a string?\u0026rdquo;\nA string is said to be a palindrome if it reads the same both forwards and backwards, for example \u0026ldquo;madam\u0026rdquo; is a palindrome while \u0026ldquo;acm\u0026rdquo; is not.\nThe students recognized that this is a classical problem but couldn\u0026rsquo;t come up with a solution better than iterating over all substrings and checking whether they are palindrome or not, obviously this algorithm is not efficient at all, after a while Andy raised his hand and said \u0026ldquo;Okay, I\u0026rsquo;ve a better algorithm\u0026rdquo; and before he starts to explain his idea he stopped for a moment and then said \u0026ldquo;Well, I\u0026rsquo;ve an even better algorithm!\u0026rdquo;.\nIf you think you know Andy\u0026rsquo;s final solution then prove it! Given a string of at most 1000000 characters find and print the length of the largest palindrome inside this string.\nè¾“å…¥ Your program will be tested on at most 30 test cases, each test case is given as a string of at most 1000000 lowercase characters on a line by itself. The input is terminated by a line that starts with the string \u0026ldquo;END\u0026rdquo; (quotes for clarity).\nè¾“å‡º For each test case in the input print the test case number and the length of the largest palindrome.\næ ·ä¾‹è¾“å…¥ 1abcbabcbabcba 2abacacbaaaab 3END æ ·ä¾‹è¾“å‡º 1Case 1: 13 2Case 2: 6 æç¤º æ— \næ€è·¯ Manacheræ¨¡æ¿é¢˜ã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int p[mxn]; 3 4int manacher_init(char *s, char *t, int n) 5{ 6 int j = 2; t[0] = \u0026#39;$\u0026#39;, t[1] = \u0026#39;#\u0026#39;; 7 for (int i=0; i\u0026lt;n; i++) 8 { 9 t[j++] = s[i]; 10 t[j++] = \u0026#39;#\u0026#39;; 11 } 12 t[j] = \u0026#39;\\0\u0026#39;; 13 return j; 14} 15 16int manacher(char *t, int *p, int n) 17{ 18 int id = 0, mx = 0, ans = 0; 19 for (int i=1; i\u0026lt;=n; i++) 20 { 21 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 22 23 while (t[i+p[i]] == t[i-p[i]]) p[i]++; // ä¸­å¿ƒæ‰©å±• 24 25 if (mx \u0026lt; i+p[i]) 26 mx = i+p[i], id = i; 27 28 ans = max(ans, p[i]); 29 } 30 return ans-1; 31} 32 33int main() 34{ 35 int cs = 1; 36 while(scanf(\u0026#34;%s\u0026#34;, s)==1 \u0026amp;\u0026amp; strcmp(s, \u0026#34;END\u0026#34;)) 37 { 38 int n = manacher_init(s, t, strlen(s)); 39 printf(\u0026#34;Case %d: %d\\n\u0026#34;, cs++, manacher(t, p, n)); 40 } 41 42 return 0; 43} ","permalink":"https://blog.lordash.de/posts/solution/poj-3974-palindrome/","summary":"Palindrome(POJ-3974) é¢˜é¢ Andy the smart computer science student was attending an algorithms class when the professor asked the students a simple question, \u0026ldquo;Can you propose an efficient algorithm to find the length of the largest palindrome in a string?\u0026rdquo; A string is said to be a palindrome if it reads the same both forwards and backwards, for example \u0026ldquo;madam\u0026rdquo; is a palindrome while \u0026ldquo;acm\u0026rdquo; is not. The students recognized","title":"POJ-3974 Palindrome"},{"content":"ç®€ä»‹ å­—å…¸æ ‘åˆç§°å•è¯æŸ¥æ‰¾æ ‘ï¼ŒTrieæ ‘ï¼Œæ˜¯ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œæ˜¯ä¸€ç§å“ˆå¸Œæ ‘çš„å˜ç§ã€‚å…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡ï¼Œæ’åºå’Œä¿å­˜å¤§é‡çš„å­—ç¬¦ä¸²ï¼ˆä½†ä¸ä»…é™äºå­—ç¬¦ä¸²ï¼‰ã€‚ä¼˜ç‚¹æ˜¯åˆ©ç”¨å­—ç¬¦ä¸²çš„å…¬å…±å‰ç¼€æ¥å‡å°‘æŸ¥è¯¢æ—¶é—´ï¼Œæœ€å¤§é™åº¦åœ°å‡å°‘æ— è°“çš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼ŒæŸ¥è¯¢æ•ˆç‡æ¯”å“ˆå¸Œæ ‘é«˜ã€‚\nTrie å­—å…¸æ ‘çš„ç»“æ„å¦‚ä¸‹ï¼š\nå­—å…¸æ ‘ç”¨è¾¹æ¥ä»£è¡¨å­—æ¯ï¼Œè€Œä»æ ¹ç»“ç‚¹åˆ°æ ‘ä¸ŠæŸä¸€ç»“ç‚¹çš„è·¯å¾„å°±ä»£è¡¨äº†ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™é¢—å­—å…¸æ ‘åŒ…å«çš„å­—ç¬¦ä¸²æœ‰{\u0026ldquo;in\u0026rdquo;, \u0026ldquo;inn\u0026rdquo;, \u0026ldquo;int\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;ten\u0026rdquo;, \u0026ldquo;to\u0026rdquo;}ã€‚\nTrieçš„ç»“æ„éå¸¸å¥½æ‡‚ï¼Œæˆ‘ä»¬ç”¨$\\delta(u, c)$è¡¨ç¤ºç»“ç‚¹uçš„cå­—ç¬¦æŒ‡å‘çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œæˆ–ç€è¯´æ˜¯ç»“ç‚¹uä»£è¡¨çš„å­—ç¬¦ä¸²åé¢æ·»åŠ ä¸€ä¸ªå­—ç¬¦cå½¢æˆçš„å­—ç¬¦ä¸²çš„ç»“ç‚¹ã€‚ï¼ˆcçš„å–å€¼èŒƒå›´å’Œå­—ç¬¦é›†å¤§å°æœ‰å…³ï¼Œä¸ä¸€å®šæ˜¯0~26ï¼‰ã€‚æœ‰æ—¶éœ€è¦æ ‡è®°æ’å…¥è¿› trie çš„æ˜¯å“ªäº›å­—ç¬¦ä¸²ï¼Œæ¯æ¬¡æ’å…¥å®Œæˆæ—¶åœ¨è¿™ä¸ªå­—ç¬¦ä¸²æ‰€ä»£è¡¨çš„èŠ‚ç‚¹å¤„æ‰“ä¸Šæ ‡è®°å³å¯ã€‚\nTrieä¸€èˆ¬æ”¯æŒä¸¤ä¸ªæ“ä½œï¼š\næ’å…¥æ“ä½œï¼Œå°±æ˜¯å°†ä¸€ä¸ªå­—ç¬¦ä¸²såŠ å…¥åˆ°é›†åˆä¸­ã€‚ æŸ¥è¯¢æ“ä½œï¼Œå°±æ˜¯æŸ¥è¯¢ä¸€ä¸ªå­—ç¬¦ä¸²Sæ˜¯ä¸æ˜¯åœ¨é›†åˆä¸­ã€‚ å®ç°ä»£ç å¦‚ä¸‹ï¼š\n1void insert(char *s, int n) 2{ 3 int p = 0; 4 for (int i=0; i\u0026lt;n; i++) 5 { 6 int c = s[i] - \u0026#39;a\u0026#39;; 7 if (!tree[p][c]) tree[p][c] = ++cnt; 8 p = tree[p][c]; 9 } 10 exist[p]++; 11} 12 13int search(char *s, int n) 14{ 15 int p = 0; 16 for (int i=0; i\u0026lt;n; i++) 17 { 18 int c = s[i] - \u0026#39;a\u0026#39;; 19 if (!tree[p][c]) return 0; 20 p = tree[p][c]; 21 } 22 return exist[p]; 23} æ¨¡æ¿ 1char s[mxn]; 2int tree[100000][26], exist[100000], cnt = 0; 3 4void insert(char *s, int n) 5{ 6 int p = 0; 7 for (int i=0; i\u0026lt;n; i++) 8 { 9 int c = s[i] - \u0026#39;a\u0026#39;; 10 if (!tree[p][c]) tree[p][c] = ++cnt; 11 p = tree[p][c]; 12 } 13 exist[p]++; 14} 15 16int search(char *s, int n) 17{ 18 int p = 0; 19 for (int i=0; i\u0026lt;n; i++) 20 { 21 int c = s[i] - \u0026#39;a\u0026#39;; 22 if (!tree[p][c]) return 0; 23 p = tree[p][c]; 24 } 25 return exist[p]; 26} 27 28int main() 29{ 30 int n, m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 31 for(int i=0; i\u0026lt;n; i++){ 32 scanf(\u0026#34;%s\u0026#34;, s); 33 insert(s, strlen(s)); 34 } 35 for(int i=0; i\u0026lt;m; i++){ 36 scanf(\u0026#34;%s\u0026#34;, s); 37 printf(\u0026#34;%d\\n\u0026#34;, search(s, strlen(s))); 38 } 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/algorithm/%E5%AD%97%E5%85%B8%E6%A0%91/","summary":"ç®€ä»‹ å­—å…¸æ ‘åˆç§°å•è¯æŸ¥æ‰¾æ ‘ï¼ŒTrieæ ‘ï¼Œæ˜¯ä¸€ç§æ ‘å½¢ç»“æ„ï¼Œæ˜¯ä¸€ç§å“ˆå¸Œæ ‘çš„å˜ç§ã€‚å…¸å‹åº”ç”¨æ˜¯ç”¨äºç»Ÿè®¡ï¼Œæ’åºå’Œä¿å­˜å¤§é‡çš„å­—ç¬¦ä¸²ï¼ˆä½†ä¸ä»…é™äºå­—ç¬¦ä¸²ï¼‰ã€‚ä¼˜","title":"å­—å…¸æ ‘"},{"content":"Best Reward(HDU-3613) é¢˜é¢ After an uphill battle, General Li won a great victory. Now the head of state decide to reward him with honor and treasures for his great exploit.\nOne of these treasures is a necklace made up of 26 different kinds of gemstones, and the length of the necklace is n. (That is to say: n gemstones are stringed together to constitute this necklace, and each of these gemstones belongs to only one of the 26 kinds.)\nIn accordance with the classical view, a necklace is valuable if and only if it is a palindrome - the necklace looks the same in either direction. However, the necklace we mentioned above may not a palindrome at the beginning. So the head of state decide to cut the necklace into two part, and then give both of them to General Li.\nAll gemstones of the same kind has the same value (may be positive or negative because of their quality - some kinds are beautiful while some others may looks just like normal stones). A necklace that is palindrom has value equal to the sum of its gemstones\u0026rsquo; value. while a necklace that is not palindrom has value zero.\nNow the problem is: how to cut the given necklace so that the sum of the two necklaces\u0026rsquo;s value is greatest. Output this value.\nè¾“å…¥ The first line of input is a single integer T (1 â‰¤ T â‰¤ 10) - the number of test cases. The description of these test cases follows.\nFor each test case, the first line is 26 integers: v1, v2, \u0026hellip;, v26 (-100 â‰¤ vi â‰¤ 100, 1 â‰¤ i â‰¤ 26), represent the value of gemstones of each kind.\nThe second line of each test case is a string made up of charactor \u0026lsquo;a\u0026rsquo; to \u0026lsquo;z\u0026rsquo;. representing the necklace. Different charactor representing different kinds of gemstones, and the value of \u0026lsquo;a\u0026rsquo; is v1, the value of \u0026lsquo;b\u0026rsquo; is v2, \u0026hellip;, and so on. The length of the string is no more than 500000.\nè¾“å‡º Output a single Integer: the maximum value General Li can get from the necklace.\næ ·ä¾‹è¾“å…¥ 12 21 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3aba 41 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 5acacac æ ·ä¾‹è¾“å‡º 11 26 æç¤º æ— \næ€è·¯ å°†ä¸€ä¸ªå­—ç¬¦ä¸²åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œè‹¥æŸä¸€å­ä¸²æ˜¯å›æ–‡ä¸²ï¼Œåˆ™è¯¥å­ä¸²çš„ä»·å€¼ä¸ºå„å­—ç¬¦çš„æƒå€¼å’Œï¼Œå¦åˆ™ä»·å€¼ä¸º0ã€‚æ±‚ä¸€ç§åˆ†å‰²æ–¹æ³•ï¼Œä½¿å¾—ä¸¤éƒ¨åˆ†ä»·å€¼å’Œæœ€å¤§ã€‚\né¦–å…ˆè·‘ä¸€éManacherï¼Œå¯¹äºåŸä¸²çš„å‰ç¼€å›æ–‡å­ä¸²ï¼Œæ»¡è¶³ä¸­å¿ƒç‚¹i==p[i]ï¼Œè€Œå¯¹äºåŸä¸²çš„åç¼€å›æ–‡å­ä¸²ï¼Œæ»¡è¶³ä¸­å¿ƒç‚¹i+p[i] == å¤„ç†è¿‡çš„åŸä¸²é•¿åº¦ å³2*len(åŸä¸²)+2ã€‚iä¸ºå¤„ç†è¿‡çš„å­—ç¬¦ä¸²æ•°ç»„ä¸‹æ ‡ï¼Œpæ•°ç»„æ˜¯æœ€å¤§å›æ–‡åŠå¾„ã€‚\næ‰€ä»¥æšä¸¾n+n-1ä¸ªå›æ–‡ä¸­å¿ƒï¼Œçœ‹æ˜¯å¦æ˜¯åŸä¸²çš„å‰ç¼€å›æ–‡å­ä¸²ï¼Œè®¨è®ºå‰©ä¸‹çš„éƒ¨åˆ†ï¼Œè‹¥å‰©ä¸‹éƒ¨åˆ†æ˜¯å›æ–‡ä¸²ï¼Œåˆ™å¯èƒ½çš„å›æ–‡ä¸­å¿ƒr = (å¤„ç†è¿‡çš„åŸä¸²é•¿åº¦n + å‰ç¼€å›æ–‡å­ä¸²çš„å³ç«¯ç‚¹i+p[i]-1) / 2ï¼Œä»¥æ­¤åˆ¤æ–­ååŠéƒ¨åˆ†æ˜¯å¦ä¸ºå›æ–‡ä¸²ï¼Œå–æœ€å¤§ä»·å€¼å’Œå³å¯ã€‚è·å–å›æ–‡å­ä¸²çš„ä»·å€¼å¯ä»¥ç”¨å‰ç¼€å’Œä¼˜åŒ–ã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int p[mxn]; 3 4int manacher_init(char *s, char *t, int n) 5{ 6 int j = 2; t[0] = \u0026#39;$\u0026#39;, t[1] = \u0026#39;#\u0026#39;; 7 for (int i=0; i\u0026lt;n; i++) 8 { 9 t[j++] = s[i]; 10 t[j++] = \u0026#39;#\u0026#39;; 11 } 12 t[j] = \u0026#39;\\0\u0026#39;; 13 return j; 14} 15 16int manacher(char *t, int *p, int n) 17{ 18 int id = 0, mx = 0, ans = 0; 19 for (int i=1; i\u0026lt;=n; i++) 20 { 21 p[i] = mx\u0026gt;i ? min(p[2*id-i], mx-i) : 1; 22 23 while (t[i+p[i]] == t[i-p[i]]) p[i]++; 24 25 if (mx \u0026lt; i+p[i]) 26 mx = i+p[i], id = i; 27 28 ans = max(ans, p[i]); 29 } 30 return ans-1; 31} 32 33int a[30]; 34int sum[mxn]; 35 36int main() 37{ 38 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 39 while(T--) 40 { 41 for(int i=0; i\u0026lt;26; i++) 42 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 43 scanf(\u0026#34;%s\u0026#34;, s); 44 int n = manacher_init(s, t, strlen(s)); 45 manacher(t, p, n); 46 47 /* å‰ç¼€å’Œ */ 48 sum[0] = sum[1] = 0; 49 for(int i=2; i\u0026lt;n; i++){ 50 sum[i] = i\u0026amp;1 ? sum[i-1] : sum[i-2] + a[t[i]-\u0026#39;a\u0026#39;]; 51 } 52 53 int ans = 0; 54 for(int i=2; i\u0026lt;n; i++) // æšä¸¾å‰åŠéƒ¨åˆ†å›æ–‡ä¸­å¿ƒ 55 { 56 int a=0, b=0; 57 if(i==p[i]){ // å¦‚æœå‰åŠéƒ¨åˆ†æ˜¯å›æ–‡ä¸² 58 a = sum[i+p[i]-1]; 59 } 60 61 int r = (n + i+p[i]-1)/2; // è·å¾—ååŠéƒ¨åˆ†å›æ–‡ä¸­å¿ƒ 62 if(r == n-1) // å‰åŠéƒ¨åˆ†ä¸ºåŸä¸²ï¼Œæ²¡æœ‰ååŠéƒ¨åˆ† 63 continue; 64 65 if(r+p[r] == n){ // å¦‚æœååŠéƒ¨åˆ†æ˜¯å›æ–‡ä¸² 66 b = sum[n-2] - sum[i+p[i]-1]; 67 } 68 ans = max(ans, a+b); 69 } 70 printf(\u0026#34;%d\\n\u0026#34;, ans); 71 } 72 73 return 0; 74} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3613-best-reward/","summary":"Best Reward(HDU-3613) é¢˜é¢ After an uphill battle, General Li won a great victory. Now the head of state decide to reward him with honor and treasures for his great exploit. One of these treasures is a necklace made up of 26 different kinds of gemstones, and the length of the necklace is n. (That is to say: n gemstones are stringed together to constitute this necklace, and each of","title":"HDU-3613 Best Reward"},{"content":"Teacher YYF(POJ-3746) é¢˜é¢ As we all know, grammar is very important when learning English. Now, YYF become a teacher of a primary school. The students are good at memory so they can tell the meaning and the function (noun, verb â€¦) of the words in the textbook. But, they cannot use these words properly.\nIn YYFâ€™s mind, writing sentences is a good way to learn grammar. So he tells the student to write 20 sentences a day, using the word learned in the class. As YYF has a lot of student, he will receive many sentences from his student. What a horrible work to check all the sentences. You are one of YYFâ€™s friends, so he asks you for help. You task is to write a program to check the sentences.\nTo make the work simple, YYF chooses a part of the grammar: All the words can be grouped into seven divisions (noun, pronoun, adjective, adverb, preposition, article, and verb). A verb can be transitive or intransitive. So we use \u0026ldquo;n.\u0026rdquo;, \u0026ldquo;pron.\u0026rdquo;, \u0026ldquo;adj.\u0026rdquo;, \u0026ldquo;adv.\u0026rdquo;, \u0026ldquo;prep.\u0026rdquo;, \u0026ldquo;art.\u0026rdquo;, \u0026ldquo;vt.\u0026rdquo; and \u0026ldquo;vi.\u0026rdquo; to be short of noun, pronoun, adjective, adverb, preposition, article, transitive verb and intransitive verb. If a word is marked as \u0026ldquo;v.\u0026rdquo;, it can be used as either transitive verb or intransitive verb.\nHere comes the sentence structure:\nSubject + Intransitive Verb Subject + Transitive Verb + Object Noun and pronoun can be used as Subject or Object. When using a noun, an article should be placed ahead of it. A noun can be modified by an adjective and a verb can be modified by an adverb. When an adjective is used to modify a noun, it should be put between article and noun. When an adverb is used to modify a verb, it should be put ahead of the verb. A prepositional phrase can be put ahead of Subject, between Subject and Verb, behind Intransitive Verb, between Verb and Object, or behind Object. A prepositional phrase is made up of a preposition and a noun/pronoun. In one sentence, at most one prepositional phrase is allowed. Any two parts of the sentence cannot intersect. For example, \u0026ldquo;He is a good student\u0026rdquo; is OK, but \u0026ldquo;He a good is student\u0026rdquo; is not. Every word in the dictionary will have only one function. The words are not case sensitive and Subject-Verb Agreement does not matter. Thatâ€™s all the rules. Now, it\u0026rsquo;s your time to show.\nè¾“å…¥ The input contains only one case. The first line specifies two number N and M (1 â‰¤ N, M â‰¤ 5000). The next N lines will be the words and the functions. Every line contains a word and its function, separated by a space. The next M lines will be the sentences \u0026ndash; one sentence per line. Each sentences contains at most 20 words. Every word in the sentences will appear in the dictionary.\nè¾“å‡º The output contains M lines. For each line, output \u0026ldquo;YES\u0026rdquo; if the sentence is OK, and output \u0026ldquo;NO\u0026rdquo; if not.\næ ·ä¾‹è¾“å…¥ 110 6 2he pron. 3see vt. 4a art. 5baby n. 6at prep. 7the art. 8airport n. 9happy adj. 10guess v. 11immediately adv. 12He guess. 13He see baby. 14Happy he see a baby. 15He immediately see a baby. 16He see a baby immediately. 17At the airport, he see a happy baby. æ ·ä¾‹è¾“å‡º 1YES 2NO 3NO 4YES 5NO 6YES æç¤º Please read the Problem Description carefully. Do not use your own English knowledge to construct rules.\næ€è·¯ ä¸å¤ªç¬¦åˆä¸“é¢˜å†…å®¹ï¼Œä¼°è®¡æ˜¯é¢˜ç›®æ‹‰é”™æ²¡åˆ ï¼Œã€é¢˜è§£ã€‘HDU-3746 Cyclic Nacklaceã€‚ç½‘ä¸Šæ‰¾çš„ç”¨stlçš„å®ç°ï¼Œå¾ˆçµæ´»ã€‚\nä»£ç  1map\u0026lt;string,string\u0026gt; mp; 2map\u0026lt;string,bool\u0026gt; ste; 3map\u0026lt;string,char\u0026gt; str, fun; 4 5void init() 6{ 7 fun[\u0026#34;n.\u0026#34;]=\u0026#39;0\u0026#39;; 8 fun[\u0026#34;pron.\u0026#34;]=\u0026#39;1\u0026#39;; 9 fun[\u0026#34;adj.\u0026#34;]=\u0026#39;2\u0026#39;; 10 fun[\u0026#34;adv.\u0026#34;]=\u0026#39;3\u0026#39;; 11 fun[\u0026#34;prep.\u0026#34;]=\u0026#39;4\u0026#39;; 12 fun[\u0026#34;art.\u0026#34;]=\u0026#39;5\u0026#39;; 13 fun[\u0026#34;vt.\u0026#34;]=\u0026#39;6\u0026#39;; 14 fun[\u0026#34;vi.\u0026#34;]=\u0026#39;7\u0026#39;; 15 fun[\u0026#34;v.\u0026#34;]=\u0026#39;8\u0026#39;; 16 17 str[\u0026#34;450\u0026#34;]=\u0026#39;A\u0026#39;; // ä»‹è¯çŸ­è¯­ 18 str[\u0026#34;4520\u0026#34;]=\u0026#39;A\u0026#39;; 19 str[\u0026#34;41\u0026#34;]=\u0026#39;A\u0026#39;; 20 str[\u0026#34;1\u0026#34;]=\u0026#39;S\u0026#39;; // ä¸»/å®¾è¯­ 21 str[\u0026#34;50\u0026#34;]=\u0026#39;S\u0026#39;; 22 str[\u0026#34;520\u0026#34;]=\u0026#39;S\u0026#39;; 23 str[\u0026#34;7\u0026#34;]=\u0026#39;I\u0026#39;; // ä¸åŠç‰©è°“è¯­ 24 str[\u0026#34;37\u0026#34;]=\u0026#39;I\u0026#39;; 25 str[\u0026#34;6\u0026#34;]=\u0026#39;T\u0026#39;; // åŠç‰©è°“è¯­ 26 str[\u0026#34;36\u0026#34;]=\u0026#39;T\u0026#39;; 27 str[\u0026#34;8\u0026#34;]=\u0026#39;V\u0026#39;; // é€šç”¨è°“è¯­ 28 str[\u0026#34;38\u0026#34;]=\u0026#39;V\u0026#39;; 29 // å¥å­å¯èƒ½çš„æ€»ä½“ç»“æ„ 30 ste[\u0026#34;SI\u0026#34;]=1; 31 ste[\u0026#34;STS\u0026#34;]=1; 32 ste[\u0026#34;SV\u0026#34;]=1; 33 ste[\u0026#34;SVS\u0026#34;]=1; 34 ste[\u0026#34;ASI\u0026#34;]=1; 35 ste[\u0026#34;ASTS\u0026#34;]=1; 36 ste[\u0026#34;ASV\u0026#34;]=1; 37 ste[\u0026#34;ASVS\u0026#34;]=1; 38 ste[\u0026#34;SAI\u0026#34;]=1; 39 ste[\u0026#34;SATS\u0026#34;]=1; 40 ste[\u0026#34;SAV\u0026#34;]=1; 41 ste[\u0026#34;SAVS\u0026#34;]=1; 42 ste[\u0026#34;SIA\u0026#34;]=1; 43 ste[\u0026#34;STAS\u0026#34;]=1; 44 ste[\u0026#34;SVA\u0026#34;]=1; 45 ste[\u0026#34;SVAS\u0026#34;]=1; 46 ste[\u0026#34;STSA\u0026#34;]=1; 47 ste[\u0026#34;SVSA\u0026#34;]=1; 48} 49 50bool check(string s){ 51 string res=\u0026#34;\u0026#34;, c=\u0026#34;\u0026#34;; 52 for(int i=0; i\u0026lt;s.size(); i++){ 53 c += s[i]; 54 if(str[c] \u0026gt; 0){ 55 res += str[c]; 56 c = \u0026#34;\u0026#34;; 57 } 58 } 59 res += c; 60 return ste[res]; 61} 62 63string work(string s){ 64 stringstream ss(s); 65 string st, ans; 66 while(ss \u0026gt;\u0026gt; st){ 67 int len=st.size(), flag=0; 68 st[0] = tolower(st[0]); 69 if(st[len-1] == \u0026#39;.\u0026#39;){ 70 flag = 1; 71 st.erase(--st.end()); 72 } 73 if(st[len-1] == \u0026#39;,\u0026#39;) 74 st.erase(--st.end()); 75 ans += fun[mp[st]]; 76 if(flag \u0026amp;\u0026amp; !check(ans)) 77 return \u0026#34;NO\u0026#34;; 78 } 79 return \u0026#34;YES\u0026#34;; 80} 81 82int main() 83{ 84 init(); int n, m; 85 while(cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m) 86 { 87 mp.clear(); 88 string s, s1, s2; 89 for(int i=0; i\u0026lt;n; i++){ 90 cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; 91 mp[s1] = s2; 92 } 93 cin.get(); 94 for(int i=0; i\u0026lt;m; i++){ 95 getline(cin, s); 96 cout \u0026lt;\u0026lt; work(s) \u0026lt;\u0026lt; endl; 97 } 98 } 99} ","permalink":"https://blog.lordash.de/posts/solution/poj-3746-teacher-yyf/","summary":"Teacher YYF(POJ-3746) é¢˜é¢ As we all know, grammar is very important when learning English. Now, YYF become a teacher of a primary school. The students are good at memory so they can tell the meaning and the function (noun, verb â€¦) of the words in the textbook. But, they cannot use these words properly. In YYFâ€™s mind, writing sentences is a good way to","title":"POJ-3746 Teacher YYF"},{"content":"Period II(FZU-1901) é¢˜é¢ For each prefix with length P of a given string S,if\nS[i]=S[i+P] for i in [0..SIZE(S)-p-1],\nthen the prefix is a â€œperiodâ€ of S. We want to all the periodic prefixs.\nè¾“å…¥ Input contains multiple cases.\nThe first line contains an integer T representing the number of cases. Then following T cases.\nEach test case contains a string S (1 \u0026lt;= SIZE(S) \u0026lt;= 1000000),represents the title.S consists of lowercase ,uppercase letter.\nè¾“å‡º For each test case, first output one line containing \u0026ldquo;Case #x: y\u0026rdquo;, where x is the case number (starting from 1) and y is the number of periodic prefixs.Then output the lengths of the periodic prefixs in ascending order.\næ ·ä¾‹è¾“å…¥ 14 2ooo 3acmacmacmacmacma 4fzufzufzuf 5stostootssto æ ·ä¾‹è¾“å‡º 1Case #1: 3 21 2 3 3Case #2: 6 43 6 9 12 15 16 5Case #3: 4 63 6 9 10 7Case #4: 2 89 12 æç¤º æ— \næ€è·¯ ç±»ä¼¼ã€é¢˜è§£ã€‘POJ-2752 Seek the Name, Seek the Fameã€‚å¯¹äºå­—ç¬¦ä¸²çš„æ‰€æœ‰å‰ç¼€ï¼Œè‹¥å­˜åœ¨å¾ªç¯èŠ‚ï¼Œè¾“å‡ºç¬¦åˆæ¡ä»¶çš„å‰ç¼€ä¸ªæ•°ä¸è¿™ä¸ªå‰ç¼€å­—ç¬¦ä¸²çš„é•¿åº¦ã€‚æ³¨æ„è¾“å‡ºæ ¼å¼ï¼Œè¡Œå°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\nä»£ç  1char t[mxn]; 2int nxt[mxn], ans[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int T, cs=1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 23 while(T--) 24 { 25 scanf(\u0026#34;%s\u0026#34;, t); 26 int tl = strlen(t); 27 getnxt(t, tl); 28 29 int num = 0; 30 for(int i=tl; i\u0026gt;0; i=nxt[i]){ 31 ans[num++] = tl-nxt[i]; 32 } 33 printf(\u0026#34;Case #%d: %d\\n\u0026#34;, cs++, num); 34 for(int i=0; i\u0026lt;num; i++){ 35 if(i) printf(\u0026#34; \u0026#34;); 36 printf(\u0026#34;%d\u0026#34;, ans[i]); 37 } 38 printf(\u0026#34;\\n\u0026#34;); 39 } 40 return 0; 41} ","permalink":"https://blog.lordash.de/posts/solution/fzu-1901-period-ii/","summary":"Period II(FZU-1901) é¢˜é¢ For each prefix with length P of a given string S,if S[i]=S[i+P] for i in [0..SIZE(S)-p-1], then the prefix is a â€œperiodâ€ of S. We want to all the periodic prefixs. è¾“å…¥ Input contains multiple cases. The first line contains an integer T representing the number of cases. Then following T cases. Each test case contains a string","title":"FZU-1901 Period II"},{"content":"Game of CS(LightOJ-1355) é¢˜é¢ Jolly and Emily are two bees studying in Computer Science. Unlike other bees they are fond of playing two-player games. They used to play Tic-tac-toe, Chess etc. But now since they are in CS they invented a new game that definitely requires some knowledge of computer science.\nInitially they draw a random rooted tree (a connected graph with no cycles) in a paper which consists of n nodes, where the nodes are numbered from 0 to n-1 and 0 is the root, and the edges are weighted. Initially all the edges are unmarked. And an edge weigh w, has w identical units.\nJolly has a green marker and Emily has a red marker. Emily starts the game first and they alternate turns.\nIn each turn, a player can color one unit of an edge of the tree if that edge has some (at least one) uncolored units and the edge can be traversed from the root using only free edges. An edge is said to be free if the edge is not fully colored (may be uncolored or partially colored).\nIf it\u0026rsquo;s Emily\u0026rsquo;s turn, she finds such an edge and colors one unit of it using the red marker.\nIf it\u0026rsquo;s Jolly\u0026rsquo;s turn, he finds such an edge and colors one unit of it with the green marker.\nThe player, who can\u0026rsquo;t find any edges to color, loses the game.\nFor example, Fig 1 shows the initial tree they have drawn. The tree contains four nodes and the weights of the edge (0, 1), (1, 2) and (0, 3) are 1, 1 and 2 respectively. Emily starts the game. She can color any edge she wants; she colors one unit of edge (0 1) with her red marker (Fig 2). Since the weight of edge (0 1) is 1 so, this edge is fully colored.\nFig 1 Fig 2 Fig 3 Fig 4 Now it\u0026rsquo;s Jolly\u0026rsquo;s turn. He can only color one unit of edge (0 3). He can\u0026rsquo;t color edge (1 2) since if he wants to traverse it from the root (0), he needs to use (0, 1) which is fully colored already. So, he colors one unit of edge (0 3) with his green marker (Fig 3). And now Emily has only one option and she colors the other unit of (0 3) with the red marker (Fig 4). So, both units of edge (0 3) are colored. Now it\u0026rsquo;s Jolly\u0026rsquo;s turn but he has no move left. Thus Emily wins. But if Emily would have colored edge (1 2) instead of edge (0 1), then Jolly would win. So, for this tree Emily will surely win if both of them play optimally.\nè¾“å…¥ Input starts with an integer T ( â‰¤ 500), denoting the number of test cases.\nEach case starts with a line containing an integer n (2 â‰¤ n â‰¤ 1000). Each of the next n-1 lines contains two integers u v w (0 â‰¤ u, v \u0026lt; n, u â‰  v, 1 â‰¤ w â‰¤ 109) denoting that there is an edge between u and v and their weight is w. You can assume that the given tree is valid.\nè¾“å‡º For each case, print the case number and the name of the winner. See the samples for details.\næ ·ä¾‹è¾“å…¥ 1 4 2 4 3 0 1 1 4 1 2 1 5 0 3 2 6 5 7 0 1 1 8 1 2 2 9 0 3 3 10 0 4 7 11 3 12 0 1 1 13 0 2 1 14 4 15 0 1 1 16 1 2 1 17 1 3 1 æ ·ä¾‹è¾“å‡º 1Case 1: Emily 2Case 2: Emily 3Case 3: Jolly 4Case 4: Emily æç¤º æ— \næ€è·¯ ç»™å®šå›¾ï¼Œä»¥0ä¸ºæ ¹èŠ‚ç‚¹ï¼Œæ¯æ¡è¾¹æœ‰ä¸€ä¸ªé•¿åº¦ï¼Œä¸¤ä¸ªäººè½®æµæ“ä½œï¼Œæ¯æ¬¡ä¸ºä¸€æ¡è¾¹ä¸Šè‰²ï¼Œä¸Šä¸€ä¸ªå•ä½é•¿åº¦ï¼Œå½“ä¸€æ¡è¾¹çš„é¢œè‰²è¢«æ¶‚æ»¡ï¼Œåˆ™ç®—ä½œæ˜¯å‡æ‰æ•´æ®µå­æ ‘ã€‚åˆ¤æ–­å…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚\nSGå®šç†ï¼Œå¯¹äºå½“å‰èŠ‚ç‚¹uï¼Œæ¯æ¬¡è€ƒè™‘å­—èŠ‚ç‚¹vï¼Œu-vè¾¹çš„é•¿åº¦ä¸ºl å½“lä¸º1æ—¶ï¼šsg(u) ^= (sg(v) + 1) å½“lä¸ºå¥‡æ•°æ—¶ï¼š éœ€è¦åˆ¤æ–­sg(v)å¥‡å¶æ€§ï¼Œå¥‡æ•°-1ï¼Œå¶æ•°+1ï¼› å½“lä¸ºå¶æ•°æ—¶ï¼šsg(u) ^= sg(v)\nä»£ç  1vector\u0026lt;int\u0026gt; g[mxm]; 2int W[mxm][mxm]; 3 4int getSg(int u, int p){ 5 int nim = 0; 6 for(int i=0; i\u0026lt;g[u].size(); i++){ 7 int v = g[u][i]; 8 if(v != p){ 9 int t = getSg(v, u); 10 if(W[u][v] == 1) 11 nim ^= t+1; 12 else if(W[u][v] \u0026amp; 1) 13 nim ^= t + (t\u0026amp;1 ? -1 : 1); 14 else 15 nim ^= t; 16 } 17 } 18 return nim; 19} 20 21int main() 22{ 23 int T, cs=1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 24 while(T--) 25 { 26 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 27 for(int i=0; i\u0026lt;n; i++) g[i].clear(); 28 29 for(int i=1; i\u0026lt;n; i++){ 30 int u, v, w; 31 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); 32 g[u].push_back(v); 33 g[v].push_back(u); 34 W[u][v] = W[v][u] = w; 35 } 36 printf(\u0026#34;Case %d: \u0026#34;, cs++); 37 if(getSg(0, -1)) 38 printf(\u0026#34;Emily\\n\u0026#34;); 39 else 40 printf(\u0026#34;Jolly\\n\u0026#34;); 41 } 42 return 0; 43} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1355-game-of-cs/","summary":"Game of CS(LightOJ-1355) é¢˜é¢ Jolly and Emily are two bees studying in Computer Science. Unlike other bees they are fond of playing two-player games. They used to play Tic-tac-toe, Chess etc. But now since they are in CS they invented a new game that definitely requires some knowledge of computer science. Initially they draw a random rooted tree (a connected graph with no cycles) in a paper which consists","title":"LightOJ-1355 Game of CS"},{"content":"How many(HDU-2609) é¢˜é¢ Give you n ( n \u0026lt; 10000) necklaces ,the length of necklace will not large than 100,tell me How many kinds of necklaces total have.(if two necklaces can equal by rotating ,we say the two necklaces are some). For example 0110 express a necklace, you can rotate it. 0110 -\u0026gt; 1100 -\u0026gt; 1001 -\u0026gt; 0011-\u0026gt; 0110.\nè¾“å…¥ The input contains multiple test cases. Each test case include: first one integers n. (2\u0026lt;=n\u0026lt;=10000) Next n lines follow. Each line has a equal length character string. (string only include \u0026lsquo;0\u0026rsquo;,\u0026lsquo;1\u0026rsquo;).\nè¾“å‡º For each test case output a integer , how many different necklaces.\næ ·ä¾‹è¾“å…¥ 14 20110 31100 41001 50011 64 71010 80101 91000 100001 æ ·ä¾‹è¾“å‡º 11 22 æç¤º æ— \næ€è·¯ å…ˆç”¨æœ€å°è¡¨ç¤ºæ³•ï¼Œæ±‚å‡ºæœ€å°å­—å…¸åºï¼Œç„¶åmapå»é‡ã€‚\nä»£ç  1string s; 2 3int getmin(int n) 4{ 5 int i=0, j=1, k=0; 6 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 7 { 8 if(s[(i+k)%n] == s[(j+k)%n]){ 9 k++; 10 }else{ 11 if(s[(i+k)%n] \u0026gt; s[(j+k)%n]) 12 i+=k+1; 13 else 14 j+=k+1; 15 k = 0; 16 if(i == j) i++; 17 } 18 } 19 return min(i, j); 20} 21 22int main() 23{ 24 int n; 25 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) 26 { 27 map\u0026lt;string, int\u0026gt; mp; 28 int ans = 0; 29 for(int i=0; i\u0026lt;n; i++) 30 { 31 cin \u0026gt;\u0026gt; s; 32 string ss = \u0026#34;\u0026#34;; 33 int st = getmin(s.length()); 34 for(int i=st; i\u0026lt;s.length(); i++) ss += s[i]; 35 for(int i=0; i\u0026lt;st; i++) ss += s[i]; 36 if(mp[ss] == 0){ 37 mp[ss] = 1; 38 ans++; 39 } 40 } 41 printf(\u0026#34;%d\\n\u0026#34;, ans); 42 } 43 return 0; 44} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2609-how-many/","summary":"How many(HDU-2609) é¢˜é¢ Give you n ( n \u0026lt; 10000) necklaces ,the length of necklace will not large than 100,tell me How many kinds of necklaces total have.(if two necklaces can equal by rotating ,we say the two necklaces are some). For example 0110 express a necklace, you can rotate it. 0110 -\u0026gt; 1100 -\u0026gt; 1001 -\u0026gt; 0011-\u0026gt; 0110. è¾“å…¥ The input contains multiple test cases. Each test","title":"HDU-2609 How many"},{"content":"String Problem(HDU-3374) é¢˜é¢ Give you a string with length N, you can generate N strings by left shifts. For example let consider the string â€œSKYLONGâ€, we can generate seven strings: String Rank SKYLONG 1 KYLONGS 2 YLONGSK 3 LONGSKY 4 ONGSKYL 5 NGSKYLO 6 GSKYLON 7 and lexicographically first of them is GSKYLON, lexicographically last is YLONGSK, both of them appear only once. Your task is easy, calculate the lexicographically fisrt stringâ€™s Rank (if there are multiple answers, choose the smallest one), its times, lexicographically last stringâ€™s Rank (if there are multiple answers, choose the smallest one), and its times also.\nè¾“å…¥ Each line contains one line the string S with length N (N \u0026lt;= 1000000) formed by lower case letters.\nè¾“å‡º Output four integers separated by one space, lexicographically fisrt stringâ€™s Rank (if there are multiple answers, choose the smallest one), the stringâ€™s times in the N generated strings, lexicographically last stringâ€™s Rank (if there are multiple answers, choose the smallest one), and its times also.\næ ·ä¾‹è¾“å…¥ 1abcder 2aaaaaa 3ababab æ ·ä¾‹è¾“å‡º 11 1 6 1 21 6 1 6 31 3 2 3 æç¤º æ— \næ€è·¯ å…ˆç”¨æœ€å°è¡¨ç¤ºæ³•ï¼Œæ±‚å‡ºæœ€å¤§æœ€å°å­—å…¸åºçš„å­ä¸²ï¼Œç„¶åè·‘KMPã€‚\nä»£ç  1char s[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 ans++; 29 j = nxt[j]; 30 // return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 return ans; 36 // return -1; 37} 38 39int getmin(char* s, int n, int cd) // cd 0:æœ€å° 1:æœ€å¤§ 40{ 41 int i=0, j=1, k=0; 42 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 43 { 44 if(s[(i+k)%n] == s[(j+k)%n]){ 45 k++; 46 }else{ 47 if((s[(i+k)%n] \u0026gt; s[(j+k)%n]) ^ cd) 48 i+=k+1; 49 else 50 j+=k+1; 51 k = 0; 52 if(i == j) i++; 53 } 54 } 55 return min(i, j); 56} 57 58int main() 59{ 60 while(~scanf(\u0026#34;%s\u0026#34;, s)) 61 { 62 int sl = strlen(s); 63 int id1 = getmin(s, sl, 0); // æœ€å°è¡¨ç¤º 64 int id2 = getmin(s, sl, 1); // æœ€å¤§è¡¨ç¤º 65 66 for(int i=0; i\u0026lt;sl; i++) s[i+sl] = s[i]; 67 s[sl+sl] = \u0026#39;\\0\u0026#39;; 68 69 getnxt(s+id1, sl); 70 int ans1 = KMP(s, s+id1, sl+sl-1, sl); 71 72 getnxt(s+id2, sl); 73 int ans2 = KMP(s, s+id2, sl+sl-1, sl); 74 75 printf(\u0026#34;%d %d %d %d\\n\u0026#34;, id1+1, ans1, id2+1, ans2); 76 } 77 return 0; 78} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3374-string-problem/","summary":"String Problem(HDU-3374) é¢˜é¢ Give you a string with length N, you can generate N strings by left shifts. For example let consider the string â€œSKYLONGâ€, we can generate seven strings: String Rank SKYLONG 1 KYLONGS 2 YLONGSK 3 LONGSKY 4 ONGSKYL 5 NGSKYLO 6 GSKYLON 7 and lexicographically first of them is GSKYLON, lexicographically last is YLONGSK, both of them","title":"HDU-3374 String Problem"},{"content":"ç®€ä»‹ æœ€å°è¡¨ç¤ºæ³•ï¼Œæ±‚æ‰€æœ‰ä¸æŸä¸ªå­—ç¬¦ä¸²å¾ªç¯åŒæ„çš„å­—ç¬¦ä¸²ä¸­ï¼Œå­—å…¸åºæœ€å°çš„é‚£ä¸ªã€‚æ¯”å¦‚è¯´ä¸€ä¸ªå­—ç¬¦ä¸²lordashï¼Œå®ƒé•¿åº¦ä¸º7ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€å¤šæœ‰ä¸ƒç§å¾ªç¯åŒæ„çš„æ–¹æ³•ã€‚\nlordashã€ordashlã€rdashloã€dashlorã€ashlordã€shlordaã€hlordasã€‚\nè¿™å‡ ä¸ªä¸²åœ¨åŸä¸²ä¸Šçš„å¼€å§‹ä½ç½®åˆ†åˆ«æ˜¯0,1,2,3,4,5,6ã€‚å­—å…¸åºæœ€å°çš„åŒæ„å³æ˜¯ä»¥4ä¸ºèµ·ç‚¹çš„é‚£ä¸ªã€‚\næœ´ç´ ç®—æ³• ç»™å‡ºä¸€ä¸ªæœ´ç´ çš„ç®—æ³•ï¼Œæˆ‘ä»¬æ¯æ¬¡æ¯”è¾ƒiå’Œjå¼€å§‹çš„å¾ªç¯åŒæ„ï¼ŒæŠŠå½“å‰æ¯”è¾ƒåˆ°çš„ä½ç½®è®°ä½œkï¼Œæ¯æ¬¡é‡åˆ°ä¸ä¸€æ ·çš„å­—ç¬¦æ—¶ä¾¿æŠŠå¤§çš„è·³è¿‡ï¼Œæœ€åå‰©ä¸‹çš„å°±æ˜¯æœ€ä¼˜è§£ã€‚æœ€åæ—¶é—´å¤æ‚åº¦$ O(|S|^{2}) $ã€‚\nå®ç°ä»£ç å¦‚ä¸‹ï¼š\n1int simple(char* s, int n) 2{ 3 int i=0, j=1, k=0; 4 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 5 { 6 if(s[(i+k)%n] == s[(j+k)%n]){ 7 k++; 8 }else{ 9 if(s[(i+k)%n] \u0026gt; s[(j+k)%n]) 10 i++; 11 else 12 j++; 13 k = 0; 14 if(i == j) i++; 15 } 16 } 17 return min(i, j); 18} æœ€å°è¡¨ç¤ºæ³•O(|S|) å¦‚æœæ¯”è¾ƒèµ·å§‹ä½ç½®$i$å’Œèµ·å§‹ä½ç½®$j$å‘ç°$S[i,i+1,\\ldots,i+k-1]=S[j,j+1,\\ldots,j+k-1]$ä¸”$S[i+k] \\lt S[j+k]$ï¼Œåˆ™èµ·å§‹ä½ç½®$j,j+1,\\ldots,j+k$éƒ½ä¸åˆæ³•ã€‚å¯¹äºæ¯ä¸ªæ•°å­—$0 \\le l \\le k$éƒ½æœ‰èµ·å§‹ä½ç½®$i+l$æ¯”èµ·å§‹ä½ç½®$j+l$ä¼˜ï¼Œå› ä¸º$S[i+l,i+l+1, \\ldots,i+k-1]=S[j+l,j+l+1,\\ldots,j+k-1]$ä¸”$S[i+k] \\lt S[j+k]$ ã€‚\nä»£ç å¦‚ä¸‹ï¼š\n1int getmin(char* s, int n) 2{ 3 int i=0, j=1, k=0; 4 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 5 { 6 if(s[(i+k)%n] == s[(j+k)%n]){ 7 k++; 8 }else{ 9 if(s[(i+k)%n] \u0026gt; s[(j+k)%n]) 10 i+=k+1; 11 else 12 j+=k+1; 13 k = 0; 14 if(i == j) i++; 15 } 16 } 17 return min(i, j); 18} æ¨¡æ¿ 1char s[mxn]; 2 3int simple(char* s, int n) 4{ 5 int i=0, j=1, k=0; 6 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 7 { 8 if(s[(i+k)%n] == s[(j+k)%n]){ 9 k++; 10 }else{ 11 if(s[(i+k)%n] \u0026gt; s[(j+k)%n]) 12 i++; 13 else 14 j++; 15 k = 0; 16 if(i == j) i++; 17 } 18 } 19 return min(i, j); 20} 21 22int getmin(char* s, int n) 23{ 24 int i=0, j=1, k=0; 25 while(i\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;n \u0026amp;\u0026amp; k\u0026lt;n) 26 { 27 if(s[(i+k)%n] == s[(j+k)%n]){ 28 k++; 29 }else{ 30 if(s[(i+k)%n] \u0026gt; s[(j+k)%n]) 31 i+=k+1; 32 else 33 j+=k+1; 34 k = 0; 35 if(i == j) i++; 36 } 37 } 38 return min(i, j); 39} 40 41int main() 42{ 43 scanf(\u0026#34;%s\u0026#34;, s); 44 int n = strlen(s); 45 printf(\u0026#34;%d\\n\u0026#34;, simple(s, n)); 46 printf(\u0026#34;%d\\n\u0026#34;, getmin(s, n)); 47 return 0; 48} ","permalink":"https://blog.lordash.de/posts/algorithm/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95/","summary":"ç®€ä»‹ æœ€å°è¡¨ç¤ºæ³•ï¼Œæ±‚æ‰€æœ‰ä¸æŸä¸ªå­—ç¬¦ä¸²å¾ªç¯åŒæ„çš„å­—ç¬¦ä¸²ä¸­ï¼Œå­—å…¸åºæœ€å°çš„é‚£ä¸ªã€‚æ¯”å¦‚è¯´ä¸€ä¸ªå­—ç¬¦ä¸²lordashï¼Œå®ƒé•¿åº¦ä¸º7ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€å¤šæœ‰ä¸ƒç§å¾ªç¯åŒ","title":"æœ€å°è¡¨ç¤ºæ³•"},{"content":"Corporate Identity(HDU-2328) é¢˜é¢ Beside other services, ACM helps companies to clearly state their â€œcorporate identityâ€, which includes company logo but also other signs, like trademarks. One of such companies is Internet Building Masters (IBM), which has recently asked ACM for a help with their new identity. IBM do not want to change their existing logos and trademarks completely, because their customers are used to the old ones. Therefore, ACM will only change existing trademarks instead of creating new ones.\nAfter several other proposals, it was decided to take all existing trademarks and find the longest common sequence of letters that is contained in all of them. This sequence will be graphically emphasized to form a new logo. Then, the old trademarks may still be used while showing the new identity.\nYour task is to find such a sequence.\nè¾“å…¥ The input contains several tasks. Each task begins with a line containing a positive integer N, the number of trademarks (2 â‰¤ N â‰¤ 4000). The number is followed by N lines, each containing one trademark. Trademarks will be composed only from lowercase letters, the length of each trademark will be at least 1 and at most 200 characters.\nAfter the last trademark, the next task begins. The last task is followed by a line containing zero.\nè¾“å‡º For each task, output a single line containing the longest string contained as a substring in all trademarks. If there are several strings of the same length, print the one that is lexicographically smallest. If there is no such non-empty string, output the words â€œIDENTITY LOSTâ€ instead.\næ ·ä¾‹è¾“å…¥ 13 2aabbaabb 3abbababb 4bbbbbabb 52 6xyz 7abc 80 æ ·ä¾‹è¾“å‡º 1abb 2IDENTITY LOST æç¤º æ— \næ€è·¯ åŒã€é¢˜è§£ã€‘POJ-3080 Blue Jeansï¼Œæšä¸¾å­ä¸²ï¼Œæš´åŠ›KMPå³å¯ã€‚\nä»£ç  1char s[mxn][mxm], t[mxm], ans[mxm]; 2int nxt[mxm]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 int n; 42 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 43 { 44 for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]); 45 int sl = strlen(s[0]), f=0; 46 47 for(int i=0; i\u0026lt;sl; i++) // æšä¸¾æ¨¡å¼ä¸²èµ·ç‚¹ 48 { 49 int tl = 0, k; 50 for(int j=i; j\u0026lt;sl; j++) // æšä¸¾æ¨¡å¼ä¸²é•¿åº¦ 51 { 52 t[tl++] = s[0][j]; 53 t[tl] = \u0026#39;\\0\u0026#39;; 54 getnxt(t, tl); 55 for(k=0; k\u0026lt;n; k++) // æšä¸¾æ‰€æœ‰æ–‡æœ¬ä¸² 56 if(KMP(s[k], t, sl, tl) == -1) 57 break; 58 if(k\u0026gt;=n) // æ‰€æœ‰ä¸²å…¬å…±å­ä¸² 59 { 60 if(!f || tl\u0026gt;strlen(ans)){ // é•¿åº¦æœ€é•¿ 61 strcpy(ans, t); f=1; 62 }else if(tl==strlen(ans) \u0026amp;\u0026amp; strcmp(t, ans)\u0026lt;0){ // å­—å…¸åºæœ€å° 63 strcpy(ans, t); 64 } 65 } 66 } 67 } 68 if (!f) 69 printf(\u0026#34;IDENTITY LOST\\n\u0026#34;); 70 else 71 printf(\u0026#34;%s\\n\u0026#34;, ans); 72 } 73 return 0; 74} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2328-corporate-identity/","summary":"Corporate Identity(HDU-2328) é¢˜é¢ Beside other services, ACM helps companies to clearly state their â€œcorporate identityâ€, which includes company logo but also other signs, like trademarks. One of such companies is Internet Building Masters (IBM), which has recently asked ACM for a help with their new identity. IBM do not want to","title":"HDU-2328 Corporate Identity"},{"content":"Substrings(HDU-1238) é¢˜é¢ You are given a number of case-sensitive strings of alphabetic characters, find the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\nè¾“å…¥ The first line of the input file contains a single integer t (1 \u0026lt;= t \u0026lt;= 10), the number of test cases, followed by the input data for each test case. The first line of each test case contains a single integer n (1 \u0026lt;= n \u0026lt;= 100), the number of given strings, followed by n lines, each representing one string of minimum length 1 and maximum length 100. There is no extra white space before and after a string.\nè¾“å‡º There should be one line per test case containing the length of the largest string found.\næ ·ä¾‹è¾“å…¥ 12 23 3ABCD 4BCDFF 5BRCD 62 7rose 8orchid æ ·ä¾‹è¾“å‡º 12 22 æç¤º æ— \næ€è·¯ æšä¸¾å­ä¸²ï¼Œæš´åŠ›KMPå³å¯ã€‚\nä»£ç  1char s[105][mxn], t[mxn], t2[mxn]; 2int nxt[mxn], nxt2[mxn], len[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 42 while(T--) 43 { 44 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 45 for(int i=0; i\u0026lt;n; i++){ 46 scanf(\u0026#34;%s\u0026#34;, s[i]); 47 len[i] = strlen(s[i]); 48 } 49 int ans=0; 50 for(int i=0; i\u0026lt;len[0]; i++) // æšä¸¾æ¨¡å¼ä¸²èµ·ç‚¹ 51 { 52 int tl = 0, k; 53 for(int j=i; j\u0026lt;len[0]; j++) // æšä¸¾æ¨¡å¼ä¸²é•¿åº¦ 54 { 55 t[tl++] = s[0][j]; 56 for(int x=0; x\u0026lt;tl; x++) t2[x] = t[tl-x-1]; 57 t[tl] = t2[tl] = \u0026#39;\\0\u0026#39;; 58 getnxt(t, tl); 59 getnxt(t2, tl); 60 for(k=0; k\u0026lt;n; k++) // æšä¸¾æ‰€æœ‰æ–‡æœ¬ä¸² 61 if(KMP(s[k], t, len[k], tl) == -1 \u0026amp;\u0026amp; KMP(s[k], t2, len[k], tl) == -1) 62 break; 63 if(k\u0026gt;=n) // æ»¡è¶³æ¡ä»¶ 64 ans = max(ans, tl); 65 } 66 } 67 printf(\u0026#34;%d\\n\u0026#34;, ans); 68 } 69 return 0; 70} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1238-substrings/","summary":"Substrings(HDU-1238) é¢˜é¢ You are given a number of case-sensitive strings of alphabetic characters, find the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings. è¾“å…¥ The first line of the input file contains a single integer t (1 \u0026lt;= t \u0026lt;= 10), the number of test cases, followed by the input data for each test","title":"HDU-1238 Substrings"},{"content":"Clairewdâ€™s message(HDU-4300) é¢˜é¢ Clairewd is a member of FBI. After several years concealing in BUPT, she intercepted some important messages and she was preparing for sending it to ykwd. They had agreed that each letter of these messages would be transfered to another one according to a conversion table. Unfortunately, GFW(someone\u0026rsquo;s name, not what you just think about) has detected their action. He also got their conversion table by some unknown methods before. Clairewd was so clever and vigilant that when she realized that somebody was monitoring their action, she just stopped transmitting messages. But GFW knows that Clairewd would always firstly send the ciphertext and then plaintext(Note that they won\u0026rsquo;t overlap each other). But he doesn\u0026rsquo;t know how to separate the text because he has no idea about the whole message. However, he thinks that recovering the shortest possible text is not a hard task for you. Now GFW will give you the intercepted text and the conversion table. You should help him work out this problem.\nè¾“å…¥ The first line contains only one integer T, which is the number of test cases. Each test case contains two lines. The first line of each test case is the conversion table S. S[i] is the ith latin letter\u0026rsquo;s cryptographic letter. The second line is the intercepted text which has n letters that you should recover. It is possible that the text is complete.\nRange of test data: T\u0026lt;= 100 ; n\u0026lt;= 100000;\nè¾“å‡º For each test case, output one line contains the shorest possible complete text.\næ ·ä¾‹è¾“å…¥ 12 2abcdefghijklmnopqrstuvwxyz 3abcdab 4qwertyuiopasdfghjklzxcvbnm 5qwertabcde æ ·ä¾‹è¾“å‡º 1abcdabcd 2qwertabcde æç¤º æ— \næ€è·¯ ç»™ä½ ä¸€ä¸ªa-zçš„å¯¹ç…§è¡¨ï¼Œä»¥åŠä¸€ä¸ª å¯†æ–‡+ä¸å®Œæ•´æ˜æ–‡ çš„å­—ç¬¦ä¸²ã€‚æ±‚æœ€çŸ­çš„ å¯†æ–‡+å®Œæ•´æ˜æ–‡ã€‚å…ˆè§£å¯†å‰åŠéƒ¨åˆ†ï¼Œå†æ±‚ä¸€ä¸ªæœ€å¤§å…¬å…±å‰ç¼€åç¼€ã€‚æ³¨æ„è€ƒè™‘å‰åç¼€é‡å çš„æƒ…å†µï¼Œå³next[len]\u0026gt;len/2ã€‚\nä»£ç  1char s[mxn], t[mxn], p[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 23 while(T--) 24 { 25 for(int i=0; i\u0026lt;26; i++){ 26 char c; scanf(\u0026#34; %c\u0026#34;, \u0026amp;c); 27 p[c-\u0026#39;a\u0026#39;] = \u0026#39;a\u0026#39;+i; 28 } 29 30 scanf(\u0026#34;%s\u0026#34;, s); 31 int n = strlen(s); 32 33 int m = (n+1)/2; 34 for(int i=0; i\u0026lt;m; i++){ 35 t[i] = p[s[i]-\u0026#39;a\u0026#39;]; 36 t[i+m] = s[i+m]; 37 } 38 getnxt(t, n); 39 40 m = nxt[n]; 41 if(m \u0026gt; n/2) 42 m = n/2; 43 m = n-m; 44 45 for(int i=0; i\u0026lt;m; i++){ 46 printf(\u0026#34;%c\u0026#34;, s[i]); 47 } 48 for(int i=0; i\u0026lt;m; i++){ 49 printf(\u0026#34;%c\u0026#34;, p[s[i]-\u0026#39;a\u0026#39;]); 50 } 51 printf(\u0026#34;\\n\u0026#34;); 52 } 53 return 0; 54} ","permalink":"https://blog.lordash.de/posts/solution/hdu-4300-clairewds-message/","summary":"Clairewdâ€™s message(HDU-4300) é¢˜é¢ Clairewd is a member of FBI. After several years concealing in BUPT, she intercepted some important messages and she was preparing for sending it to ykwd. They had agreed that each letter of these messages would be transfered to another one according to a conversion table. Unfortunately, GFW(someone\u0026rsquo;s name, not what you just think about) has detected","title":"HDU-4300 Clairewdâ€™s message"},{"content":"Count the string(HDU-3336) é¢˜é¢ It is well known that AekdyCoin is good at string problems as well as number theory problems. When given a string s, we can write down all the non-empty prefixes of this string. For example: s: \u0026ldquo;abab\u0026rdquo; The prefixes are: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;aba\u0026rdquo;, \u0026ldquo;abab\u0026rdquo; For each prefix, we can count the times it matches in s. So we can see that prefix \u0026ldquo;a\u0026rdquo; matches twice, \u0026ldquo;ab\u0026rdquo; matches twice too, \u0026ldquo;aba\u0026rdquo; matches once, and \u0026ldquo;abab\u0026rdquo; matches once. Now you are asked to calculate the sum of the match times for all the prefixes. For \u0026ldquo;abab\u0026rdquo;, it is 2 + 2 + 1 + 1 = 6. The answer may be very large, so output the answer mod 10007.\nè¾“å…¥ The first line is a single integer T, indicating the number of test cases. For each case, the first line is an integer n (1 \u0026lt;= n \u0026lt;= 200000), which is the length of string s. A line follows giving the string s. The characters in the strings are all lower-case letters.\nè¾“å‡º For each case, output only one number: the sum of the match times for all the prefixes of s mod 10007.\næ ·ä¾‹è¾“å…¥ 11 24 3abab æ ·ä¾‹è¾“å‡º 16 æç¤º æ— \næ€è·¯ æ±‚nextæ•°ç»„ï¼Œæ¯ä¸ªç›¸ç­‰çš„å‰åç¼€éƒ½ä¼šå¯¹å®ƒçš„å›æº¯+1è´¡çŒ®ã€‚\nä»£ç  1char t[mxn]; 2int nxt[mxn], ans[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 23 while(T--) 24 { 25 int m, mod = 10007; 26 scanf(\u0026#34;%d %s\u0026#34;, \u0026amp;m, t); 27 getnxt(t, m); 28 memset(ans, 0 ,sizeof(ans)); 29 int sum = 0; 30 for(int i=1; i\u0026lt;=m; i++){ 31 ans[i] = ans[nxt[i]] + 1; 32 sum = (sum + ans[i]) % mod; 33 } 34 printf(\u0026#34;%d\\n\u0026#34;, sum); 35 } 36 return 0; 37} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3336-count-the-string/","summary":"Count the string(HDU-3336) é¢˜é¢ It is well known that AekdyCoin is good at string problems as well as number theory problems. When given a string s, we can write down all the non-empty prefixes of this string. For example: s: \u0026ldquo;abab\u0026rdquo; The prefixes are: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;aba\u0026rdquo;, \u0026ldquo;abab\u0026rdquo; For each prefix, we can count the times it matches in s. So we can see that prefix \u0026ldquo;a\u0026rdquo; matches twice,","title":"HDU-3336 Count the string"},{"content":"Simpsonsâ€™ Hidden Talents(HDU-2594) é¢˜é¢ Homer: Marge, I just figured out a way to discover some of the talents we werenâ€™t aware we had. Marge: Yeah, what is it? Homer: Take me for example. I want to find out if I have a talent in politics, OK? Marge: OK. Homer: So I take some politicianâ€™s name, say Clinton, and try to find the length of the longest prefix in Clintonâ€™s name that is a suffix in my name. Thatâ€™s how close I am to being a politician like Clinton Marge: Why on earth choose the longest prefix that is a suffix??? Homer: Well, our talents are deeply hidden within ourselves, Marge. Marge: So how close are you? Homer: 0! Marge: Iâ€™m not surprised. Homer: But you know, you must have some real math talent hidden deep in you. Marge: How come? Homer: Riemann and Marjorie gives 3!!! Marge: Who the heck is Riemann? Homer: Never mind. Write a program that, when given strings s1 and s2, finds the longest prefix of s1 that is a suffix of s2.\nè¾“å…¥ Input consists of two lines. The first line contains s1 and the second line contains s2. You may assume all letters are in lowercase.\nè¾“å‡º Output consists of a single line that contains the longest string that is a prefix of s1 and a suffix of s2, followed by the length of that prefix. If the longest such string is the empty string, then the output should be 0. The lengths of s1 and s2 will be at most 50000.\næ ·ä¾‹è¾“å…¥ 1clinton 2homer 3riemann 4marjorie æ ·ä¾‹è¾“å‡º 10 2rie 3 æç¤º æ— \næ€è·¯ æ±‚æœ€é•¿çš„ç›¸ç­‰çš„Sçš„å‰ç¼€ä¸Tçš„åç¼€ã€‚å°†Så’ŒTæ‹¼æ¥èµ·æ¥ï¼Œæ±‚nextæ•°ç»„å³å¯ï¼Œæ³¨æ„ç­”æ¡ˆä¸åŸé•¿æ±‚minã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 while(~scanf(\u0026#34;%s %s\u0026#34;, s, t)) 23 { 24 int n = strlen(s), m = strlen(t); 25 strcpy(s+n, t); 26 getnxt(s, n+m); 27 int ans = min(nxt[n+m], min(n, m)); 28 if(ans) 29 printf(\u0026#34;%s \u0026#34;, s+n+m-ans); 30 printf(\u0026#34;%d\\n\u0026#34;, ans); 31 } 32 return 0; 33} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2594-simpsons-hidden-talents/","summary":"Simpsonsâ€™ Hidden Talents(HDU-2594) é¢˜é¢ Homer: Marge, I just figured out a way to discover some of the talents we werenâ€™t aware we had. Marge: Yeah, what is it? Homer: Take me for example. I want to find out if I have a talent in politics, OK? Marge: OK. Homer: So I take some po","title":"HDU-2594 Simpsonsâ€™ Hidden Talents"},{"content":"Blue Jeans (POJ-3080) é¢˜é¢ The Genographic Project is a research partnership between IBM and The National Geographic Society that is analyzing DNA from hundreds of thousands of contributors to map how the Earth was populated.\nAs an IBM researcher, you have been tasked with writing a program that will find commonalities amongst given snippets of DNA that can be correlated with individual survey information to identify new genetic markers.\nA DNA base sequence is noted by listing the nitrogen bases in the order in which they are found in the molecule. There are four bases: adenine (A), thymine (T), guanine (G), and cytosine (C). A 6-base DNA sequence could be represented as TAGACC.\nGiven a set of DNA base sequences, determine the longest series of bases that occurs in all of the sequences.\nè¾“å…¥ Input to this problem will begin with a line containing a single integer n indicating the number of datasets. Each dataset consists of the following components:\nA single positive integer m (2 \u0026lt;= m \u0026lt;= 10) indicating the number of base sequences in this dataset. m lines each containing a single base sequence consisting of 60 bases. è¾“å‡º For each dataset in the input, output the longest base subsequence common to all of the given base sequences. If the longest common subsequence is less than three bases in length, display the string \u0026ldquo;no significant commonalities\u0026rdquo; instead. If multiple subsequences of the same longest length exist, output only the subsequence that comes first in alphabetical order.\næ ·ä¾‹è¾“å…¥ 13 22 3GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA 4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 53 6GATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATACCAGATA 7GATACTAGATACTAGATACTAGATACTAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA 8GATACCAGATACCAGATACCAGATACCAAAGGAAAGGGAAAAGGGGAAAAAGGGGGAAAA 93 10CATCATCATCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC 11ACATCATCATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 12AACATCATCATTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT æ ·ä¾‹è¾“å‡º 1no significant commonalities 2AGATAC 3CATCATCAT æç¤º æ— \næ€è·¯ æœ€å¤š10ä¸ªä¸²ï¼Œæ¯ä¸ªä¸²æœ€é•¿60ï¼Œn^3æš´åŠ›å³å¯ã€‚\nä»£ç  1char s[15][mxn], t[mxn], ans[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 42 while(T--) 43 { 44 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 45 for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]); 46 int sl = strlen(s[0]), f=0; 47 48 for(int i=0; i\u0026lt;sl; i++) // æšä¸¾æ¨¡å¼ä¸²èµ·ç‚¹ 49 { 50 int tl = 0, k; 51 for(int j=i; j\u0026lt;sl; j++) // æšä¸¾æ¨¡å¼ä¸²é•¿åº¦ 52 { 53 t[tl++] = s[0][j]; 54 t[tl] = \u0026#39;\\0\u0026#39;; 55 getnxt(t, tl); 56 for(k=0; k\u0026lt;n; k++) // æšä¸¾æ‰€æœ‰æ–‡æœ¬ä¸² 57 if(KMP(s[k], t, sl, tl) == -1) 58 break; 59 if(k\u0026gt;=n) // æ‰€æœ‰ä¸²å…¬å…±å­ä¸² 60 { 61 if(!f || tl\u0026gt;strlen(ans)){ // é•¿åº¦æœ€é•¿ 62 strcpy(ans, t); f=1; 63 }else if(tl==strlen(ans) \u0026amp;\u0026amp; strcmp(t, ans)\u0026lt;0){ // å­—å…¸åºæœ€å° 64 strcpy(ans, t); 65 } 66 } 67 } 68 } 69 if (!f || strlen(ans)\u0026lt;3) 70 printf(\u0026#34;no significant commonalities\\n\u0026#34;); 71 else 72 printf(\u0026#34;%s\\n\u0026#34;, ans); 73 } 74 return 0; 75} ","permalink":"https://blog.lordash.de/posts/solution/poj-3080-blue-jeans/","summary":"Blue Jeans (POJ-3080) é¢˜é¢ The Genographic Project is a research partnership between IBM and The National Geographic Society that is analyzing DNA from hundreds of thousands of contributors to map how the Earth was populated. As an IBM researcher, you have been tasked with writing a program that will find commonalities amongst given snippets of DNA that can be correlated with individual survey information to identify new genetic markers.","title":"POJ-3080 Blue Jeans"},{"content":"Power Strings (POJ-2406) é¢˜é¢ Given two strings a and b we define ab to be their concatenation. For example, if a = \u0026ldquo;abc\u0026rdquo; and b = \u0026ldquo;def\u0026rdquo; then ab = \u0026ldquo;abcdef\u0026rdquo;. If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = \u0026quot;\u0026quot; (the empty string) and a^(n+1) = a*(a^n).\nè¾“å…¥ Each test case is a line of input representing s, a string of printable characters. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case.\nè¾“å‡º For each s you should print the largest n such that s = a^n for some string a.\næ ·ä¾‹è¾“å…¥ 1abcd 2aaaa 3ababab 4. æ ·ä¾‹è¾“å‡º 11 24 33 æç¤º This problem has huge input, use scanf instead of cin to avoid time limit exceed.\næ€è·¯ KMPæ±‚æœ€å°å¾ªç¯èŠ‚ã€‚è¾“å‡ºæœ€å°å¾ªç¯å‘¨æœŸã€‚POJæäº¤æ—¶æ³¨æ„C++å’ŒG++çš„åŒºåˆ«ã€‚\nä»£ç  1char t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 while(scanf(\u0026#34;%s\u0026#34;, t) \u0026amp;\u0026amp; strcmp(t, \u0026#34;.\u0026#34;)) 23 { 24 int m = strlen(t); 25 getnxt(t, m); 26 27 int L = m-nxt[m]; // æœ€å°å¾ªç¯èŠ‚=åŸä¸²é•¿åº¦-æœ«ä½å¤±é…ï¼ŒL=len-next[len] 28 printf(\u0026#34;%d\\n\u0026#34;, m%L ? 1 : m/L); // å¾ªç¯å‘¨æœŸT=len/L 29 } 30 return 0; 31} ","permalink":"https://blog.lordash.de/posts/solution/poj-2406-power-strings/","summary":"Power Strings (POJ-2406) é¢˜é¢ Given two strings a and b we define ab to be their concatenation. For example, if a = \u0026ldquo;abc\u0026rdquo; and b = \u0026ldquo;def\u0026rdquo; then ab = \u0026ldquo;abcdef\u0026rdquo;. If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = \u0026quot;\u0026quot; (the empty string) and a^(n+1) = a*(a^n). è¾“å…¥ Each test case is a line of input","title":"POJ-2406 Power Strings"},{"content":"Period (HDU-1358) é¢˜é¢ For each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 \u0026lt;= i \u0026lt;= N) we want to know the largest K \u0026gt; 1 (if there is one) such that the prefix of S with length i can be written as AK , that is A concatenated K times, for some string A. Of course, we also want to know the period K.\nè¾“å…¥ The input file consists of several test cases. Each test case consists of two lines. The first one contains N (2 \u0026lt;= N \u0026lt;= 1 000 000) â€“ the size of the string S. The second line contains the string S. The input file ends with a line, having the number zero on it.\nè¾“å‡º For each test case, output â€œTest case #â€ and the consecutive test case number on a single line; then, for each prefix with length i that has a period K \u0026gt; 1, output the prefix size i and the period K separated by a single space; the prefix sizes must be in increasing order. Print a blank line after each test case.\næ ·ä¾‹è¾“å…¥ 13 2aaa 312 4aabaabaabaab 50 æ ·ä¾‹è¾“å‡º 1Test case #1 22 2 33 3 4 5Test case #2 62 2 76 2 89 3 912 4 æç¤º æ— \næ€è·¯ KMPæ±‚æœ€å°å¾ªç¯èŠ‚ã€‚è¾“å‡ºæ‰€æœ‰å¯ä»¥ç”±å¾ªç¯æ„æˆçš„å‰ç¼€ã€‚\nä»£ç  1char t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int cs=0, m; 23 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;m) \u0026amp;\u0026amp; m) 24 { 25 scanf(\u0026#34;%s\u0026#34;, t); 26 getnxt(t, m); 27 printf(\u0026#34;Test case #%d\\n\u0026#34;, ++cs); 28 29 for(int i=0; i\u0026lt;=m; i++){ 30 if(nxt[i]\u0026gt;0){ 31 int L = i-nxt[i]; // æœ€å°å¾ªç¯èŠ‚=åŸä¸²é•¿åº¦-æœ«ä½å¤±é…ï¼ŒL=len-next[len] 32 if(i%L == 0) 33 printf(\u0026#34;%d %d\\n\u0026#34;, i, i/L); // å¾ªç¯å‘¨æœŸT=len/L 34 } 35 } 36 printf(\u0026#34;\\n\u0026#34;); 37 } 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1358-period/","summary":"Period (HDU-1358) é¢˜é¢ For each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 \u0026lt;= i \u0026lt;= N) we want to know the largest K \u0026gt; 1 (if there is one) such that the prefix of S with length i can","title":"HDU-1358 Period"},{"content":"Cyclic Nacklace (HDU-3746) é¢˜é¢ CC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of \u0026ldquo;HDU CakeMan\u0026rdquo;, he wants to sell some little things to make money. Of course, this is not an easy task.\nAs Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl\u0026rsquo;s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls\u0026rsquo; lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet\u0026rsquo;s cycle is 9 and its cyclic count is 2: Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden. CC is satisfied with his ideas and ask you for help.\nè¾“å…¥ The first line of the input is a single integer T ( 0 \u0026lt; T \u0026lt;= 100 ) which means the number of test cases. Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by \u0026lsquo;a\u0026rsquo; ~\u0026lsquo;z\u0026rsquo; characters. The length of the string Len: ( 3 \u0026lt;= Len \u0026lt;= 100000 ).\nè¾“å‡º For each case, you are required to output the minimum count of pearls added to make a CharmBracelet.\næ ·ä¾‹è¾“å…¥ 13 2aaa 3abca 4abcde æ ·ä¾‹è¾“å‡º 10 22 35 æç¤º æ— \næ€è·¯ KMPæ±‚æœ€å°å¾ªç¯èŠ‚ã€‚\næœ€å°å¾ªç¯èŠ‚=åŸä¸²é•¿åº¦-æœ«ä½å¤±é…ï¼ŒL=len-next[len]ã€‚ å¦‚æœlenå¯ä»¥è¢«len-next[len]æ•´é™¤ï¼Œåˆ™è¡¨æ˜å­—ç¬¦ä¸²Så¯ä»¥å®Œå…¨ç”±å¾ªç¯èŠ‚å¾ªç¯ç»„æˆï¼Œå¾ªç¯å‘¨æœŸT=len/Lã€‚ éœ€è¦è¡¥çš„ä¸ªæ•°æ˜¯å¾ªç¯ä¸ªæ•°L-len%L = L-(len-L)%L = L-next[len]%Lã€‚ ä»£ç  1char t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int main() 21{ 22 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 23 while(T--) 24 { 25 scanf(\u0026#34;%s\u0026#34;, t); 26 int m = strlen(t); 27 getnxt(t, m); 28 if(nxt[m] == 0){ 29 printf(\u0026#34;%d\\n\u0026#34;, m); 30 }else{ 31 int L = m - nxt[m]; // æœ€å°å¾ªç¯èŠ‚=åŸä¸²é•¿åº¦-æœ«ä½å¤±é…ï¼ŒL=len-next[len] 32 printf(\u0026#34;%d\\n\u0026#34;, m%L ? L-m%L : 0); // éœ€è¦è¡¥çš„ä¸ªæ•°æ˜¯å¾ªç¯ä¸ªæ•°L-len%L = L-(len-L)%L = L-next[len]%L 33 } 34 } 35 return 0; 36} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3746-cyclic-nacklace/","summary":"Cyclic Nacklace (HDU-3746) é¢˜é¢ CC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of \u0026ldquo;HDU CakeMan\u0026rdquo;, he wants to sell some little things to make money. Of course, this is not","title":"HDU-3746 Cyclic Nacklace"},{"content":"å‰ªèŠ±å¸ƒæ¡ (HDU-2087) é¢˜é¢ ä¸€å—èŠ±å¸ƒæ¡ï¼Œé‡Œé¢æœ‰äº›å›¾æ¡ˆï¼Œå¦æœ‰ä¸€å—ç›´æ¥å¯ç”¨çš„å°é¥°æ¡ï¼Œé‡Œé¢ä¹Ÿæœ‰ä¸€äº›å›¾æ¡ˆã€‚å¯¹äºç»™å®šçš„èŠ±å¸ƒæ¡å’Œå°é¥°æ¡ï¼Œè®¡ç®—ä¸€ä¸‹èƒ½ä»èŠ±å¸ƒæ¡ä¸­å°½å¯èƒ½å‰ªå‡ºå‡ å—å°é¥°æ¡æ¥å‘¢ï¼Ÿ\nè¾“å…¥ è¾“å…¥ä¸­å«æœ‰ä¸€äº›æ•°æ®ï¼Œåˆ†åˆ«æ˜¯æˆå¯¹å‡ºç°çš„èŠ±å¸ƒæ¡å’Œå°é¥°æ¡ï¼Œå…¶å¸ƒæ¡éƒ½æ˜¯ç”¨å¯è§ASCIIå­—ç¬¦è¡¨ç¤ºçš„ï¼Œå¯è§çš„ASCIIå­—ç¬¦æœ‰å¤šå°‘ä¸ªï¼Œå¸ƒæ¡çš„èŠ±çº¹ä¹Ÿæœ‰å¤šå°‘ç§èŠ±æ ·ã€‚èŠ±çº¹æ¡å’Œå°é¥°æ¡ä¸ä¼šè¶…è¿‡1000ä¸ªå­—ç¬¦é•¿ã€‚å¦‚æœé‡è§#å­—ç¬¦ï¼Œåˆ™ä¸å†è¿›è¡Œå·¥ä½œã€‚\nè¾“å‡º è¾“å‡ºèƒ½ä»èŠ±çº¹å¸ƒä¸­å‰ªå‡ºçš„æœ€å¤šå°é¥°æ¡ä¸ªæ•°ï¼Œå¦‚æœä¸€å—éƒ½æ²¡æœ‰ï¼Œé‚£å°±è€è€å®å®è¾“å‡º0ï¼Œæ¯ä¸ªç»“æœä¹‹é—´åº”æ¢è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 1abcde a3 2aaaaaa aa 3# æ ·ä¾‹è¾“å‡º 10 23 æç¤º æ— \næ€è·¯ KMPæ¨¡æ¿é¢˜ï¼Œæ³¨æ„åŒ¹é…æˆåŠŸä¹‹åj=0è€Œä¸æ˜¯ç»§ç»­æ¥ç€ä¸Šä¸€ä¸ªçš„ã€‚\nä»£ç  1char s[mxn], t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 ans++; 29 j = 0; 30 // return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 return ans; 36 // return -1; 37} 38 39int main() 40{ 41 while(scanf(\u0026#34;%s\u0026#34;, s)==1 \u0026amp;\u0026amp; strcmp(s, \u0026#34;#\u0026#34;)) 42 { 43 scanf(\u0026#34;%s\u0026#34;, t); 44 int tl = strlen(t), sl = strlen(s); 45 getnxt(t, tl); 46 printf(\u0026#34;%d\\n\u0026#34;, KMP(s, t, sl, tl)); 47 } 48 return 0; 49} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2087-%E5%89%AA%E8%8A%B1%E5%B8%83%E6%9D%A1/","summary":"å‰ªèŠ±å¸ƒæ¡ (HDU-2087) é¢˜é¢ ä¸€å—èŠ±å¸ƒæ¡ï¼Œé‡Œé¢æœ‰äº›å›¾æ¡ˆï¼Œå¦æœ‰ä¸€å—ç›´æ¥å¯ç”¨çš„å°é¥°æ¡ï¼Œé‡Œé¢ä¹Ÿæœ‰ä¸€äº›å›¾æ¡ˆã€‚å¯¹äºç»™å®šçš„èŠ±å¸ƒæ¡å’Œå°é¥°æ¡ï¼Œè®¡ç®—ä¸€ä¸‹èƒ½ä»èŠ±å¸ƒæ¡ä¸­å°½å¯èƒ½å‰ªå‡º","title":"HDU-2087 å‰ªèŠ±å¸ƒæ¡"},{"content":"Number Sequence (HDU-1711) é¢˜é¢ Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.\nè¾“å…¥ The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). The second line contains N integers which indicate a[1], a[2], \u0026hellip;\u0026hellip; , a[N]. The third line contains M integers which indicate b[1], b[2], \u0026hellip;\u0026hellip; , b[M]. All integers are in the range of [-1000000, 1000000].\nè¾“å‡º For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.\næ ·ä¾‹è¾“å…¥ 12 213 5 31 2 1 2 3 1 2 3 1 3 2 1 2 41 2 3 1 3 513 5 61 2 1 2 3 1 2 3 1 3 2 1 2 71 2 3 2 1 æ ·ä¾‹è¾“å‡º 16 2-1 æç¤º æ— \næ€è·¯ KMPæ¨¡æ¿é¢˜\nä»£ç  1int s[mxn], t[mxn]; 2int nxt[mxn]; 3 4void getnxt(int* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(int* s, int* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 42 while(T--) 43 { 44 int n, m; 45 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 46 for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;s[i]); 47 for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[i]); 48 getnxt(t, m); 49 int ans = KMP(s, t, n, m); 50 printf(\u0026#34;%d\\n\u0026#34;, ans == -1 ? -1 : ans+1); 51 } 52 return 0; 53} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1711-number-sequence/","summary":"Number Sequence (HDU-1711) é¢˜é¢ Given two sequences of numbers : a[1], a[2], \u0026hellip;\u0026hellip; , a[N], and b[1], b[2], \u0026hellip;\u0026hellip; , b[M] (1 \u0026lt;= M \u0026lt;= 10000, 1 \u0026lt;= N \u0026lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], \u0026hellip;\u0026hellip; , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest","title":"HDU-1711 Number Sequence"},{"content":"ç®€ä»‹ Manacherâ€˜s Algorithmæ˜¯ç”¨æ¥æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­ä¸²çš„çº¿æ€§æ–¹æ³•ï¼Œç”±ä¸€ä¸ªå«Manacherçš„äººåœ¨1975å¹´å‘æ˜çš„ã€‚ä¸­æ–‡è°éŸ³â€œé©¬æ‹‰è½¦â€ç®—æ³•ã€‚æ—¶é—´å¤æ‚åº¦O(|S|)ã€‚\næœ´ç´ ç®—æ³• ç»™å‡ºä¸€ä¸ªæœ´ç´ çš„ä¸­å¿ƒæ‰©å±•ç®—æ³•ï¼Œå¯»æ‰¾æœ€é•¿å›æ–‡å­ä¸²ï¼Œæšä¸¾æ‰€æœ‰å¥‡å¶å›æ–‡ä¸­å¿ƒç‚¹ï¼ˆn+n-1ä¸ªï¼‰ï¼Œç„¶åå‘ä¸¤ç«¯æ‰©å±•ï¼Œåˆ¤æ–­å·¦å³å­—ç¬¦æ˜¯å¦ç›¸ç­‰å³å¯ã€‚æ—¶é—´å¤æ‚åº¦$ O(|S|^{2}) $ã€‚\nå®ç°ä»£ç å¦‚ä¸‹ï¼š\n1int expand(char* s, int n, int l, int r) 2{ 3 while(l\u0026gt;=0 \u0026amp;\u0026amp; r\u0026lt;=n \u0026amp;\u0026amp; s[l]==s[r]) 4 l--, r++; 5 return r-l-1; 6} 7 8int simple(char* s) 9{ 10 int n = strlen(s), len = 0; 11 int start = 0, end = 0; 12 13 for(int i=0; i\u0026lt;n; i++) 14 { 15 int t = max(expand(s, n, i, i), expand(s, n, i, i+1)); 16 if(t \u0026gt; len){ 17 len = t; 18 start = i - (len - 1) / 2; 19 end = i + len / 2; 20 } 21 } 22 for(int i=start; i\u0026lt;=end; i++){ 23 printf(\u0026#34;%c\u0026#34;, s[i]); 24 } 25 printf(\u0026#34;\\n\u0026#34;); 26 return len; 27} é¢„å¤„ç† é¦–å…ˆæˆ‘ä»¬å¤„ç†ä¸€ä¸‹é•¿åº¦çš„å¥‡å¶ï¼Œåœ¨æ¯ä¸ªå­—ç¬¦é—´æ’å…¥'#'ï¼Œå¹¶ä¸”ä¸ºä½¿å¾—æ‰©å±•åˆ°è¾¹ç•Œèƒ½è‡ªåŠ¨ç»“æŸï¼Œåœ¨é¦–å°¾åˆ†åˆ«æ’å…¥'^'å’Œ'$'ï¼ˆä¸ä¼šåœ¨åŸä¸²ä¸­å‡ºç°çš„å­—ç¬¦ï¼‰ã€‚è¿™æ ·å­—ç¬¦ä¸²çš„é•¿åº¦å°±è¢«å¤„ç†ä¸ºå¥‡æ•°äº†ã€‚\né¢„å¤„ç†ä»£ç å¦‚ä¸‹ï¼š\n1int manacher_init(char *s, char *t, int n) 2{ 3 int j = 2; t[0] = \u0026#39;$\u0026#39;, t[1] = \u0026#39;#\u0026#39;; 4 for (int i=0; i\u0026lt;n; i++) 5 { 6 t[j++] = s[i]; 7 t[j++] = \u0026#39;#\u0026#39;; 8 } 9 t[j] = \u0026#39;\\0\u0026#39;; 10 return j; 11} Manacherç®—æ³• idx 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 T $ # a # b # a # b # a # a # b # c # \\0 r 1 2 1 4 1 6 1 4 1 2 5 2 1 2 1 2 1 p 0 1 0 3 0 5 0 3 0 1 4 1 0 1 0 1 0 è§‚å¯Ÿå¯å¾—ï¼Œæœ€é•¿å›æ–‡å­ä¸²p[i] = æœ€é•¿å›æ–‡åŠå¾„r[i] - 1ï¼Œp[i]æ‰€ä»£è¡¨çš„å­ä¸²åœ¨åŸä¸²çš„èµ·ç‚¹ä¸º(i-p[i])/2ã€‚\né‚£ä¹ˆp[i]æ€ä¹ˆæ±‚å‘¢ï¼Œä»¤mxä¸ºå½“å‰å·²æ±‚å‡ºçš„æœ€å³çš„å›æ–‡å­ä¸²å³è¾¹ç•Œï¼Œä»¤idä¸ºè¿™ä¸ªå›æ–‡å­ä¸²çš„ä¸­å¿ƒç‚¹ï¼Œè®¨è®ºä»¥ä¸‹3ç§æƒ…å†µï¼š\n(1) å½“i$\u0026lt;$mxæ—¶ï¼Œä»¤j=2*id-1ï¼Œå³iå…³äºidçš„å¯¹ç§°ç‚¹ï¼Œå¦‚æœi+p[j]$\u0026lt;$mxï¼Œé‚£ä¹ˆç”±å›æ–‡ä¸²çš„æ€§è´¨å¯çŸ¥p[i]=p[j]ã€‚\n(2) å½“i$\u0026lt;$mxæ—¶ï¼Œä»¤j=2*id-1ï¼Œå³iå…³äºidçš„å¯¹ç§°ç‚¹ï¼Œå¦‚æœi+p[j]$\u0026gt;=$mxï¼Œé‚£ä¹ˆå¯ä»¥ç¡®å®šçš„æ˜¯p[i]=mx-iï¼Œç„¶åè¶…å‡ºéƒ¨åˆ†å°±éœ€è¦ä¸­å¿ƒæ‹“å±•æ¯”è¾ƒäº†ã€‚\n(3) å½“i\u0026gt;=mxæ—¶ï¼Œæ— æ³•æ ¹æ®å·²çŸ¥æ¡ä»¶åˆ¤æ–­ï¼Œåªèƒ½ä¸­å¿ƒæ‹“å±•æ¯”è¾ƒäº†ã€‚\næŒ‰ç…§ä»¥ä¸Šæ€è·¯ï¼Œéå†ä¸€ä¸‹å³å¯ï¼Œæ³¨æ„æ›´æ–°idå’Œmxã€‚æ­¤å†™æ³•å¾—å‡ºçš„p[i]æ˜¯æœ€é•¿åŠå¾„æ•°ç»„ï¼Œå¹¶éæœ€é•¿å›æ–‡å­ä¸²é•¿åº¦ï¼Œanséœ€è¦å‡1ï¼Œè‹¥æœ‰éœ€è¦ï¼Œä¿®æ”¹ä¸­å¿ƒæ‰©å±•ä»£ç å³å¯ã€‚ä»£ç å¦‚ä¸‹ï¼š\n1int manacher(char *t, int *p, int n) 2{ 3 int id = 0, mx = 0, ans = 0; 4 for (int i=1; i\u0026lt;=n; i++) 5 { 6 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 7 8 while (t[i+p[i]] == t[i-p[i]]) p[i]++; // ä¸­å¿ƒæ‰©å±• 9 10 if (mx \u0026lt; i+p[i]) 11 mx = i+p[i], id = i; 12 13 ans = max(ans, p[i]); 14 } 15 return ans-1; 16} æ¨¡æ¿ 1char s[mxn], t[mxn]; 2int p[mxn]; 3 4int manacher_init(char *s, char *t, int n) 5{ 6 int j = 2; t[0] = \u0026#39;$\u0026#39;, t[1] = \u0026#39;#\u0026#39;; 7 for (int i=0; i\u0026lt;n; i++) 8 { 9 t[j++] = s[i]; 10 t[j++] = \u0026#39;#\u0026#39;; 11 } 12 t[j] = \u0026#39;\\0\u0026#39;; 13 return j; 14} 15 16int manacher(char *t, int *p, int n) 17{ 18 int id = 0, mx = 0, ans = 0; 19 for (int i=1; i\u0026lt;=n; i++) 20 { 21 p[i] = i\u0026lt;mx ? min(p[2*id-i], mx-i) : 1; 22 23 while (t[i+p[i]] == t[i-p[i]]) p[i]++; // ä¸­å¿ƒæ‰©å±• 24 25 if (mx \u0026lt; i+p[i]) 26 mx = i+p[i], id = i; 27 28 ans = max(ans, p[i]); 29 } 30 return ans-1; 31} 32 33int expand(char* s, int n, int l, int r) 34{ 35 while(l\u0026gt;=0 \u0026amp;\u0026amp; r\u0026lt;=n \u0026amp;\u0026amp; s[l]==s[r]) 36 l--, r++; 37 return r-l-1; 38} 39 40int simple(char* s) 41{ 42 int n = strlen(s), len = 0; 43 int start = 0, end = 0; 44 45 for(int i=0; i\u0026lt;n; i++) 46 { 47 int t = max(expand(s, n, i, i), expand(s, n, i, i+1)); 48 if(t \u0026gt; len){ 49 len = t; 50 start = i - (len - 1) / 2; 51 end = i + len / 2; 52 } 53 } 54 // for(int i=start; i\u0026lt;=end; i++){ 55 // printf(\u0026#34;%c\u0026#34;, s[i]); 56 // } 57 // printf(\u0026#34;\\n\u0026#34;); 58 return len; 59} 60 61int main() 62{ 63 scanf(\u0026#34;%s\u0026#34;, s); 64 int n = manacher_init(s, t, strlen(s)); 65 printf(\u0026#34;%d\\n\u0026#34;, simple(s)); 66 printf(\u0026#34;%d\\n\u0026#34;, manacher(t, p, n)); 67 for(int i=0; i\u0026lt;n; i++){ 68 printf(\u0026#34;%d \u0026#34;, p[i]); 69 } 70 printf(\u0026#34;\\n\u0026#34;); 71 return 0; 72} ","permalink":"https://blog.lordash.de/posts/algorithm/manacher/","summary":"ç®€ä»‹ Manacherâ€˜s Algorithmæ˜¯ç”¨æ¥æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­ä¸²çš„çº¿æ€§æ–¹æ³•ï¼Œç”±ä¸€ä¸ªå«Manacherçš„äººåœ¨1975å¹´å‘æ˜çš„ã€‚ä¸­æ–‡","title":"Manacher"},{"content":"ç®€ä»‹ ç»™å®šé•¿åº¦ä¸ºnçš„æ–‡æœ¬ä¸²Så’Œé•¿åº¦ä¸ºmçš„æ¨¡å¼ä¸²Tï¼Œå®šä¹‰extend[i]ä¸ºS[iâ€¦n-1]ä¸T[0â€¦m-1]çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ï¼Œæ±‚extend[i]ã€‚å½“extend[x]==mæ—¶ï¼Œåˆ™å¯çŸ¥æ–‡æœ¬ä¸²Sä¸­åŒ…å«æ¨¡å¼ä¸²Tï¼Œå¹¶ä¸”é¦–ä½ç½®ä¸ºxï¼Œè€Œè¿™æ­£æ˜¯KMPç®—æ³•å¤„ç†çš„æ¨¡å¼åŒ¹é…é—®é¢˜ã€‚ç›¸è¾ƒäºKMPç®—æ³•ï¼Œæ‰©å±•KMPç®—æ³•èƒ½æ‰¾åˆ°æ–‡æœ¬ä¸²Sä¸­æ‰€æœ‰æ¨¡å¼ä¸²Tçš„åŒ¹é…ï¼Œæ›´ä¸€èˆ¬åœ°ï¼Œå¯ä»¥çŸ¥é“æ–‡æœ¬ä¸²Sä¸­ä»¥æ¯ä¸ªå­—ç¬¦å¼€å§‹çš„åç¼€ä¸æ¨¡å¼ä¸²Tçš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ï¼Œæ—¶é—´å¤æ‚åº¦O(n+m)ã€‚\næ‰©å±•KMP å‡è®¾éå†åˆ°iæ—¶ï¼Œå·²ç»æ±‚å‡ºextend[0â€¦i-1]çš„å€¼ã€‚æˆ‘ä»¬è®°å½•ä¸‹éå†è¿‡ç¨‹ä¸­åŒ¹é…æˆåŠŸçš„å­—ç¬¦çš„æœ€è¿œä½ç½®ä¸ºpï¼Œå¹¶ä¸”è¿™æ¬¡åŒ¹é…çš„èµ·å§‹ä½ç½®ä¸ºaã€‚æ¢å¥è¯è¯´ï¼Œè®¡ç®—åˆ°xæ—¶ï¼ŒåŒ¹é…æˆåŠŸçš„æœ€è¿œä½ç½®æ˜¯x+extend[x]-1ï¼Œpå°±æ˜¯x=0â€¦i-1å¾—åˆ°çš„æœ€å¤§å€¼ï¼Œaå°±æ˜¯å¯¹åº”çš„xã€‚\nè®¾è¾…åŠ©æ•°ç»„next[i]è¡¨ç¤ºT[iâ€¦m-1]å’ŒT[0â€¦m-1]çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ï¼ˆæ³¨æ„è¿™é‡Œä¸KMPç®—æ³•ä¸­çš„nextæ•°ç»„å«ä¹‰ä¸åŒï¼‰ã€‚ä»¤len=next[i-a]ï¼Œè®¨è®ºä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š\n(1) i + len-1 \u0026lt; p\nç”±nextæ•°ç»„å®šä¹‰å¯çŸ¥ T[0â€¦len-1] == T[i-aâ€¦i-a+len-1]ï¼Œå¹¶ä¸”ç”±extendæ•°ç»„å®šä¹‰å¯çŸ¥ S[aâ€¦p] == T[0â€¦p-a]ï¼Œå¾—åˆ° S[iâ€¦i+len-1] == T[i-aâ€¦i-a+len-1] ï¼Œæ‰€ä»¥ S[iâ€¦i+len-1] == T[0â€¦len-1]ã€‚å¹¶ä¸” S[i+len-1â€¦p] != T[len-1â€¦i-a]ï¼Œä¸ç„¶è¿èƒŒäº†nextæ•°ç»„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦çš„å®šä¹‰ã€‚äºæ˜¯ï¼Œæ— éœ€ä»»ä½•æ¯”è¾ƒå°±å¯ä»¥å¾—å‡ºextend[i] = lenã€‚\n(2) i + len-1 \u0026gt;= p\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼ŒåŒ¹é…æœ€è¿œçš„ä½ç½®åªåˆ°pï¼Œå¯¹äºpä¹‹åçš„åŒ¹é…ç»“æœæ˜¯æœªçŸ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­åŒ¹é…S[pâ€¦n-1]å’ŒT[p-iâ€¦m-1]ã€‚åŒ¹é…å®Œä¹‹åï¼Œè¿˜éœ€è¦æ›´æ–°aå’Œpã€‚\nä»¥ä¸Šå°±æ˜¯æ‰©å±•KMPçš„ä¸»è¦æ€æƒ³ï¼Œéå†å³å¯ï¼Œä¸‹é¢ç»™å‡ºå­—ç¬¦ä¸²ä¸‹æ ‡ä»0å¼€å§‹çš„ä¸€ç§exKMPçš„å®ç°ï¼Œæ³¨æ„ä¸ºäº†å®ç°æ–¹ä¾¿ï¼Œä»£ç ä¸­çš„pæ˜¯ä¸Šé¢åˆ†æçš„p+1ï¼Œæ‰€ä»¥åˆ¤æ–­çš„æ—¶å€™æ˜¯i+next[i-a]ã€‚è€Œä¸”åŒæ—¶ç”¨äº†å˜é‡jè·Ÿè¸ªpåœ¨æ–‡æœ¬ä¸²Sä¸æ¨¡å¼ä¸²Tä¸­çš„å¯¹åº”ä½ç½®ï¼Œæ³¨æ„éå†æ–‡æœ¬ä¸²Sæ—¶ï¼Œiåœ¨é€’å¢ï¼Œjéœ€è¦é€’å‡ã€‚\n1void exKMP(char* s, char* t, int n, int m) 2{ 3 int a, p; 4 for (int i=0, j=-1; i\u0026lt;n; i++, j--) //jå³ç­‰äºpä¸içš„è·ç¦»ï¼Œå…¶ä½œç”¨æ˜¯åˆ¤æ–­iæ˜¯å¦å¤§äºpï¼ˆå¦‚æœj\u0026lt;0ï¼Œåˆ™iå¤§äºpï¼‰ 5 { 6 if (j\u0026lt;0 || i+nxt[i-a] \u0026gt;= p) 7 { 8 if (j\u0026lt;0) p = i, j = 0; //å¦‚æœiå¤§äºp 9 while (p\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;m \u0026amp;\u0026amp; s[p]==t[j]) p++, j++; 10 extend[i] = j, a = i; 11 } else 12 extend[i] = nxt[i-a]; 13 } 14} nextæ•°ç»„ æ ¹æ®nextæ•°ç»„å®šä¹‰ï¼Œnext[i]è¡¨ç¤ºT[iâ€¦n]å’ŒT[0â€¦n]çš„æœ€é•¿å…¬å…±å‰ç¼€çš„é•¿åº¦ï¼Œå…¶å®å°±ç›¸å½“äºæ¨¡å¼ä¸²Tä¸è‡ªèº«çš„åŒ¹é…ï¼Œä¸è¿‡è¿™é‡Œnextæ•°ç»„æ˜¯ä»1å¼€å§‹çš„ï¼Œnext[0]åŒ¹é…çš„è‚¯å®šæ˜¯æ•´ä¸ªä¸²çš„é•¿åº¦mã€‚æœ‰å…´è¶£çš„å¯ä»¥è¯•è¯•å†™åˆ°ä¸€ä¸ªå‡½æ•°ä¸­å»ï¼Œä¸‹é¢æ¨¡æ¿ä¸­ç»™å‡ºåˆ†ç¦»çš„å®ç°ã€‚å†æ¬¡å¼ºè°ƒC++ä¸­nextæ˜¯å…³é”®å­—ï¼ˆè¿­ä»£å™¨çš„ä¸€ä¸ªå‡½æ•°ï¼‰ï¼Œå¯ä»¥æ¢ä¸ªåå­—é¿å… CEã€‚\næ¨¡æ¿ 1char s[mxn], t[mxn]; 2int nxt[mxn], extend[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int a, p; nxt[0] = m; 7 for (int i=1, j=-1; i\u0026lt;m; i++, j--) 8 { 9 if (j\u0026lt;0 || i+nxt[i-a] \u0026gt;= p) 10 { 11 if (j\u0026lt;0) p = i, j = 0; 12 while (p\u0026lt;m \u0026amp;\u0026amp; t[p]==t[j]) p++, j++; 13 nxt[i] = j, a = i; 14 } else 15 nxt[i] = nxt[i-a]; 16 } 17} 18 19void exKMP(char* s, char* t, int n, int m) 20{ 21 int a, p; 22 for (int i=0, j=-1; i\u0026lt;n; i++, j--) //jå³ç­‰äºpä¸içš„è·ç¦»ï¼Œå…¶ä½œç”¨æ˜¯åˆ¤æ–­iæ˜¯å¦å¤§äºpï¼ˆå¦‚æœj\u0026lt;0ï¼Œåˆ™iå¤§äºpï¼‰ 23 { 24 if (j\u0026lt;0 || i+nxt[i-a] \u0026gt;= p) 25 { 26 if (j\u0026lt;0) p = i, j = 0; //å¦‚æœiå¤§äºp 27 while (p\u0026lt;n \u0026amp;\u0026amp; j\u0026lt;m \u0026amp;\u0026amp; s[p]==t[j]) p++, j++; 28 extend[i] = j, a = i; 29 } else 30 extend[i] = nxt[i-a]; 31 } 32} 33 34 35int main() 36{ 37 scanf(\u0026#34;%s%s\u0026#34;, s, t); 38 getnxt(t, strlen(t)); 39 exKMP(s, t, strlen(s), strlen(t)); 40 41 for(int i=0; i\u0026lt;strlen(t); i++) 42 printf(\u0026#34;%d \u0026#34;, nxt[i]); 43 printf(\u0026#34;\\n\u0026#34;); 44 45 for(int i=0; i\u0026lt;strlen(s); i++) 46 printf(\u0026#34;%d \u0026#34;, extend[i]); 47 printf(\u0026#34;\\n\u0026#34;); 48 49 return 0; 50} ","permalink":"https://blog.lordash.de/posts/algorithm/%E6%89%A9%E5%B1%95kmp/","summary":"ç®€ä»‹ ç»™å®šé•¿åº¦ä¸ºnçš„æ–‡æœ¬ä¸²Så’Œé•¿åº¦ä¸ºmçš„æ¨¡å¼ä¸²Tï¼Œå®šä¹‰extend[i]ä¸ºS[iâ€¦n-1]ä¸T[0â€¦m-1]çš„æœ€é•¿å…¬å…±å‰ç¼€é•¿åº¦ï¼Œæ±‚extend","title":"æ‰©å±•KMP"},{"content":"ç®€ä»‹ Knuth-Morris-Prattå­—ç¬¦ä¸²æŸ¥æ‰¾ç®—æ³•ï¼Œç®€ç§°ä¸ºâ€œKMPç®—æ³•â€ï¼Œå¸¸ç”¨äºåœ¨ä¸€ä¸ªæ–‡æœ¬ä¸²Så†…æŸ¥æ‰¾ä¸€ä¸ªæ¨¡å¼ä¸²Tçš„å‡ºç°ä½ç½®ã€‚è¿™ä¸ªç®—æ³•ç”±Donald Knuthã€Vaughan Prattã€James H. Morrisä¸‰äººäº1977å¹´è”åˆå‘è¡¨ï¼Œæ•…å–è¿™3äººçš„å§“æ°å‘½åæ­¤ç®—æ³•ã€‚æ—¶é—´å¤æ‚åº¦O(|S|+|T|)ã€‚\næœ´ç´ ç®—æ³• ç»™å‡ºä¸€ä¸ªæœ€ä¸ºå¸¸è§çš„æœ´ç´ å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…ç®—æ³•ï¼Œæšä¸¾æ–‡æœ¬ä¸²Sçš„æ¯ä¸€ä½ï¼Œä½œä¸ºèµ·ç‚¹ä¸æ¨¡å¼ä¸²Tè¿›è¡ŒåŒ¹é…ã€‚æ—¶é—´å¤æ‚åº¦O(|S|*|T|)ã€‚\n1int simple(char* s, char* t, int n, int m) 2{ 3 int i = 0, j = 0; 4 while (i \u0026lt; n) 5 { 6 if (s[i] == t[j]) { 7 i++, j++; 8 if (j \u0026gt;= m) { // åŒ¹é…æˆåŠŸ 9 return i-j; 10 } 11 } else { 12 i = i-j + 1; 13 j = 0; 14 } 15 } 16 return -1; 17} æœ´ç´ ç®—æ³•çš„è¿è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼š\næ³¨æ„åˆ°ï¼Œå¦‚ä¸‹å›¾ï¼Œæšä¸¾ä»¥S[1]ä¸ºèµ·ç‚¹ï¼ŒåŒ¹é…åˆ°æœ€åä¸€ä¸ªå­—ç¬¦ï¼ŒS[4]!=T[3]ï¼Œå¤±é…ä¹‹åæœ´ç´ åšæ³•æ˜¯æŒ‡é’ˆå›é€€ï¼Œä»¥S[2]ä¸ºèµ·ç‚¹å¼€å§‹ä¸‹ä¸€è½®åŒ¹é…ï¼Œå³i=i-j+1, j=0ã€‚\næ¯«æ— ç–‘é—®ï¼Œéšç€æ–‡æœ¬ä¸²Sçš„é•¿åº¦å¢åŠ ï¼Œæ¯ä¸€æ¬¡å›é€€é‡æ–°åŒ¹é…ä¼šèŠ±è´¹å¤§é‡çš„æ—¶é—´ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•ä¼˜åŒ–å‘¢ï¼Ÿ\nnextæ•°ç»„ é€šè¿‡åˆ†ææ¨¡å¼ä¸²Tå¯ä»¥å¾—åˆ°nextæ•°ç»„ï¼Œä¹Ÿå¯ä»¥å½“ä½œfailæ•°ç»„ç†è§£ã€‚å¯¹äºæ¨¡å¼ä¸²T=\u0026quot;abac\u0026quot;ï¼Œå½“åŒ¹é…åˆ°'c'æ—¶å¤±é…äº†ï¼Œé‚£ä¹ˆè¯´æ˜å‰é¢çš„\u0026quot;aba\u0026quot;å·²ç»åŒ¹é…æˆåŠŸï¼Œ\u0026quot;aba\u0026quot;**æœ€é•¿çš„ç›¸ç­‰å‰ç¼€åç¼€(ä¸åŒ…æ‹¬æœ¬èº«)**æ˜¯'a'ï¼Œé‚£ä¹ˆå¤±é…'c'åï¼Œæˆ‘ä»¬å¯ä»¥è·³è¿‡s[3]='a'ï¼ˆæ–‡æœ¬ä¸²S\u0026quot;aba\u0026quot;çš„åç¼€ï¼‰ä¸T[0]='a'ï¼ˆæ¨¡å¼ä¸²T\u0026quot;aba\u0026quot;çš„å‰ç¼€ï¼‰ï¼Œç›´æ¥åŒ¹é…S[4]='b'ä¸T[0]='b'ã€‚\nä¸ºä»€ä¹ˆæ˜¯æœ€é•¿çš„ã€ç›¸ç­‰çš„ã€ä¸åŒ…æ‹¬æœ¬èº«çš„å‰ç¼€åç¼€å‘¢ï¼Ÿçœ‹ä¸‹å›¾è‡ªè¡Œç†è§£ã€‚\nç”±ä¸‹è¡¨å¯ä»¥çœ‹å‡ºæœ€é•¿ç›¸ç­‰å‰ç¼€åç¼€æ•´ä½“å³ç§»ï¼Œé¦–ä½åŠ ä¸Š-1ï¼Œå³æ˜¯nextæ•°ç»„ã€‚\næ¨¡å¼ä¸² a b a c æœ€é•¿ç›¸ç­‰å‰ç¼€åç¼€ 0 0 1 0 nextæ•°ç»„ -1 0 0 1 nextæ•°ç»„ä¼˜åŒ– å¯¹äºå¤±é…æ—¶S[4]='c'ä¸T[3]='b'ä¸ç›¸ç­‰ï¼Œç”±T[1]='b'ä¸T[3]='b'ç›¸ç­‰ï¼Œå¾—å‡ºT[1]='b'ä¸S[4]='c'ä¹Ÿä¸ç›¸ç­‰ï¼Œæˆ‘ä»¬å¯ä»¥è·³è¿‡è¿™ä¸€æ­¥åŒ¹é…ã€‚\næ³¨æ„C++ä¸­nextæ˜¯å…³é”®å­—ï¼ˆè¿­ä»£å™¨çš„ä¸€ä¸ªå‡½æ•°ï¼‰ï¼Œä»¥åŠå­—ç¬¦ä¸²ä¸‹æ ‡ä»0å¼€å§‹å’Œä»1å¼€å§‹çš„ä»£ç ç¨æœ‰ä¸åŒï¼Œæ³¨æ„å¿…é¡»æ±‚åˆ°next[|T|]ï¼Œæ±‚å­—ç¬¦ä¸²åŒ¹é…æ•°é‡ä»¥åŠæœ€å°å¾ªç¯èŠ‚éƒ½éœ€è¦ç”¨åˆ°ã€‚ä¸‹é¢ç»™å‡ºçš„æ˜¯å­—ç¬¦ä¸²ä¸‹æ ‡ä»0å¼€å§‹çš„nextæ•°ç»„çš„ä¸€ç§æ±‚æ³•ï¼š\n1int nxt[mxn]; 2 3void getnxt(char* t, int m) 4{ 5 int i = 0, j = -1; nxt[0] = -1; 6 while (i \u0026lt; m) 7 { 8 if (j == -1 || t[i] == t[j]) { 9 i++, j++; 10 // if (t[i] == t[j]) 11 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 12 // else 13 nxt[i] = j; 14 } else 15 j = nxt[j]; 16 } 17} KMPç®—æ³• æœ‰äº†nextæ•°ç»„ï¼Œä¸‹é¢ç»™å‡ºKMPç®—æ³•ä»£ç ï¼Œä¸æœ´ç´ ç®—æ³•ç±»ä¼¼ï¼Œä½†æ˜¯iä¸ç”¨å›é€€äº†ï¼Œå¯ä»¥çœ‹å‡ºæ±‚nextæ•°ç»„çš„è¿‡ç¨‹ä¹Ÿæ˜¯ä¸€ä¸ªæ¨¡å¼ä¸²Tä¸è‡ªèº«åŒ¹é…çš„è¿‡ç¨‹ã€‚\n1int KMP(char* s, char* t, int n, int m) 2{ 3 int i = 0, j = 0, ans = 0; 4 while (i \u0026lt; n) 5 { 6 if (j == -1 || s[i] == t[j]) { 7 i++, j++; 8 if (j \u0026gt;= m) { // åŒ¹é…æˆåŠŸ 9 return i-j; 10 } 11 } else 12 j = nxt[j]; 13 } 14 return -1; 15} KMPç®—æ³•çš„è¿è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼š\næœ€å°å¾ªç¯èŠ‚ å‚è€ƒ KMPæ¨¡æ¿ï¼Œæœ€å°å¾ªç¯èŠ‚ã€‚\nå®šç†ï¼š\nå‡è®¾Sçš„é•¿åº¦ä¸ºlenï¼Œåˆ™Så­˜åœ¨æœ€å°å¾ªç¯èŠ‚ï¼Œå¾ªç¯èŠ‚çš„é•¿åº¦Lä¸ºlen-next[len]ï¼Œå­ä¸²ä¸ºS[0â€¦len-next[len]-1]ã€‚ ï¼ˆ1ï¼‰å¦‚æœlenå¯ä»¥è¢«len-next[len]æ•´é™¤ï¼Œåˆ™è¡¨æ˜å­—ç¬¦ä¸²Så¯ä»¥å®Œå…¨ç”±å¾ªç¯èŠ‚å¾ªç¯ç»„æˆï¼Œå¾ªç¯å‘¨æœŸT=len/Lã€‚ ï¼ˆ2ï¼‰å¦‚æœä¸èƒ½ï¼Œè¯´æ˜è¿˜éœ€è¦å†æ·»åŠ å‡ ä¸ªå­—æ¯æ‰èƒ½è¡¥å…¨ã€‚éœ€è¦è¡¥çš„ä¸ªæ•°æ˜¯å¾ªç¯ä¸ªæ•°L-len%L=L-(len-L)%L=L-next[len]%Lï¼ŒL=len-next[len]ã€‚\nindex 0 1 2 3 4 5 6 7 char a b c d a b c next -1 0 0 0 0 1 2 3 ä¸ºæ–¹ä¾¿è¯´æ˜ï¼Œå…ˆè®¾å­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºlenï¼Œå¾ªç¯å­ä¸²çš„é•¿åº¦ä¸ºL\nä¾‹1 s0s1s2s3s4s5ï¼Œnext[6]=3 å³s0s1s2=s3s4s5 å¾ˆæ˜æ˜¾å¯çŸ¥ï¼šå¾ªç¯å­ä¸²ä¸ºs0s1s2ï¼ŒL=len-next[6]=3ï¼Œä¸”èƒ½è¢«lenæ•´é™¤ã€‚\nä¾‹2 s0s1s2s3s4s5s6s7ï¼Œnext[8]=6 æ­¤æ—¶len-next[8]=2ï¼Œå³L=2 ç”±s0s1s2s3s4s5=s2s3s4s5s6s7 å¯çŸ¥s0s1=s2s3ï¼Œs2s3=s4s5ï¼Œs4s5=s6s7 æ˜¾ç„¶s0s1ä¸ºå¾ªç¯å­ä¸²\nä¾‹3 s0s1s2s3s4s5s6ï¼Œnext[7]=4 æ­¤æ—¶len-next[7]=3ï¼Œå³L=3 ç”±s0s1s2s3=s3s4s5s6 å¯çŸ¥s0s1=s3s4ï¼Œs2s3=s5s6 ä»è€Œå¯çŸ¥s0s1s2=s3s4s5ï¼Œs0=s3=s6 å³å¦‚æœå†æ·»åŠ 3-4%3=2ä¸ªå­—æ¯ï¼ˆs1s2ï¼‰ï¼Œé‚£ä¹ˆå¾—åˆ°çš„å­—ç¬¦ä¸²å°±å¯ä»¥ç”±s0s1s2å¾ªç¯3æ¬¡ç»„æˆ\nå¯¹äºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚abcd abcd abcdï¼Œç”±é•¿åº¦ä¸º4çš„å­—ç¬¦ä¸²abcdé‡å¤3æ¬¡å¾—åˆ°ï¼Œé‚£ä¹ˆå¿…ç„¶æœ‰åŸå­—ç¬¦ä¸²çš„å‰å…«ä½ç­‰äºåå…«ä½ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºæŸä¸ªä¸‹æ ‡ä»0å¼€å§‹çš„å­—ç¬¦ä¸²Sï¼Œé•¿åº¦ä¸ºlenï¼Œç”±é•¿åº¦ä¸ºLçš„å­—ç¬¦ä¸²sé‡å¤Ræ¬¡å¾—åˆ°ï¼Œå½“Râ‰¥2æ—¶å¿…ç„¶æœ‰S[0â€¦len-L-1]=S[Lâ€¦len-1]ã€‚\né‚£ä¹ˆå¯¹äºKMPç®—æ³•æ¥è¯´ï¼Œå°±æœ‰next[len]=len-Lã€‚æ­¤æ—¶Lè‚¯å®šå·²ç»æ˜¯æœ€å°çš„äº†ï¼ˆå› ä¸ºnextçš„å€¼æ˜¯å‰ç¼€å’Œåç¼€ç›¸ç­‰çš„æœ€å¤§é•¿åº¦ï¼Œå³len-Læ˜¯æœ€å¤§çš„ï¼Œé‚£ä¹ˆåœ¨lenå·²ç»ç¡®å®šçš„æƒ…å†µä¸‹ï¼ŒLæ˜¯æœ€å°çš„ï¼‰\næ¨¡æ¿ 1char s[mxn], t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 scanf(\u0026#34;%s %s\u0026#34;, s, t); 42 getnxt(t, strlen(t)); 43 for(int i=0; i\u0026lt;strlen(t); i++){ 44 printf(\u0026#34;%d \u0026#34;, nxt[i]); 45 } 46 printf(\u0026#34;\\n\u0026#34;); 47 printf(\u0026#34;%d\\n\u0026#34;, simple(s, t, strlen(s), strlen(t))); 48 printf(\u0026#34;%d\\n\u0026#34;, KMP(s, t, strlen(s), strlen(t))); 49 return 0; 50} ","permalink":"https://blog.lordash.de/posts/algorithm/kmp/","summary":"ç®€ä»‹ Knuth-Morris-Prattå­—ç¬¦ä¸²æŸ¥æ‰¾ç®—æ³•ï¼Œç®€ç§°ä¸ºâ€œKMPç®—æ³•â€ï¼Œå¸¸ç”¨äºåœ¨ä¸€ä¸ªæ–‡æœ¬ä¸²Så†…æŸ¥æ‰¾ä¸€ä¸ªæ¨¡å¼ä¸²Tçš„å‡ºç°ä½ç½®ã€‚è¿™ä¸ªç®—æ³•ç”±D","title":"KMP"},{"content":"Paint Chain(HDU-3980) é¢˜é¢ Aekdycoin and abcdxyzk are playing a game. They get a circle chain with some beads. Initially none of the beads is painted. They take turns to paint the chain. In Each turn one player must paint a unpainted beads. Whoever is unable to paint in his turn lose the game. Aekdycoin will take the first move.\nNow, they thought this game is too simple, and they want to change some rules. In each turn one player must select a certain number of consecutive unpainted beads to paint. The other rules is The same as the original. Who will win under the rules ?You may assume that both of them are so clever.\nè¾“å…¥ First line contains T, the number of test cases. Following T line contain 2 integer N, M, indicate the chain has N beads, and each turn one player must paint M consecutive beads. (1 \u0026lt;= N, M \u0026lt;= 1000)\nè¾“å‡º For each case, print \u0026ldquo;Case #idx: \u0026quot; first where idx is the case number start from 1, and the name of the winner.\næ ·ä¾‹è¾“å…¥ 12 23 1 34 2 æ ·ä¾‹è¾“å‡º 1Case #1: aekdycoin 2Case #2: abcdxyzk æç¤º æ— \næ€è·¯ Anti-Nimåšå¼ˆï¼Œå¯ä»¥å‚è§ã€é¢˜è§£ã€‘POJ-3480 Johnã€‚\nä»£ç  1using namespace std; 2int SG[1005]; 3 4int getSg(int n, int m){ 5 if(n\u0026lt;m) return SG[n]=0; 6 if(SG[n]!=-1) return SG[n]; 7 bool S[1005]={0}; 8 9 for(int i=0; i\u0026lt;=n-m; i++) 10 S[getSg(i, m) ^ getSg(n-m-i, m)] = 1; 11 12 int mex = 0; 13 while(S[mex]) mex++; 14 return SG[n]=mex; 15} 16 17int main() 18{ 19 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 20 for(int cs=1; cs\u0026lt;=T; cs++) 21 { 22 memset(SG, -1, sizeof(SG)); 23 int n, m; 24 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 25 printf(\u0026#34;Case #%d: \u0026#34;, cs); 26 if(n\u0026lt;m || getSg(n-m, m)){ 27 printf(\u0026#34;abcdxyzk\\n\u0026#34;); 28 }else{ 29 printf(\u0026#34;aekdycoin\\n\u0026#34;); 30 } 31 } 32 return 0; 33} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3980-paint-chain/","summary":"Paint Chain(HDU-3980) é¢˜é¢ Aekdycoin and abcdxyzk are playing a game. They get a circle chain with some beads. Initially none of the beads is painted. They take turns to paint the chain. In Each turn one player must paint a unpainted beads. Whoever is unable to paint in his turn lose the game. Aekdycoin will take the first move. Now, they thought this game is too simple, and they","title":"HDU-3980 Paint Chain"},{"content":"Be the Winner(HDU-2509) é¢˜é¢ Let\u0026rsquo;s consider m apples divided into n groups. Each group contains no more than 100 apples, arranged in a line. You can take any number of consecutive apples at one time. For example \u0026ldquo;@@@\u0026rdquo; can be turned into \u0026ldquo;@@\u0026rdquo; or \u0026ldquo;@\u0026rdquo; or \u0026ldquo;@ @\u0026quot;(two piles). two people get apples one after another and the one who takes the last is the loser. Fra wants to know in which situations he can win by playing strategies (that is, no matter what action the rival takes, fra will win).\nè¾“å…¥ You will be given several cases. Each test case begins with a single number n (1 \u0026lt;= n \u0026lt;= 100), followed by a line with n numbers, the number of apples in each pile. There is a blank line between cases.\nè¾“å‡º If a winning strategies can be found, print a single line with \u0026ldquo;Yes\u0026rdquo;, otherwise print \u0026ldquo;No\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 12 22 2 31 43 æ ·ä¾‹è¾“å‡º 1No 2Yes æç¤º æ— \næ€è·¯ Anti-Nimåšå¼ˆï¼Œå¯ä»¥å‚è§ã€é¢˜è§£ã€‘POJ-3480 Johnã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n; 6 for(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) 7 { 8 int nim=0, anti=0; 9 for(int i=0; i\u0026lt;n; i++){ 10 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 11 if(x\u0026gt;1) anti = 1; 12 nim ^=x; 13 } 14 if((!nim\u0026amp;\u0026amp;!anti) || (nim\u0026amp;\u0026amp;anti)){ 15 printf(\u0026#34;Yes\\n\u0026#34;); 16 }else{ 17 printf(\u0026#34;No\\n\u0026#34;); 18 } 19 } 20 return 0; 21} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2509-be-the-winner/","summary":"Be the Winner(HDU-2509) é¢˜é¢ Let\u0026rsquo;s consider m apples divided into n groups. Each group contains no more than 100 apples, arranged in a line. You can take any number of consecutive apples at one time. For example \u0026ldquo;@@@\u0026rdquo; can be turned into \u0026ldquo;@@\u0026rdquo; or \u0026ldquo;@\u0026rdquo; or \u0026ldquo;@ @\u0026quot;(two piles). two people get apples one after another and the one who takes the last is the loser. Fra wants to","title":"HDU-2509 Be the Winner"},{"content":"Partitioning Game(LightOJ-1199) é¢˜é¢ Alice and Bob are playing a strange game. The rules of the game are:\nInitially there are n piles. A pile is formed by some cells. Alice starts the game and they alternate turns. In each tern a player can pick any pile and divide it into two unequal piles. If a player cannot do so, he/she loses the game. Now you are given the number of cells in each of the piles, you have to find the winner of the game if both of them play optimally.\nè¾“å…¥ Input starts with an integer T (â‰¤ 1000), denoting the number of test cases.\nEach case starts with a line containing an integer n (1 â‰¤ n â‰¤ 100). The next line contains n integers, where the ith integer denotes the number of cells in the ith pile. You can assume that the number of cells in each pile is between 1 and 10000.\nè¾“å‡º For each case, print the case number and \u0026lsquo;Alice\u0026rsquo; or \u0026lsquo;Bob\u0026rsquo; depending on the winner of the game.\næ ·ä¾‹è¾“å…¥ 13 21 34 43 51 2 3 61 77 æ ·ä¾‹è¾“å‡º 1Case 1: Bob 2Case 2: Alice 3Case 3: Bob æç¤º æ— \næ€è·¯ SGå‡½æ•°æ‰“è¡¨ã€‚\nä»£ç  1using namespace std; 2int SG[10005]; 3 4void getSg(int n) { 5 for(int i=1; i\u0026lt;=n; i++){ 6 bool S[10005]={0}; 7 for(int j=1; j+j\u0026lt;i; j++) 8 S[SG[j] ^ SG[i-j]] = 1; 9 int mex = 0; 10 while(S[mex]) mex++; 11 SG[i] = mex; 12 } 13} 14 15int main() 16{ 17 getSg(10005); 18 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 19 for(int cs=1; cs\u0026lt;=T; cs++) 20 { 21 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 22 23 int nim = 0; 24 for(int i=0; i\u0026lt;n; i++){ 25 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 26 nim ^= SG[x]; 27 } 28 printf(\u0026#34;Case %d: \u0026#34;, cs); 29 if(nim){ 30 printf(\u0026#34;Alice\\n\u0026#34;); 31 }else{ 32 printf(\u0026#34;Bob\\n\u0026#34;); 33 } 34 } 35 return 0; 36} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1199-partitioning-game/","summary":"Partitioning Game(LightOJ-1199) é¢˜é¢ Alice and Bob are playing a strange game. The rules of the game are: Initially there are n piles. A pile is formed by some cells. Alice starts the game and they alternate turns. In each tern a player can pick any pile and divide it into two unequal piles. If a player cannot do so, he/she loses the game. Now you are given the number","title":"LightOJ-1199 Partitioning Game"},{"content":"Crazy Calendar(LightOJ-1393) é¢˜é¢ 2011 was a crazy year. Many people all over the world proposed on 11-11-11, married on 11-11-11, some even went through surgery only to have 11-11-11 as their child\u0026rsquo;s birth date. How crazy people can be! Don\u0026rsquo;t they see there is a \u0026ldquo;20\u0026rdquo; hidden? Then what to do? A very elegant solution came from ARR, a very famous and funny character - why do we need to follow Christian (or some calls it Gregorian) calendar? Why don\u0026rsquo;t we start our own calendar on the day of marriage? And those who like to celebrate their marriage ceremony too frequent, why don\u0026rsquo;t they declare only 1 day per year. In that fashion they can celebrate their anniversary every day. And may be one minute a year or a second or \u0026hellip; Uh.. getting complex. Let\u0026rsquo;s back to the title. From now, we start to have a new calendar system, \u0026ldquo;Kisu Pari Na\u0026rdquo;. And we hope to update this calendar on every national contest.\nThe purpose of this calendar is - we all will try our best to learn something new in every year. For this first year let\u0026rsquo;s learn some combinatory. It reminds me of my first year in college. I faced this problem but could not solve this then. But see how easy it is:\n(1, 1) (1, 2) (1, 3) (1, 4) (2, 1) (2, 2) (2, 3) (2, 4) (3, 1) (3, 2) (3, 3) (3, 4) Say you start from upper left cell and want to go to lower right cell. The only restriction is you can only move downward or rightward. How many ways are there? How to solve it? Not that difficult. You have to go two times Down and three times Right (whichever way you try) to reach the goal from the starting cell, right? So the answer is number of ways you can arrange two D (represents Down) and three R (represent Right). 2 same characters and 3 same characters, total 5 characters. So it is:\n$ \\frac{5!}{2!3!} $ Or = $ \\frac{(D+R)!}{D!R!} $ D+RCR. Easy isn\u0026rsquo;t it?\nOk enough with learning. Now back to problem, given a grid and at each cell there are some coins. Inky and Pinky are playing a game getting inspiration from the above problem. At each turn, a player chooses a non empty cell and then removes one or more coins from that cell and put them to the cell exactly right of it or exactly beneath it. A player can\u0026rsquo;t divide the coins and put one part to right and others to down. Note that, for the cells at the right column the player can\u0026rsquo;t move it to more right, and same for the bottom-most row. So a player can\u0026rsquo;t move coins from the lower right cell. The game will finish when no moves are available and the player who moved last will win. Now inky being very modest asked Pinky to move first. Can you say if Pinky will win if both play perfectly?\nè¾“å…¥ Input starts with an integer T (â‰¤ 100), denoting the number of test cases.\nEach case starts with a line containing two integers R C (1 â‰¤ R * C â‰¤ 50000), where R denotes the number of rows and C denotes the number of columns of the grid respectively. Each of the next R lines contains C space separated integers denoting the grid. These integers lie in the range [0, 109].\nè¾“å‡º For every test case, output case number followed by \u0026ldquo;win\u0026rdquo; if Pinky can win or \u0026ldquo;lose\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 11 22 2 31 1 41 1 æ ·ä¾‹è¾“å‡º 1Case 1: lose æç¤º Dataset is huge, use faster I/O methods.\næ€è·¯ å¯ä»¥å‘ç°æ›¼å“ˆé¡¿è·ç¦»ä¸ºå¶æ•°çš„ï¼Œå…ˆæ‰‹å¿…èƒœï¼›ä¸ºå¥‡æ•°çš„ï¼ŒNimä¸€ä¸‹ã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 for(int cs=1; cs\u0026lt;=T; cs++) 7 { 8 int n, m; 9 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 10 11 int nim=0; 12 for(int i=0; i\u0026lt;n; i++){ 13 for(int j=0; j\u0026lt;m; j++){ 14 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 15 if((n-i+m-j) \u0026amp; 1) 16 nim ^= x; 17 } 18 } 19 printf(\u0026#34;Case %d: \u0026#34;, cs); 20 if(nim){ 21 printf(\u0026#34;win\\n\u0026#34;); 22 }else{ 23 printf(\u0026#34;lose\\n\u0026#34;); 24 } 25 } 26 return 0; 27} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1393-crazy-calendar/","summary":"Crazy Calendar(LightOJ-1393) é¢˜é¢ 2011 was a crazy year. Many people all over the world proposed on 11-11-11, married on 11-11-11, some even went through surgery only to have 11-11-11 as their child\u0026rsquo;s birth date. How crazy people can be! Don\u0026rsquo;t they see there is a \u0026ldquo;20\u0026rdquo; hidden? Then what to do? A very elegant solution came from ARR, a very famous and funny character - why do we need","title":"LightOJ-1393 Crazy Calendar"},{"content":"Misere Nim(LightOJ-1253) é¢˜é¢ Alice and Bob are playing game of MisÃ¨re Nim. MisÃ¨re Nim is a game playing on k piles of stones, each pile containing one or more stones. The players alternate turns and in each turn a player can select one of the piles and can remove as many stones from that pile unless the pile is empty. In each turn a player must remove at least one stone from any pile. Alice starts first. The player who removes the last stone loses the game.\nè¾“å…¥ Input starts with an integer T (â‰¤ 200), denoting the number of test cases.\nEach case starts with a line containing an integer k (1 â‰¤ k â‰¤ 100). The next line contains k space separated integers denoting the number of stones in each pile. The number of stones in a pile lies in the range [1, 109].\nè¾“å‡º For each case, print the case number and \u0026lsquo;Alice\u0026rsquo; if Alice wins otherwise print \u0026lsquo;Bob\u0026rsquo;.\næ ·ä¾‹è¾“å…¥ 13 24 32 3 4 5 45 51 1 2 4 10 61 71 æ ·ä¾‹è¾“å‡º 1Case 1: Bob 2Case 2: Alice 3Case 3: Bob æç¤º æ— \næ€è·¯ Anti-Nimåšå¼ˆï¼Œå¯ä»¥å‚è§ã€é¢˜è§£ã€‘POJ-3480 Johnã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 for(int cs=1; cs\u0026lt;=T; cs++) 7 { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 int nim=0, anti=0; 11 for(int i=0; i\u0026lt;n; i++){ 12 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 13 if(x\u0026gt;1) anti = 1; 14 nim ^=x; 15 } 16 printf(\u0026#34;Case %d: \u0026#34;, cs); 17 if((!nim\u0026amp;\u0026amp;!anti) || (nim\u0026amp;\u0026amp;anti)){ 18 printf(\u0026#34;Alice\\n\u0026#34;); 19 }else{ 20 printf(\u0026#34;Bob\\n\u0026#34;); 21 } 22 } 23 return 0; 24} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1253-misere-nim/","summary":"Misere Nim(LightOJ-1253) é¢˜é¢ Alice and Bob are playing game of MisÃ¨re Nim. MisÃ¨re Nim is a game playing on k piles of stones, each pile containing one or more stones. The players alternate turns and in each turn a player can select one of the piles and can remove as many stones from that pile unless the pile is","title":"LightOJ-1253 Misere Nim"},{"content":"Matrix Game(LightOJ-1247) é¢˜é¢ Given an m x n matrix, where m denotes the number of rows and n denotes the number of columns and in each cell a pile of stones is given. For example, let there be a 2 x 3 matrix, and the piles are\n2 3 8\n5 2 7\nThat means that in cell(1, 1) there is a pile with 2 stones, in cell(1, 2) there is a pile with 3 stones and so on.\nNow Alice and Bob are playing a strange game in this matrix. Alice starts first and they alternate turns. In each turn a player selects a row, and can draw any number of stones from any number of cells in that row. But he/she must draw at least one stone. For example, if Alice chooses the 2nd row in the given matrix, she can pick 2 stones from cell(2, 1), 0 stones from cell (2, 2), 7 stones from cell(2, 3). Or she can pick 5 stones from cell(2, 1), 1 stone from cell(2, 2), 4 stones from cell(2, 3). There are many other ways but she must pick at least one stone from all piles. The player who can\u0026rsquo;t take any stones loses.\nNow if both play optimally who will win?\nè¾“å…¥ Input starts with an integer T (â‰¤ 100), denoting the number of test cases.\nEach case starts with a line containing two integers: m and n (1 â‰¤ m, n â‰¤ 50). Each of the next m lines contains n space separated integers that form the matrix. All the integers will be between 0 and 10^9 (inclusive).\nè¾“å‡º For each case, print the case number and \u0026lsquo;Alice\u0026rsquo; if Alice wins, or \u0026lsquo;Bob\u0026rsquo; otherwise.\næ ·ä¾‹è¾“å…¥ 12 22 3 32 3 8 45 2 7 52 3 61 2 3 73 2 1 æ ·ä¾‹è¾“å‡º 1Case 1: Alice 2Case 2: Bob æç¤º æ— \næ€è·¯ Nimåšå¼ˆï¼Œæ¯è¡Œä»»æ„å–ï¼Œä»¥æ¯è¡Œæ€»å’Œä¸ºçŸ³å­å †æ•°åšä¸€ä¸ªNImåšå¼ˆå³å¯ã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 for(int cs=1; cs\u0026lt;=T; cs++) 7 { 8 int n, m; 9 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 10 11 int nim = 0; 12 for(int i=0; i\u0026lt;n; i++){ 13 int sum = 0; 14 for(int j=0; j\u0026lt;m; j++){ 15 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 16 sum += x; 17 } 18 nim ^= sum; 19 } 20 printf(\u0026#34;Case %d: \u0026#34;, cs); 21 if(nim){ 22 printf(\u0026#34;Alice\\n\u0026#34;); 23 }else{ 24 printf(\u0026#34;Bob\\n\u0026#34;); 25 } 26 27 } 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1247-matrix-game/","summary":"Matrix Game(LightOJ-1247) é¢˜é¢ Given an m x n matrix, where m denotes the number of rows and n denotes the number of columns and in each cell a pile of stones is given. For example, let there be a 2 x 3 matrix, and the piles are 2 3 8 5 2 7 That means that in cell(1, 1) there is a pile with 2 stones, in cell(1, 2)","title":"LightOJ-1247 Matrix Game"},{"content":"Left Right(LightOJ-1192) é¢˜é¢ Two players, Alice and Bob are playing a strange game in a 1 x n board. The cells are numbered from 0 to n-1, where the left most cell is marked as cell 0. Each cell can contain at most one piece.\nThere are two kinds of pieces, gray and white. Alice moves all the gray pieces, and bob moves all the white ones. The pieces alternate, that is, leftmost piece is gray, next is white, next to that is gray, then it\u0026rsquo;s white again, and so on. There will always be equal number of black and gray pieces. Alice can only move pieces to the right. Bob can only move pieces to the left.\nIn each move, a player selects one piece and moves that piece, either to its left (Bob) or to its right (Alice), any number of cells (at least 1) but, it can neither jump over other pieces, nor it can move outside of the board. The players alternate their turns.\nFor example, if Alice decides to move the left most gray piece, these two moves are available to her.\nIllustration Fig 1: Initial Position Fig 2: Alice moving the gray piece one cell to the right Fig 3: Alice moving the gray piece two cells to the right Alice moves first. The game ends, when someone is unable to make any move, and loses the game. You can assume that, both of them play optimally (that is, if it is possible to apply a strategy that will ensure someone\u0026rsquo;s win, he/she will always use that strategy). Now you are given a configuration of a board, you have to find the winner.\nè¾“å…¥ Input starts with an integer T (â‰¤ 200), denoting the number of test cases.\nEach case starts with a line containing an integer k (1 â‰¤ k â‰¤ 100) denoting the number of gray pieces in the board. The next line contains 2k distinct integers (in ascending order) denoting the position of the pieces. The first integer denotes a gray piece, the second integer denotes a white piece, the next integer denotes a gray piece and so on. All the integers will lie in the range [0, 10^9].\nAssume that n is sufficiently large to contain all the pieces. And at least one move is remaining.\nè¾“å‡º For each case, print the case number and Alice or Bob depending on the winner of the game.\næ ·ä¾‹è¾“å…¥ 12 22 30 3 7 9 42 51 3 7 9 æ ·ä¾‹è¾“å‡º 1Case 1: Alice 2Case 2: Bob æç¤º æ— \næ€è·¯ Nimåšå¼ˆï¼Œä»¥é—´è·ä¸ºçŸ³å­å †æ•°åšä¸€ä¸ªNimåšå¼ˆå³å¯ã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 for(int cs=1; cs\u0026lt;=T; cs++) 7 { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 int nim = 0; 11 for(int i=0; i\u0026lt;n; i++){ 12 int a, b; 13 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); 14 nim ^= b-a-1; 15 } 16 17 printf(\u0026#34;Case %d: \u0026#34;, cs); 18 if(nim){ 19 printf(\u0026#34;Alice\\n\u0026#34;); 20 }else{ 21 printf(\u0026#34;Bob\\n\u0026#34;); 22 } 23 24 } 25 return 0; 26} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1192-left-right-/","summary":"Left Right(LightOJ-1192) é¢˜é¢ Two players, Alice and Bob are playing a strange game in a 1 x n board. The cells are numbered from 0 to n-1, where the left most cell is marked as cell 0. Each cell can contain at most one piece. There are two kinds of pieces, gray and white. Alice moves all the gray pieces, and bob moves all the white ones. The pieces","title":"LightOJ-1192 Left Right"},{"content":"Incredible Chess(LightOJ-1186) é¢˜é¢ You are given an n x n chess board. Only pawn is used in the \u0026lsquo;Incredible Chess\u0026rsquo; and they can move forward or backward. In each column there are two pawns, one white and one black. White pawns are placed in the lower part of the board and the black pawns are placed in the upper part of the board.\nThe game is played by two players. Initially a board configuration is given. One player uses white pieces while the other uses black. In each move, a player can move a pawn of his piece, which can go forward or backward any positive integer steps, but it cannot jump over any piece. White gives the first move.\nThe game ends when there is no move for a player and he will lose the game. Now you are given the initial configuration of the board. You have to write a program to determine who will be the winner.\nè¾“å…¥ Input starts with an integer T (â‰¤ 200), denoting the number of test cases.\nEach case starts with an integer n (3 â‰¤ n â‰¤ 100) denoting the dimension of the board. The next line will contain n integers, W0, W1, \u0026hellip;, Wn-1 giving the position of the white pieces. The next line will also contain n integers, B0, B1, \u0026hellip; Bn-1 giving the position of the black pieces. Wi means the row position of the white piece of ith column. And Bi means the row position of the black piece of ith column. You can assume that (0 â‰¤ Wi \u0026lt; Bi \u0026lt; n) for (0 â‰¤ i \u0026lt; n) and at least one move is remaining.\nè¾“å‡º For each case, print the case number and \u0026lsquo;white wins\u0026rsquo; or \u0026lsquo;black wins\u0026rsquo; depending on the result.\næ ·ä¾‹è¾“å…¥ 12 26 31 3 2 2 0 1 45 5 5 3 1 2 57 61 3 2 2 0 4 0 73 4 4 3 1 5 6 æ ·ä¾‹è¾“å‡º 1Case 1: black wins 2Case 2: white wins æç¤º æ— \næ€è·¯ Nimåšå¼ˆï¼Œä»¥é»‘ç™½æ£‹å­é—´è·ä¸ºçŸ³å­å †æ•°åšä¸€ä¸ªNImåšå¼ˆå³å¯ã€‚\nä»£ç  1using namespace std; 2const int mxn = 1000; 3int a[mxn]; 4 5int main() 6{ 7 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 8 for(int cs=1; cs\u0026lt;=T; cs++) 9 { 10 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 11 for(int i=0; i\u0026lt;n; i++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 13 14 int nim = 0; 15 for(int i=0; i\u0026lt;n; i++) { 16 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 17 nim ^= x-a[i]-1; 18 } 19 printf(\u0026#34;Case %d: \u0026#34;, cs); 20 if(nim){ 21 printf(\u0026#34;white wins\\n\u0026#34;); 22 }else{ 23 printf(\u0026#34;black wins\\n\u0026#34;); 24 } 25 26 } 27 return 0; 28} ","permalink":"https://blog.lordash.de/posts/solution/lightoj-1186-incredible-chess/","summary":"Incredible Chess(LightOJ-1186) é¢˜é¢ You are given an n x n chess board. Only pawn is used in the \u0026lsquo;Incredible Chess\u0026rsquo; and they can move forward or backward. In each column there are two pawns, one white and one black. White pawns are placed in the lower part of the board and the black pawns are placed in the upper part of the board. The game is played by two","title":"LightOJ-1186 Incredible Chess"},{"content":"Stone Game II (HDU-4388) é¢˜é¢ Stone Game II comes. It needs two players to play this game. There are some piles of stones on the desk at the beginning. Two players move the stones in turn. At each step of the game the player should do the following operations. First, choose a pile of stones. (We assume that the number of stones in this pile is n) Second, take some stones from this pile. Assume the number of stones left in this pile is k. The player must ensure that 0 \u0026lt; k \u0026lt; n and (k XOR n) \u0026lt; n, otherwise he loses. At last, add a new pile of size (k XOR n). Now the player can add a pile of size ((2*k) XOR n) instead of (k XOR n) (However, there is only one opportunity for each player in each game). The first player who can\u0026rsquo;t do these operations loses. Suppose two players will do their best in the game, you are asked to write a program to determine who will win the game.\nè¾“å…¥ The first line contains the number T of test cases (T\u0026lt;=150). The first line of each test cases contains an integer number n (n\u0026lt;=50), denoting the number of piles. The following n integers describe the number of stones in each pile at the beginning of the game. You can assume that all the number of stones in each pile will not exceed 100,000.\nè¾“å‡º For each test case, print the case number and the answer. if the first player will win the game print \u0026ldquo;Yes\u0026rdquo;(quotes for clarity) in a single line, otherwise print \u0026ldquo;No\u0026rdquo;(quotes for clarity).\næ ·ä¾‹è¾“å…¥ 13 22 31 2 43 51 2 3 64 71 2 3 3 æ ·ä¾‹è¾“å‡º 1Case 1: No 2Case 2: Yes 3Case 3: No æç¤º æ— \næ€è·¯ å¯¹äºæ¯ä¸€å †ï¼Œåˆ†è§£åˆ°2çš„å¹‚å°±æ— æ³•å†æ¬¡åˆ†è§£äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»Ÿè®¡ä¸€ä¸‹äºŒè¿›åˆ¶ä¸‹1çš„æ•°é‡ï¼Œcnt-1ä¸ºå¥‡æ•°æ—¶å…ˆæ‰‹èƒœï¼Œåä¹‹ã€‚\nä»£ç  1using namespace std; 2 3int bitcount(int x){ 4 int ans=0; 5 while(x){ 6 x \u0026amp;= x-1; 7 ans++; 8 } 9 return ans; 10} 11 12int main() 13{ 14 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 15 for(int cs=1; cs\u0026lt;=T; cs++) 16 { 17 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 18 19 int nim = 0; 20 for(int i=0; i\u0026lt;n; i++){ 21 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 22 nim ^= (bitcount(x)-1) \u0026amp; 1; 23 } 24 printf(\u0026#34;Case %d: \u0026#34;, cs); 25 if(nim){ 26 printf(\u0026#34;Yes\\n\u0026#34;); 27 }else{ 28 printf(\u0026#34;No\\n\u0026#34;); 29 } 30 } 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/hdu-4388-stone-game-ii/","summary":"Stone Game II (HDU-4388) é¢˜é¢ Stone Game II comes. It needs two players to play this game. There are some piles of stones on the desk at the beginning. Two players move the stones in turn. At each step of the game the player should do the following operations. First, choose a pile of stones. (We assume that the number of stones in this pile is n) Second, take","title":"HDU-4388 Stone Game II"},{"content":"æ‚¼å¿µ512æ±¶å·å¤§åœ°éœ‡é‡éš¾åŒèƒâ€”â€”é€‰æ‹”å¿—æ„¿è€…(HDU-2188) é¢˜é¢ å¯¹äºå››å·åŒèƒé­å—çš„ç¾éš¾ï¼Œå…¨å›½äººæ°‘çº·çº·ä¼¸å‡ºæ´åŠ©ä¹‹æ‰‹ï¼Œå‡ ä¹æ¯ä¸ªçœå¸‚éƒ½æ´¾å‡ºäº†å¤§é‡çš„æ•‘æ´äººå‘˜ï¼Œè¿™å…¶ä¸­åŒ…æ‹¬æŠ¢é™©æ•‘ç¾çš„æ­¦è­¦éƒ¨é˜Ÿï¼Œæ²»ç–—å’Œé˜²ç–«çš„åŒ»æŠ¤äººå‘˜ï¼Œä»¥åŠè¿›è¡Œå¿ƒç†ç–å¯¼çš„å¿ƒç†å­¦ä¸“å®¶ã€‚æ ¹æ®è¦æ±‚ï¼Œæˆ‘æ ¡ä¹Ÿæœ‰ä¸€ä¸ªå¥”èµ´ç¾åŒºæ•‘ç¾çš„åé¢ï¼Œç”±äºå¹¿å¤§å¸ˆç”ŸæŠ¥åè¸Šè·ƒï¼Œå­¦æ ¡ä¸å¾—ä¸è¿›è¡Œé€‰æ‹”æ¥å†³å®šæœ€åçš„äººé€‰ã€‚ç»è¿‡å¤šè½®çš„è€ƒæ ¸ï¼Œå½¢åŠ¿é€æ¸æ˜æœ—ï¼Œæœ€åçš„åé¢å°†åœ¨â€œæ—é˜Ÿâ€å’Œâ€œå¾é˜Ÿâ€ä¹‹é—´äº§ç”Ÿã€‚ä½†æ˜¯å¾ˆå·§åˆï¼Œ2ä¸ªäººçš„ç®€å†å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œè¿™è®©ä¸»æŒé€‰æ‹”çš„8600å¾ˆæ˜¯ä¸ºéš¾ã€‚æ— å¥ˆï¼Œä»–å†³å®šé€šè¿‡ææ¬¾æ¥å†³å®šä¸¤äººè°èƒ½å…¥é€‰ã€‚ é€‰æ‹”è§„åˆ™å¦‚ä¸‹ï¼š 1ã€æœ€åˆçš„ææ¬¾ç®±æ˜¯ç©ºçš„ï¼› 2ã€ä¸¤äººè½®æµææ¬¾ï¼Œæ¯æ¬¡ææ¬¾é¢å¿…é¡»ä¸ºæ­£æ•´æ•°ï¼Œå¹¶ä¸”æ¯äººæ¯æ¬¡ææ¬¾æœ€å¤šä¸è¶…è¿‡må…ƒ(1\u0026lt;=m\u0026lt;=10)ã€‚ 3ã€æœ€å…ˆä½¿å¾—æ€»ææ¬¾é¢è¾¾åˆ°æˆ–è€…è¶…è¿‡nå…ƒï¼ˆ0\u0026lt;n\u0026lt;10000ï¼‰çš„ä¸€æ–¹ä¸ºèƒœè€…ï¼Œåˆ™å…¶å¯ä»¥äº²èµ´ç¾åŒºæœåŠ¡ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œä¸¤äººéƒ½å¾ˆæƒ³å…¥é€‰å¿—æ„¿è€…åå•ï¼Œå¹¶ä¸”éƒ½æ˜¯éå¸¸èªæ˜çš„äººï¼Œå‡è®¾æ—é˜Ÿå…ˆæï¼Œè¯·ä½ åˆ¤æ–­è°èƒ½å…¥é€‰æœ€åçš„åå•ï¼Ÿ\nè¾“å…¥ è¾“å…¥æ•°æ®é¦–å…ˆåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°Cï¼Œè¡¨ç¤ºåŒ…å«Cç»„æµ‹è¯•ç”¨ä¾‹ï¼Œç„¶åæ˜¯Cè¡Œæ•°æ®ï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•°nï¼Œmï¼Œnå’Œmçš„å«ä¹‰å‚è§ä¸Šé¢æåˆ°çš„è§„åˆ™ã€‚\nè¾“å‡º å¯¹äºæ¯ç»„æµ‹è¯•æ•°æ®ï¼Œå¦‚æœæ—é˜Ÿèƒ½å…¥é€‰ï¼Œè¯·è¾“å‡ºå­—ç¬¦ä¸²\u0026quot;Grass\u0026quot;ï¼Œ å¦‚æœå¾é˜Ÿèƒ½å…¥é€‰ï¼Œè¯·è¾“å‡ºå­—ç¬¦ä¸²\u0026quot;Rabbit\u0026quot;ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 12 28 10 311 10 æ ·ä¾‹è¾“å‡º 1Grass 2Rabbit æç¤º æ— \næ€è·¯ Bashåšå¼ˆã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 while(T--) 7 { 8 int n, m; 9 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 10 11 if(n%(m+1)==0){ 12 printf(\u0026#34;Rabbit\\n\u0026#34;); 13 }else{ 14 printf(\u0026#34;Grass\\n\u0026#34;); 15 } 16 } 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2188-%E6%82%BC%E5%BF%B5512/","summary":"æ‚¼å¿µ512æ±¶å·å¤§åœ°éœ‡é‡éš¾åŒèƒâ€”â€”é€‰æ‹”å¿—æ„¿è€…(HDU-2188) é¢˜é¢ å¯¹äºå››å·åŒèƒé­å—çš„ç¾éš¾ï¼Œå…¨å›½äººæ°‘çº·çº·ä¼¸å‡ºæ´åŠ©ä¹‹æ‰‹ï¼Œå‡ ä¹æ¯ä¸ªçœå¸‚éƒ½æ´¾å‡ºäº†å¤§é‡","title":"HDU-2188 æ‚¼å¿µ512"},{"content":"é‚‚é€…æ˜ä¸‹(HDU-2897) é¢˜é¢ å½“æ—¥é‡åˆ°æœˆï¼Œäºæ˜¯æœ‰äº†æ˜ã€‚å½“æˆ‘é‡åˆ°äº†ä½ ï¼Œä¾¿æˆäº†ä¾£ã€‚ é‚£å¤©ï¼Œæ—¥æœˆç›¸ä¼šï¼Œæˆ‘è§åˆ°äº†ä½ ã€‚è€Œä¸”ï¼Œå¤§åœ°å¤±å»äº†å…‰è¾‰ï¼Œä½ æˆ‘æ˜¯å¦æˆä¾£ï¼Ÿè¿™æ³¨å®šæ˜¯ä¸ªå‡„ç¾çš„æ•…äº‹ã€‚ï¼ˆä»¥ä¸Šæ˜¯åºŸè¯ï¼‰ å°tå’Œæ‰€æœ‰ä¸–ä¿—çš„äººä»¬ä¸€æ ·ï¼ŒæœŸå¾…é‚£ç™¾å¹´éš¾é‡çš„æ—¥é£Ÿã€‚é©»è¶³è¡—å¤´çœ‹å¤©ï¼Œçœ‹æ—¥æœˆæ¸æ¸èµ°è¿‘ï¼Œå°tçš„è„–å­é‚£ä¸ªé…¸å‘€ï¼ˆä»–åšæŒè¿™ä¸ªå§¿åŠ¿å·²ç»æœ‰åŠä¸ªå¤šå°æ—¶å•¦ï¼‰ã€‚ä»–ä½ä¸‹ä»°èµ·çš„å¤´ï¼Œç¯é¡¾å››å‘¨ã€‚å¿½ç„¶å‘ç°èº«è¾¹ç«Ÿç«™ç€ä½æ¼‚äº®çš„mmã€‚å¤©æ¸æ¸æš—ä¸‹ï¼Œè¿™mmåœ¨è¿™è¡—å¤´ç«Ÿç„¶å¦‚æ­¤è€€çœ¼ï¼Œå¥¹æ˜¯å¤©ä½¿å—ï¼Ÿç«™ç€å°tèº«è¾¹çš„å¤©ä½¿ã€‚ å°tå¯¹mmæƒŠå‘¼ï¼šâ€œç¼˜åˆ†å‘~~â€ã€‚mmå´æ¯«ä¸å«ç³Šï¼šâ€œæ˜¯å•Šï¼Œ500å¹´ä¸€é‡å“¦ï¼â€ï¼ˆæ­¤åçœç•¥5000å­—â€¦.ï¼‰ å°tèµ¶ç´§å‘mmè¦è”ç³»æ–¹å¼ï¼Œå¯mmè¯´ï¼šâ€œæˆ‘å’Œä½ ç©ä¸ªæ¸¸æˆå§ï¼Œèµ¢äº†ï¼Œæˆ‘å°±æŠŠæˆ‘çš„æ‰‹æœºå·å‘Šè¯‰ä½ ã€‚â€å°tï¼Œå¿ƒæƒ³å¤©ä¸‹å“ªæœ‰é¢˜ç›®èƒ½éš¾å€’æˆ‘å‘¢ï¼Œä¾¿æ»¡å£ç­”åº”ä¸‹æ¥ã€‚mmå¼€å§‹è¯´æ¸¸æˆè§„åˆ™ï¼šâ€œæˆ‘æœ‰ä¸€å †ç¡¬å¸ï¼Œä¸€å…±7æšï¼Œä»è¿™ä¸ªç¡¬å¸å †é‡Œå–ç¡¬å¸ï¼Œä¸€æ¬¡æœ€å°‘å–2æšï¼Œæœ€å¤š4æšï¼Œå¦‚æœå‰©ä¸‹å°‘äº2æšå°±è¦ä¸€æ¬¡å–å®Œã€‚æˆ‘å’Œä½ è½®æµå–ï¼Œç›´åˆ°å †é‡Œçš„ç¡¬å¸å–å®Œï¼Œæœ€åä¸€æ¬¡å–ç¡¬å¸çš„ç®—è¾“ã€‚æˆ‘ç©è¿‡è¿™ä¸ªæ¸¸æˆå¥½å¤šæ¬¡äº†ï¼Œå°±è®©è®©ä½ ï¼Œè®©ä½ å…ˆå–å§~â€ å°tææŒ‡ä¸€ç®—ï¼Œä¸å¯¹å‘€ï¼Œè¿™æ˜¯ä¸å¯èƒ½çš„ä»»åŠ¡ä¹ˆã€‚å°téœ²å‡ºå¾—æ„çš„ç¬‘ï¼šâ€œè¿˜æ˜¯mmä¼˜å…ˆå•¦ï¼Œå‘µå‘µ~â€mméœæ—¶æ„£ä½äº†ï¼Œæƒ³æ˜¯å¯¹å°tçš„ååº”å‡ºä¹æ„æ–™å§ã€‚ å¥¹å´ä¹Ÿä¸ç”Ÿæ°”ï¼šâ€œå¥½å°å­ï¼ŒæŒºèªæ˜å‘¢ï¼Œè¦ä¸è¿™æ ·å§ï¼Œä½ æŠŠæˆ‘çš„é‚®ç®±ç»™æˆ‘ï¼Œæˆ‘ç»™ä½ å‘ä¸ªæ–‡æœ¬ï¼Œæ¯è¡Œæœ‰ä¸‰ä¸ªæ•°å­—nï¼Œpï¼Œqï¼Œè¡¨ç¤ºä¸€å †ç¡¬å¸ä¸€å…±æœ‰næšï¼Œä»è¿™ä¸ªç¡¬å¸å †é‡Œå–ç¡¬å¸ï¼Œä¸€æ¬¡æœ€å°‘å–pæšï¼Œæœ€å¤šqæšï¼Œå¦‚æœå‰©ä¸‹å°‘äºpæšå°±è¦ä¸€æ¬¡å–å®Œã€‚ä¸¤äººè½®æµå–ï¼Œç›´åˆ°å †é‡Œçš„ç¡¬å¸å–å®Œï¼Œæœ€åä¸€æ¬¡å–ç¡¬å¸çš„ç®—è¾“ã€‚å¯¹äºæ¯ä¸€è¡Œçš„ä¸‰ä¸ªæ•°å­—ï¼Œç»™å‡ºå…ˆå–çš„äººæ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ï¼Œå¦‚æœæœ‰å›ç­”WINï¼Œå¦åˆ™å›ç­”LOSTã€‚ä½ æŠŠå¯¹åº”çš„ç­”æ¡ˆå‘ç»™æˆ‘ï¼Œå¦‚æœä½ èƒ½åœ¨ä»Šå¤©æ™šä¸Š8ç‚¹ä»¥å‰å‘ç»™æˆ‘æ­£ç¡®ç­”æ¡ˆï¼Œæˆ–è®¸æˆ‘ä»¬æ˜å¤©ä¸‹åˆå¯ä»¥å†è§ã€‚â€ å°täºŒè¯æ²¡è¯´ï¼Œå°†è‡ªå·±çš„é‚®ç®±ç»™äº†mmã€‚å½“ä»–å…´å†²å†²å¾—èµ¶å›å®¶ï¼Œä¸Šç½‘çœ‹é‚®ç®±ï¼Œå“‡ï¼mmçš„é‚®ä»¶å·²ç»åˆ°äº†ã€‚ä»–å‘ç°æ–‡æœ¬é•¿è¾¾100000è¡Œï¼Œæ¯è¡Œçš„ä¸‰ä¸ªæ•°å­—éƒ½å¾ˆå¤§ï¼Œä½†æ˜¯éƒ½æ˜¯ä¸è¶…è¿‡65536çš„æ•´æ•°ã€‚å°tçœ‹è¡¨å·²ç»ä¸‹åˆ6ç‚¹äº†ï¼Œè¦æƒ³æ‰‹å·¥ç®—å‡ºæ‰€æœ‰ç»“æœï¼Œçœ‹æ¥æ˜¯ä¸å¯èƒ½äº†ã€‚ä½ èƒ½å¸®å¸®ä»–ï¼Œè®©ä»–å†è§åˆ°é‚£ä¸ªmmå—ï¼Ÿ\nè¾“å…¥ ä¸è¶…è¿‡100000è¡Œï¼Œæ¯è¡Œä¸‰ä¸ªæ­£æ•´æ•°nï¼Œpï¼Œqã€‚\nè¾“å‡º å¯¹åº”æ¯è¡Œè¾“å…¥ï¼ŒæŒ‰å‰é¢ä»‹ç»çš„æ¸¸æˆè§„åˆ™ï¼Œåˆ¤æ–­å…ˆå–è€…æ˜¯å¦æœ‰å¿…èƒœç­–ç•¥ã€‚è¾“å‡ºWINæˆ–è€…LOSTã€‚\næ ·ä¾‹è¾“å…¥ 17 2 4 26 2 4 æ ·ä¾‹è¾“å‡º 1LOST 2WIN æç¤º æ— \næ€è·¯ Bashåšå¼ˆå˜å½¢ï¼ŒBashåšå¼ˆå¯ä»¥å‚è€ƒã€ä¸“é¢˜ã€‘Bashåšå¼ˆã€‚\nè‹¥å½“å‰çŸ³å­å…±æœ‰n =ï¼ˆp+qï¼‰* rä¸ªï¼Œåˆ™å…ˆæ‰‹å¿…èƒœï¼Œå¿…èƒœç­–ç•¥ä¸ºï¼šå…ˆæ‰‹ç¬¬ä¸€æ¬¡å–qä¸ªï¼Œä»¥åæ¯æ¬¡è‹¥åæ‰‹å–Kä¸ªï¼Œå…ˆæ‰‹å–ï¼ˆp+q-kï¼‰ä¸ªï¼Œå¦‚æ­¤ä¸‹å»æœ€åå¿…å‰©ä¸‹pä¸ªç»™åæ‰‹ï¼Œæ‰€ä»¥å…ˆæ‰‹å¿…èƒœã€‚\nè‹¥n =ï¼ˆp+qï¼‰* r + leftä¸ªï¼ˆ1\u0026lt; left \u0026lt;= pï¼‰åæ‰‹å¿…èƒœï¼Œå¿…èƒœç­–ç•¥ä¸ºï¼šæ¯æ¬¡å–çŸ³å­æ´»åŠ¨ä¸­ï¼Œè‹¥å…ˆæ‰‹å–kä¸ªï¼Œåˆ™åæ‰‹å–ï¼ˆp+q-kï¼‰ä¸ªï¼Œé‚£ä¹ˆæœ€åå‰©ä¸‹leftä¸ªç»™å…ˆæ‰‹ï¼Œæ­¤æ—¶left \u0026lt;= pï¼Œæ‰€ä»¥å…ˆæ‰‹åªèƒ½ä¸€æ¬¡å–å®Œï¼Œåæ‰‹èƒœã€‚\nè‹¥n =ï¼ˆp+qï¼‰* r + leftä¸ªï¼ˆp \u0026lt; left \u0026lt;= qï¼‰ï¼Œåˆ™å…ˆæ‰‹å¿…èƒœï¼Œå¿…èƒœç­–ç•¥ä¸ºï¼šå…ˆæ‰‹ç¬¬ä¸€æ¬¡å–tï¼ˆ1\u0026lt;left â€“ t \u0026lt;= pï¼‰ä¸ªï¼Œä»¥åæ¯æ¬¡åæ‰‹å–kä¸ªï¼Œåˆ™å…ˆæ‰‹å–ï¼ˆp+q-kï¼‰ä¸ªï¼Œé‚£ä¹ˆæœ€åç•™ä¸‹1\u0026lt; left â€“ t \u0026lt;=pç»™åæ‰‹ï¼Œåˆ™å…ˆæ‰‹èƒœã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n, p, q; 6 while(~scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;p, \u0026amp;q)) 7 { 8 int s = n % (p+q); 9 if(s!=0 \u0026amp;\u0026amp; s\u0026lt;=p){ 10 printf(\u0026#34;LOST\\n\u0026#34;); 11 }else{ 12 printf(\u0026#34;WIN\\n\u0026#34;); 13 } 14 } 15 return 0; 16} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2897-%E9%82%82%E9%80%85%E6%98%8E%E4%B8%8B/","summary":"é‚‚é€…æ˜ä¸‹(HDU-2897) é¢˜é¢ å½“æ—¥é‡åˆ°æœˆï¼Œäºæ˜¯æœ‰äº†æ˜ã€‚å½“æˆ‘é‡åˆ°äº†ä½ ï¼Œä¾¿æˆäº†ä¾£ã€‚ é‚£å¤©ï¼Œæ—¥æœˆç›¸ä¼šï¼Œæˆ‘è§åˆ°äº†ä½ ã€‚è€Œä¸”ï¼Œå¤§åœ°å¤±å»äº†å…‰è¾‰ï¼Œä½ æˆ‘æ˜¯å¦æˆ","title":"HDU-2897 é‚‚é€…æ˜ä¸‹"},{"content":"å–çŸ³å­æ¸¸æˆ(HDU-2516) é¢˜é¢ 1å †çŸ³å­æœ‰nä¸ª,ä¸¤äººè½®æµå–.å…ˆå–è€…ç¬¬1æ¬¡å¯ä»¥å–ä»»æ„å¤šä¸ªï¼Œä½†ä¸èƒ½å…¨éƒ¨å–å®Œ.ä»¥åæ¯æ¬¡å–çš„çŸ³å­æ•°ä¸èƒ½è¶…è¿‡ä¸Šæ¬¡å–å­æ•°çš„2å€ã€‚å–å®Œè€…èƒœ.å…ˆå–è€…è´Ÿè¾“å‡º\u0026quot;Second win\u0026quot;.å…ˆå–è€…èƒœè¾“å‡º\u0026quot;First win\u0026quot;.\nè¾“å…¥ è¾“å…¥æœ‰å¤šç»„.æ¯ç»„ç¬¬1è¡Œæ˜¯2\u0026lt;=n\u0026lt;2^31. n=0é€€å‡º.\nè¾“å‡º å…ˆå–è€…è´Ÿè¾“å‡º\u0026quot;Second win\u0026quot;. å…ˆå–è€…èƒœè¾“å‡º\u0026quot;First win\u0026quot;. å‚çœ‹Sample Output.\næ ·ä¾‹è¾“å…¥ 12 213 310000 40 æ ·ä¾‹è¾“å‡º 1Second win 2Second win 3First win æç¤º æ— \næ€è·¯ å•å †Fibonacciåšå¼ˆï¼Œä¸ç”¨æ±‚SGå‡½æ•°ã€‚\nä»£ç  1using namespace std; 2int f[50]; 3 4void fib(){ 5 f[1] = f[2] = 1; 6 for(int i=3; i\u0026lt;47; i++){ 7 f[i] = f[i-1] + f[i-2]; 8 } 9} 10 11int main() 12{ 13 fib(); 14 int n; 15 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 16 { 17 int flag = 1; 18 for(int i=1; i\u0026lt;47; i++){ 19 if(f[i]==n){ 20 printf(\u0026#34;Second win\\n\u0026#34;); 21 flag = 0; 22 break; 23 } 24 } 25 if(flag){ 26 printf(\u0026#34;First win\\n\u0026#34;); 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2516-%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","summary":"å–çŸ³å­æ¸¸æˆ(HDU-2516) é¢˜é¢ 1å †çŸ³å­æœ‰nä¸ª,ä¸¤äººè½®æµå–.å…ˆå–è€…ç¬¬1æ¬¡å¯ä»¥å–ä»»æ„å¤šä¸ªï¼Œä½†ä¸èƒ½å…¨éƒ¨å–å®Œ.ä»¥åæ¯æ¬¡å–çš„çŸ³å­æ•°ä¸èƒ½è¶…è¿‡ä¸Šæ¬¡å–å­","title":"HDU-2516 å–çŸ³å­æ¸¸æˆ"},{"content":"A simple stone game(HDU-2486) é¢˜é¢ After he has learned how to play Nim game, Mike begins to try another stone game which seems much easier.\nThe game goes like this: Two players start the game with a pile of n stones. They take stones from the pile in turn and every time they take at least one stone. The one who goes first can take at most n-1 stones for his first move. From then on a player can take at most k times as many stones as his opponent has taken last time. For example, if one player take m stones in his turn, then the other player can take at most k * m stones next time. The player who takes the last stone wins the game. Suppose that those two players always take the best moves and never make mistakes, your job is to find out who will definitely win the game.\nè¾“å…¥ The first line contains a integer t, indicating that there are t test cases following.(t\u0026lt;=20). Each test case is a line consisting of two integer n and k.(2\u0026lt;=n\u0026lt;=10^8,1\u0026lt;=k\u0026lt;=10^5).\nè¾“å‡º For each test case, output one line starting with â€œCase N: â€, N is the case number. And then, if the first player can ensure a winning, print the minimum number of stones he should take in his first turn. Otherwise, print \u0026ldquo;lose\u0026rdquo;. Please note that there is a blank following the colon.\næ ·ä¾‹è¾“å…¥ 15 216 1 311 1 432 2 534 2 619 3 æ ·ä¾‹è¾“å‡º 1Case 1: lose 2Case 2: 1 3Case 3: 3 4Case 4: lose 5Case 5: 4 æç¤º When k = 1, the first player will definitely lose if the initial amount of stones is in the set {2, 4, 8, 16, 32, \u0026hellip;}. Let\u0026rsquo;s call this kind of set â€œfirst-player-lose setâ€.\nWhen k = 2, the first-player-lose set is {2, 3, 5, 8, 13, 21, 34, 57 \u0026hellip;} , which happens to be the Fibonacci sequence starting from 2.\næ€è·¯ Kå€åŠ¨æ€å‡æ³•åšå¼ˆï¼Œå‚ç…§æ–æ³¢é‚£å¥‘åšå¼ˆå’Œé½è‚¯å¤šå¤«å®šç†çš„è¯æ˜è¿‡ç¨‹ï¼Œå°† $ f_{i} = f_{i-1} + f_{i-2} $ æ›¿æ¢ä¸º $ f_{i} = f_{i-1} + f_{k} \\mid { K \\times f{k-1} \\lt f_{i-1} \\le K \\times f_{k}} $ ï¼Œä¹Ÿå°±æ˜¯å°†é½è‚¯å¤šå¤«å®šç†è¡¨è¿°ä¸­çš„ è‹¥å¹²ä¸è¿ç»­çš„é¡¹ æ›¿æ¢ä¸º è‹¥å¹²ä¸¤ä¸¤ä¹‹æ¯”å¤§äºKé¡¹ã€‚é¢„å¤„ç†å‡ºç±»ä¼¼æ–æ³¢é‚£å¥‘åšå¼ˆä¸­çš„æ–æ³¢é‚£å¥‘åºåˆ—ï¼Œé¢å¯¹å±€åŠ¿ä¸ºåºåˆ—é¡¹çš„ï¼Œå…ˆæ‰‹å¿…è´¥ã€‚\næ³¨æ„æ—¶é—´å¤æ‚åº¦ä¸º $ O(Tlog_{\\frac{k+1}{k}}N) \\approx 2 \\times 10^{8} $ï¼Œå¡å¸¸ã€‚\nè¯¦ç»†å‚è€ƒã€Šä»â€œkå€åŠ¨æ€å‡æ³•æ¸¸æˆâ€å‡ºå‘æ¢ç©¶ä¸€ç±»ç»„åˆæ¸¸æˆé—®é¢˜ã€‹ã€[POJ3922]Nowè§£é¢˜æŠ¥å‘Šã€‚\nä»£ç  1using namespace std; 2int f[1000005] = {1}; 3 4int main() 5{ 6 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 7 for(int cs=1; cs\u0026lt;=T; cs++) 8 { 9 int n, k; 10 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); 11 12 int i=1, j=0; 13 for(; f[i] \u0026lt;= n; i++){ 14 for(; 1LL * k * f[j] \u0026lt; f[i]; j++); 15 f[i+1] = f[i] + f[j]; 16 } 17 i--; 18 19 printf(\u0026#34;Case %d: \u0026#34;, cs); 20 if(f[i] == n){ 21 printf(\u0026#34;lose\\n\u0026#34;); 22 }else{ 23 while(n != f[i]){ 24 for(n-=f[i]; n\u0026lt;f[i]; i--); 25 } 26 printf(\u0026#34;%d\\n\u0026#34;, n); 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2486-a-simple-stone-game/","summary":"A simple stone game(HDU-2486) é¢˜é¢ After he has learned how to play Nim game, Mike begins to try another stone game which seems much easier. The game goes like this: Two players start the game with a pile of n stones. They take stones from the pile in turn and every time they take at least one stone. The one who goes first can take at most n-1 stones","title":"HDU-2486 A simple stone game"},{"content":"å–(2å †)çŸ³å­æ¸¸æˆ(HDU-2177) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯ä»¥åœ¨ä»»æ„çš„ä¸€å †ä¸­å–èµ°ä»»æ„å¤šçš„çŸ³å­ï¼›äºŒæ˜¯å¯ä»¥åœ¨ä¸¤å †ä¸­åŒæ—¶å–èµ°ç›¸åŒæ•°é‡çš„çŸ³å­ã€‚æœ€åæŠŠçŸ³å­å…¨éƒ¨å–å®Œè€…ä¸ºèƒœè€…ã€‚ç°åœ¨ç»™å‡ºåˆå§‹çš„ä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œå¦‚æœè½®åˆ°ä½ å…ˆå–ï¼Œå‡è®¾åŒæ–¹éƒ½é‡‡å–æœ€å¥½çš„ç­–ç•¥ï¼Œé—®æœ€åä½ æ˜¯èƒœè€…è¿˜æ˜¯è´¥è€…ã€‚å¦‚æœä½ èƒœï¼Œä½ ç¬¬1æ¬¡æ€æ ·å–å­?\nè¾“å…¥ è¾“å…¥åŒ…å«è‹¥å¹²è¡Œï¼Œè¡¨ç¤ºè‹¥å¹²ç§çŸ³å­çš„åˆå§‹æƒ…å†µï¼Œå…¶ä¸­æ¯ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªéè´Ÿæ•´æ•°aå’Œbï¼Œè¡¨ç¤ºä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œaå’Œbéƒ½ä¸å¤§äº1,000,000ï¼Œä¸”a\u0026lt;=bã€‚a=b=0é€€å‡ºã€‚\nè¾“å‡º è¾“å‡ºä¹Ÿæœ‰è‹¥å¹²è¡Œï¼Œå¦‚æœæœ€åä½ æ˜¯è´¥è€…ï¼Œåˆ™ä¸º0ï¼Œåä¹‹ï¼Œè¾“å‡º1ï¼Œå¹¶è¾“å‡ºä½¿ä½ èƒœçš„ä½ ç¬¬1æ¬¡å–çŸ³å­åå‰©ä¸‹çš„ä¸¤å †çŸ³å­çš„æ•°é‡x,y,x\u0026lt;=yã€‚å¦‚æœåœ¨ä»»æ„çš„ä¸€å †ä¸­å–èµ°çŸ³å­èƒ½èƒœåŒæ—¶åœ¨ä¸¤å †ä¸­åŒæ—¶å–èµ°ç›¸åŒæ•°é‡çš„çŸ³å­ä¹Ÿèƒ½èƒœï¼Œå…ˆè¾“å‡ºå–èµ°ç›¸åŒæ•°é‡çš„çŸ³å­çš„æƒ…å†µ.\næ ·ä¾‹è¾“å…¥ 11 2 25 8 34 7 42 2 50 0 æ ·ä¾‹è¾“å‡º 10 21 34 7 43 5 50 61 70 0 81 2 æç¤º æ— \næ€è·¯ Wythoffåšå¼ˆï¼Œç”±b-aå¯ä»¥ç®—å‡ºåŒæ—¶å–çš„æƒ…å†µï¼Œç„¶åæš´åŠ›æšä¸¾ä¸€ä¸‹å•ä¸ªå–çš„æƒ…å†µï¼Œæ•°æ®å¾ˆæ°´ï¼Œè‡ªå·±æ‰¾æ ·ä¾‹æµ‹æµ‹ã€‚\nä»£ç  1using namespace std; 2typedef pair\u0026lt;int, int\u0026gt; pii; 3const double t = (sqrt(5) + 1) / 2; 4 5int main() 6{ 7 int a, b; 8 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) \u0026amp;\u0026amp; (a || b)) 9 { 10 if(a \u0026gt; b) swap(a, b); 11 int x = t * (b-a); 12 13 if(a == x){ 14 printf(\u0026#34;0\\n\u0026#34;); 15 continue; 16 } 17 18 printf(\u0026#34;1\\n\u0026#34;); 19 set\u0026lt;pii \u0026gt; s; 20 if(a\u0026gt;x){ // åŒæ—¶å– 21 printf(\u0026#34;%d %d\\n\u0026#34;, x, x+b-a); 22 s.insert(pii(x, x+b-a)); 23 } 24 25 for(int i=a-1; i\u0026gt;=0; i--){ // å–a 26 if(i==(int)(t * (b-i)) \u0026amp;\u0026amp; s.find(pii(i, b))==s.end()){ 27 printf(\u0026#34;%d %d\\n\u0026#34;, i, b); 28 s.insert(pii(i, b)); 29 break; 30 } 31 } 32 33 for(int i=b-1; i\u0026gt;=0; i--){ // å–b 34 int n=min(a, i), m=max(a, i); 35 if(n==(int)(t * (m-n)) \u0026amp;\u0026amp; s.find(pii(n, m))==s.end()) { 36 printf(\u0026#34;%d %d\\n\u0026#34;, n, m); 37 break; 38 } 39 } 40 } 41 return 0; 42} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2177-%E5%8F%962%E5%A0%86%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","summary":"å–(2å †)çŸ³å­æ¸¸æˆ(HDU-2177) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯","title":"HDU-2177 å–(2å †)çŸ³å­æ¸¸æˆ"},{"content":"Beans Game(ZOJ-3057) é¢˜é¢ There are three piles of beans. TT and DD pick any number of beans from any pile or the same number from any two piles by turns. Who get the last bean will win. TT and DD are very clever.\nè¾“å…¥ Each test case contains of a single line containing 3 integers a b c, indicating the numbers of beans of these piles. It is assumed that 0 \u0026lt;= a,b,c \u0026lt;= 300 and a + b + c \u0026gt; 0.\nè¾“å‡º For each test case, output 1 if TT will win, ouput 0 if DD will win.\næ ·ä¾‹è¾“å…¥ 11 0 0 21 1 1 32 3 6 æ ·ä¾‹è¾“å‡º 11 20 30 æç¤º æ— \næ€è·¯ å¯¹äºå…ˆæ‰‹æ¥è¯´ï¼Œå¦‚æœæ•°é‡åˆ†åˆ«ä¸º(a, a, b)æˆ–(a, b, a)ï¼Œæˆ–(b, a, a)çš„å½¢å¼ï¼Œé‚£ä¹ˆå…ˆæ‰‹å¿…èµ¢ï¼Œå› ä¸ºå…ˆæ‰‹å¯ä»¥ä½¿å…¶æˆä¸º(a, a, a)çš„å½¢å¼ï¼Œé‚£ä¹ˆä¸è®ºåæ‰‹æ€ä¹ˆæ‹¿ï¼Œéƒ½æ˜¯å…ˆæ‰‹æœ€åä½¿å…¶æˆä¸º(a, a, a)çš„å½¢å¼ç›´è‡³(0, 0, 0)ï¼›å¦‚æœ(a, b, c)æ˜¯å¿…è´¥æ€ï¼Œé‚£ä¹ˆå°†å…¶ä¸­æŸä¸ªæ•°åŠ kï¼Œæˆ–å°†å…¶ä¸­æŸä¸¤ä¸ªæ•°åŒæ—¶åŠ kï¼Œå°±æ˜¯å¿…èƒœæ€ã€‚\n1using namespace std; 2bool SG[305][305][305]; 3 4void getSg(){ 5 for(int i=0; i\u0026lt;=300; i++) 6 for(int j=0; j\u0026lt;=300; j++) 7 for(int k=0; k\u0026lt;=300; k++){ 8 if(SG[i][j][k] == 0){ 9 for(int x=i+1; x\u0026lt;=300; x++) SG[x][j][k] = 1; 10 for(int x=j+1; x\u0026lt;=300; x++) SG[i][x][k] = 1; 11 for(int x=k+1; x\u0026lt;=300; x++) SG[i][j][x] = 1; 12 for(int x=1; x+i\u0026lt;=300 \u0026amp;\u0026amp; x+j\u0026lt;=300; x++) SG[x+i][x+j][k] = 1; 13 for(int x=1; x+j\u0026lt;=300 \u0026amp;\u0026amp; x+k\u0026lt;=300; x++) SG[i][x+j][x+k] = 1; 14 for(int x=1; x+i\u0026lt;=300 \u0026amp;\u0026amp; x+k\u0026lt;=300; x++) SG[x+i][j][x+k] = 1; 15 } 16 } 17 18} 19 20int main() 21{ 22 getSg(); 23 24 int a, b, c; 25 while(~scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c)) 26 { 27 printf(\u0026#34;%d\\n\u0026#34;, SG[a][b][c]); 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/zoj-3057-beans-game/","summary":"Beans Game(ZOJ-3057) é¢˜é¢ There are three piles of beans. TT and DD pick any number of beans from any pile or the same number from any two piles by turns. Who get the last bean will win. TT and DD are very clever. è¾“å…¥ Each test case contains of a single line containing 3 integers a b c, indicating the numbers of beans of these piles. It is","title":"ZOJ-3057 Beans Game"},{"content":"A simple stone game(POJ-3922) é¢˜é¢ After he has learned how to play Nim game, Mike begins to try another stone game which seems much easier.\nThe game goes like this: Two players start the game with a pile of n stones. They take stones from the pile in turn and every time they take at least one stone. The one who goes first can take at most n-1 stones for his first move. From then on a player can take at most k times as many stones as his opponent has taken last time. For example, if one player take m stones in his turn, then the other player can take at most k * m stones next time. The player who takes the last stone wins the game. Suppose that those two players always take the best moves and never make mistakes, your job is to find out who will definitely win the game.\nè¾“å…¥ The first line contains a integer t, indicating that there are t test cases following.(t\u0026lt;=20). Each test case is a line consisting of two integer n and k.(2\u0026lt;=n\u0026lt;=10^8,1\u0026lt;=k\u0026lt;=10^5).\nè¾“å‡º For each test case, output one line starting with â€œCase N: â€, N is the case number. And then, if the first player can ensure a winning, print the minimum number of stones he should take in his first turn. Otherwise, print \u0026ldquo;lose\u0026rdquo;. Please note that there is a blank following the colon.\næ ·ä¾‹è¾“å…¥ 15 216 1 311 1 432 2 534 2 619 3 æ ·ä¾‹è¾“å‡º 1Case 1: lose 2Case 2: 1 3Case 3: 3 4Case 4: lose 5Case 5: 4 æç¤º When k = 1, the first player will definitely lose if the initial amount of stones is in the set {2, 4, 8, 16, 32, \u0026hellip;}. Let\u0026rsquo;s call this kind of set â€œfirst-player-lose setâ€.\nWhen k = 2, the first-player-lose set is {2, 3, 5, 8, 13, 21, 34, 57 \u0026hellip;} , which happens to be the Fibonacci sequence starting from 2.\næ€è·¯ Kå€åŠ¨æ€å‡æ³•åšå¼ˆï¼Œå‚ç…§æ–æ³¢é‚£å¥‘åšå¼ˆå’Œé½è‚¯å¤šå¤«å®šç†çš„è¯æ˜è¿‡ç¨‹ï¼Œå°† $ f_{i} = f_{i-1} + f_{i-2} $ æ›¿æ¢ä¸º $ f_{i} = f_{i-1} + f_{k} \\mid { K \\times f{k-1} \\lt f_{i-1} \\le K \\times f_{k}} $ ï¼Œä¹Ÿå°±æ˜¯å°†é½è‚¯å¤šå¤«å®šç†è¡¨è¿°ä¸­çš„ è‹¥å¹²ä¸è¿ç»­çš„é¡¹ æ›¿æ¢ä¸º è‹¥å¹²ä¸¤ä¸¤ä¹‹æ¯”å¤§äºKé¡¹ã€‚é¢„å¤„ç†å‡ºç±»ä¼¼æ–æ³¢é‚£å¥‘åšå¼ˆä¸­çš„æ–æ³¢é‚£å¥‘åºåˆ—ï¼Œé¢å¯¹å±€åŠ¿ä¸ºåºåˆ—é¡¹çš„ï¼Œå…ˆæ‰‹å¿…è´¥ã€‚\næ³¨æ„æ—¶é—´å¤æ‚åº¦ä¸º $ O(Tlog_{\\frac{k+1}{k}}N) \\approx 2 \\times 10^{8} $ï¼Œå¡å¸¸ã€‚\nè¯¦ç»†å‚è€ƒã€Šä»â€œkå€åŠ¨æ€å‡æ³•æ¸¸æˆâ€å‡ºå‘æ¢ç©¶ä¸€ç±»ç»„åˆæ¸¸æˆé—®é¢˜ã€‹ã€[POJ3922]Nowè§£é¢˜æŠ¥å‘Šã€‚\nä»£ç  1using namespace std; 2int f[1000005] = {1}; 3 4int main() 5{ 6 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 7 for(int cs=1; cs\u0026lt;=T; cs++) 8 { 9 int n, k; 10 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); 11 12 int i=1, j=0; 13 for(; f[i] \u0026lt;= n; i++){ 14 for(; 1LL * k * f[j] \u0026lt; f[i]; j++); 15 f[i+1] = f[i] + f[j]; 16 } 17 i--; 18 19 printf(\u0026#34;Case %d: \u0026#34;, cs); 20 if(f[i] == n){ 21 printf(\u0026#34;lose\\n\u0026#34;); 22 }else{ 23 while(n != f[i]){ 24 for(n-=f[i]; n\u0026lt;f[i]; i--); 25 } 26 printf(\u0026#34;%d\\n\u0026#34;, n); 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/poj-3922-a-simple-stone-game/","summary":"A simple stone game(POJ-3922) é¢˜é¢ After he has learned how to play Nim game, Mike begins to try another stone game which seems much easier. The game goes like this: Two players start the game with a pile of n stones. They take stones from the pile in turn and every time they take at least one stone. The one who goes first can take at most n-1 stones","title":"POJ-3922 A simple stone game"},{"content":"Light Switching Game(POJ-3533) é¢˜é¢ The Light Switching Game is played on a 1000 Ã— 1000 Ã— 1000 cube of cells with a light in each cell, as Figure.1 shows. Initially, most of the lights are off while exactly N lights are on. Two players take moves alternately. A move consists of switching the lights at the corners of a cuboid, i.e. (x1,y1,z1), (x1,y1,z2), (x1,y2,z1), (x1,y2,z2), (x2,y1,z1), (x2,y1,z2), (x2,y2,z1), (x2,y2,z2) where 1 â‰¤ x1 â‰¤ x2 â‰¤ 1000, 1 â‰¤y1 â‰¤ y2 â‰¤ 1000, 1 â‰¤z1 â‰¤ z2 â‰¤ 1000 and the light at the corner (x2,y2,z2) must be on (and turned off after the move). Notice the cuboid is possibly degenerated to a rectangle, a line or even a single cell so that the player may also switching four, two or one besides eight lights in a move. The player loses the game when he can not take a move.\nYou will find out whether the second player can win if both players play optimally.\nè¾“å…¥ There are multiple test cases. Every test case starts with one line containing a single number N indicating the number of lights which is initially on. (N â‰¤ 100) Each of the next N lines contains the coordinates (x, y, z) (1 â‰¤ x, y, z â‰¤ 1000) showing that the light at this position is on initially.\nè¾“å‡º One line for each test case which contains \u0026ldquo;Yes\u0026rdquo; or \u0026ldquo;No\u0026rdquo; indicating whether the second player can win the game.\næ ·ä¾‹è¾“å…¥ 14 25 11 30 35 19 19 423 15 6 52 26 16 63 79 20 9 88 1 28 930 22 26 æ ·ä¾‹è¾“å‡º 1Yes 2No æç¤º æ— \næ€è·¯ Nimç§¯ï¼Œè§ã€é¢˜è§£ã€‘HDU-3404 Switch lights\nä»£ç  1using namespace std; 2 3/* 4 Nimç§¯ x @ y = mex{(a @ y) ^ (x @ b) ^ (a @ b)}, 0 \u0026lt;= a \u0026lt; x, 0 \u0026lt;= b \u0026lt; y 5 6 1. X x 2^(2^a) = X * 2^(2^a) 7 2. X x Y \u0026lt; 2^(2^a) 8 3. 2^(2^a) x 2^(2^a) = (3/2) * 2^(2^a) 9 10 è°ƒç”¨ ans ^= f(x, y) 11*/ 12 13 14int SG[20][20]; 15 16int f(int, int); 17int g(int x, int y) // è®¡ç®—2^xä¸2^yçš„nimç§¯ 18{ 19 if(SG[x][y] != -1) return SG[x][y]; 20 if(!x) return SG[x][y] = 1\u0026lt;\u0026lt;y; // x==0ä¹Ÿå°±æ˜¯1ä¸2^yçš„nimç§¯ï¼Œç­‰äº2^y 21 if(!y) return SG[x][y] = 1\u0026lt;\u0026lt;x; 22 23 int ans=1, t; 24 int xx=x, yy=y, k=1; 25 while(x || y) // å†å°†xå’Œyåˆ†ä¸ºäºŒè¿›åˆ¶ï¼Œè¿™é‡Œè®¡ç®—é‚£äº›æ™®é€šä¹˜ç§¯çš„ï¼ˆå³å¯¹åº”äºŒè¿›åˆ¶ä½ä¸åŒçš„ï¼‰ 26 { 27 t = 1\u0026lt;\u0026lt;k; // ä»æ­¤ä½å¾—åˆ°çš„æœ€ç»ˆçš„æ•°2^k 28 if((x^y)\u0026amp;1) ans *= t; // è¯¥ä½ä¸åŒ 29 x\u0026gt;\u0026gt;=1; y\u0026gt;\u0026gt;=1; k\u0026lt;\u0026lt;=1; // ä»æ­¤ä½å¾—åˆ°çš„æŒ‡æ•°(æœ¬èº«ä¹Ÿæ˜¯2çš„å¹‚) 30 } 31 32 x=xx; y=yy; k=1; 33 while(x || y) // è®¡ç®—é‚£äº›ç›¸åŒçš„fermat 2-power æ•°ï¼Œä¸å·²å¾—å‡ºçš„æ•°çš„nimç§¯ 34 { 35 t = 1\u0026lt;\u0026lt;k; 36 if ((x\u0026amp;y)\u0026amp;1) ans = f(ans, t/2*3); // è¯¥ä½ç›¸åŒ 37 x\u0026gt;\u0026gt;=1; y\u0026gt;\u0026gt;=1; k\u0026lt;\u0026lt;=1; // ä»æ­¤ä½å¾—åˆ°çš„æŒ‡æ•°(æœ¬èº«ä¹Ÿæ˜¯2çš„å¹‚) 38 } 39 return SG[xx][yy] = ans; 40} 41 42int f(int x, int y) //è®¡ç®—äºŒä½Nimç§¯ 43{ 44 if(!x || !y) return 0; 45 if(x == 1) return y; 46 if(y == 1) return x; 47 48 int ans=0; 49 for (int i=x, a=0; i; i\u0026gt;\u0026gt;=1, a++) //å°†xå’ŒäºŒè¿›åˆ¶åˆ†è§£ 50 { 51 if ((i\u0026amp;1)==0) continue; //è¯¥ä½æ˜¯1æ‰è®¡ç®— 52 for (int j=y, b=0; j; j\u0026gt;\u0026gt;=1, b++) 53 { 54 if ((j\u0026amp;1)==0) continue; 55 ans ^= g(a, b); 56 } 57 } 58 return ans; 59} 60 61int main() 62{ 63 memset(SG, -1, sizeof(SG)); 64 int n; 65 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 66 { 67 int nim=0; 68 for(int i=0; i\u0026lt;n; i++){ 69 int x, y, z; 70 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); 71 nim ^= f(x, f(y, z)); 72 } 73 if(nim){ 74 printf(\u0026#34;No\\n\u0026#34;); 75 }else{ 76 printf(\u0026#34;Yes\\n\u0026#34;); 77 } 78 } 79 return 0; 80} ","permalink":"https://blog.lordash.de/posts/solution/poj-3533-light-switching-game/","summary":"Light Switching Game(POJ-3533) é¢˜é¢ The Light Switching Game is played on a 1000 Ã— 1000 Ã— 1000 cube of cells with a light in each cell, as Figure.1 shows. Initially, most of the lights are off while exactly N lights are on. Two players take moves alternately. A move consists of switching the lights at the corners of a cuboid, i.e. (x1,y1,z1), (x1,y1,z2), (x1,y2,z1), (x1,y2,z2), (x2,y1,z1), (x2,y1,z2), (x2,y2,z1), (x2,y2,z2)","title":"POJ-3533 Light Switching Game"},{"content":"Switch lights(HDU-3404) é¢˜é¢ lxhgww is playing a game with his computer Deep Blue. The game is played on a matrix containing lights. At first, some lights are on, while others are off. lxhgww and Deep Blue take turns to switch the lights. For each step, the player should choose a rectangle in the matrix: (x1 , y1) , (x1 , y2) , (x2 , y1) , (x2 , y2) , (x1\u0026lt;=x2,y1\u0026lt;=y2, the light at (x2, y2) should be on) and change the lightsâ€™ status on the four vertex of the rectangle, namely on to off, and off to on. The player turns all the lights off wins the game. Notice the rectangle is possibly degenerated to line or even a single cell so that the player may also switch two or one besides four lights in a move. Deep Blue\u0026rsquo;s strategy is perfect, if it has a chance to win, never will it lose. Does lxhgww have a chance to win if he takes the first step?\nè¾“å…¥ The first line is an integer T(T\u0026lt;=100) indicating the case number. Each case has one integers n (n\u0026lt;= 1000 ), the number of on-lights at the beginning of the game. Then come n lines, each line has two integers, xi , yi, (1\u0026lt;=xi\u0026lt;=10000, 1\u0026lt;=yi\u0026lt;=10000) , so light at (xi, yi) is on at first. (No two lights at the same position)\nè¾“å‡º If lxhgww still has a chance to win, output \u0026ldquo;Have a try, lxhgww.\u0026rdquo;, otherwise tell lxhgww \u0026ldquo;Don\u0026rsquo;t waste your time.\u0026rdquo;\næ ·ä¾‹è¾“å…¥ 12 22 31 2 42 1 52 61 1 72 2 æ ·ä¾‹è¾“å‡º 1Don\u0026#39;t waste your time. 2Have a try, lxhgww. æç¤º æ— \næ€è·¯ ä¸€ä¸ªäºŒç»´çŸ©é˜µä¸Šï¼Œæœ‰è‹¥å¹²ä¸ªäº®ç€çš„ç¯æ³¡ ã€‚ æ¯æ¬¡é€‰æ‹©ä¸€ä¸ªçŸ©é˜µï¼ˆå³ä¸Šè§’çš„ç¯æ³¡å¿…é¡»æ˜¯äº®çš„ï¼‰ï¼Œæ”¹å˜å››ä¸ªè§’ç¯æ³¡çš„çŠ¶æ€ï¼Œä¸èƒ½æ“ä½œçš„é€‰æ‰‹åˆ¤è´Ÿã€‚\nNimç§¯å®šä¹‰\n$ x \\otimes y = sg(x, y) = mex{(a \\otimes y) \\oplus (x \\otimes b) \\oplus (a \\otimes b), 0 \\le a \\lt x, 0 \\le b \\lt y} $\nä»¥ä¸‹æ˜¯å¯¹äº x, yâ‰¤4 çš„ä¸€ä¸ªå°è¡¨ã€‚\n0 1 2 3 4 0 0 0 0 0 0 1 0 1 2 3 4 2 0 2 3 1 8 3 0 3 1 2 12 4 0 4 8 12 6 å®šä¹‰è´¹é©¬æ•°Fermat 2-powerä¸º$ 2^{2^{k}} $ï¼Œå¯¹äº$ x,y \u0026lt; 2^{2^{k}} $æœ‰ä»¥ä¸‹æ€§è´¨\nä¸€ä¸ª Fermat 2-power ä¸ä»»æ„å°äºå®ƒçš„æ•°çš„ Nim ç§¯ä¸ºä¸€èˆ¬æ„ä¹‰ä¸‹ä¹˜æ³•çš„ç§¯ï¼Œå³$ x \\otimes 2^{2^{k}} = x * 2^{2^{k}} $\nä¸€ä¸ª Fermat 2-power ä¸è‡ªå·±çš„ Nim ç§¯ä¸ºè‡ªå·±çš„ $ \\frac{3}{2} $ å€ï¼Œå³ $ 2^{2^{k}} \\otimes 2^{2^{k}} = \\frac{3}{2} * 2^{2^{k}}$\n$ x \\otimes y \u0026lt; 2^{2^{k}} $\næ ¹æ®æ€§è´¨å¯ä»¥å¾—å‡ºé€’å½’æ±‚Nimç§¯çš„æ¿å­ã€‚\nè¯¦ç»†å‚è§è®ºæ–‡ã€Šä»â€œkå€åŠ¨æ€å‡æ³•æ¸¸æˆâ€å‡ºå‘æ¢ç©¶ä¸€ç±»ç»„åˆæ¸¸æˆé—®é¢˜ã€‹ã€‚\nä»£ç  1using namespace std; 2 3/* 4 Nimç§¯ x @ y = mex{(a @ y) ^ (x @ b) ^ (a @ b)}, 0 \u0026lt;= a \u0026lt; x, 0 \u0026lt;= b \u0026lt; y 5 6 1. X x 2^(2^a) = X * 2^(2^a) 7 2. X x Y \u0026lt; 2^(2^a) 8 3. 2^(2^a) x 2^(2^a) = (3/2) * 2^(2^a) 9 10 æ¨¡æ¿ä¸€ï¼šè°ƒç”¨ ans ^= f(x, y) 11*/ 12 13 14int SG[20][20]; 15 16int f(int, int); 17int g(int x, int y) // è®¡ç®—2^xä¸2^yçš„nimç§¯ 18{ 19 if(SG[x][y] != -1) return SG[x][y]; 20 if(!x) return SG[x][y] = 1\u0026lt;\u0026lt;y; // x==0ä¹Ÿå°±æ˜¯1ä¸2^yçš„nimç§¯ï¼Œç­‰äº2^y 21 if(!y) return SG[x][y] = 1\u0026lt;\u0026lt;x; 22 23 int ans=1, t; 24 int xx=x, yy=y, k=1; 25 while(x || y) // å†å°†xå’Œyåˆ†ä¸ºäºŒè¿›åˆ¶ï¼Œè¿™é‡Œè®¡ç®—é‚£äº›æ™®é€šä¹˜ç§¯çš„ï¼ˆå³å¯¹åº”äºŒè¿›åˆ¶ä½ä¸åŒçš„ï¼‰ 26 { 27 t = 1\u0026lt;\u0026lt;k; // ä»æ­¤ä½å¾—åˆ°çš„æœ€ç»ˆçš„æ•°2^k 28 if((x^y)\u0026amp;1) ans *= t; // è¯¥ä½ä¸åŒ 29 x\u0026gt;\u0026gt;=1; y\u0026gt;\u0026gt;=1; k\u0026lt;\u0026lt;=1; // ä»æ­¤ä½å¾—åˆ°çš„æŒ‡æ•°(æœ¬èº«ä¹Ÿæ˜¯2çš„å¹‚) 30 } 31 32 x=xx; y=yy; k=1; 33 while(x || y) // è®¡ç®—é‚£äº›ç›¸åŒçš„fermat 2-power æ•°ï¼Œä¸å·²å¾—å‡ºçš„æ•°çš„nimç§¯ 34 { 35 t = 1\u0026lt;\u0026lt;k; 36 if ((x\u0026amp;y)\u0026amp;1) ans = f(ans, t/2*3); // è¯¥ä½ç›¸åŒ 37 x\u0026gt;\u0026gt;=1; y\u0026gt;\u0026gt;=1; k\u0026lt;\u0026lt;=1; // ä»æ­¤ä½å¾—åˆ°çš„æŒ‡æ•°(æœ¬èº«ä¹Ÿæ˜¯2çš„å¹‚) 38 } 39 return SG[xx][yy] = ans; 40} 41 42int f(int x, int y) //è®¡ç®—äºŒä½Nimç§¯ 43{ 44 if(!x || !y) return 0; 45 if(x == 1) return y; 46 if(y == 1) return x; 47 48 int ans=0; 49 for (int i=x, a=0; i; i\u0026gt;\u0026gt;=1, a++) //å°†xå’ŒäºŒè¿›åˆ¶åˆ†è§£ 50 { 51 if ((i\u0026amp;1)==0) continue; //è¯¥ä½æ˜¯1æ‰è®¡ç®— 52 for (int j=y, b=0; j; j\u0026gt;\u0026gt;=1, b++) 53 { 54 if ((j\u0026amp;1)==0) continue; 55 ans ^= g(a, b); 56 } 57 } 58 return ans; 59} 60 61/* 62 kä¸ºæœ€å¤§çš„æ•´æ•°æ»¡è¶³ M = 2^(2^k) \u0026lt;= x 63 x = p * M + q, y = s * M + t 64 x @ y = spMM + sqM + tpM + tq 65 = M(sp+sq+tp) + tq + (M/2 @ sp) 66 67 æ¨¡æ¿äºŒï¼šè°ƒç”¨ ans ^ Nim_Multi(x, y) 68*/ 69 70int getSg(int x, int y){ 71 if(!x || !y) return 0; 72 if(SG[x][y]!=-1) return SG[x][y]; 73 bool S[1\u0026lt;\u0026lt;8] = {0}; 74 75 for(int i=0; i\u0026lt;x; i++) 76 S[getSg(i, y)] = 1; 77 78 for(int i=0; i\u0026lt;y; i++) 79 S[getSg(x, i)] = 1; 80 81 for(int i=1; i\u0026lt;x; i++) 82 for(int j=1; j\u0026lt;y; j++) 83 S[getSg(i,y) ^ getSg(x,j) ^ getSg(i,j)] = 1; 84 85 int mex = 0; 86 while(S[mex]) mex++; 87 return SG[x][y]=mex; 88} 89 90int Nim_Multi_Power(int x, int y) 91{ 92 if (x \u0026lt; 16) return getSg(x, y); 93 int a=1, m; 94 for(; (1\u0026lt;\u0026lt;a) \u0026lt;= x; a\u0026lt;\u0026lt;=1); 95 a \u0026gt;\u0026gt;= 1; m = 1\u0026lt;\u0026lt;a; 96 int p = x/m, s = y/m, t = y\u0026amp;(m-1); 97 int d1 = Nim_Multi_Power(p, s); 98 int d2 = Nim_Multi_Power(p, t); 99 return ((d1^d2) \u0026lt;\u0026lt; a) ^ Nim_Multi_Power(m/2, d1); 100} 101 102int Nim_Multi(int x, int y) 103{ 104 if (x \u0026lt; y) swap(x, y); 105 if (x \u0026lt; 16) return getSg(x, y); 106 int a=1, m; 107 for(; (1\u0026lt;\u0026lt;a) \u0026lt;= x; a\u0026lt;\u0026lt;=1); 108 a \u0026gt;\u0026gt;= 1; m = 1\u0026lt;\u0026lt;a; 109 int p = x/m, q = x\u0026amp;(m-1), s = y/ m, t = y\u0026amp;(m-1); 110 int c1 = Nim_Multi(p, s); 111 int c2 = Nim_Multi(p, t) ^ Nim_Multi(q, s); 112 int c3 = Nim_Multi(q, t); 113 return ((c1^c2) \u0026lt;\u0026lt; a) ^ c3 ^ Nim_Multi_Power(m/2, c1); 114} 115 116 117int main() 118{ 119 memset(SG, -1, sizeof(SG)); 120 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 121 while(T--) 122 { 123 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 124 125 int nim=0; 126 for(int i=0; i\u0026lt;n; i++){ 127 int x, y; 128 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); 129 //nim ^= f(x, y); 130 nim ^= Nim_Multi(x, y); 131 } 132 if(nim){ 133 printf(\u0026#34;Have a try, lxhgww.\\n\u0026#34;); 134 }else{ 135 printf(\u0026#34;Don\u0026#39;t waste your time.\\n\u0026#34;); 136 } 137 } 138 return 0; 139} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3404-switch-lights/","summary":"Switch lights(HDU-3404) é¢˜é¢ lxhgww is playing a game with his computer Deep Blue. The game is played on a matrix containing lights. At first, some lights are on, while others are off. lxhgww and Deep Blue take turns to switch the lights. For each step, the player should choose a rectangle in the matrix: (x1 , y1) , (x1 , y2) , (x2 , y1) , (x2 , y2)","title":"HDU-3404 Switch lights"},{"content":"John(POJ-3480) é¢˜é¢ Little John is playing very funny game with his younger brother. There is one big box filled with M\u0026amp;Ms of different colors. At first John has to eat several M\u0026amp;Ms of the same color. Then his opponent has to make a turn. And so on. Please note that each player has to eat at least one M\u0026amp;M during his turn. If John (or his brother) will eat the last M\u0026amp;M from the box he will be considered as a looser and he will have to buy a new candy box.\nBoth of players are using optimal game strategy. John starts first always. You will be given information about M\u0026amp;Ms and your task is to determine a winner of such a beautiful game.\nè¾“å…¥ The first line of input will contain a single integer T â€“ the number of test cases. Next T pairs of lines will describe tests in a following format. The first line of each test will contain an integer N â€“ the amount of different M\u0026amp;M colors in a box. Next line will contain N integers Ai, separated by spaces â€“ amount of M\u0026amp;Ms of i-th color.\nConstraints: 1 \u0026lt;= T \u0026lt;= 474, 1 \u0026lt;= N \u0026lt;= 47, 1 \u0026lt;= Ai \u0026lt;= 4747\nè¾“å‡º Output T lines each of them containing information about game winner. Print â€œJohnâ€ if John will win the game or â€œBrotherâ€ in other case.For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position.\næ ·ä¾‹è¾“å…¥ 12 23 33 5 1 41 51 æ ·ä¾‹è¾“å‡º 1John 2Brother æç¤º æ— \næ€è·¯ Anti-Nimåšå¼ˆï¼Œå±äºAnti-SGæ¸¸æˆçš„ä¸€ç§ã€‚\nAnti-SGæ¸¸æˆå®šä¹‰ï¼š\nå†³ç­–é›†åˆä¸ºç©ºçš„æ“ä½œè€…èƒœã€‚\nå…¶ä½™è§„åˆ™ä¸SGæ¸¸æˆä¸€è‡´ã€‚\nSJå®šç†ï¼š\nå¯¹äºä»»æ„ä¸€ä¸ªAnti-SGæ¸¸æˆï¼Œå¦‚æœå®šä¹‰æ‰€æœ‰å­æ¸¸æˆçš„SGå€¼ä¸º0æ—¶æ¸¸æˆç»“æŸï¼Œå…ˆæ‰‹å¿…èƒœçš„æ¡ä»¶ï¼š\næ¸¸æˆçš„SGå€¼ä¸º0ä¸”æ‰€æœ‰å­æ¸¸æˆSGå€¼å‡ä¸è¶…è¿‡1ã€‚ æ¸¸æˆçš„SGå€¼ä¸ä¸º0ä¸”è‡³å°‘ä¸€ä¸ªå­æ¸¸æˆSGå€¼è¶…è¿‡1ã€‚ ä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 while(T--) 7 { 8 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 int nim=0, anti=0; 11 for(int i=0; i\u0026lt;n; i++){ 12 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 13 if(x\u0026gt;1) anti = 1; 14 nim ^=x; 15 } 16 if((!nim\u0026amp;\u0026amp;!anti) || (nim\u0026amp;\u0026amp;anti)){ 17 printf(\u0026#34;John\\n\u0026#34;); 18 }else{ 19 printf(\u0026#34;Brother\\n\u0026#34;); 20 } 21 } 22 return 0; 23} ","permalink":"https://blog.lordash.de/posts/solution/poj-3480-john/","summary":"John(POJ-3480) é¢˜é¢ Little John is playing very funny game with his younger brother. There is one big box filled with M\u0026amp;Ms of different colors. At first John has to eat several M\u0026amp;Ms of the same color. Then his opponent has to make a turn. And so on. Please note that each player has to eat at least one M\u0026amp;M during his turn. If John (or his brother) will eat","title":"POJ-3480 John"},{"content":"Nim(POJ-2975) é¢˜é¢ Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a playerâ€™s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task is to determine how many winning moves there are in that position.A position in Nim is called â€œlosingâ€ if the first player to move from that position would lose if both sides played perfectly. A â€œwinning move,â€ then, is a move that leaves the game in a losing position. There is a famous theorem that classifies all losing positions. Suppose a Nim position contains n piles having k1, k2, â€¦, kn stones respectively; in such a position, there are k1 + k2 + â€¦ + kn possible moves. We write each ki in binary (base 2). Then, the Nim position is losing if and only if, among all the kiâ€™s, there are an even number of 1â€™s in each digit position. In other words, the Nim position is losing if and only if the xor of the kiâ€™s is 0.Consider the position with three piles given by k1 = 7, k2 = 11, and k3 = 13. In binary, these values are as follows:\n0111\n1011\n1101\nThere are an odd number of 1â€™s among the rightmost digits, so this position is not losing. However, suppose k3 were changed to be 12. Then, there would be exactly two 1â€™s in each digit position, and thus, the Nim position would become losing. Since a winning move is any move that leaves the game in a losing position, it follows that removing one stone from the third pile is a winning move when k1 = 7, k2 = 11, and k3 = 13. In fact, there are exactly three winning moves from this position: namely removing one stone from any of the three piles.\nè¾“å…¥ The input test file will contain multiple test cases, each of which begins with a line indicating the number of piles, 1 â‰¤ n â‰¤ 1000. On the next line, there are n positive integers, 1 â‰¤ ki â‰¤ 1, 000, 000, 000, indicating the number of stones in each pile. The end-of-file is marked by a test case with n = 0 and should not be processed.\nè¾“å‡º For each test case, write a single line with an integer indicating the number of winning moves from the given Nim position.\næ ·ä¾‹è¾“å…¥ 13 27 11 13 32 41000000000 1000000000 50 æ ·ä¾‹è¾“å‡º 13 20 æç¤º æ— \næ€è·¯ Nimåšå¼ˆã€‚\nä»£ç  1using namespace std; 2int f[1005]; 3 4 5int main() 6{ 7 int n; 8 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 9 { 10 int nim=0; 11 for(int i=0; i\u0026lt;n; i++){ 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i]); 13 nim ^= f[i]; 14 } 15 16 int num = 0; 17 for(int i=0; i\u0026lt;n; i++){ 18 if((nim^f[i]) \u0026lt; f[i]) 19 num++; 20 } 21 printf(\u0026#34;%d\\n\u0026#34;, num); 22 } 23 return 0; 24} ","permalink":"https://blog.lordash.de/posts/solution/poj-2975-nim/","summary":"Nim(POJ-2975) é¢˜é¢ Nim is a 2-player game featuring several piles of stones. Players alternate turns, and on his/her turn, a playerâ€™s move consists of removing one or more stones from any single pile. Play ends when all the stones have been removed, at which point the last player to have moved is declared the winner. Given a position in Nim, your task","title":"POJ-2975 Nim"},{"content":"S-Nim(POJ-2960) é¢˜é¢ Arthur and his sister Caroll have been playing a game called Nim for some time now. Nim is played as follows:\nThe starting position has a number of heaps, all containing some, not necessarily equal, number of beads. The players take turns chosing a heap and removing a positive number of beads from it. The first player not able to make a move, loses. Arthur and Caroll really enjoyed playing this simple game until they recently learned an easy way to always be able to find the best move:\nXor the number of beads in the heaps in the current position (i.e. if we have 2, 4 and 7 the xor-sum will be 1 as 2 xor 4 xor 7 = 1). If the xor-sum is 0, too bad, you will lose. Otherwise, move such that the xor-sum becomes 0. This is always possible. It is quite easy to convince oneself that this works. Consider these facts:\nThe player that takes the last bead wins. After the winning player\u0026rsquo;s last move the xor-sum will be 0. The xor-sum will change after every move. Which means that if you make sure that the xor-sum always is 0 when you have made your move, your opponent will never be able to win, and, thus, you will win.\nUnderstandibly it is no fun to play a game when both players know how to play perfectly (ignorance is bliss). Fourtunately, Arthur and Caroll soon came up with a similar game, S-Nim, that seemed to solve this problem. Each player is now only allowed to remove a number of beads in some predefined set S, e.g. if we have S = {2, 5} each player is only allowed to remove 2 or 5 beads. Now it is not always possible to make the xor-sum 0 and, thus, the strategy above is useless. Or is it?\nyour job is to write a program that determines if a position of S-Nim is a losing or a winning position. A position is a winning position if there is at least one move to a losing position. A position is a losing position if there are no moves to a losing position. This means, as expected, that a position with no legal moves is a losing position.\nè¾“å…¥ Input consists of a number of test cases. For each test case: The first line contains a number k (0 \u0026lt; k â‰¤ 100) describing the size of S, followed by k numbers si (0 \u0026lt; si â‰¤ 10000) describing S. The second line contains a number m (0 \u0026lt; m â‰¤ 100) describing the number of positions to evaluate. The next m lines each contain a number l (0 \u0026lt; l â‰¤ 100) describing the number of heaps and l numbers hi (0 â‰¤ hi â‰¤ 10000) describing the number of beads in the heaps. The last test case is followed by a 0 on a line of its own.\nè¾“å‡º For each position: If the described position is a winning position print a \u0026lsquo;W\u0026rsquo;.If the described position is a losing position print an \u0026lsquo;L\u0026rsquo;. Print a newline after each test case.\næ ·ä¾‹è¾“å…¥ 12 2 5 23 32 5 12 43 2 4 7 54 2 3 7 12 65 1 2 3 4 5 73 82 5 12 93 2 4 7 104 2 3 7 12 110 æ ·ä¾‹è¾“å‡º 1LWW 2WWL æç¤º æ— \næ€è·¯ SGå‡½æ•°æ‰“è¡¨ï¼Œæœ€åè¿ç”¨SGå®šç†æ¯å †çŸ³å­å¼‚æˆ–ä¸€ä¸‹å³å¯ã€‚\nä»£ç  1using namespace std; 2int SG[10000], f[10000]; 3 4void getSg(int n, int m){ 5 for(int i=1; i\u0026lt;=n; i++){ 6 bool S[10000]={0}; 7 for(int j=0; j\u0026lt;m \u0026amp;\u0026amp; f[j]\u0026lt;=i; j++){ 8 S[SG[i-f[j]]] = 1; 9 } 10 int mex=0; 11 while(S[mex]) mex++; 12 SG[i]=mex; 13 } 14} 15 16int main() 17{ 18 int k; 19 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;k) \u0026amp;\u0026amp; k) 20 { 21 for(int i=0; i\u0026lt;k; i++){ 22 scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i]); 23 } 24 sort(f, f+k); 25 getSg(10000, k); 26 27 int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 28 while(m--){ 29 int l; scanf(\u0026#34;%d\u0026#34;, \u0026amp;l); 30 int nim = 0; 31 while(l--){ 32 int h; scanf(\u0026#34;%d\u0026#34;, \u0026amp;h); 33 nim ^= SG[h]; 34 } 35 if(nim){ 36 printf(\u0026#34;W\u0026#34;); 37 }else{ 38 printf(\u0026#34;L\u0026#34;); 39 } 40 } 41 printf(\u0026#34;\\n\u0026#34;); 42 } 43 return 0; 44} ","permalink":"https://blog.lordash.de/posts/solution/poj-2960-s-nim/","summary":"S-Nim(POJ-2960) é¢˜é¢ Arthur and his sister Caroll have been playing a game called Nim for some time now. Nim is played as follows: The starting position has a number of heaps, all containing some, not necessarily equal, number of beads. The players take turns chosing a heap and removing a positive number of beads from it. The first player not able to make a move, loses. Arthur and Caroll","title":"POJ-2960 S-Nim"},{"content":"A Chess Game(POJ-2425) é¢˜é¢ Let\u0026rsquo;s design a new chess game. There are N positions to hold M chesses in this game. Multiple chesses can be located in the same position. The positions are constituted as a topological graph, i.e. there are directed edges connecting some positions, and no cycle exists. Two players you and I move chesses alternately. In each turn the player should move only one chess from the current position to one of its out-positions along an edge. The game does not end, until one of the players cannot move chess any more. If you cannot move any chess in your turn, you lose. Otherwise, if the misfortune falls on me\u0026hellip; I will disturb the chesses and play it again.\nDo you want to challenge me? Just write your program to show your qualification!\nè¾“å…¥ Input contains multiple test cases. Each test case starts with a number N (1 \u0026lt;= N \u0026lt;= 1000) in one line. Then the following N lines describe the out-positions of each position. Each line starts with an integer Xi that is the number of out-positions for the position i. Then Xi integers following specify the out-positions. Positions are indexed from 0 to N-1. Then multiple queries follow. Each query occupies only one line. The line starts with a number M (1 \u0026lt;= M \u0026lt;= 10), and then come M integers, which are the initial positions of chesses. A line with number 0 ends the test case.\nè¾“å‡º There is one line for each query, which contains a string \u0026ldquo;WIN\u0026rdquo; or \u0026ldquo;LOSE\u0026rdquo;. \u0026ldquo;WIN\u0026rdquo; means that the player taking the first turn can win the game according to a clever strategy; otherwise \u0026ldquo;LOSE\u0026rdquo; should be printed.\næ ·ä¾‹è¾“å…¥ 14 22 1 2 30 41 3 50 61 0 72 0 2 80 9 104 111 1 121 2 130 140 152 0 1 162 1 1 173 0 1 3 180 æ ·ä¾‹è¾“å‡º 1WIN 2WIN 3WIN 4LOSE 5WIN æç¤º Huge input,scanf is recommended.\næ€è·¯ ç»™å®šä¸€ä¸ª n ä¸ªèŠ‚ç‚¹çš„æœ‰å‘æ— ç¯å›¾ï¼Œå†ç»™å‡º m ä¸ªæ£‹å­ï¼Œæ¯ä¸€ä¸ªæ£‹å­ä½äºä¸€ä¸ªç‚¹ä¸Šä¸”äº’ç›¸ä¸å½±å“(å³ä¸€ä¸ªç‚¹ä¸Šå¯ä»¥æœ‰å¤šä¸ªæ£‹å­)ï¼Œæ¯å›åˆå¯ä»¥é€‰æ‹©ä¸€ä¸ªæ£‹å­æŒ‰ç…§ç»™å‡ºçš„å›¾æŠŠå®ƒç§»å‘ä¸‹ä¸€ä¸ªç‚¹ï¼Œå³å½“å‰ç‚¹ä¸ä¸‹ä¸€ä¸ªç‚¹é—´æœ‰ä¸€æ¡æœ‰å‘è¾¹ï¼Œç”±å½“å‰ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªç‚¹ï¼Œæ— æ³•è¿›è¡Œæ“ä½œåˆ™åˆ¤è¾“ï¼Œé—®å…ˆæ‰‹æ˜¯å¦å¿…èƒœã€‚\nä¸€ä¸ªæ£‹å­ä¸èƒ½å†ç§»åŠ¨å½“ä¸”ä»…å½“è¿™ä¸ªç‚¹çš„å‡ºåº¦ä¸º0ï¼Œå› ä¸ºæ¯ä¸ªæ£‹å­äº’ä¸å½±å“ï¼Œæ‰€ä»¥åˆ†åˆ«æ±‚å‡ºæ¯ä¸ªæ£‹å­çš„SGå‡½æ•°ï¼Œæ±‚ä¸€ä¸‹å¼‚æˆ–å’Œå°±å¥½äº†ã€‚\nä»£ç  1using namespace std; 2const int mxn = 1e3 + 5; 3 4vector\u0026lt;int\u0026gt; E[mxn]; 5int SG[mxn]; 6 7int getSg(int x){ 8 if(SG[x]!=-1) return SG[x]; 9 bool S[mxn] = {0}; 10 11 for(int i=0; i\u0026lt;E[x].size(); i++){ 12 S[getSg(E[x][i])] = 1; 13 } 14 15 int mex = 0; 16 while(S[mex]) mex++; 17 return SG[x]=mex; 18} 19 20int main(){ 21 int n; 22 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 23 { 24 memset(SG, -1, sizeof(SG)); 25 for(int i=0; i\u0026lt;n; i++){ 26 E[i].clear(); 27 int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 28 while(m--){ 29 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 30 E[i].push_back(x); 31 } 32 } 33 int q; 34 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;q) \u0026amp;\u0026amp; q){ 35 int nim = 0; 36 while(q--){ 37 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 38 nim ^= getSg(x); 39 } 40 if(nim){ 41 printf(\u0026#34;WIN\\n\u0026#34;); 42 }else{ 43 printf(\u0026#34;LOSE\\n\u0026#34;); 44 } 45 } 46 } 47} ","permalink":"https://blog.lordash.de/posts/solution/poj-2425-a-chess-game/","summary":"A Chess Game(POJ-2425) é¢˜é¢ Let\u0026rsquo;s design a new chess game. There are N positions to hold M chesses in this game. Multiple chesses can be located in the same position. The positions are constituted as a topological graph, i.e. there are directed edges connecting some positions, and no cycle exists. Two players you and I move chesses alternately. In each turn the player should move only one chess from","title":"POJ-2425 A Chess Game"},{"content":"Euclid\u0026rsquo;s Game(POJ-2348) é¢˜é¢ Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a multiple of the lesser number from the greater to reach 0, and thereby wins. For example, the players may start with (25,7):\n1 25 7 2 11 7 3 4 7 4 4 3 5 1 3 6 1 0 an Stan wins.\nè¾“å…¥ The input consists of a number of lines. Each line contains two positive integers giving the starting two numbers of the game. Stan always starts.\nè¾“å‡º For each line of input, output one line saying either Stan wins or Ollie wins assuming that both of them play perfectly. The last line of input contains two zeroes and should not be processed.\næ ·ä¾‹è¾“å…¥ 134 12 215 24 30 0 æ ·ä¾‹è¾“å‡º 1Stan wins 2Ollie wins æç¤º æ— \næ€è·¯ å½“å±€é¢ä¸º(a, b) a\u0026lt;=bï¼Œb%a==0çš„æ—¶å€™ï¼Œå…ˆæ‰‹å¿…èƒœï¼›å½“b\u0026gt;2*açš„æ—¶å€™ï¼Œå…ˆæ‰‹å¯ä»¥å°†å¿…è´¥æ€è½¬åŒ–ä¸ºå¿…èƒœæ€ï¼Œå³è‹¥b=a*x+yï¼Œå–èµ°a*xä¼šå¯¼è‡´å¿…è´¥æ€ï¼ˆå°†å¿…èƒœæ€ç•™ç»™å¯¹æ‰‹ï¼Œæ­¤æ—¶å¿…è´¥ï¼‰çš„æ—¶å€™ï¼Œç”±äºx\u0026gt;2ï¼Œå…ˆæ‰‹å¯ä»¥é€‰æ‹©å–èµ°a*(x-1)è€Œå°†å¿…è´¥æ€ç•™ç»™å¯¹æ‰‹ï¼›å½“2*a\u0026gt;b\u0026gt;aæ—¶ï¼Œå…ˆæ‰‹åªèƒ½å°†å±€é¢å–b-aï¼ŒçŠ¶æ€äº’æ¢ã€‚\nä¾‹å¦‚ï¼š\n(0, 1) å…ˆæ‰‹å¿…è´¥\n(1, 2) å…ˆæ‰‹å¿…èƒœ\nå½“å±€é¢ä¸º(2, 3)æ—¶ï¼Œå…ˆæ‰‹åªèƒ½å–æˆ(1, 2)ï¼Œå°†å¿…èƒœæ€ç•™ç»™å¯¹æ‰‹ï¼Œæ­¤æ—¶å…ˆæ‰‹å¿…è´¥\nå½“å±€é¢ä¸º(2, 5)æ—¶ï¼Œå…ˆæ‰‹å¯ä»¥å–æˆ(1, 2)å’Œ(2, 3)ï¼Œæ¯«æ— ç–‘é—®ï¼Œå–æˆ(2, 3)å¯ä»¥å°†å¿…è´¥æ€ç•™ç»™å¯¹æ‰‹ï¼Œæ­¤æ—¶å…ˆæ‰‹å¿…èƒœã€‚\nä»£ç  1using namespace std; 2 3int main(){ 4 int a, b; 5 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b) \u0026amp;\u0026amp; a \u0026amp;\u0026amp; b) 6 { 7 int win = 1; 8 while(1){ 9 if(a \u0026gt; b) swap(a, b); 10 if(b%a==0 || b-a\u0026gt;a) break; 11 b -= a; 12 win = !win; 13 } 14 if(win){ 15 printf(\u0026#34;Stan wins\\n\u0026#34;); 16 }else{ 17 printf(\u0026#34;Ollie wins\\n\u0026#34;); 18 } 19 } 20} ","permalink":"https://blog.lordash.de/posts/solution/poj-2348-euclids-game/","summary":"Euclid\u0026rsquo;s Game(POJ-2348) é¢˜é¢ Two players, Stan and Ollie, play, starting with two natural numbers. Stan, the first player, subtracts any positive multiple of the lesser of the two numbers from the greater of the two numbers, provided that the resulting number must be nonnegative. Then Ollie, the second player, does the same with the two resulting numbers, then Stan, etc., alternately, until one player is able to subtract a","title":"POJ-2348 Euclid's Game"},{"content":"Fibonacci again and again(HDU-1848) é¢˜é¢ ä»»ä½•ä¸€ä¸ªå¤§å­¦ç”Ÿå¯¹è²æ³¢é‚£å¥‘æ•°åˆ—(Fibonacci numbers)åº”è¯¥éƒ½ä¸ä¼šé™Œç”Ÿï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š F(1)=1; F(2)=2; F(n)=F(n-1)+F(n-2)(n\u0026gt;=3); æ‰€ä»¥ï¼Œ1,2,3,5,8,13â€¦â€¦å°±æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ã€‚ åœ¨HDOJä¸Šæœ‰ä¸å°‘ç›¸å…³çš„é¢˜ç›®ï¼Œæ¯”å¦‚1005 Fibonacci againå°±æ˜¯æ›¾ç»çš„æµ™æ±Ÿçœèµ›é¢˜ã€‚ ä»Šå¤©ï¼Œåˆä¸€ä¸ªå…³äºFibonacciçš„é¢˜ç›®å‡ºç°äº†ï¼Œå®ƒæ˜¯ä¸€ä¸ªå°æ¸¸æˆï¼Œå®šä¹‰å¦‚ä¸‹ï¼š 1ã€ è¿™æ˜¯ä¸€ä¸ªäºŒäººæ¸¸æˆ; 2ã€ ä¸€å…±æœ‰3å †çŸ³å­ï¼Œæ•°é‡åˆ†åˆ«æ˜¯m, n, pä¸ªï¼› 3ã€ ä¸¤äººè½®æµèµ°; 4ã€ æ¯èµ°ä¸€æ­¥å¯ä»¥é€‰æ‹©ä»»æ„ä¸€å †çŸ³å­ï¼Œç„¶åå–èµ°fä¸ªï¼› 5ã€ fåªèƒ½æ˜¯è²æ³¢é‚£å¥‘æ•°åˆ—ä¸­çš„å…ƒç´ ï¼ˆå³æ¯æ¬¡åªèƒ½å–1ï¼Œ2ï¼Œ3ï¼Œ5ï¼Œ8â€¦ç­‰æ•°é‡ï¼‰ï¼› 6ã€ æœ€å…ˆå–å…‰æ‰€æœ‰çŸ³å­çš„äººä¸ºèƒœè€…ï¼›\nå‡è®¾åŒæ–¹éƒ½ä½¿ç”¨æœ€ä¼˜ç­–ç•¥ï¼Œè¯·åˆ¤æ–­å…ˆæ‰‹çš„äººä¼šèµ¢è¿˜æ˜¯åæ‰‹çš„äººä¼šèµ¢ã€‚\nè¾“å…¥ è¾“å…¥æ•°æ®åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å ä¸€è¡Œï¼ŒåŒ…å«3ä¸ªæ•´æ•°m,n,pï¼ˆ1\u0026lt;=m,n,p\u0026lt;=1000ï¼‰ã€‚ m=n=p=0åˆ™è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚\nè¾“å‡º å¦‚æœå…ˆæ‰‹çš„äººèƒ½èµ¢ï¼Œè¯·è¾“å‡ºâ€œFiboâ€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œNacciâ€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 11 1 1 21 4 1 30 0 0 æ ·ä¾‹è¾“å‡º 1Fibo 2Nacci æç¤º æ— \næ€è·¯ é¢„å¤„ç†æ–æ³¢é‚£å¥‘æ•°åˆ—ï¼ŒSGå‡½æ•°æ‰“è¡¨ã€‚\nä»£ç  1using namespace std; 2int SG[1000], f[1000]; 3 4void fib(int n){ 5 f[1] = f[2] = 1; 6 for(int i=3; ; i++){ 7 f[i] = f[i-1] + f[i-2]; 8 if(f[i] \u0026gt; n) break; 9 } 10} 11 12void getSg(int n){ 13 for(int i=1; i\u0026lt;=n; i++){ 14 bool S[1000]={0}; 15 for(int j=1; f[j]\u0026lt;=i; j++){ 16 S[SG[i-f[j]]] = 1; 17 } 18 int mex=0; 19 while(S[mex]) mex++; 20 SG[i]=mex; 21 } 22} 23 24int main() 25{ 26 fib(1000); 27 getSg(1000); 28 29 int n, m, p; 30 while(~scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;p) \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m \u0026amp;\u0026amp; p) 31 { 32 if(SG[n] ^ SG[m] ^ SG[p]){ 33 printf(\u0026#34;Fibo\\n\u0026#34;); 34 }else{ 35 printf(\u0026#34;Nacci\\n\u0026#34;); 36 } 37 } 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1848-fibonacci-again-and-again/","summary":"Fibonacci again and again(HDU-1848) é¢˜é¢ ä»»ä½•ä¸€ä¸ªå¤§å­¦ç”Ÿå¯¹è²æ³¢é‚£å¥‘æ•°åˆ—(Fibonacci numbers)åº”è¯¥éƒ½ä¸ä¼šé™Œç”Ÿï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š F(1)=1; F(2)=2; F(n)=F(n-1)+F(n-2)(n\u0026gt;=3); æ‰€ä»¥ï¼Œ1,2,3,5,8,","title":"HDU-1848 Fibonacci again and again"},{"content":"Nim(POJ-2068) é¢˜é¢ Let\u0026rsquo;s play a traditional game Nim. You and I are seated across a table and we have a hundred stones on the table (we know the number of stones exactly). We play in turn and at each turn, you or I can remove on to four stones from the heap. You play first and the one who removed the last stone loses. In this game, you have a winning strategy. To see this, you first remove four stones and leave 96 stones. No matter how I play, I will end up with leaving 92 - 95 stones. Then you will in turn leave 91 stones for me (verify this is always possible). This way, you can always leave 5k+1 stones for me and finally I get the last stone, sigh. If we initially had 101 stones, on the other hand, I have a winning strategy and you are doomed to lose.\nLet\u0026rsquo;s generalize the game a little bit. First, let\u0026rsquo;s make it a team game. Each team has n players and the 2n players are seated around the table, with each player having opponents at both sides. Turn around the table so the two teams play alternately. Second, let\u0026rsquo;s vary the maximum number of stones each player can take. That is, each player has his/her own maximum number of stones he/she can take at each turn (The minimum is always one). So the game is asymmetric and may even be unfair.\nIn general, when played between two teams of experts, the outcome of a game is completely determined by the initial number of stones and the maximum number of stones each player can take at each turn. In other words, either team has a winning strategy.\nYou are the head-coach of a team. In each game, the umpire shows both teams the initial number of stones and the maximum number of stones each player can take at each turn. Your team plays first. Your job is, given those numbers, to instantaneously judge whether your team has a winning strategy.\nIncidentally, there is a rumor that Captain Future and her officers of Hakodate-maru love this game, and they are killing their time playing it during their missions. You wonder where the stones are? Well, they do not have stones but do have plenty of balls in the fuel containers!\nè¾“å…¥ The input is a sequence of lines, followed by the last line containing a zero. Each line except the last is a sequence of integers and has the following format.\nn S M1 M2 . . . M2n\nwhere n is the number of players in a team, S the initial number of stones, and Mi the maximum number of stones ith player can take. 1st, 3rd, 5th, \u0026hellip; players are your team\u0026rsquo;s players and 2nd, 4th, 6th, \u0026hellip; the opponents. Numbers are separated by a single space character. You may assume 1 \u0026lt;= n \u0026lt;= 10, 1 \u0026lt;= Mi \u0026lt;= 16, and 1 \u0026lt;= S \u0026lt; 2^13.\nè¾“å‡º The output should consist of lines each containing either a one, meaning your team has a winning strategy, or a zero otherwise.\næ ·ä¾‹è¾“å…¥ 11 101 4 4 21 100 4 4 33 97 8 7 6 5 4 3 40 æ ·ä¾‹è¾“å‡º 10 21 31 æç¤º æ— \næ€è·¯ ç±»ä¼¼DFSï¼ŒSGå‡½æ•°æš´åŠ›æ‰“è¡¨ã€‚\nä»£ç  1using namespace std; 2int SG[20][10005], f[20]; 3 4int getSg(int x, int s, int m){ 5 if(s==0) return SG[x][s]=1; 6 if(SG[x][s]!=-1) return SG[x][s]; 7 8 for(int i=1; i\u0026lt;=f[x]; i++){ 9 if(s\u0026lt;i) break; 10 if(getSg((x+1)%m, s-i, m)==0) 11 return SG[x][s]=1; 12 } 13 14 return SG[x][s]=0; 15} 16 17int main() 18{ 19 int n; 20 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 21 { 22 memset(SG, -1, sizeof(SG)); 23 24 int s; scanf(\u0026#34;%d\u0026#34;, \u0026amp;s); 25 int m = 2*n; 26 for(int i=0; i\u0026lt;m; i++) 27 scanf(\u0026#34;%d\u0026#34;, \u0026amp;f[i]); 28 29 printf(\u0026#34;%d\\n\u0026#34;, getSg(0, s, m)); 30 } 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/poj-2068-nim/","summary":"Nim(POJ-2068) é¢˜é¢ Let\u0026rsquo;s play a traditional game Nim. You and I are seated across a table and we have a hundred stones on the table (we know the number of stones exactly). We play in turn and at each turn, you or I can remove on to four stones from the heap. You play first and the one who removed the last stone loses. In this game, you have","title":"POJ-2068 Nim"},{"content":"Cutting Game(POJ-2311) é¢˜é¢ Urej loves to play various types of dull games. He usually asks other people to play with him. He says that playing those games can show his extraordinary wit. Recently Urej takes a great interest in a new game, and Erif Nezorf becomes the victim. To get away from suffering playing such a dull game, Erif Nezorf requests your help. The game uses a rectangular paper that consists of W*H grids. Two players cut the paper into two pieces of rectangular sections in turn. In each turn the player can cut either horizontally or vertically, keeping every grids unbroken. After N turns the paper will be broken into N+1 pieces, and in the later turn the players can choose any piece to cut. If one player cuts out a piece of paper with a single grid, he wins the game. If these two people are both quite clear, you should write a problem to tell whether the one who cut first can win or not.\nè¾“å…¥ The input contains multiple test cases. Each test case contains only two integers W and H (2 \u0026lt;= W, H \u0026lt;= 200) in one line, which are the width and height of the original paper.\nè¾“å‡º For each test case, only one line should be printed. If the one who cut first can win the game, print \u0026ldquo;WIN\u0026rdquo;, otherwise, print \u0026ldquo;LOSE\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 12 2 23 2 34 2 æ ·ä¾‹è¾“å‡º 1LOSE 2LOSE 3WIN æç¤º æ— \næ€è·¯ SGå‡½æ•°æ‰“è¡¨ï¼Œå‰ªåˆ°2å°±ç»“æŸäº†ã€‚\nä»£ç  1using namespace std; 2 3int SG[205][205]; 4 5int getSg(int n, int m){ 6 if(SG[n][m]!=-1) return SG[n][m]; 7 bool S[1005]={0}; 8 9 for(int i=2; i\u0026lt;=n-i; i++) 10 S[getSg(i, m) ^ getSg(n-i, m)] = 1; 11 for(int i=2; i\u0026lt;=m-i; i++) 12 S[getSg(n, i) ^ getSg(n, m-i)] = 1; 13 14 int mex = 0; 15 while(S[mex]) mex++; 16 return SG[n][m]=mex; 17} 18 19int main() 20{ 21 memset(SG, -1, sizeof(SG)); 22 23 int n, m; 24 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m) \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) 25 { 26 if(getSg(n, m)){ 27 printf(\u0026#34;WIN\\n\u0026#34;); 28 }else{ 29 printf(\u0026#34;LOSE\\n\u0026#34;); 30 } 31 } 32 return 0; 33} ","permalink":"https://blog.lordash.de/posts/solution/poj-2311-cutting-game/","summary":"Cutting Game(POJ-2311) é¢˜é¢ Urej loves to play various types of dull games. He usually asks other people to play with him. He says that playing those games can show his extraordinary wit. Recently Urej takes a great interest in a new game, and Erif Nezorf becomes the victim. To get away from suffering playing such a dull game, Erif Nezorf requests your help. The game uses a rectangular paper","title":"POJ-2311 Cutting Game"},{"content":"A New Stone Game(POJ-1740) é¢˜é¢ Alice and Bob decide to play a new stone game.At the beginning of the game they pick n(1\u0026lt;=n\u0026lt;=10) piles of stones in a line. Alice and Bob move the stones in turn. At each step of the game,the player choose a pile,remove at least one stones,then freely move stones from this pile to any other pile that still has stones. For example:n=4 and the piles have (3,1,4,2) stones.If the player chose the first pile and remove one.Then it can reach the follow states. 2 1 4 2 1 2 4 2ï¼ˆmove one stone to Pile 2ï¼‰ 1 1 5 2ï¼ˆmove one stone to Pile 3ï¼‰ 1 1 4 3ï¼ˆmove one stone to Pile 4ï¼‰ 0 2 5 2ï¼ˆmove one stone to Pile 2 and another one to Pile 3ï¼‰ 0 2 4 3ï¼ˆmove one stone to Pile 2 and another one to Pile 4ï¼‰ 0 1 5 3ï¼ˆmove one stone to Pile 3 and another one to Pile 4ï¼‰ 0 3 4 2ï¼ˆmove two stones to Pile 2ï¼‰ 0 1 6 2ï¼ˆmove two stones to Pile 3ï¼‰ 0 1 4 4ï¼ˆmove two stones to Pile 4ï¼‰ Alice always moves first. Suppose that both Alice and Bob do their best in the game. You are to write a program to determine who will finally win the game.\nè¾“å…¥ The input contains several test cases. The first line of each test case contains an integer number n, denoting the number of piles. The following n integers describe the number of stones in each pile at the beginning of the game, you may assume the number of stones in each pile will not exceed 100. The last test case is followed by one zero.\nè¾“å‡º For each test case, if Alice win the game,output 1,otherwise output 0.\næ ·ä¾‹è¾“å…¥ 13 22 1 3 32 41 1 50 æ ·ä¾‹è¾“å‡º 11 20 æç¤º æ— \næ€è·¯ å½“çŸ³å­å †æ•°ä¸ºå¶æ•°ï¼Œä¸”çŸ³å­æ•°ç›¸ç­‰çš„å †ä¹Ÿæ˜¯å¶æ•°ä¸ªæ—¶ï¼Œåæ‰‹å¯ä»¥æ¨¡ä»¿å…ˆæ‰‹æ“ä½œè·å¾—èƒœåˆ©ï¼Œæ­¤æ—¶ä¸ºå¿…è´¥æ€ã€‚å…¶å®ƒæƒ…å†µæ—¶ï¼Œå…ˆæ‰‹éƒ½å¯ä»¥æŠŠæœ€å¤§å †çš„çŸ³å­å–èµ°ä¸€ä¸ªï¼Œå¹¶å°†å‰©ä¸‹çš„çŸ³å­åˆ†é…ç»™åˆ«çš„å †ä½¿å¾—å±€é¢ä¸ºå¿…è´¥æ€ã€‚\nä»£ç  1using namespace std; 2const int mxn = 1e5 + 5; 3int a[mxn]; 4 5int main() 6{ 7 int n; 8 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 9 { 10 for(int i=0; i\u0026lt;n; i++) 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 12 13 if(n\u0026amp;1){ 14 printf(\u0026#34;1\\n\u0026#34;); 15 continue; 16 } 17 sort(a, a+n); 18 19 int f = 1; 20 for(int i=0; i\u0026lt;n; i+=2){ 21 if(a[i+1] != a[i]){ 22 printf(\u0026#34;1\\n\u0026#34;); 23 f = 0; 24 break; 25 } 26 } 27 if(f) 28 printf(\u0026#34;0\\n\u0026#34;); 29 } 30 return 0; 31} ","permalink":"https://blog.lordash.de/posts/solution/poj-1740-a-new-stone-game/","summary":"A New Stone Game(POJ-1740) é¢˜é¢ Alice and Bob decide to play a new stone game.At the beginning of the game they pick n(1\u0026lt;=n\u0026lt;=10) piles of stones in a line. Alice and Bob move the stones in turn. At each step of the game,the player choose a pile,remove at least one stones,then freely move stones from this pile to any other pile that still has stones. For example:n=4 and the","title":"POJ-1740 A New Stone Game"},{"content":"Georgia and Bob(POJ-1704) é¢˜é¢ Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, \u0026hellip;, and place N chessmen on different grids, as shown in the following figure for example: Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the left without going over any other chessmen or across the left edge. The player can freely choose number of steps the chessman moves, with the constraint that the chessman must be moved at least ONE step and one grid can at most contains ONE single chessman. The player who cannot make a move loses the game.\nGeorgia always plays first since \u0026ldquo;Lady first\u0026rdquo;. Suppose that Georgia and Bob both do their best in the game, i.e., if one of them knows a way to win the game, he or she will be able to carry it out.\nGiven the initial positions of the n chessmen, can you predict who will finally win the game?\nè¾“å…¥ The first line of the input contains a single integer T (1 \u0026lt;= T \u0026lt;= 20), the number of test cases. Then T cases follow. Each test case contains two lines. The first line consists of one integer N (1 \u0026lt;= N \u0026lt;= 1000), indicating the number of chessmen. The second line contains N different integers P1, P2 \u0026hellip; Pn (1 \u0026lt;= Pi \u0026lt;= 10000), which are the initial positions of the n chessmen.\nè¾“å‡º For each test case, prints a single line, \u0026ldquo;Georgia will win\u0026rdquo;, if Georgia will win the game; \u0026ldquo;Bob will win\u0026rdquo;, if Bob will win the game; otherwise \u0026lsquo;Not sure\u0026rsquo;.\næ ·ä¾‹è¾“å…¥ 12 23 31 2 3 48 51 5 6 7 9 12 14 17 æ ·ä¾‹è¾“å‡º 1Bob will win 2Georgia will win æç¤º æ— \næ€è·¯ å½“æ£‹å­ä¸¤ä¸¤ä¸€ç»„ä½äºåŒä¸€æ ¼æ—¶ï¼Œåæ‰‹å¯ä»¥æ¨¡ä»¿å…ˆæ‰‹æ“ä½œè·å¾—èƒœåˆ©ï¼Œæ­¤æ—¶ä¸ºå¿…è´¥æ€ã€‚äºæ˜¯å¯ä»¥å°†æ£‹å­åˆ’åˆ†ä¸ºä¸¤ä¸¤ä¸€ç»„ï¼ˆnä¸ºå¥‡æ•°æ—¶å¯ä»¥åŠ ä¸Šä¸€ä¸ªä½ç½®ä¸º0çš„æ£‹å­ï¼‰ï¼Œæ¯ç»„å†…çš„è·ç¦»å½“ä½œçŸ³å­æ•°åšä¸€ä¸ªNimåšå¼ˆã€‚å…ˆæ‰‹æ˜¯æœ€åç§»åŠ¨å®Œæ£‹å­ä½¿å¾—å±€é¢ä¸ºå¿…è´¥æ€çš„ï¼Œå’Œæœ€åç»“æœä¸€æ ·ã€‚\nä»£ç  1using namespace std; 2const int mxn = 1e5 + 5; 3int a[mxn]; 4 5int main() 6{ 7 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 8 while(T--) 9 { 10 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 11 for(int i=0; i\u0026lt;n; i++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 13 14 if(n\u0026amp;1){ 15 a[n++] = 0; 16 } 17 sort(a, a+n); 18 19 int nim=0; 20 for(int i=0; i\u0026lt;n; i+=2){ 21 nim ^= a[i+1]-a[i]-1; 22 } 23 if(nim){ 24 printf(\u0026#34;Georgia will win\\n\u0026#34;); 25 }else{ 26 printf(\u0026#34;Bob will win\\n\u0026#34;); 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/poj-1704-georgia-and-bob/","summary":"Georgia and Bob(POJ-1704) é¢˜é¢ Georgia and Bob decide to play a self-invented game. They draw a row of grids on paper, number the grids from left to right by 1, 2, 3, \u0026hellip;, and place N chessmen on different grids, as shown in the following figure for example: Georgia and Bob move the chessmen in turn. Every time a player will choose a chessman, and move it to the","title":"POJ-1704 Georgia and Bob"},{"content":"Brave Game(HDU-1846) é¢˜é¢ åå¹´å‰è¯»å¤§å­¦çš„æ—¶å€™ï¼Œä¸­å›½æ¯å¹´éƒ½è¦ä»å›½å¤–å¼•è¿›ä¸€äº›ç”µå½±å¤§ç‰‡ï¼Œå…¶ä¸­æœ‰ä¸€éƒ¨ç”µå½±å°±å«ã€Šå‹‡æ•¢è€…çš„æ¸¸æˆã€‹ï¼ˆè‹±æ–‡åç§°ï¼šZathuraï¼‰ï¼Œä¸€ç›´åˆ°ç°åœ¨ï¼Œæˆ‘ä¾ç„¶å¯¹äºç”µå½±ä¸­çš„éƒ¨åˆ†ç”µè„‘ç‰¹æŠ€å°è±¡æ·±åˆ»ã€‚ ä»Šå¤©ï¼Œå¤§å®¶é€‰æ‹©ä¸Šæœºè€ƒè¯•ï¼Œå°±æ˜¯ä¸€ç§å‹‡æ•¢ï¼ˆbraveï¼‰çš„é€‰æ‹©ï¼›è¿™ä¸ªçŸ­å­¦æœŸï¼Œæˆ‘ä»¬è®²çš„æ˜¯åšå¼ˆï¼ˆgameï¼‰ä¸“é¢˜ï¼›æ‰€ä»¥ï¼Œå¤§å®¶ç°åœ¨ç©çš„ä¹Ÿæ˜¯â€œå‹‡æ•¢è€…çš„æ¸¸æˆâ€ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘å‘½åè¿™ä¸ªé¢˜ç›®çš„åŸå› ã€‚ å½“ç„¶ï¼Œé™¤äº†â€œå‹‡æ•¢â€ï¼Œæˆ‘è¿˜å¸Œæœ›çœ‹åˆ°â€œè¯šä¿¡â€ï¼Œæ— è®ºè€ƒè¯•æˆç»©å¦‚ä½•ï¼Œå¸Œæœ›çœ‹åˆ°çš„éƒ½æ˜¯ä¸€ä¸ªçœŸå®çš„ç»“æœï¼Œæˆ‘ä¹Ÿç›¸ä¿¡å¤§å®¶ä¸€å®šèƒ½åšåˆ°çš„~\nå„ä½å‹‡æ•¢è€…è¦ç©çš„ç¬¬ä¸€ä¸ªæ¸¸æˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå¾ˆç®€å•ï¼Œå®ƒæ˜¯è¿™æ ·å®šä¹‰çš„ï¼š 1ã€ æœ¬æ¸¸æˆæ˜¯ä¸€ä¸ªäºŒäººæ¸¸æˆ; 2ã€ æœ‰ä¸€å †çŸ³å­ä¸€å…±æœ‰nä¸ªï¼› 3ã€ ä¸¤äººè½®æµè¿›è¡Œ; 4ã€ æ¯èµ°ä¸€æ­¥å¯ä»¥å–èµ°1â€¦mä¸ªçŸ³å­ï¼› 5ã€ æœ€å…ˆå–å…‰çŸ³å­çš„ä¸€æ–¹ä¸ºèƒœï¼›\nå¦‚æœæ¸¸æˆçš„åŒæ–¹ä½¿ç”¨çš„éƒ½æ˜¯æœ€ä¼˜ç­–ç•¥ï¼Œè¯·è¾“å‡ºå“ªä¸ªäººèƒ½èµ¢ã€‚\nè¾“å…¥ è¾“å…¥æ•°æ®é¦–å…ˆåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°C(C\u0026lt;=100)ï¼Œè¡¨ç¤ºæœ‰Cç»„æµ‹è¯•æ•°æ®ã€‚ æ¯ç»„æµ‹è¯•æ•°æ®å ä¸€è¡Œï¼ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°nå’Œmï¼ˆ1\u0026lt;=n,m\u0026lt;=1000ï¼‰ï¼Œnå’Œmçš„å«ä¹‰è§é¢˜ç›®æè¿°ã€‚\nè¾“å‡º å¦‚æœå…ˆèµ°çš„äººèƒ½èµ¢ï¼Œè¯·è¾“å‡ºâ€œfirstâ€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œsecondâ€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 12 223 2 34 3 æ ·ä¾‹è¾“å‡º 1first 2second æç¤º æ— \næ€è·¯ Bashåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 6 while(T--) 7 { 8 int n, m; 9 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 10 11 if(n%(m+1)==0){ 12 printf(\u0026#34;second\\n\u0026#34;); 13 }else{ 14 printf(\u0026#34;first\\n\u0026#34;); 15 } 16 } 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1846-brave-game/","summary":"Brave Game(HDU-1846) é¢˜é¢ åå¹´å‰è¯»å¤§å­¦çš„æ—¶å€™ï¼Œä¸­å›½æ¯å¹´éƒ½è¦ä»å›½å¤–å¼•è¿›ä¸€äº›ç”µå½±å¤§ç‰‡ï¼Œå…¶ä¸­æœ‰ä¸€éƒ¨ç”µå½±å°±å«ã€Šå‹‡æ•¢è€…çš„æ¸¸æˆã€‹ï¼ˆè‹±æ–‡åç§°ï¼šZathuraï¼‰ï¼Œä¸€ç›´åˆ°ç°åœ¨ï¼Œ","title":"HDU-1846 Brave Game"},{"content":"Good Luck in CET-4 Everybody!(HDU-1847) é¢˜é¢ å¤§å­¦è‹±è¯­å››çº§è€ƒè¯•å°±è¦æ¥ä¸´äº†ï¼Œä½ æ˜¯ä¸æ˜¯åœ¨ç´§å¼ çš„å¤ä¹ ï¼Ÿä¹Ÿè®¸ç´§å¼ å¾—è¿çŸ­å­¦æœŸçš„ACMéƒ½æ²¡å·¥å¤«ç»ƒä¹ äº†ï¼Œåæ­£æˆ‘çŸ¥é“çš„Kikiå’ŒCiciéƒ½æ˜¯å¦‚æ­¤ã€‚å½“ç„¶ï¼Œä½œä¸ºåœ¨è€ƒåœºæµ¸æ¶¦äº†åå‡ è½½çš„å½“ä»£å¤§å­¦ç”Ÿï¼ŒKikiå’ŒCiciæ›´æ‡‚å¾—è€ƒå‰çš„æ”¾æ¾ï¼Œæ‰€è°“â€œå¼ å¼›æœ‰é“â€å°±æ˜¯è¿™ä¸ªæ„æ€ã€‚è¿™ä¸ï¼ŒKikiå’ŒCiciåœ¨æ¯å¤©æ™šä¸Šä¼‘æ¯ä¹‹å‰éƒ½è¦ç©ä¸€ä¼šå„¿æ‰‘å…‹ç‰Œä»¥æ”¾æ¾ç¥ç»ã€‚ â€œå‡çº§â€ï¼Ÿâ€œåŒæ‰£â€ï¼Ÿâ€œçº¢äº”â€ï¼Ÿè¿˜æ˜¯â€œæ–—åœ°ä¸»â€ï¼Ÿ å½“ç„¶éƒ½ä¸æ˜¯ï¼é‚£å¤šä¿—å•Š~ ä½œä¸ºè®¡ç®—æœºå­¦é™¢çš„å­¦ç”Ÿï¼ŒKikiå’ŒCiciæ‰“ç‰Œçš„æ—¶å€™å¯æ²¡å¿˜è®°ä¸“ä¸šï¼Œå¥¹ä»¬æ‰“ç‰Œçš„è§„åˆ™æ˜¯è¿™æ ·çš„ï¼š 1ã€ æ€»å…±nå¼ ç‰Œ; 2ã€ åŒæ–¹è½®æµæŠ“ç‰Œï¼› 3ã€ æ¯äººæ¯æ¬¡æŠ“ç‰Œçš„ä¸ªæ•°åªèƒ½æ˜¯2çš„å¹‚æ¬¡ï¼ˆå³ï¼š1ï¼Œ2ï¼Œ4ï¼Œ8ï¼Œ16â€¦ï¼‰ 4ã€ æŠ“å®Œç‰Œï¼Œèƒœè´Ÿç»“æœä¹Ÿå‡ºæ¥äº†ï¼šæœ€åæŠ“å®Œç‰Œçš„äººä¸ºèƒœè€…ï¼› å‡è®¾Kikiå’ŒCiciéƒ½æ˜¯è¶³å¤Ÿèªæ˜ï¼ˆå…¶å®ä¸ç”¨å‡è®¾ï¼Œå“ªæœ‰ä¸èªæ˜çš„å­¦ç”Ÿ~ï¼‰ï¼Œå¹¶ä¸”æ¯æ¬¡éƒ½æ˜¯Kikiå…ˆæŠ“ç‰Œï¼Œè¯·é—®è°èƒ½èµ¢å‘¢ï¼Ÿ å½“ç„¶ï¼Œæ‰“ç‰Œæ— è®ºè°èµ¢éƒ½é—®é¢˜ä¸å¤§ï¼Œé‡è¦çš„æ˜¯é©¬ä¸Šåˆ°æ¥çš„CET-4èƒ½æœ‰å¥½çš„çŠ¶æ€ã€‚\nGood luck in CET-4 everybody!\nè¾“å…¥ è¾“å…¥æ•°æ®åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å ä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªæ•´æ•°nï¼ˆ1\u0026lt;=n\u0026lt;=1000ï¼‰ã€‚\nè¾“å‡º å¦‚æœKikièƒ½èµ¢çš„è¯ï¼Œè¯·è¾“å‡ºâ€œKikiâ€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œCiciâ€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 11 23 æ ·ä¾‹è¾“å‡º 1Kiki 2Cici æç¤º æ— \næ€è·¯ æ‰“è¡¨ï¼Œnä¸º3çš„å€æ•°æ—¶ï¼Œå…ˆæ‰‹å¿…è´¥\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n; 6 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 7 { 8 if(n%3==0){ 9 printf(\u0026#34;Cici\\n\u0026#34;); 10 }else{ 11 printf(\u0026#34;Kiki\\n\u0026#34;); 12 } 13 } 14 return 0; 15} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1847-good-luck-in-cet-4-everybody/","summary":"Good Luck in CET-4 Everybody!(HDU-1847) é¢˜é¢ å¤§å­¦è‹±è¯­å››çº§è€ƒè¯•å°±è¦æ¥ä¸´äº†ï¼Œä½ æ˜¯ä¸æ˜¯åœ¨ç´§å¼ çš„å¤ä¹ ï¼Ÿä¹Ÿè®¸ç´§å¼ å¾—è¿çŸ­å­¦æœŸçš„ACMéƒ½æ²¡å·¥å¤«ç»ƒä¹ äº†ï¼Œåæ­£æˆ‘çŸ¥é“çš„Kikiå’ŒCiciéƒ½æ˜¯","title":"HDU-1847 Good Luck in CET-4 Everybody!"},{"content":"Rabbit and Grass(HDU-1849) é¢˜é¢ å¤§å­¦æ—¶å…‰æ˜¯æµªæ¼«çš„ï¼Œå¥³ç”Ÿæ˜¯æµªæ¼«çš„ï¼Œåœ£è¯æ›´æ˜¯æµªæ¼«çš„ï¼Œä½†æ˜¯Rabbitå’ŒGrassè¿™ä¸¤ä¸ªå¤§å­¦å¥³ç”Ÿåœ¨ä»Šå¹´çš„åœ£è¯èŠ‚å´è¡¨ç°å¾—ä¸€ç‚¹éƒ½ä¸æµªæ¼«ï¼šä¸å»é€›å•†åœºï¼Œä¸å»é€›å…¬å›­ï¼Œä¸å»å’ŒACç”·çº¦ä¼šï¼Œä¸¤ä¸ªäººç«Ÿç„¶çŒ«åœ¨å¯é£Ÿä¸‹æ£‹â€¦â€¦ è¯´æ˜¯ä¸‹æ£‹ï¼Œå…¶å®åªæ˜¯ä¸€ä¸ªç®€å•çš„å°æ¸¸æˆè€Œå·²ï¼Œæ¸¸æˆçš„è§„åˆ™æ˜¯è¿™æ ·çš„ï¼š 1ã€æ£‹ç›˜åŒ…å«1*nä¸ªæ–¹æ ¼ï¼Œæ–¹æ ¼ä»å·¦åˆ°å³åˆ†åˆ«ç¼–å·ä¸º0ï¼Œ1ï¼Œ2ï¼Œâ€¦ï¼Œn-1ï¼› 2ã€mä¸ªæ£‹å­æ”¾åœ¨æ£‹ç›˜çš„æ–¹æ ¼ä¸Šï¼Œæ–¹æ ¼å¯ä»¥ä¸ºç©ºï¼Œä¹Ÿå¯ä»¥æ”¾å¤šäºä¸€ä¸ªçš„æ£‹å­ï¼› 3ã€åŒæ–¹è½®æµèµ°æ£‹ï¼› 4ã€æ¯ä¸€æ­¥å¯ä»¥é€‰æ‹©ä»»æ„ä¸€ä¸ªæ£‹å­å‘å·¦ç§»åŠ¨åˆ°ä»»æ„çš„ä½ç½®ï¼ˆå¯ä»¥å¤šä¸ªæ£‹å­ä½äºåŒä¸€ä¸ªæ–¹æ ¼ï¼‰ï¼Œå½“ç„¶ï¼Œä»»ä½•æ£‹å­ä¸èƒ½è¶…å‡ºæ£‹ç›˜è¾¹ç•Œï¼› 5ã€å¦‚æœæ‰€æœ‰çš„æ£‹å­éƒ½ä½äºæœ€å·¦è¾¹ï¼ˆå³ç¼–å·ä¸º0çš„ä½ç½®ï¼‰ï¼Œåˆ™æ¸¸æˆç»“æŸï¼Œå¹¶ä¸”è§„å®šæœ€åèµ°æ£‹çš„ä¸€æ–¹ä¸ºèƒœè€…ã€‚\nå¯¹äºæœ¬é¢˜ï¼Œä½ ä¸éœ€è¦è€ƒè™‘nçš„å¤§å°ï¼ˆæˆ‘ä»¬å¯ä»¥å‡è®¾åœ¨åˆå§‹çŠ¶æ€ï¼Œæ£‹å­æ€»æ˜¯ä½äºæ£‹ç›˜çš„é€‚å½“ä½ç½®ï¼‰ã€‚ä¸‹é¢çš„ç¤ºæ„å›¾å³ä¸ºä¸€ä¸ª1*15çš„æ£‹ç›˜ï¼Œå…±æœ‰6ä¸ªæ£‹å­ï¼Œå…¶ä¸­ï¼Œç¼–å·8çš„ä½ç½®æœ‰ä¸¤ä¸ªæ£‹å­ã€‚\nå¤§å®¶çŸ¥é“ï¼Œè™½ç„¶å¶å°”ä¸å¤Ÿæµªæ¼«ï¼Œä½†æ˜¯Rabbitå’ŒGrasséƒ½æ˜¯å†°é›ªèªæ˜çš„å¥³ç”Ÿï¼Œå¦‚æœæ¯æ¬¡éƒ½æ˜¯Rabbitå…ˆèµ°æ£‹ï¼Œè¯·è¾“å‡ºæœ€åçš„ç»“æœã€‚\nè¾“å…¥ è¾“å…¥æ•°æ®åŒ…å«å¤šç»„æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å äºŒè¡Œï¼Œé¦–å…ˆä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°mï¼ˆ0\u0026lt;=m\u0026lt;=1000ï¼‰ï¼Œè¡¨ç¤ºæœ¬æµ‹è¯•ç”¨ä¾‹çš„æ£‹å­æ•°ç›®ï¼Œç´§è·Ÿç€çš„ä¸€è¡ŒåŒ…å«mä¸ªæ•´æ•°Ki(i=1â€¦m; 0\u0026lt;=Ki\u0026lt;=1000)ï¼Œåˆ†åˆ«è¡¨ç¤ºmä¸ªæ£‹å­åˆå§‹çš„ä½ç½®ï¼Œm=0åˆ™ç»“æŸè¾“å…¥ã€‚\nè¾“å‡º å¦‚æœRabbitèƒ½èµ¢çš„è¯ï¼Œè¯·è¾“å‡ºâ€œRabbit Win!â€ï¼Œå¦åˆ™è¯·è¾“å‡ºâ€œGrass Win!â€ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 12 23 5 33 43 5 6 50 æ ·ä¾‹è¾“å‡º 1Rabbit Win! 2Grass Win! æç¤º æ— \næ€è·¯ Nimåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n; 6 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 7 { 8 int nim = 0; 9 for(int i=0; i\u0026lt;n; i++){ 10 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 11 nim ^= x; 12 } 13 if(nim){ 14 printf(\u0026#34;Rabbit Win!\\n\u0026#34;); 15 }else{ 16 printf(\u0026#34;Grass Win!\\n\u0026#34;); 17 } 18 } 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1849-rabbit-and-grass/","summary":"Rabbit and Grass(HDU-1849) é¢˜é¢ å¤§å­¦æ—¶å…‰æ˜¯æµªæ¼«çš„ï¼Œå¥³ç”Ÿæ˜¯æµªæ¼«çš„ï¼Œåœ£è¯æ›´æ˜¯æµªæ¼«çš„ï¼Œä½†æ˜¯Rabbitå’ŒGrassè¿™ä¸¤ä¸ªå¤§å­¦å¥³ç”Ÿåœ¨ä»Šå¹´çš„åœ£è¯èŠ‚å´è¡¨ç°å¾—ä¸€ç‚¹éƒ½ä¸æµªæ¼«ï¼šä¸å»","title":"HDU-1849 Rabbit and Grass"},{"content":"Being a Good Boy in Spring Festival(HDU-1805) é¢˜é¢ ä¸€å¹´åœ¨å¤– çˆ¶æ¯æ—¶åˆ»ç‰µæŒ‚ æ˜¥èŠ‚å›å®¶ ä½ èƒ½åšå‡ å¤©å¥½å­©å­å— å¯’å‡é‡Œå°è¯•åšåšä¸‹é¢çš„äº‹æƒ…å§\né™ªå¦ˆå¦ˆé€›ä¸€æ¬¡èœåœº æ‚„æ‚„ç»™çˆ¸çˆ¸ä¹°ä¸ªå°ç¤¼ç‰© ä¸»åŠ¨åœ° å¼ºçƒˆåœ° è¦æ±‚æ´—ä¸€æ¬¡ç¢— æŸä¸€å¤©æ—©èµ· ç»™çˆ¸å¦ˆç”¨å¿ƒåœ°åšå›æ—©é¤\nå¦‚æœæ„¿æ„ ä½ è¿˜å¯ä»¥å’Œçˆ¸å¦ˆè¯´ å’±ä»¬ç©ä¸ªå°æ¸¸æˆå§ ACMè¯¾ä¸Šå­¦çš„å‘¢ï½\nä¸‹é¢æ˜¯ä¸€ä¸ªäºŒäººå°æ¸¸æˆï¼šæ¡Œå­ä¸Šæœ‰Må †æ‰‘å…‹ç‰Œï¼›æ¯å †ç‰Œçš„æ•°é‡åˆ†åˆ«ä¸ºNi(i=1â€¦M)ï¼›ä¸¤äººè½®æµè¿›è¡Œï¼›æ¯èµ°ä¸€æ­¥å¯ä»¥ä»»æ„é€‰æ‹©ä¸€å †å¹¶å–èµ°å…¶ä¸­çš„ä»»æ„å¼ ç‰Œï¼›æ¡Œå­ä¸Šçš„æ‰‘å…‹å…¨éƒ¨å–å…‰ï¼Œåˆ™æ¸¸æˆç»“æŸï¼›æœ€åä¸€æ¬¡å–ç‰Œçš„äººä¸ºèƒœè€…ã€‚ ç°åœ¨æˆ‘ä»¬ä¸æƒ³ç ”ç©¶åˆ°åº•å…ˆæ‰‹ä¸ºèƒœè¿˜æ˜¯ä¸ºè´Ÿï¼Œæˆ‘åªæƒ³é—®å¤§å®¶ï¼š â€”â€”â€œå…ˆæ‰‹çš„äººå¦‚æœæƒ³èµ¢ï¼Œç¬¬ä¸€æ­¥æœ‰å‡ ç§é€‰æ‹©å‘¢ï¼Ÿâ€\nè¾“å…¥ è¾“å…¥æ•°æ®åŒ…å«å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å 2è¡Œï¼Œé¦–å…ˆä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°M(1\u0026lt;M\u0026lt;=100)ï¼Œè¡¨ç¤ºæ‰‘å…‹ç‰Œçš„å †æ•°ï¼Œç´§æ¥ç€ä¸€è¡ŒåŒ…å«Mä¸ªæ•´æ•°Ni(1\u0026lt;=Ni\u0026lt;=1000000ï¼Œi=1â€¦M)ï¼Œåˆ†åˆ«è¡¨ç¤ºMå †æ‰‘å…‹çš„æ•°é‡ã€‚Mä¸º0åˆ™è¡¨ç¤ºè¾“å…¥æ•°æ®çš„ç»“æŸã€‚\nè¾“å‡º å¦‚æœå…ˆæ‰‹çš„äººèƒ½èµ¢ï¼Œè¯·è¾“å‡ºä»–ç¬¬ä¸€æ­¥å¯è¡Œçš„æ–¹æ¡ˆæ•°ï¼Œå¦åˆ™è¯·è¾“å‡º0ï¼Œæ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 13 25 7 9 30 æ ·ä¾‹è¾“å‡º 11 æç¤º æ— \næ€è·¯ Nimåšå¼ˆ\nä»£ç  1using namespace std; 2const int mxn = 1e6 + 5; 3int a[mxn]; 4 5int main() 6{ 7 int n; 8 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 9 { 10 int nim = 0; 11 for(int i=0; i\u0026lt;n; i++){ 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 13 nim ^= a[i]; 14 } 15 int ans = 0; 16 if(nim){ 17 for(int i=0; i\u0026lt;n; i++) 18 if(a[i] \u0026gt; (a[i]^nim)) 19 ans++; 20 } 21 printf(\u0026#34;%d\\n\u0026#34;, ans); 22 } 23 return 0; 24} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1805-being-a-good-boy-in-spring-festival/","summary":"Being a Good Boy in Spring Festival(HDU-1805) é¢˜é¢ ä¸€å¹´åœ¨å¤– çˆ¶æ¯æ—¶åˆ»ç‰µæŒ‚ æ˜¥èŠ‚å›å®¶ ä½ èƒ½åšå‡ å¤©å¥½å­©å­å— å¯’å‡é‡Œå°è¯•åšåšä¸‹é¢çš„äº‹æƒ…å§ é™ªå¦ˆå¦ˆé€›ä¸€æ¬¡èœåœº æ‚„æ‚„ç»™çˆ¸çˆ¸ä¹°ä¸ªå°ç¤¼ç‰© ä¸»åŠ¨åœ° å¼ºçƒˆåœ° è¦","title":"HDU-1805 Being a Good Boy in Spring Festival"},{"content":"kiki\u0026rsquo;s game(HDU-2147) é¢˜é¢ Recently kiki has nothing to do. While she is bored, an idea appears in his mind, she just playes the checkerboard game.The size of the chesserboard is n*m.First of all, a coin is placed in the top right corner(1,m). Each time one people can move the coin into the left, the underneath or the left-underneath blank space.The person who can\u0026rsquo;t make a move will lose the game. kiki plays it with ZZ.The game always starts with kiki. If both play perfectly, who will win the game?\nè¾“å…¥ Input contains multiple test cases. Each line contains two integer n, m (0\u0026lt;n,m\u0026lt;=2000). The input is terminated when n=0 and m=0.\nè¾“å‡º If kiki wins the game printf \u0026ldquo;Wonderful!\u0026rdquo;, else \u0026ldquo;What a pity!\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 15 3 25 4 36 6 40 0 æ ·ä¾‹è¾“å‡º 1What a pity! 2Wonderful! 3Wonderful! æç¤º æ— \næ€è·¯ å¦‚æœè¡Œåˆ—éƒ½ä¸ºå¥‡æ•°æ—¶ï¼Œå…ˆæ‰‹å¿…è´¥\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n, m; 6 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m) \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) 7 { 8 if((n\u0026amp;1) \u0026amp;\u0026amp; (m\u0026amp;1)){ 9 printf(\u0026#34;What a pity!\\n\u0026#34;); 10 }else{ 11 printf(\u0026#34;Wonderful!\\n\u0026#34;); 12 } 13 } 14 return 0; 15} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2147-kikis-game/","summary":"kiki\u0026rsquo;s game(HDU-2147) é¢˜é¢ Recently kiki has nothing to do. While she is bored, an idea appears in his mind, she just playes the checkerboard game.The size of the chesserboard is n*m.First of all, a coin is placed in the top right corner(1,m). Each time one people can move the coin into the left, the underneath or the left-underneath blank space.The person who can\u0026rsquo;t make a move will lose the","title":"HDU-2147 kiki's game"},{"content":"Public Sale(HDU-2149) é¢˜é¢ è™½ç„¶ä¸æƒ³ï¼Œä½†æ˜¯ç°å®æ€»å½’æ˜¯ç°å®ï¼ŒLeleå§‹ç»ˆæ²¡æœ‰é€ƒè¿‡é€€å­¦çš„å‘½è¿ï¼Œå› ä¸ºä»–æ²¡æœ‰æ‹¿åˆ°å¥–å­¦é‡‘ã€‚ç°åœ¨ç­‰å¾…ä»–çš„ï¼Œå°±æ˜¯åƒFarmJohnä¸€æ ·çš„å†œç”°ç”Ÿæ¶¯ã€‚\nè¦ç§ç”°å¾—æœ‰ç”°æ‰è¡Œï¼ŒLeleå¬è¯´è¡—ä¸Šæ­£åœ¨ä¸¾è¡Œä¸€åœºåˆ«å¼€ç”Ÿé¢çš„æ‹å–ä¼šï¼Œæ‹å–çš„ç‰©å“æ­£å¥½å°±æ˜¯ä¸€å—20äº©çš„ç”°åœ°ã€‚äºæ˜¯ï¼ŒLeleå¸¦ä¸Šä»–çš„å…¨éƒ¨ç§¯è“„ï¼Œå†²å¾€æ‹å–ä¼šã€‚\nåæ¥å‘ç°ï¼Œæ•´ä¸ªæ‹å–ä¼šåªæœ‰Leleå’Œä»–çš„æ­»å¯¹å¤´Yueyueã€‚\né€šè¿‡æ‰“å¬ï¼ŒLeleçŸ¥é“è¿™åœºæ‹å–çš„è§„åˆ™æ˜¯è¿™æ ·çš„ï¼šåˆšå¼€å§‹åº•ä»·ä¸º0ï¼Œä¸¤ä¸ªäººè½®æµå¼€å§‹åŠ ä»·ï¼Œä¸è¿‡æ¯æ¬¡åŠ ä»·çš„å¹…åº¦è¦åœ¨1ï½Nä¹‹é—´ï¼Œå½“ä»·æ ¼å¤§äºæˆ–ç­‰äºç”°åœ°çš„æˆæœ¬ä»· M æ—¶ï¼Œä¸»åŠæ–¹å°±æŠŠè¿™å—ç”°åœ°å–ç»™è¿™æ¬¡å«ä»·çš„äººã€‚\nLeleå’ŒYueyueè™½ç„¶è€ƒè¯•ä¸è¡Œï¼Œä½†æ˜¯å¯¹æ‹å–å´ååˆ†ç²¾é€šï¼Œè€Œä¸”ä»–ä»¬ä¸¤ä¸ªäººéƒ½ååˆ†æƒ³å¾—åˆ°è¿™å—ç”°åœ°ã€‚æ‰€ä»¥ä»–ä»¬æ¯æ¬¡éƒ½æ˜¯é€‰å¯¹è‡ªå·±æœ€æœ‰åˆ©çš„æ–¹å¼è¿›è¡ŒåŠ ä»·ã€‚\nç”±äºLeleå­—å…¸åºæ¯”Yueyueé å‰ï¼Œæ‰€ä»¥æ¯æ¬¡éƒ½æ˜¯ç”±Leleå…ˆå¼€å§‹åŠ ä»·ï¼Œè¯·é—®ï¼Œç¬¬ä¸€æ¬¡åŠ ä»·çš„æ—¶å€™ï¼Œ Leleè¦å‡ºå¤šå°‘æ‰èƒ½ä¿è¯è‡ªå·±ä¹°å¾—åˆ°è¿™å—åœ°å‘¢ï¼Ÿ\nè¾“å…¥ æœ¬é¢˜ç›®åŒ…å«å¤šç»„æµ‹è¯•ï¼Œè¯·å¤„ç†åˆ°æ–‡ä»¶ç»“æŸ(EOF)ã€‚æ¯ç»„æµ‹è¯•å ä¸€è¡Œã€‚ æ¯ç»„æµ‹è¯•åŒ…å«ä¸¤ä¸ªæ•´æ•°Må’ŒN(å«ä¹‰è§é¢˜ç›®æè¿°ï¼Œ0\u0026lt;Nï¼ŒM\u0026lt;1100)\nè¾“å‡º å¯¹äºæ¯ç»„æ•°æ®ï¼Œåœ¨ä¸€è¡Œé‡ŒæŒ‰é€’å¢çš„é¡ºåºè¾“å‡ºLeleç¬¬ä¸€æ¬¡å¯ä»¥åŠ çš„ä»·ã€‚ä¸¤ä¸ªæ•°æ®ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚ å¦‚æœLeleåœ¨ç¬¬ä¸€æ¬¡æ— è®ºå¦‚ä½•å‡ºä»·éƒ½æ— æ³•ä¹°åˆ°è¿™å—åœŸåœ°ï¼Œå°±è¾“å‡º\u0026quot;none\u0026quot;ã€‚\næ ·ä¾‹è¾“å…¥ 14 2 23 2 33 5 æ ·ä¾‹è¾“å‡º 11 2none 33 4 5 æç¤º æ— \næ€è·¯ Bashåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n, m; 6 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;m, \u0026amp;n)) 7 { 8 if(m%(n+1)==0) { 9 printf(\u0026#34;none\\n\u0026#34;); 10 continue; 11 } 12 printf(\u0026#34;%d\u0026#34;, m%(n+1)); 13 if(m\u0026lt;n) 14 for(int i=m+1; i\u0026lt;=n; i++){ 15 printf(\u0026#34; %d\u0026#34;, i); 16 } 17 printf(\u0026#34;\\n\u0026#34;); 18 } 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2149-public-sale/","summary":"Public Sale(HDU-2149) é¢˜é¢ è™½ç„¶ä¸æƒ³ï¼Œä½†æ˜¯ç°å®æ€»å½’æ˜¯ç°å®ï¼ŒLeleå§‹ç»ˆæ²¡æœ‰é€ƒè¿‡é€€å­¦çš„å‘½è¿ï¼Œå› ä¸ºä»–æ²¡æœ‰æ‹¿åˆ°å¥–å­¦é‡‘ã€‚ç°åœ¨ç­‰å¾…ä»–çš„ï¼Œå°±æ˜¯åƒFarmJohnä¸€æ ·çš„å†œç”°ç”Ÿ","title":"HDU-2149 Public Sale"},{"content":"A multiplication game(POJ-2505) é¢˜é¢ Stan and Ollie play the game of multiplication by multiplying an integer p by one of the numbers 2 to 9. Stan always starts with p = 1, does his multiplication, then Ollie multiplies the number, then Stan and so on. Before a game starts, they draw an integer 1 \u0026lt; n \u0026lt; 4294967295 and the winner is who first reaches p \u0026gt;= n.\nè¾“å…¥ Each line of input contains one integer number n.\nè¾“å‡º For each line of input output one line either Stan wins. or Ollie wins. assuming that both of them play perfectly.\næ ·ä¾‹è¾“å…¥ 1162 217 334012226 æ ·ä¾‹è¾“å‡º 1Stan wins. 2Ollie wins. 3Stan wins. æç¤º æ— \næ€è·¯ æ‰¾å‡ºå…ˆæ‰‹å¿…è´¥åŒºé—´(9, 18]ï¼Œ(162, 324]ï¼Œ$ \\ldots $\nè§„å¾‹ï¼š 9 = 9 18 = 2 * 9 162 = 9 * 2 * 9 324 = 2 * 9 * 2 * 9 $ \\ldots $\nä»£ç  1using namespace std; 2typedef long long LL; 3 4int main() 5{ 6 LL n; 7 while(~scanf(\u0026#34;%lld\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 8 { 9 while(1){ 10 if(n\u0026lt;=9){ 11 printf(\u0026#34;Stan wins.\\n\u0026#34;); 12 break; 13 }else if(n\u0026lt;=18){ 14 printf(\u0026#34;Ollie wins.\\n\u0026#34;); 15 break; 16 } 17 n = (LL)ceil(n/18.0); 18 } 19 } 20 return 0; 21} ","permalink":"https://blog.lordash.de/posts/solution/poj-2505-a-multiplication-game/","summary":"A multiplication game(POJ-2505) é¢˜é¢ Stan and Ollie play the game of multiplication by multiplying an integer p by one of the numbers 2 to 9. Stan always starts with p = 1, does his multiplication, then Ollie multiplies the number, then Stan and so on. Before a game starts, they draw an integer 1 \u0026lt; n \u0026lt; 4294967295 and the winner is who first reaches p \u0026gt;= n. è¾“","title":"POJ-2505 A multiplication game"},{"content":"A Funny Game(POJ-2484) é¢˜é¢ Alice and Bob decide to play a funny game. At the beginning of the game they pick n(1 \u0026lt;= n \u0026lt;= 106) coins in a circle, as Figure 1 shows. A move consists in removing one or two adjacent coins, leaving all other coins untouched. At least one coin must be removed. Players alternate moves with Alice starting. The player that removes the last coin wins. (The last player to move wins. If you can\u0026rsquo;t move, you lose.) Note: For n \u0026gt; 3, we use c1, c2, \u0026hellip;, cn to denote the coins clockwise and if Alice remove c2, then c1 and c3 are NOT adjacent! (Because there is an empty place between c1 and c3.)\nSuppose that both Alice and Bob do their best in the game. You are to write a program to determine who will finally win the game.\nè¾“å…¥ There are several test cases. Each test case has only one line, which contains a positive integer n (1 \u0026lt;= n \u0026lt;= 10^6). There are no blank lines between cases. A line with a single 0 terminates the input.\nè¾“å‡º For each test case, if Alice win the game,output \u0026ldquo;Alice\u0026rdquo;, otherwise output \u0026ldquo;Bob\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 11 22 33 40 æ ·ä¾‹è¾“å‡º 1Alice 2Alice 3Bob æç¤º æ— \næ€è·¯ å½“n \u0026lt; 3æ—¶ï¼Œå…ˆæ‰‹å¯ä»¥ç›´æ¥å–å®Œï¼›n = 3æ—¶ï¼Œæ— è®ºå…ˆæ‰‹å¦‚ä½•å–ï¼Œåæ‰‹éƒ½èƒ½å–èµ°å‰©ä¸‹çš„ï¼›n \u0026gt; 3æ—¶ï¼Œæ— è®ºå…ˆæ‰‹å¦‚ä½•å–ï¼Œåæ‰‹éƒ½èƒ½å–èµ°å¯¹åº”çš„ï¼Œä½¿å¾—å±€é¢å˜ä¸ºç›¸ç­‰çš„ä¸¤éƒ¨åˆ†ï¼Œéšä¹‹åæ‰‹æ¨¡ä»¿å…ˆæ‰‹æ“ä½œå³å¯è·å¾—èƒœåˆ©ã€‚\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n; 6 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) 7 { 8 if(n\u0026lt;3){ 9 printf(\u0026#34;Alice\\n\u0026#34;); 10 }else{ 11 printf(\u0026#34;Bob\\n\u0026#34;); 12 } 13 } 14 return 0; 15} ","permalink":"https://blog.lordash.de/posts/solution/poj-2484-a-funny-game/","summary":"A Funny Game(POJ-2484) é¢˜é¢ Alice and Bob decide to play a funny game. At the beginning of the game they pick n(1 \u0026lt;= n \u0026lt;= 106) coins in a circle, as Figure 1 shows. A move consists in removing one or two adjacent coins, leaving all other coins untouched. At least one coin must be removed. Players alternate moves with Alice starting. The player that removes the last coin","title":"POJ-2484 A Funny Game"},{"content":"Matches Game(POJ-2234) é¢˜é¢ Here is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen pile). If after a playerâ€™s turn, there is no match left, the player is the winner. Suppose that the two players are all very clear. Your job is to tell whether the player who plays first can win the game or not.\nè¾“å…¥ The input consists of several lines, and in each line there is a test case. At the beginning of a line, there is an integer M (1 \u0026lt;= M \u0026lt;=20), which is the number of piles. Then comes M positive integers, which are not larger than 10000000. These M integers represent the number of matches in each pile.\nè¾“å‡º For each test case, output \u0026ldquo;Yes\u0026rdquo; in a single line, if the player who play first will win, otherwise output \u0026ldquo;No\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 12 45 45 23 3 6 9 æ ·ä¾‹è¾“å‡º 1No 2Yes æç¤º æ— \næ€è·¯ Nimåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int n; 6 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) 7 { 8 int nim = 0; 9 for(int i=0; i\u0026lt;n; i++){ 10 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 11 nim ^= x; 12 } 13 if(nim == 0){ 14 printf(\u0026#34;No\\n\u0026#34;); 15 }else{ 16 printf(\u0026#34;Yes\\n\u0026#34;); 17 } 18 } 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/poj-2234-matches-game/","summary":"Matches Game(POJ-2234) é¢˜é¢ Here is a simple game. In this game, there are several piles of matches and two players. The two player play in turn. In each turn, one can choose a pile and take away arbitrary number of matches from the pile (Of course the number of matches, which is taken away, cannot be zero and cannot be larger than the number of matches in the chosen","title":"POJ-2234 Matches Game"},{"content":"å–çŸ³å­æ¸¸æˆ(HDU-1527) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯ä»¥åœ¨ä»»æ„çš„ä¸€å †ä¸­å–èµ°ä»»æ„å¤šçš„çŸ³å­ï¼›äºŒæ˜¯å¯ä»¥åœ¨ä¸¤å †ä¸­åŒæ—¶å–èµ°ç›¸åŒæ•°é‡çš„çŸ³å­ã€‚æœ€åæŠŠçŸ³å­å…¨éƒ¨å–å®Œè€…ä¸ºèƒœè€…ã€‚ç°åœ¨ç»™å‡ºåˆå§‹çš„ä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œå¦‚æœè½®åˆ°ä½ å…ˆå–ï¼Œå‡è®¾åŒæ–¹éƒ½é‡‡å–æœ€å¥½çš„ç­–ç•¥ï¼Œé—®æœ€åä½ æ˜¯èƒœè€…è¿˜æ˜¯è´¥è€…ã€‚\nè¾“å…¥ è¾“å…¥åŒ…å«è‹¥å¹²è¡Œï¼Œè¡¨ç¤ºè‹¥å¹²ç§çŸ³å­çš„åˆå§‹æƒ…å†µï¼Œå…¶ä¸­æ¯ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªéè´Ÿæ•´æ•°aå’Œbï¼Œè¡¨ç¤ºä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œaå’Œbéƒ½ä¸å¤§äº1,000,000,000ã€‚\nè¾“å‡º è¾“å‡ºå¯¹åº”ä¹Ÿæœ‰è‹¥å¹²è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ•°å­—1æˆ–0ï¼Œå¦‚æœæœ€åä½ æ˜¯èƒœè€…ï¼Œåˆ™ä¸º1ï¼Œåä¹‹ï¼Œåˆ™ä¸º0ã€‚\næ ·ä¾‹è¾“å…¥ 12 1 28 4 34 7 æ ·ä¾‹è¾“å‡º 10 21 30 æç¤º æ— \næ€è·¯ Wythoffåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int a, b; 6 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b)) 7 { 8 if(a \u0026gt; b) swap(a, b); 9 if(a == (int)((sqrt(5)+1)/2 * (b-a))){ 10 printf(\u0026#34;0\\n\u0026#34;); 11 }else{ 12 printf(\u0026#34;1\\n\u0026#34;); 13 } 14 } 15 return 0; 16} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1527-%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","summary":"å–çŸ³å­æ¸¸æˆ(HDU-1527) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯ä»¥åœ¨ä»»æ„","title":"HDU-1527 å–çŸ³å­æ¸¸æˆ"},{"content":"å–çŸ³å­æ¸¸æˆ(POJ-1067) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯ä»¥åœ¨ä»»æ„çš„ä¸€å †ä¸­å–èµ°ä»»æ„å¤šçš„çŸ³å­ï¼›äºŒæ˜¯å¯ä»¥åœ¨ä¸¤å †ä¸­åŒæ—¶å–èµ°ç›¸åŒæ•°é‡çš„çŸ³å­ã€‚æœ€åæŠŠçŸ³å­å…¨éƒ¨å–å®Œè€…ä¸ºèƒœè€…ã€‚ç°åœ¨ç»™å‡ºåˆå§‹çš„ä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œå¦‚æœè½®åˆ°ä½ å…ˆå–ï¼Œå‡è®¾åŒæ–¹éƒ½é‡‡å–æœ€å¥½çš„ç­–ç•¥ï¼Œé—®æœ€åä½ æ˜¯èƒœè€…è¿˜æ˜¯è´¥è€…ã€‚\nè¾“å…¥ è¾“å…¥åŒ…å«è‹¥å¹²è¡Œï¼Œè¡¨ç¤ºè‹¥å¹²ç§çŸ³å­çš„åˆå§‹æƒ…å†µï¼Œå…¶ä¸­æ¯ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªéè´Ÿæ•´æ•°aå’Œbï¼Œè¡¨ç¤ºä¸¤å †çŸ³å­çš„æ•°ç›®ï¼Œaå’Œbéƒ½ä¸å¤§äº1,000,000,000ã€‚\nè¾“å‡º è¾“å‡ºå¯¹åº”ä¹Ÿæœ‰è‹¥å¹²è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ•°å­—1æˆ–0ï¼Œå¦‚æœæœ€åä½ æ˜¯èƒœè€…ï¼Œåˆ™ä¸º1ï¼Œåä¹‹ï¼Œåˆ™ä¸º0ã€‚\næ ·ä¾‹è¾“å…¥ 12 1 28 4 34 7 æ ·ä¾‹è¾“å‡º 10 21 30 æç¤º æ— \næ€è·¯ Wythoffåšå¼ˆ\nä»£ç  1using namespace std; 2 3int main() 4{ 5 int a, b; 6 while(~scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b)) 7 { 8 if(a \u0026gt; b) swap(a, b); 9 if(a == (int)((sqrt(5)+1)/2 * (b-a))){ 10 printf(\u0026#34;0\\n\u0026#34;); 11 }else{ 12 printf(\u0026#34;1\\n\u0026#34;); 13 } 14 } 15 return 0; 16} ","permalink":"https://blog.lordash.de/posts/solution/poj-1067-%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/","summary":"å–çŸ³å­æ¸¸æˆ(POJ-1067) é¢˜é¢ æœ‰ä¸¤å †çŸ³å­ï¼Œæ•°é‡ä»»æ„ï¼Œå¯ä»¥ä¸åŒã€‚æ¸¸æˆå¼€å§‹ç”±ä¸¤ä¸ªäººè½®æµå–çŸ³å­ã€‚æ¸¸æˆè§„å®šï¼Œæ¯æ¬¡æœ‰ä¸¤ç§ä¸åŒçš„å–æ³•ï¼Œä¸€æ˜¯å¯ä»¥åœ¨ä»»æ„","title":"POJ-1067 å–çŸ³å­æ¸¸æˆ"},{"content":"Fibonacciåšå¼ˆ åŸºæœ¬çš„æ–æ³¢é‚£å¥‘åšå¼ˆï¼ˆFibonacci Gameï¼‰æè¿°å¦‚ä¸‹ï¼š\næœ‰ä¸€å †æ•°é‡å¤šäºä¸€çš„ç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œç¬¬ä¸€æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œä½†ä¸èƒ½å–å®Œï¼Œä»ç¬¬äºŒæ¬¡å¼€å§‹æ¯ä¸ªäººæœ€å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–å¯¹æ‰‹ä¸Šæ¬¡å–çš„ä¸¤å€ã€‚\nåšå¼ˆè¿‡ç¨‹å¦‚ä¸‹ï¼š\nå½“nä¸ºæ–æ³¢é‚£å¥‘æ•°æ—¶ï¼Œä»¤F[k]ä¸ºæ–æ³¢é‚£å¥‘æ•°ç¬¬ké¡¹ï¼Œé‚£ä¹ˆå½“n=2=F[3]ï¼Œn=3=F[4]æ˜¾ç„¶å…ˆæ‰‹å¿…è´¥ï¼Œå‡è®¾n=F[i]ï¼Œi\u0026lt;kæ—¶å‘½é¢˜éƒ½æˆç«‹ï¼Œè®¨è®ºn=F[k]æ—¶ï¼Œæ­¤æ—¶n=F[k]=F[k-2]+F[k-1]ï¼Œç”±äºF[k-1]\u0026lt;2$ \\times $F[k-2]ï¼Œæ‰€ä»¥å…ˆæ‰‹å¿…ä¸èƒ½ç›´æ¥å–èµ°å¤§äºç­‰äºF[k-2]çš„ç‰©å“ï¼ŒåŒç†å…ˆæ‰‹å–èµ°å¤§äºç­‰äº$ \\frac{F[k-2]}{3} $çš„ç‰©å“æ—¶ï¼Œåæ‰‹å¯ä»¥ç›´æ¥å–å®ŒF[k-2]ï¼Œä¸”å›  $F[k-1] \\gt 2 \\times \\frac{2 \\times F[k-2]}{3} $ ä¸ä¼šå¯¹F[k-1]é€ æˆå½±å“ï¼Œæ‰€ä»¥æ¯ä¸ªF[k]å¯ä»¥åˆ†è§£ä¸ºF[k-2]ï¼ŒF[k-1]è¿™æ ·å•ç‹¬ä¸”äº’ä¸å½±å“çš„æ–æ³¢é‚£å¥‘å±€é¢ï¼ˆå¯ä»¥ç»§ç»­åˆ†è§£ï¼‰æ­¤æ—¶å…ˆæ‰‹å¿…è´¥ã€‚ å¾—å‡ºå½“nä¸ºæ–æ³¢é‚£å¥‘æ•°æ—¶å…ˆæ‰‹å¿…è´¥ã€‚\nå½“nä¸ºéæ–æ³¢é‚£å¥‘æ•°æ—¶ï¼Œç”±é½è‚¯å¤šå¤«å®šç†ï¼Œå¯ä»¥å°†nåˆ†è§£ä¸ºè‹¥å¹²ä¸ç›¸é‚»çš„æ–æ³¢é‚£å¥‘æ•°ä¹‹å’Œï¼Œä¾‹å¦‚85=55+21+8+1ã€‚æ­¤æ—¶$ n = F[x_{1}] + F[x_{2}] + \\ldots + F[x_{k}], (x_{1} \u0026gt; x_{2} \u0026gt; \\ldots \u0026gt; x_{k})$ï¼Œç”±äº$ F[x_{k-1}] \u0026gt; 2 \\times F[x_{k}] $ï¼Œå–å®Œ$ F[x_{k}] $ä¸ä¼šå¯¹$ F[x_{k-1}] $é€ æˆå½±å“ï¼Œå³å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸ªå•ç‹¬ä¸”äº’ä¸å½±å“çš„æ–æ³¢é‚£å¥‘æ•°å±€é¢ï¼Œä½†å…ˆæ‰‹å¯ä»¥ç›´æ¥å–èµ°$ F[x_{k}] $ï¼Œåæ‰‹å¯¹äºæ¯ä¸ªåˆ†è§£çš„è‹¥å¹²å•ç‹¬ä¸”äº’ä¸å½±å“çš„æ–æ³¢é‚£å¥‘å±€é¢éƒ½æ˜¯å¿…è´¥çš„ã€‚å¾—å‡ºå½“nä¸ºéæ–æ³¢é‚£å¥‘æ•°æ—¶å…ˆæ‰‹å¿…è´¥ã€‚\nZeckendorfå®šç† Zeckendorfå®šç†ï¼š\nä»»ä½•æ­£æ•´æ•°éƒ½å¯ä»¥è¡¨ç¤ºæˆè‹¥å¹²ä¸ªä¸è¿ç»­çš„æ–æ³¢é‚£å¥‘æ•°ï¼ˆä¸åŒ…æ‹¬ç¬¬ä¸€ä¸ªæ–æ³¢é‚£å¥‘æ•°ï¼‰ä¹‹å’Œã€‚\nç®€å•è¯æ˜å¦‚ä¸‹ï¼š\nä»¤F[k]ä¸ºæ–æ³¢é‚£å¥‘æ•°ç¬¬ké¡¹ï¼Œé‚£ä¹ˆå½“n=1=F[1]=F[2]ï¼Œn=2=F[3]ï¼Œn=3=F[4]å‘½é¢˜æˆç«‹ã€‚å‡è®¾i\u0026lt;næ—¶å‘½é¢˜éƒ½æˆç«‹ï¼Œè®¨è®ºi=næ—¶ï¼Œå½“nä¸ºæ–æ³¢é‚£å¥‘æ•°æ—¶ï¼Œå‘½é¢˜æ˜¾ç„¶æˆç«‹ï¼›å½“nä¸ºéæ–æ³¢é‚£å¥‘æ•°æ—¶ï¼Œä»¤kä¸ºæœ€å¤§çš„æ•´æ•°ä½¿å¾—F[k]\u0026lt;n\u0026lt;F[k+1]ï¼Œè®¾m=n-F[k]\u0026lt;(F[k+1]-F[k]=F[k-1])ï¼Œå¯å¾—m\u0026lt;F[k-1]\u0026lt;nï¼Œç”±äº$ m = F[x_{1}] + F[x_{2}] + \\ldots + F[x_{k}], (F[x_{k}]æœ€å¤§) $ï¼Œå› ä¸ºm\u0026lt;F[k-1]ï¼Œæ‰€ä»¥$ x_{k} \u0026lt; k - 1$ï¼Œæ‰€ä»¥$ n = F[x_{1}] + F[x_{2}] + \\ldots + F[x_{k}] + F[k] $ï¼Œä»ç„¶å¯ä»¥åˆ†è§£ä¸ºè‹¥å¹²ä¸ªæ–æ³¢é‚£å¥‘æ•°ä¹‹å’Œï¼Œä¸”ä¸æ˜¯è¿ç»­çš„$ (x_{k} \u0026lt; k - 1) $ã€‚ ","permalink":"https://blog.lordash.de/posts/algorithm/fibonacci%E5%8D%9A%E5%BC%88/","summary":"Fibonacciåšå¼ˆ åŸºæœ¬çš„æ–æ³¢é‚£å¥‘åšå¼ˆï¼ˆFibonacci Gameï¼‰æè¿°å¦‚ä¸‹ï¼š æœ‰ä¸€å †æ•°é‡å¤šäºä¸€çš„ç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œç¬¬ä¸€æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œ","title":"Fibonacciåšå¼ˆ"},{"content":"Wythoffåšå¼ˆ åŸºæœ¬çš„å¨ä½å¤«åšå¼ˆï¼ˆWythoff Gameï¼‰æè¿°å¦‚ä¸‹ï¼š\næœ‰ä¸¤å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–åŒæ—¶ä»ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šè€…ä¸é™ï¼Œæœ€åå–å…‰è€…å¾—èƒœã€‚\næˆ‘ä»¬ä½¿ç”¨(a, b)æ¥æè¿°ä¸€ä¸ªå±€é¢ï¼Œå¯ä»¥å‘ç°(a, b)å’Œ(b, a)å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥åœ¨æ­¤å®šä¹‰a $ \\le $ bã€‚æ˜¾ç„¶(0, 0)æ˜¯ç¬¬ä¸€ä¸ªå¿…è´¥æ€ï¼ˆå…ˆæ‰‹å¿…è´¥å±€é¢ã€å¥‡å¼‚å±€é¢ã€P-positionï¼‰ï¼Œä½¿ç”¨P/N-çŠ¶æ€æˆ–è€…SGå‡½æ•°å¯ä»¥æ›´å®¹æ˜“åœ°åˆ†æå±€é¢ï¼Œç®€å•è®²å°±æ˜¯ï¼šâ€œç§»åŠ¨å¯ä»¥å¯¼è‡´å¿…è´¥æ€çš„ï¼Œæ­¤æ—¶å…ˆæ‰‹å¿…èƒœï¼›ç§»åŠ¨åªèƒ½å¯¼è‡´å¿…èƒœæ€çš„ï¼Œæ­¤æ—¶å…ˆæ‰‹å¿…è´¥â€ã€‚æ‰“è¡¨å¯å¾—å¿…è´¥æ€ä¸º(0, 0)ã€(1, 2)ã€(3, 5)ã€(4, 7)ã€(6, 10)ã€(8, 13)ã€(9, 15)ã€ $ \\cdots $ ä»”ç»†è§‚å¯Ÿï¼Œå¤§èƒ†å‡è®¾ï¼Œè‡ªè¡Œæ±‚è¯ï¼Œå¯¹äº $ (a_n, b_n) $ æœ‰ä»¥ä¸‹æ€§è´¨ï¼š\n$ a_n $ æ˜¯å‰é¢å¿…è´¥æ€ä¸­æœªå‡ºç°è¿‡çš„æœ€å°è‡ªç„¶æ•°\n$ b_n = a_n + n $\nåšå¼ˆè¿‡ç¨‹å¦‚ä¸‹ï¼š\nç”± $ a_n $ æ˜¯æœªåœ¨å‰é¢å‡ºç°è¿‡çš„æœ€å°è‡ªç„¶æ•°ï¼Œæ‰€ä»¥ $ a_n \u0026gt; a_{n-1} $ ï¼Œè€Œ $ (b_n = a_n + n) \u0026gt; (a_{n-1} + n) \u0026gt; (a_{n-1} + n - 1 = b_{n-1}) \u0026gt; a_{n-1} $ ï¼Œå¾—å‡ºä»»ä½•è‡ªç„¶æ•°éƒ½åŒ…å«äºæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªå¿…è´¥æ€ä¸­ã€‚ å½“å±€é¢å¤„äºå¿…è´¥æ€æ—¶ï¼Œå¦‚æœåªæ”¹å˜å…¶ä¸­ä¸€ä¸ªåˆ†é‡ï¼Œé‚£ä¹ˆä¸å¦ä¸€ä¸ªåˆ†é‡å°±ä¸åœ¨åŒä¸€ä¸ªå¿…è´¥æ€ä¸­ã€‚å¦‚æœä½¿ä¸¤ä¸ªåˆ†é‡åŒæ—¶å‡å°‘ï¼Œé‚£ä¹ˆç”±äºaå’Œbçš„å·®å€¼ä¸å˜ï¼Œæ”¹å˜åä¹Ÿä¸ä¼šæ˜¯å…¶å®ƒçš„å¿…è´¥æ€ã€‚å¾—å‡ºå¿…è´¥æ€åªèƒ½è½¬ç§»åˆ°å¿…èƒœæ€ã€‚ å½“å±€é¢å¤„äºå¿…èƒœæ€(x, y)æ—¶ï¼Œå¦‚æœä¸xå‡ºç°åœ¨å¿…è´¥æ€æ—¶çš„å¦ä¸€ä¸ªåˆ†é‡ $ a_x $ æˆ–è€… $ b_x $ å°äºyï¼Œé‚£ä¹ˆå°†yå–æˆ $ a_x $ æˆ–è€… $ b_x $ ï¼Œå±€é¢å˜ä¸ºå¿…è´¥æ€ $ (a_x, x) $ æˆ–è€… $ (x, b_x) $ ï¼›å¦åˆ™åœ¨ä¸¤å †åŒæ—¶å–èµ° $ x-a_{y-x} $ ï¼Œå±€é¢å˜ä¸ºå¿…è´¥æ€ $ (a_{y-x}, b_{y-x}) $ã€‚å¾—å‡ºå¿…èƒœæ€å¯ä»¥è½¬ç§»åˆ°å¿…è´¥æ€ã€‚ SGå‡½æ•°æ‰“è¡¨æ‰¾å‡ºè§„å¾‹ï¼Œå°±å¯ä»¥å¼€å§‹æ¨å¯¼äº†ï¼Œå®é™…ä¸Š $ a_n $ å’Œ $ b_n $ æ˜¯Bettyåºåˆ—å¹¶æ»¡è¶³Bettyå®šç†ï¼Œä»¤ $ A = a_{n}, B = a_{n}+n $ è§£æ–¹ç¨‹ $ \\frac{1}{a} + \\frac{1}{a+1} = 1 $ å¾— $ a = \\frac{\\sqrt{5} + 1}{2} $ ã€‚å³å¯¹äºWythoffåšå¼ˆå±€é¢(a, b)ï¼Œå½“ $ a == (int)((b-a) \\times \\frac{\\sqrt{5} + 1}{2}) $ æ—¶å…ˆæ‰‹å¿…è´¥ï¼Œåä¹‹å…ˆæ‰‹å¿…èƒœã€‚\nBettyå®šç† Bettyå®šç†ï¼š\nå¦‚æœä¸¤ä¸ªæ— ç†æ•°æ»¡è¶³ $ \\frac{1}{a} + \\frac{1}{b} = 1 $ï¼Œé‚£ä¹ˆå¯¹äºä¸¤ä¸ªé›†åˆ $ A = {[na]}, B = {[na]}, n \\in Z $ ï¼Œå¯å¾—å‡º $ A \\cap B = \\varnothing, A \\cup B = N^{+} $ ã€‚\nç®€å•è¯æ˜å¦‚ä¸‹ï¼š\n$ A \\cap B = \\varnothing $\nç”± $ \\frac{1}{a} + \\frac{1}{b} = 1 $ï¼Œä¸”aï¼Œbä¸ºæ­£ï¼Œå¯ä»¥å¾—åˆ°aï¼Œbå‡å¤§äº1ï¼Œæ‰€ä»¥[na]çš„è·¨åº¦å¤§äº1ï¼Œå‘ä¸‹å–æ•´ä¸ä¼šé‡å¤ã€‚å–æ•´æ•°kä½¿å¾— $ k \\in A, k \\in B $ï¼Œé‚£ä¹ˆ $ k \u0026lt; ma \u0026lt; k+1, k \u0026lt; nb \u0026lt; k+1 $ ï¼ŒåŒ–ç®€ä¸€ä¸‹ $ \\frac{k}{m} \u0026lt; a \u0026lt; \\frac{k+1}{m} \\Longrightarrow \\frac{m}{k+1} \u0026lt; \\frac{1}{a} \u0026lt; \\frac{m}{k} $ ï¼ŒåŒç† $ \\frac{n}{k+1} \u0026lt; \\frac{1}{b} \u0026lt; \\frac{n}{k} $ ï¼Œä¸¤å¼ç›¸åŠ  $ \\frac{m+n}{k+1} \u0026lt; \\frac{1}{a} + \\frac{1}{b} \u0026lt; \\frac{m+n}{k} \\Longrightarrow \\frac{m+n}{k+1} \u0026lt; 1 \u0026lt; \\frac{m+n}{k} \\Longrightarrow k \u0026lt; m + n \u0026lt; k + 1 $ ï¼Œä¸mï¼Œnä¸ºæ•´æ•°çŸ›ç›¾ã€‚\n$ A \\cup B = N^{+} $\nå–æ•´æ•°kæ»¡è¶³ $ k \\in C_{N^{+}}A \\cup B $ ï¼Œæ­¤æ—¶å¿…æœ‰æ•´æ•°mï¼Œnæ»¡è¶³ $ [ma] \u0026lt; k \u0026lt; [(m+1)a], [nb] \u0026lt; k \u0026lt; [(n+1)b] $ ï¼ŒåŒ–ç®€ä¸€ä¸‹ $ ma \u0026lt; k \\le [(m+1)a] - 1 $ ï¼Œç”±äºaä¸ºæ— ç†æ•°ï¼Œæ‰€ä»¥æœ‰ $ ma \u0026lt; k \u0026lt; (m+1)a - 1 \\Longrightarrow \\frac{m}{k} \u0026lt; \\frac{1}{a} \u0026lt; \\frac{m+1}{k+1} $ ï¼ŒåŒç† $ \\frac{n}{k} \u0026lt; \\frac{1}{b} \u0026lt; \\frac{m+1}{k+1} $ ï¼Œä¸¤å¼ç›¸åŠ  $ \\frac{m+n}{k} \u0026lt; \\frac{1}{a} + \\frac{1}{b} \u0026lt; \\frac{m+n+2}{k+1} \\Longrightarrow \\frac{m+n}{k} \u0026lt; 1 \u0026lt; \\frac{m+n+2}{k+1} \\Longrightarrow m + n \u0026lt; k \u0026lt; k + 1 \u0026lt; m + n + 2 $ ï¼Œä¸m+nå’Œm+n+2é—´åªæœ‰ä¸€ä¸ªæ•´æ•°çŸ›ç›¾ã€‚\n","permalink":"https://blog.lordash.de/posts/algorithm/wythoff%E5%8D%9A%E5%BC%88/","summary":"Wythoffåšå¼ˆ åŸºæœ¬çš„å¨ä½å¤«åšå¼ˆï¼ˆWythoff Gameï¼‰æè¿°å¦‚ä¸‹ï¼š æœ‰ä¸¤å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †æˆ–åŒæ—¶ä»ä¸¤å †ä¸­å–åŒæ ·å¤šçš„ç‰©å“ï¼Œæ¯","title":"Wythoffåšå¼ˆ"},{"content":"Bashåšå¥• åŸºæœ¬çš„å·´ä»€åšå¼ˆï¼ˆBash Gameï¼‰æè¿°å¦‚ä¸‹ï¼š\næœ‰ä¸€å †nä¸ªç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å…‰è€…è·èƒœã€‚\nåšå¼ˆè¿‡ç¨‹å¦‚ä¸‹ï¼š\nå¦‚æœn\u0026lt;mï¼Œé‚£ä¹ˆå…ˆæ‰‹å¯ä»¥ä¸€æ¬¡å–å®Œã€‚å…ˆæ‰‹å¿…èƒœã€‚\nå¦‚æœn=m+1ï¼Œé‚£ä¹ˆç”±äºä¸€æ¬¡æœ€å¤šå–èµ°mä¸ªï¼Œæ— è®ºå…ˆæ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œåæ‰‹éƒ½èƒ½ä¸€æ¬¡æ€§å–å®Œã€‚æ­¤æ—¶å…ˆæ‰‹å¿…è´¥ã€‚ å¯ä»¥å‡è®¾ï¼Œæ¸¸æˆå±€é¢ä¸m+1æœ‰å…³ã€‚\nå¦‚æœn%(m+1)=0ï¼Œé‚£ä¹ˆæ— è®ºå…ˆæ‰‹å–èµ°å¤šå°‘ä¸ªï¼Œå‡è®¾æ­¤æ—¶ä¸ºiä¸ªï¼ˆæ“ä½œåˆæ³•æ—¶1 $ \\le $ i $ \\le $ mï¼‰ï¼Œåæ‰‹éƒ½èƒ½å–èµ°m+1-iä¸ªï¼Œä½¿å¾—å±€é¢é‡æ–°å›åˆ°n%(m+1)=0ã€‚ç›´è‡³æœ€åå±€é¢å˜æˆn=m+1ã€‚æ­¤æ—¶å…ˆæ‰‹å¿…è´¥ã€‚\nå¦‚æœn%(m+1)=k $ \\neq $ 0ï¼Œæ˜¾ç„¶1 $ \\le $ k $ \\le $ mï¼Œé‚£ä¹ˆå…ˆæ‰‹å–èµ°kä¸ªï¼Œåˆ™å°†n%(m+1)=0çš„å¿…è¾“æ€ï¼ˆå…ˆæ‰‹å¿…è´¥å±€é¢ã€å¥‡å¼‚å±€é¢ã€P-positionï¼‰ç•™ç»™å¯¹é¢äº†ã€‚æ­¤æ—¶å…ˆæ‰‹å¿…èƒœã€‚\nä¿®æ”¹ä¸€ä¸‹è·èƒœæ¡ä»¶ï¼š\næœ‰ä¸€å †nä¸ªç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å…‰è€…å¤±è´¥ã€‚\nå¯ä»¥è½¬åŒ–ä¸ºåŸºæœ¬çš„å·´ä»€åšå¼ˆï¼Œåªä¸è¿‡æ­¤æ—¶éœ€è¦ç»™å¯¹æ‰‹ç•™ä¸‹æœ€å1ä¸ªï¼Œè€ƒè™‘çš„ $ n\u0026rsquo; $ å®é™…ä¸ºn-1ï¼Œå³(n-1)%(m+1) ? å…ˆæ‰‹èƒœ : åæ‰‹èƒœ\nå¦ä¸€ç±»çš„å·´ä»€åšå¼ˆï¼š\næœ‰ä¸€å †nä¸ªç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–pä¸ªï¼Œæœ€å¤šå–qä¸ªï¼Œå‰©ä½™ä¸è¶³pä¸ªæ—¶ä¸€æ¬¡å–å®Œï¼Œæœ€åå–å…‰è€…å¤±è´¥ã€‚\nå¯å¾— $ n = (p + q) \\times r + s $ æ—¶ï¼Œ(s!=0 \u0026amp;\u0026amp; s\u0026lt;=p) ? åæ‰‹èƒœ : å…ˆæ‰‹èƒœ\n","permalink":"https://blog.lordash.de/posts/algorithm/bash%E5%8D%9A%E5%BC%88/","summary":"Bashåšå¥• åŸºæœ¬çš„å·´ä»€åšå¼ˆï¼ˆBash Gameï¼‰æè¿°å¦‚ä¸‹ï¼š æœ‰ä¸€å †nä¸ªç‰©å“ï¼Œä¸¤äººè½®æµå–èµ°ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œæœ€å¤šå–mä¸ªï¼Œæœ€åå–å…‰è€…è·èƒœã€‚ åšå¼ˆè¿‡","title":"Bashåšå¼ˆ"},{"content":"Nimåšå¼ˆ åŸºæœ¬çš„å°¼å§†åšå¼ˆï¼ˆNim Gameï¼‰æè¿°å¦‚ä¸‹ï¼š\næœ‰è‹¥å¹²å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †å–ä»»æ„å¤šçš„ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šè€…ä¸é™ï¼Œæœ€åå–å…‰è€…å¾—èƒœã€‚\nåšå¼ˆè¿‡ç¨‹å¦‚ä¸‹ï¼š\nå¯¹äºå±€é¢ $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n = 0 $ï¼Œæ— è®ºå…ˆæ‰‹æ€ä¹ˆå–ï¼Œå¿…å°†å¯¼è‡´å¼‚æˆ–å’Œæ”¹å˜ä¸º $ a\u0026rsquo;_1 \\oplus a\u0026rsquo;_2 \\oplus \\ldots \\oplus a\u0026rsquo;_n = k \\neq 0 $ ï¼Œè€Œæ­¤æ—¶å¿…æœ‰ $ a_i $ ä½¿å¾— $ a_i $ äºŒè¿›åˆ¶ä¸‹ç¬¬kä½ä¸º1ï¼Œåæ‰‹åªè¦å°† $ a_i $ å–æˆ $ a_i \\oplus k $ ï¼Œä½¿å¾—å±€é¢é‡æ–°å›åˆ°å¼‚æˆ–å’Œä¸º0ï¼Œç›´è‡³æœ€åå±€é¢å˜æˆ $ (0, 0, \\ldots, 0) $ ï¼Œæ­¤æ—¶å¼‚æˆ–å’Œä¸º0ã€‚å…ˆæ‰‹å¿…è¾“ã€‚ å¯¹äºå±€é¢ $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n \\neq 0 $ ï¼Œåä¹‹ï¼Œå…ˆæ‰‹å¿…èƒœã€‚ è¯¦ç»†è¯æ˜è§ä¸‹æ–¹Boutonå®šç†ã€‚\nBoutonå®šç† Boutonå®šç†ï¼š\nå‡è®¾Nimåšå¼ˆçš„çŸ³å­æœ‰ $ n $ å †ï¼Œç¬¬ $ i $ å †çš„çŸ³å­ä¸ªæ•°æˆ‘ä»¬ç”¨ $ a_i $ è¡¨ç¤ºï¼Œåˆ™æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ $ (a_1, a_2, \\ldots, a_n) $ è¡¨ç¤ºä¸€ä¸ªNimåšå¼ˆçš„å±€é¢ã€‚å¯¹äº $ (a_1, a_2, \\ldots, a_n) $ çš„Nimåšå¼ˆå±€é¢ï¼Œå½“ä¸”ä»…å½“ $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n \\neq 0 $ æ—¶ï¼ˆå…¶ä¸­ $ \\oplus $ æ˜¯æŒ‰ä½å¼‚æˆ–è¿ç®—ï¼‰ï¼Œå…ˆæ‰‹å¿…èƒœã€‚\nç®€å•è¯æ˜å¦‚ä¸‹ï¼š\nå¯¹äº $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n \\neq 0 $ çš„Nimåšå¼ˆå±€é¢ $ (a_1, a_2, \\ldots, a_n) $ ï¼Œæˆ‘ä»¬è®¾ $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n = k $ ã€‚åˆ™å¿…å­˜åœ¨ $ a_i $ ï¼Œå…¶äºŒè¿›åˆ¶è¡¨ç¤ºåœ¨ $ k $ çš„æœ€é«˜ä½ä¸Šä¸º1ï¼ˆå¼‚æˆ–è¿ç®—çš„æ€§è´¨ï¼‰ï¼Œä¸”æœ‰ $ a_i \\oplus k \u0026lt; a_i $ ã€‚åˆ™å¯¹äºå½“å‰å±€é¢ä¸‹çš„å…ˆæ‰‹å¯ä»¥é€šè¿‡åˆæ³•çš„ç§»åŠ¨å°†ç¬¬å †çŸ³å­å–åˆ°åªå‰© $ a_i \\oplus k $ ä¸ªï¼Œé‚£ä¹ˆæ­¤æ—¶æ¸¸æˆå±€é¢å˜ä¸º $ (a_1, a_2, \\ldots, a_{i-1},a_i \\oplus k, a_{i+1}, \\ldots a_n ) $ ã€‚ è€Œæ­¤æ—¶ $ a_1\\oplus a_2 \\oplus \\ldots \\oplus a_{i-1} \\oplus (a_i \\oplus k) \\oplus a_{i+1} \\oplus \\dots \\oplus a_n = k \\oplus k = 0 $ã€‚å¾—å‡ºå¼‚æˆ–å’Œä¸ä¸º0çš„å±€é¢ä¸€å®šå­˜åœ¨åˆæ³•ç§»åŠ¨å¯ä»¥å˜ä¸ºå¼‚æˆ–å’Œä¸º0çš„å±€é¢ã€‚ å¯¹äº $ a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n = 0 $ çš„Nimåšå¼ˆå±€é¢ $ (a_1, a_2, \\ldots, a_n) $ ï¼Œå‡è®¾æˆ‘ä»¬å°†ç¬¬ $ i $ å †çŸ³å­ç”± $ a_i $ ä¸ªå–åˆ° $ a\u0026rsquo;_i $ ä¸ªï¼Œåˆ™æœ‰ $ a_i \\neq a\u0026rsquo;i $ ï¼Œåˆ™å¿…æœ‰ $ a_1\\oplus a_2 \\oplus \\ldots \\oplus a{i-1} \\oplus a\u0026rsquo;i \\oplus a{i+1} \\oplus \\dots \\oplus a_n \\neq 0 $ ï¼ˆå¯ç”¨åè¯æ³•è¯æ˜ï¼‰ã€‚å³å¼‚æˆ–å’Œä¸º0çš„å±€é¢æ— è®ºæ€æ ·åˆæ³•åœ°è¿›è¡Œç§»åŠ¨ï¼Œéƒ½å°†è½¬å˜ä¸ºå¼‚æˆ–å’Œä¸ä¸º0çš„å±€é¢ã€‚ å¯¹äºå±€é¢ $ (0, 0, \\ldots, 0) $ ï¼Œå…¶å¼‚æˆ–å’Œä¸º0ï¼Œå¯¹äºå…ˆæ‰‹è€Œè¨€æ˜¯å¿…è¾“çš„å±€é¢ã€‚ å¯¹äºä»»ä½•å¼‚æˆ–å’Œä¸ä¸º0çš„å±€é¢ï¼Œå…ˆæ‰‹åªéœ€è¦æŒ‰ç…§ç­–ç•¥å°†å…¶è½¬å˜ä¸ºå¼‚æˆ–å’Œä¸º0çš„å±€é¢ï¼Œå°±èƒ½ä¿è¯åæ‰‹æ°¸è¿œåªèƒ½æ‹¿åˆ°å¼‚æˆ–å’Œä¸º0çš„å±€é¢ã€‚åˆå› ä¸ºæ¯ä¸€æ¬¡åˆæ³•çš„ç§»åŠ¨éƒ½å°†å¯¼è‡´çŸ³å­ä¸ªæ•°å‡å°‘ï¼Œæ•…æ€»çš„ç§»åŠ¨æ­¥æ•°æ˜¯æœ‰é™çš„ï¼Œæœ€ç»ˆåæ‰‹å°†æ‹¿åˆ°çš„å±€é¢è€Œæ— çŸ³å­å¯æ‹¿ï¼Œæ•…åæ‰‹å¿…è¾“ï¼Œå…ˆæ‰‹å¿…èƒœã€‚åè¿‡æ¥å³å¯è¯ï¼Œå¯¹äºä»»ä½•å¼‚æˆ–å’Œä¸º0çš„å±€é¢ï¼Œå…ˆæ‰‹å¿…è¾“ã€‚ ","permalink":"https://blog.lordash.de/posts/algorithm/nim%E5%8D%9A%E5%BC%88/","summary":"Nimåšå¼ˆ åŸºæœ¬çš„å°¼å§†åšå¼ˆï¼ˆNim Gameï¼‰æè¿°å¦‚ä¸‹ï¼š æœ‰è‹¥å¹²å †å„è‹¥å¹²ä¸ªç‰©å“ï¼Œä¸¤ä¸ªäººè½®æµä»æŸä¸€å †å–ä»»æ„å¤šçš„ç‰©å“ï¼Œæ¯æ¬¡è‡³å°‘å–ä¸€ä¸ªï¼Œå¤šè€…ä¸é™ï¼Œæœ€åå–","title":"Nimåšå¼ˆ"},{"content":"å…¬å¹³ç»„åˆæ¸¸æˆ å…¬å¹³ç»„åˆæ¸¸æˆï¼ˆImpartial Combinatorial Gamesï¼‰ç®€ç§°ICGï¼Œå¤§è‡´å®šä¹‰å¦‚ä¸‹ï¼š\næ¸¸æˆæœ‰2åé€‰æ‰‹ å¯¹äºæ¸¸æˆä»»ä½•ä¸€ç§å¯èƒ½çš„å±€é¢ï¼ˆpositionï¼‰ï¼Œåˆæ³•çš„æ“ä½œé›†åˆåªå–å†³äºè¿™ä¸ªå±€é¢æœ¬èº« é€‰æ‰‹è½®æµæ“ä½œï¼ˆmoveï¼‰ï¼Œä¸”åªèƒ½åœ¨åˆæ³•æ“ä½œé›†åˆä¸­é€‰æ‹© åœ¨æ¸¸æˆå‡ºäºæŸçŠ¶æ€ï¼Œå½“å‰é€‰æ‰‹åˆæ³•æ“ä½œé›†åˆä¸ºç©ºæ—¶åˆ¤è´Ÿï¼Œæ¸¸æˆç»“æŸ {% fold æŸ¥çœ‹è§£æ %}\nä¸€ä¸ªå…¬å¹³æ¸¸æˆå¯ä»¥æŠ½è±¡åœ°ç”¨ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾æ¥è¡¨ç¤ºï¼Œè¿™ä¸ªå›¾ä¸­æ¯ä¸ªç‚¹éƒ½å¯¹åº”ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯æ¡æœ‰å‘è¾¹ä»£è¡¨ä»ä¸€ä¸ªçŠ¶æ€åˆ°å¦ä¸€ä¸ªçŠ¶æ€çš„åˆæ³•æ“ä½œã€‚\næˆ‘ä»¬å¯ä»¥æƒ³è±¡ä¸€ä¸ªç¡¬å¸æœ€åˆæ”¾åœ¨æŸä¸ªç‚¹ä¸Šï¼Œç„¶åä¸¤ä¸ªç©å®¶è½®æµå°†å…¶ä»å½“å‰çš„ç‚¹ç§»åŠ¨åˆ°å®ƒçš„åç»§ç‚¹ã€‚å½“ç¡¬å¸ç§»åŠ¨åˆ°æ±‡ç‚¹ï¼ˆæ²¡æœ‰å‡ºåº¦çš„ç‚¹ï¼‰æ—¶æ¸¸æˆç»“æŸï¼Œæ— æ³•æ“ä½œçš„ç©å®¶åˆ¤è´Ÿã€‚\n{% endfold %}\nå¿…èƒœæ€å’Œå¿…è´¥æ€ å¿…è´¥æ€ï¼ˆP-positionï¼‰ï¼šä¸Šä¸€ä¸ªé€‰æ‰‹ï¼ˆprevious playerå…ˆå‰åˆšæ“ä½œå®Œçš„é€‰æ‰‹ï¼‰å¤„äºå¿…èƒœå±€é¢ï¼Œå³æ­¤æ—¶å…ˆæ‰‹å¿…è´¥ å¿…èƒœæ€ï¼ˆN-positionï¼‰ï¼šä¸‹ä¸€ä¸ªé€‰æ‰‹ï¼ˆnext playerå½“å‰å³å°†æ“ä½œçš„é€‰æ‰‹ï¼‰å¤„äºå¿…èƒœå±€é¢ï¼Œå³æ­¤æ—¶å…ˆæ‰‹å¿…èƒœ {% fold æŸ¥çœ‹è§£æ %}\næ›´åŠ ä¸¥è°¨çš„å®šä¹‰ï¼š1.æ— æ³•è¿›è¡Œä»»ä½•ç§»åŠ¨çš„å±€é¢ç»ˆç»“ç‚¹ï¼ˆä¹Ÿå°±æ˜¯terminal positionï¼‰æ˜¯P-positionï¼›2.å¯ä»¥ç§»åŠ¨åˆ°P-positionçš„å±€é¢æ˜¯N-positionï¼›3.æ‰€æœ‰ç§»åŠ¨éƒ½å¯¼è‡´N-positionçš„å±€é¢æ˜¯P-positionã€‚\nP-positionå’ŒN-positionçš„å±€é¢ä¿¡æ¯æä¾›äº†æ¸¸æˆçš„å¿…èƒœç­–ç•¥ã€‚å¦‚æœè½®åˆ°æˆ‘ä»¬æ“ä½œä¸”æ¸¸æˆå¤„åœ¨ä¸€ä¸ªN-positionï¼Œæˆ‘ä»¬åº”è¯¥ç§»åŠ¨åˆ°ä¸€ä¸ªP-positionã€‚æ¥ç€æˆ‘ä»¬çš„å¯¹æ‰‹å°±ä¼šè¢«è¿«è¿›å…¥N-positionï¼Œä¾æ¬¡ç±»æ¨ã€‚æˆ‘ä»¬æœ€ç»ˆä¼šç§»å…¥ä¸€ä¸ªæ±‡ç‚¹å¹¶è·å¾—èƒœåˆ©ã€‚\n{% endfold %}\nSGå‡½æ•° å…ˆå®šä¹‰mex(minimal excludant)è¿ç®—ï¼Œè¿™æ˜¯æ–½åŠ äºä¸€ä¸ªé›†åˆçš„è¿ç®—ï¼Œè¡¨ç¤ºæœ€å°çš„ä¸å±äºè¿™ä¸ªé›†åˆçš„éè´Ÿæ•´æ•°ã€‚ä¾‹å¦‚mex{2,3,5}=0ã€mex{0,1,2,4}=3ã€mex{}=0ã€‚ å¯¹äºä»»æ„çŠ¶æ€xï¼Œå®šä¹‰SG(x)=mex(S)ï¼Œå…¶ä¸­Sæ˜¯xåç»§çŠ¶æ€çš„SGå‡½æ•°å€¼çš„é›†åˆã€‚å¦‚xæœ‰ä¸‰ä¸ªåç»§çŠ¶æ€åˆ†åˆ«ä¸ºaã€bã€cï¼Œé‚£ä¹ˆSG(x)=mex{SG(a), SG(b), SG(c)}ã€‚ è¿™æ ·ï¼Œé›†åˆSçš„ç»ˆæ€å¿…ç„¶æ˜¯ç©ºé›†ï¼Œæ‰€ä»¥å½“ä¸”ä»…å½“xä¸ºå¿…è´¥ç‚¹Pæ—¶ï¼ŒSGå‡½æ•°çš„ç»ˆæ€ä¸ºSG(x)=0ã€‚\n{% fold æŸ¥çœ‹è§£æ %}\né€šè¿‡SGå‡½æ•°ï¼Œæ¯ä¸ªICGéƒ½å¯ä»¥è½¬æ¢æˆNimåšå¼ˆã€‚SGå‡½æ•°çš„å®šä¹‰åŸŸä¸ºICGçš„å†³ç­–æ ‘ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ­¤æ—¶å…·ä½“å®šä¹‰ä¸ºï¼šSG(x)=mex{SG(y)|yæ˜¯xçš„èŠ‚ç‚¹}ã€‚å¯¹äºICGçš„å†³ç­–æ ‘ä¸Šçš„èŠ‚ç‚¹uï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªåªæœ‰ä¸€å †çŸ³å­ï¼Œä¸ªæ•°ä¸ºSG(u)çš„Nimåšå¼ˆã€‚\nå¯¹äºèŠ‚ç‚¹uçš„å­èŠ‚ç‚¹vï¼š\næ ¹æ®SGå‡½æ•°çš„å®šä¹‰ï¼Œå¿…æœ‰SG(u) $ \\neq $ SG(v) ã€‚ è‹¥SG(u) $ \u0026lt; $ SG(v)ï¼Œåˆ™æ ¹æ®SGå‡½æ•°çš„å®šä¹‰ï¼ŒvèŠ‚ç‚¹å¿…å®šå­˜åœ¨å­èŠ‚ç‚¹wä½¿å¾—SG(w)=SG(u)ã€‚å€˜è‹¥å…ˆæ‰‹å°è¯•ä½¿å¾—å±€é¢çš„SGå‡½æ•°å€¼å˜å¤§ï¼Œç”±å±€é¢uç§»åŠ¨åˆ°å±€é¢vï¼Œåˆ™åæ‰‹å¿…å®šå¯ä»¥å°†å±€é¢ç”±vè½¬ç§»åˆ°wï¼Œæ¢å¤SGå‡½æ•°å€¼ã€‚æ•…å…ˆæ‰‹æ— æœ‰æ•ˆçš„æ‰‹æ®µè®©å±€é¢çš„SGå‡½æ•°å€¼å¢å¤§ï¼Œæˆ‘ä»¬åªéœ€è¦è€ƒè™‘SG(u) $ \u0026gt; $ SG(v)çš„æƒ…å†µã€‚ å¯¹äºå…¨ä½“SG(u)\u0026gt;SG(v)çš„å­èŠ‚ç‚¹vï¼Œå…¶SGå‡½æ•°å€¼å°†å®Œæ•´è¦†ç›–åŒºé—´[0, SG(u)-1]ä¸Šçš„æ‰€æœ‰æ•´æ•°ã€‚æˆ‘ä»¬ä»å±€é¢uç§»åŠ¨åˆ°å±€é¢vï¼Œå…¶å®ç›¸å½“äºåœ¨ä¸€å †ä¸ªæ•°ä¸ºSG(u)çš„çŸ³å­ä¸Šå–èµ°è‹¥å¹²çŸ³å­ï¼Œä½¿å‰©ä¸‹ä¸€å †ä¸ªæ•°ä¸ºSG(v)çš„çŸ³å­ã€‚ å½“ICGä¸­å­˜åœ¨nä¸ªäº’ç›¸ä¸å¹²æ‰°çš„ç§»åŠ¨ç±»å‹æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™nç§ç§»åŠ¨ç±»å‹è§†ä¸ºnå †çŸ³å­ï¼Œå°†è¯¥ICGè§†ä¸ºnå †çŸ³å­çš„Nimåšå¼ˆï¼Œè¿ç”¨Boutonå®šç†ï¼Œè¯¥ICGçš„å…ˆæ‰‹å¿…èƒœä¸å¦çš„æƒ…å†µå¯ä»¥é€šè¿‡è®¡ç®—æ¯ä¸ªç§»åŠ¨ç±»å‹ä¸‹çš„åˆå§‹çŠ¶æ€çš„SGå‡½æ•°ï¼Œå¹¶è®¡ç®—è¿™äº›SGå‡½æ•°å€¼çš„å¼‚æˆ–å’Œæ¥å¾—å‡ºã€‚å³ä¸‹é¢çš„SGå®šç†ã€‚\n{% endfold %}\nSGå®šç† Sprague-Grundyå®šç†ï¼š\næ¸¸æˆå’Œçš„SGå‡½æ•°ç­‰äºå„ä¸ªæ¸¸æˆSGå‡½æ•°çš„Nimå’Œï¼ˆNimå’Œï¼šå„ä¸ªæ•°ç›¸å¼‚æˆ–çš„ç»“æœï¼‰ã€‚\nè¿™æ ·å°±å¯ä»¥å°†æ¯ä¸€ä¸ªå­æ¸¸æˆåˆ†è€Œæ²»ä¹‹ï¼Œä»è€Œç®€åŒ–äº†é—®é¢˜ã€‚è€ŒBoutonå®šç†å°±æ˜¯Sprague-Grundyå®šç†åœ¨Nimåšå¼ˆä¸­çš„ç›´æ¥åº”ç”¨ã€‚å› ä¸ºå•å †Nimåšå¼ˆï¼ˆåœ¨ä¸€å †nä¸ªçŸ³å­ä¸­å¯ä»¥å–1~nä¸ªçŸ³å­ï¼‰çš„SGå‡½æ•°æ»¡è¶³SG(n)=mex(n-1, n-2, n-3, \u0026hellip;, n-n)=nï¼Œæ ¹æ®SGå®šç†ï¼Œæ¯ä¸€å †çŸ³å­æ€»æ•°ç›¸äº’å¼‚æˆ–å³ä¸ºç­”æ¡ˆã€‚\næ¨¡æ¿ 1// POJ 2311 2int SG[205][205]; 3 4// é€’å½’ 5int getSg(int n, int m){ 6 if(SG[n][m]!=-1) return SG[n][m]; 7 bool S[1005]={0}; 8 9 for(int i=2; i\u0026lt;=n-i; i++) 10 S[getSg(i, m) ^ getSg(n-i, m)] = 1; 11 for(int i=2; i\u0026lt;=m-i; i++) 12 S[getSg(n, i) ^ getSg(n, m-i)] = 1; 13 14 int mex = 0; 15 while(S[mex]) mex++; 16 return SG[n][m]=mex; 17} 18 19// é€’æ¨ 20 21void getSg(int n, int m) { 22 for(int i = 2; i \u0026lt;= n; i++){ 23 for(int j = 2; j \u0026lt;= m; j++){ 24 bool S[1005]={0}; 25 for(int k = 2; i - k \u0026gt;= 2; k++) S[SG[k][j] ^ SG[i-k][j]] = 1; 26 for(int k = 2; j - k \u0026gt;= 2; k++) S[SG[i][k] ^ SG[i][j-k]] = 1; 27 int mex = 0; 28 while(S[mex]) mex++; 29 SG[i][j] = mex; 30 } 31 } 32} ","permalink":"https://blog.lordash.de/posts/algorithm/sg%E5%87%BD%E6%95%B0/","summary":"å…¬å¹³ç»„åˆæ¸¸æˆ å…¬å¹³ç»„åˆæ¸¸æˆï¼ˆImpartial Combinatorial Gamesï¼‰ç®€ç§°ICGï¼Œå¤§è‡´å®šä¹‰å¦‚ä¸‹ï¼š æ¸¸æˆæœ‰2åé€‰æ‰‹ å¯¹äºæ¸¸æˆä»»ä½•ä¸€ç§å¯èƒ½çš„å±€é¢ï¼ˆpositio","title":"SGå‡½æ•°"},{"content":"è§£ç PATå‡†è€ƒè¯ (PATB-1095) é¢˜é¢ PAT å‡†è€ƒè¯å·ç”± 4 éƒ¨åˆ†ç»„æˆï¼š\nç¬¬ 1 ä½æ˜¯çº§åˆ«ï¼Œå³ T ä»£è¡¨é¡¶çº§ï¼›A ä»£è¡¨ç”²çº§ï¼›B ä»£è¡¨ä¹™çº§ï¼› ç¬¬ 2~4 ä½æ˜¯è€ƒåœºç¼–å·ï¼ŒèŒƒå›´ä» 101 åˆ° 999ï¼› ç¬¬ 5~10 ä½æ˜¯è€ƒè¯•æ—¥æœŸï¼Œæ ¼å¼ä¸ºå¹´ã€æœˆã€æ—¥é¡ºæ¬¡å„å  2 ä½ï¼› æœ€å 11~13 ä½æ˜¯è€ƒç”Ÿç¼–å·ï¼ŒèŒƒå›´ä» 000 åˆ° 999ã€‚ ç°ç»™å®šä¸€ç³»åˆ—è€ƒç”Ÿçš„å‡†è€ƒè¯å·å’Œä»–ä»¬çš„æˆç»©ï¼Œè¯·ä½ æŒ‰ç…§è¦æ±‚è¾“å‡ºå„ç§ç»Ÿè®¡ä¿¡æ¯ã€‚\nè¾“å…¥ è¾“å…¥é¦–å…ˆåœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤104ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«ä¸ºè€ƒç”Ÿäººæ•°å’Œç»Ÿè®¡è¦æ±‚çš„ä¸ªæ•°ã€‚\næ¥ä¸‹æ¥ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªè€ƒç”Ÿçš„å‡†è€ƒè¯å·å’Œå…¶åˆ†æ•°ï¼ˆåœ¨åŒºé—´ [0,100] å†…çš„æ•´æ•°ï¼‰ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè€ƒç”Ÿä¿¡æ¯ä¹‹åï¼Œå†ç»™å‡º M è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç»Ÿè®¡è¦æ±‚ï¼Œæ ¼å¼ä¸ºï¼šç±»å‹ æŒ‡ä»¤ï¼Œå…¶ä¸­\nç±»å‹ ä¸º 1 è¡¨ç¤ºè¦æ±‚æŒ‰åˆ†æ•°éå‡åºè¾“å‡ºæŸä¸ªæŒ‡å®šçº§åˆ«çš„è€ƒç”Ÿçš„æˆç»©ï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºä»£è¡¨æŒ‡å®šçº§åˆ«çš„å­—æ¯ï¼› ç±»å‹ ä¸º 2 è¡¨ç¤ºè¦æ±‚å°†æŸæŒ‡å®šè€ƒåœºçš„è€ƒç”Ÿäººæ•°å’Œæ€»åˆ†ç»Ÿè®¡è¾“å‡ºï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºæŒ‡å®šè€ƒåœºçš„ç¼–å·ï¼› ç±»å‹ ä¸º 3 è¡¨ç¤ºè¦æ±‚å°†æŸæŒ‡å®šæ—¥æœŸçš„è€ƒç”Ÿäººæ•°åˆ†è€ƒåœºç»Ÿè®¡è¾“å‡ºï¼Œå¯¹åº”çš„ æŒ‡ä»¤ åˆ™ç»™å‡ºæŒ‡å®šæ—¥æœŸï¼Œæ ¼å¼ä¸å‡†è€ƒè¯ä¸Šæ—¥æœŸç›¸åŒã€‚ è¾“å‡º å¯¹æ¯é¡¹ç»Ÿè®¡è¦æ±‚ï¼Œé¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡º Case #: è¦æ±‚ï¼Œå…¶ä¸­ # æ˜¯è¯¥é¡¹è¦æ±‚çš„ç¼–å·ï¼Œä» 1 å¼€å§‹ï¼›è¦æ±‚ å³å¤åˆ¶è¾“å…¥ç»™å‡ºçš„è¦æ±‚ã€‚éšåè¾“å‡ºç›¸åº”çš„ç»Ÿè®¡ç»“æœï¼š\nç±»å‹ ä¸º 1 çš„æŒ‡ä»¤ï¼Œè¾“å‡ºæ ¼å¼ä¸è¾“å…¥çš„è€ƒç”Ÿä¿¡æ¯æ ¼å¼ç›¸åŒï¼Œå³ å‡†è€ƒè¯å· æˆç»©ã€‚å¯¹äºåˆ†æ•°å¹¶åˆ—çš„è€ƒç”Ÿï¼ŒæŒ‰å…¶å‡†è€ƒè¯å·çš„å­—å…¸åºé€’å¢è¾“å‡ºï¼ˆé¢˜ç›®ä¿è¯æ— é‡å¤å‡†è€ƒè¯å·ï¼‰ï¼› ç±»å‹ ä¸º 2 çš„æŒ‡ä»¤ï¼ŒæŒ‰ äººæ•° æ€»åˆ† çš„æ ¼å¼è¾“å‡ºï¼› ç±»å‹ ä¸º 3 çš„æŒ‡ä»¤ï¼Œè¾“å‡ºæŒ‰äººæ•°éé€’å¢é¡ºåºï¼Œæ ¼å¼ä¸º è€ƒåœºç¼–å· æ€»äººæ•°ã€‚è‹¥äººæ•°å¹¶åˆ—åˆ™æŒ‰è€ƒåœºç¼–å·é€’å¢é¡ºåºè¾“å‡ºã€‚ å¦‚æœæŸ¥è¯¢ç»“æœä¸ºç©ºï¼Œåˆ™è¾“å‡º NAã€‚\næ ·ä¾‹è¾“å…¥ 18 4 2B123180908127 99 3B102180908003 86 4A112180318002 98 5T107150310127 62 6A107180908108 100 7T123180908010 78 8B112160918035 88 9A107180908021 98 101 A 112 107 123 180908 132 999 æ ·ä¾‹è¾“å‡º 1Case 1: 1 A 2A107180908108 100 3A107180908021 98 4A112180318002 98 5Case 2: 2 107 63 260 7Case 3: 3 180908 8107 2 9123 2 10102 1 11Case 4: 2 999 12NA æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e4 + 5; 2 3struct P{ 4 char s[20]; 5 int x, t; 6 7 bool operator \u0026lt; (const P \u0026amp;x) const 8 { 9 if(t != x.t) 10 return t \u0026gt; x.t; 11 return strcmp(s, x.s) \u0026lt; 0; 12 } 13}a[mxn], ans[mxn]; 14 15struct P2{ 16 int s, cnt; 17 18 bool operator \u0026lt; (const P2 \u0026amp;x) const 19 { 20 if(cnt != x.cnt) 21 return cnt \u0026gt; x.cnt; 22 return s \u0026lt; x.s; 23 } 24}b[mxn]; 25 26int idx[mxn]; 27 28int main() 29{ 30 int n, m; 31 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 32 33 for(int i=0; i\u0026lt;n; i++){ 34 scanf(\u0026#34;%s %d\u0026#34;, a[i].s, \u0026amp;a[i].t); 35 sscanf(a[i].s+1, \u0026#34;%3d\u0026#34;, \u0026amp;a[i].x); 36 } 37 sort(a, a+n); 38 39 for(int cs=1; cs\u0026lt;=m; cs++) 40 { 41 int c; char g[10]; 42 scanf(\u0026#34;%d %s\u0026#34;, \u0026amp;c, g); 43 printf(\u0026#34;Case %d: %d %s\\n\u0026#34;, cs, c, g); 44 45 int num=0, sum=0; 46 if(c == 1) 47 { 48 for(int i=0; i\u0026lt;n; i++) 49 { 50 if(a[i].s[0] == g[0]){ 51 printf(\u0026#34;%s %d\\n\u0026#34;, a[i].s, a[i].t); 52 num++; 53 } 54 } 55 if(num == 0) 56 printf(\u0026#34;NA\\n\u0026#34;); 57 continue; 58 } 59 60 if(c == 2) 61 { 62 for(int i=0; i\u0026lt;n; i++) 63 { 64 if(strncmp(a[i].s+1, g, 3) == 0) 65 sum += a[i].t, num++; 66 } 67 if(num) 68 printf(\u0026#34;%d %d\\n\u0026#34;, num, sum); 69 else 70 printf(\u0026#34;NA\\n\u0026#34;); 71 continue; 72 } 73 74 if(c == 3) 75 { 76 for(int i=0; i\u0026lt;n; i++) 77 { 78 if(strncmp(a[i].s+4, g, 6) == 0) 79 { 80 int x = a[i].x; 81 if(idx[x] == 0){ 82 idx[x] = ++num; 83 b[idx[x]].s = x; 84 } 85 b[idx[x]].cnt++; 86 } 87 } 88 if(num) 89 { 90 sort(b+1, b+num+1); 91 for(int i=1; i\u0026lt;=num; i++) 92 { 93 printf(\u0026#34;%03d %d\\n\u0026#34;, b[i].s, b[i].cnt); 94 b[i].cnt = idx[b[i].s] = 0; 95 } 96 } 97 else 98 printf(\u0026#34;NA\\n\u0026#34;); 99 } 100 } 101 102 return 0; 103} ","permalink":"https://blog.lordash.de/posts/solution/patb-1095-%E8%A7%A3%E7%A0%81pat%E5%87%86%E8%80%83%E8%AF%81/","summary":"è§£ç PATå‡†è€ƒè¯ (PATB-1095) é¢˜é¢ PAT å‡†è€ƒè¯å·ç”± 4 éƒ¨åˆ†ç»„æˆï¼š ç¬¬ 1 ä½æ˜¯çº§åˆ«ï¼Œå³ T ä»£è¡¨é¡¶çº§ï¼›A ä»£è¡¨ç”²çº§ï¼›B ä»£è¡¨ä¹™çº§ï¼› ç¬¬ 2~4 ä½æ˜¯è€ƒåœºç¼–å·ï¼ŒèŒƒå›´ä» 101 åˆ° 999ï¼› ç¬¬ 5~10 ä½","title":"PATB-1095 è§£ç PATå‡†è€ƒè¯"},{"content":"è°·æ­Œçš„æ‹›è˜ (PATB-1094) é¢˜é¢ 2004 å¹´ 7 æœˆï¼Œè°·æ­Œåœ¨ç¡…è°·çš„ 101 å·å…¬è·¯è¾¹ç«–ç«‹äº†ä¸€å—å·¨å¤§çš„å¹¿å‘Šç‰Œï¼ˆå¦‚ä¸‹å›¾ï¼‰ç”¨äºæ‹›è˜ã€‚å†…å®¹è¶…çº§ç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªä»¥ .com ç»“å°¾çš„ç½‘å€ï¼Œè€Œå‰é¢çš„ç½‘å€æ˜¯ä¸€ä¸ª 10 ä½ç´ æ•°ï¼Œè¿™ä¸ªç´ æ•°æ˜¯è‡ªç„¶å¸¸æ•° e ä¸­æœ€æ—©å‡ºç°çš„ 10 ä½è¿ç»­æ•°å­—ã€‚èƒ½æ‰¾å‡ºè¿™ä¸ªç´ æ•°çš„äººï¼Œå°±å¯ä»¥é€šè¿‡è®¿é—®è°·æ­Œçš„è¿™ä¸ªç½‘ç«™è¿›å…¥æ‹›è˜æµç¨‹çš„ä¸‹ä¸€æ­¥ã€‚\nè‡ªç„¶å¸¸æ•° e æ˜¯ä¸€ä¸ªè‘—åçš„è¶…è¶Šæ•°ï¼Œå‰é¢è‹¥å¹²ä½å†™å‡ºæ¥æ˜¯è¿™æ ·çš„ï¼še = 2.71828182845904523536028747135266249775\n7247093699959574966967627724076630353547594571382178525166427427466391932003059921\u0026hellip;\nå…¶ä¸­ç²—ä½“æ ‡å‡ºçš„ 10 ä½æ•°å°±æ˜¯ç­”æ¡ˆã€‚\næœ¬é¢˜è¦æ±‚ä½ ç¼–ç¨‹è§£å†³ä¸€ä¸ªæ›´é€šç”¨çš„é—®é¢˜ï¼šä»ä»»ä¸€ç»™å®šçš„é•¿åº¦ä¸º L çš„æ•°å­—ä¸­ï¼Œæ‰¾å‡ºæœ€æ—©å‡ºç°çš„ K ä½è¿ç»­æ•°å­—æ‰€ç»„æˆçš„ç´ æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º 2 ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ Lï¼ˆä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ï¼Œä¸ºæ•°å­—é•¿åº¦ï¼‰å’Œ Kï¼ˆå°äº 10 çš„æ­£æ•´æ•°ï¼‰ã€‚æ¥ä¸‹æ¥ä¸€è¡Œç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º L çš„æ­£æ•´æ•° Nã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡º N ä¸­æœ€æ—©å‡ºç°çš„ K ä½è¿ç»­æ•°å­—æ‰€ç»„æˆçš„ç´ æ•°ã€‚å¦‚æœè¿™æ ·çš„ç´ æ•°ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º 404ã€‚æ³¨æ„ï¼ŒåŸå§‹æ•°å­—ä¸­çš„å‰å¯¼é›¶ä¹Ÿè®¡ç®—åœ¨ä½æ•°ä¹‹å†…ã€‚ä¾‹å¦‚åœ¨ 200236 ä¸­æ‰¾ 4 ä½ç´ æ•°ï¼Œ0023 ç®—æ˜¯è§£ï¼›ä½†ç¬¬ä¸€ä½ 2 ä¸èƒ½è¢«å½“æˆ 0002 è¾“å‡ºï¼Œå› ä¸ºåœ¨åŸå§‹æ•°å­—ä¸­ä¸å­˜åœ¨è¿™ä¸ª 2 çš„å‰å¯¼é›¶ã€‚\næ ·ä¾‹è¾“å…¥1 120 5 223654987725541023819 æ ·ä¾‹è¾“å‡º1 149877 æ ·ä¾‹è¾“å…¥2 110 3 22468024680 æ ·ä¾‹è¾“å‡º2 1404 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn]; 3 4bool isPrime(int n) 5{ 6 if (n == 0 || n == 1) return 0; 7 if (n == 2 || n == 3) return 1; 8 if (n % 6 != 1 \u0026amp;\u0026amp; n % 6 != 5) return 0; 9 10 int m = sqrt(n); 11 for (int i = 5; i \u0026lt;= m; i += 6) 12 { 13 if (n % i == 0 || n % (i + 2) == 0) 14 return 0; 15 } 16 return 1; 17} 18 19int main() 20{ 21 int L, K; 22 scanf(\u0026#34;%d %d %s\u0026#34;, \u0026amp;L, \u0026amp;K, s); 23 24 int f = 1; 25 for(int i=0; i\u0026lt;=L-K; i++) 26 { 27 int t; char a[15]; 28 memset(a, 0, sizeof a); 29 strncpy(a, s+i, K); 30 sscanf(a, \u0026#34;%d\u0026#34;, \u0026amp;t); 31 if(isPrime(t)) 32 { 33 printf(\u0026#34;%s\\n\u0026#34;, a); 34 f = 0; 35 break; 36 } 37 } 38 39 if(f) 40 printf(\u0026#34;404\\n\u0026#34;); 41 42 return 0; 43} ","permalink":"https://blog.lordash.de/posts/solution/patb-1094-%E8%B0%B7%E6%AD%8C%E7%9A%84%E6%8B%9B%E8%81%98/","summary":"è°·æ­Œçš„æ‹›è˜ (PATB-1094) é¢˜é¢ 2004 å¹´ 7 æœˆï¼Œè°·æ­Œåœ¨ç¡…è°·çš„ 101 å·å…¬è·¯è¾¹ç«–ç«‹äº†ä¸€å—å·¨å¤§çš„å¹¿å‘Šç‰Œï¼ˆå¦‚ä¸‹å›¾ï¼‰ç”¨äºæ‹›è˜ã€‚å†…å®¹è¶…çº§ç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªä»¥ .com ç»“å°¾çš„ç½‘å€ï¼Œè€Œå‰é¢çš„ç½‘å€","title":"PATB-1094 è°·æ­Œçš„æ‹›è˜"},{"content":"å­—ç¬¦ä¸²A+B (PATB-1093) é¢˜é¢ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² A å’Œ Bï¼Œæœ¬é¢˜è¦æ±‚ä½ è¾“å‡º A+Bï¼Œå³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å¹¶é›†ã€‚è¦æ±‚å…ˆè¾“å‡º Aï¼Œå†è¾“å‡º Bï¼Œä½†é‡å¤çš„å­—ç¬¦å¿…é¡»è¢«å‰”é™¤ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸¤è¡Œä¸­åˆ†åˆ«ç»™å‡º A å’Œ Bï¼Œå‡ä¸ºé•¿åº¦ä¸è¶…è¿‡ 10^6çš„ã€ç”±å¯è§ ASCII å­—ç¬¦ (å³ç å€¼ä¸º32~126)å’Œç©ºæ ¼ç»„æˆçš„ã€ç”±å›è½¦æ ‡è¯†ç»“æŸçš„éç©ºå­—ç¬¦ä¸²ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºé¢˜é¢è¦æ±‚çš„ A å’Œ B çš„å’Œã€‚\næ ·ä¾‹è¾“å…¥ 1This is a sample test 2to show you_How it works æ ·ä¾‹è¾“å‡º 1This ampletowyu_Hrk æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4int main() 5{ 6 for(int i=0; i\u0026lt;2; i++) 7 { 8 char c; 9 while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;c) \u0026amp;\u0026amp; c!=\u0026#39;\\n\u0026#39;) 10 { 11 if(a[c] == 0) 12 { 13 printf(\u0026#34;%c\u0026#34;, c); 14 a[c] = 1; 15 } 16 } 17 } 18 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/patb-1093-%E5%AD%97%E7%AC%A6%E4%B8%B2a+b/","summary":"å­—ç¬¦ä¸²A+B (PATB-1093) é¢˜é¢ ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸² A å’Œ Bï¼Œæœ¬é¢˜è¦æ±‚ä½ è¾“å‡º A+Bï¼Œå³ä¸¤ä¸ªå­—ç¬¦ä¸²çš„å¹¶é›†ã€‚è¦æ±‚å…ˆè¾“å‡º Aï¼Œå†è¾“å‡º Bï¼Œä½†é‡å¤çš„å­—ç¬¦å¿…é¡»è¢«å‰”é™¤ã€‚ è¾“å…¥ è¾“å…¥åœ¨","title":"PATB-1093 å­—ç¬¦ä¸²A+B"},{"content":"æœ€å¥½åƒçš„æœˆé¥¼ (PATB-1092) é¢˜é¢ æœˆé¥¼æ˜¯ä¹…è´Ÿç››åçš„ä¸­å›½ä¼ ç»Ÿç³•ç‚¹ä¹‹ä¸€ï¼Œè‡ªå”æœä»¥æ¥ï¼Œå·²ç»å‘å±•å‡ºå‡ ç™¾å“ç§ã€‚\nè‹¥æƒ³è¯„æ¯”å‡ºä¸€ç§â€œæœ€å¥½åƒâ€çš„æœˆé¥¼ï¼Œé‚£åŠ¿å¿…åœ¨åƒè´§ç•Œå¼•å‘ä¸€åœºè…¥é£è¡€é›¨â€¦â€¦ åœ¨è¿™é‡Œæˆ‘ä»¬ç”¨æ•°å­—è¯´è¯ï¼Œç»™å‡ºå…¨å›½å„åœ°å„ç§æœˆé¥¼çš„é”€é‡ï¼Œè¦æ±‚ä½ ä»ä¸­æ‰¾å‡ºé”€é‡å† å†›ï¼Œè®¤å®šä¸ºæœ€å¥½åƒçš„æœˆé¥¼ã€‚\nè¾“å…¥ è¾“å…¥é¦–å…ˆç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«ä¸ºæœˆé¥¼çš„ç§ç±»æ•°ï¼ˆäºæ˜¯é»˜è®¤æœˆé¥¼ç§ç±»ä» 1 åˆ° N ç¼–å·ï¼‰å’Œå‚ä¸ç»Ÿè®¡çš„åŸå¸‚æ•°é‡ã€‚\næ¥ä¸‹æ¥ M è¡Œï¼Œæ¯è¡Œç»™å‡º N ä¸ªéè´Ÿæ•´æ•°ï¼ˆå‡ä¸è¶…è¿‡ 1 ç™¾ä¸‡ï¼‰ï¼Œå…¶ä¸­ç¬¬ i ä¸ªæ•´æ•°ä¸ºç¬¬ i ç§æœˆé¥¼çš„é”€é‡ï¼ˆå—ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ç¬¬ä¸€è¡Œä¸­è¾“å‡ºæœ€å¤§é”€é‡ï¼Œç¬¬äºŒè¡Œè¾“å‡ºé”€é‡æœ€å¤§çš„æœˆé¥¼çš„ç§ç±»ç¼–å·ã€‚å¦‚æœå† å†›ä¸å”¯ä¸€ï¼Œåˆ™æŒ‰ç¼–å·é€’å¢é¡ºåºè¾“å‡ºå¹¶åˆ—å† å†›ã€‚æ•°å­—é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 15 3 21001 992 0 233 6 38 0 2018 0 2008 436 18 0 1024 4 æ ·ä¾‹è¾“å‡º 12018 23 5 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4int main() 5{ 6 int n, m; 7 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 8 9 while(m--) 10 { 11 for(int i=1; i\u0026lt;=n; i++) 12 { 13 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 14 a[i] += t; 15 } 16 } 17 18 int mx = 0; 19 for(int i=1; i\u0026lt;=n; i++) 20 mx = max(mx, a[i]); 21 22 printf(\u0026#34;%d\\n\u0026#34;, mx); 23 24 int nf = 0; 25 for(int i=1; i\u0026lt;=n; i++) 26 { 27 if(a[i] == mx) 28 { 29 if(nf) 30 printf(\u0026#34; \u0026#34;); 31 else 32 nf = 1; 33 printf(\u0026#34;%d\u0026#34;, i); 34 } 35 } 36 37 return 0; 38} ","permalink":"https://blog.lordash.de/posts/solution/patb-1092-%E6%9C%80%E5%A5%BD%E5%90%83%E7%9A%84%E6%9C%88%E9%A5%BC/","summary":"æœ€å¥½åƒçš„æœˆé¥¼ (PATB-1092) é¢˜é¢ æœˆé¥¼æ˜¯ä¹…è´Ÿç››åçš„ä¸­å›½ä¼ ç»Ÿç³•ç‚¹ä¹‹ä¸€ï¼Œè‡ªå”æœä»¥æ¥ï¼Œå·²ç»å‘å±•å‡ºå‡ ç™¾å“ç§ã€‚ è‹¥æƒ³è¯„æ¯”å‡ºä¸€ç§â€œæœ€å¥½åƒâ€çš„æœˆé¥¼ï¼Œé‚£åŠ¿å¿…åœ¨åƒè´§ç•Œå¼•å‘ä¸€åœºè…¥","title":"PATB-1092 æœ€å¥½åƒçš„æœˆé¥¼"},{"content":"N-è‡ªå®ˆæ•° (PATB-1091) é¢˜é¢ å¦‚æœæŸä¸ªæ•° K çš„å¹³æ–¹ä¹˜ä»¥ N ä»¥åï¼Œç»“æœçš„æœ«å°¾å‡ ä½æ•°ç­‰äº Kï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸ªæ•°ä¸ºâ€œN-è‡ªå®ˆæ•°â€ã€‚ä¾‹å¦‚ 3Ã—922=25392ï¼Œè€Œ 25392 çš„æœ«å°¾ä¸¤ä½æ­£å¥½æ˜¯ 92ï¼Œæ‰€ä»¥ 92 æ˜¯ä¸€ä¸ª 3-è‡ªå®ˆæ•°ã€‚\næœ¬é¢˜å°±è¯·ä½ ç¼–å†™ç¨‹åºåˆ¤æ–­ä¸€ä¸ªç»™å®šçš„æ•°å­—æ˜¯å¦å…³äºæŸä¸ª N æ˜¯ N-è‡ªå®ˆæ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºæ­£æ•´æ•° Mï¼ˆâ‰¤20ï¼‰ï¼Œéšåä¸€è¡Œç»™å‡º M ä¸ªå¾…æ£€æµ‹çš„ã€ä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªéœ€è¦æ£€æµ‹çš„æ•°å­—ï¼Œå¦‚æœå®ƒæ˜¯ N-è‡ªå®ˆæ•°å°±åœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€å°çš„ N å’Œ NK2 çš„å€¼ï¼Œä»¥ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼›å¦åˆ™è¾“å‡º Noã€‚æ³¨æ„é¢˜ç›®ä¿è¯ N\u0026lt;10ã€‚\næ ·ä¾‹è¾“å…¥ 13 292 5 233 æ ·ä¾‹è¾“å‡º 13 25392 21 25 3No æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 5 while(n--) 6 { 7 int m, f=1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 8 for(int i=1; i\u0026lt;=9; i++) 9 { 10 int x = i * m * m; 11 char s[20], t[20]; 12 sprintf(s, \u0026#34;%d\u0026#34;, x); 13 sprintf(t, \u0026#34;%d\u0026#34;, m); 14 15 if(strcmp(s+strlen(s)-strlen(t), t) == 0) 16 { 17 printf(\u0026#34;%d %d\\n\u0026#34;, i, x); 18 f = 0; 19 break; 20 } 21 } 22 if(f) printf(\u0026#34;No\\n\u0026#34;); 23 } 24 25 return 0; 26} ","permalink":"https://blog.lordash.de/posts/solution/patb-1091-n-%E8%87%AA%E5%AE%88%E6%95%B0/","summary":"N-è‡ªå®ˆæ•° (PATB-1091) é¢˜é¢ å¦‚æœæŸä¸ªæ•° K çš„å¹³æ–¹ä¹˜ä»¥ N ä»¥åï¼Œç»“æœçš„æœ«å°¾å‡ ä½æ•°ç­‰äº Kï¼Œé‚£ä¹ˆå°±ç§°è¿™ä¸ªæ•°ä¸ºâ€œN-è‡ªå®ˆæ•°â€ã€‚ä¾‹å¦‚ 3Ã—922=25392ï¼Œè€Œ 25392 çš„æœ«å°¾","title":"PATB-1091 N-è‡ªå®ˆæ•°"},{"content":"å±é™©å“è£…ç®± (PATB-1090) é¢˜é¢ é›†è£…ç®±è¿è¾“è´§ç‰©æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç‰¹åˆ«å°å¿ƒï¼Œä¸èƒ½æŠŠä¸ç›¸å®¹çš„è´§ç‰©è£…åœ¨ä¸€åªç®±å­é‡Œã€‚æ¯”å¦‚æ°§åŒ–å‰‚ç»å¯¹ä¸èƒ½è·Ÿæ˜“ç‡ƒæ¶²ä½“åŒç®±ï¼Œå¦åˆ™å¾ˆå®¹æ˜“é€ æˆçˆ†ç‚¸ã€‚\næœ¬é¢˜ç»™å®šä¸€å¼ ä¸ç›¸å®¹ç‰©å“çš„æ¸…å•ï¼Œéœ€è¦ä½ æ£€æŸ¥æ¯ä¸€å¼ é›†è£…ç®±è´§å“æ¸…å•ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯å¦èƒ½è£…åœ¨åŒä¸€åªç®±å­é‡Œã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•°ï¼šN (â‰¤104) æ˜¯æˆå¯¹çš„ä¸ç›¸å®¹ç‰©å“çš„å¯¹æ•°ï¼›M (â‰¤100) æ˜¯é›†è£…ç®±è´§å“æ¸…å•çš„å•æ•°ã€‚\néšåæ•°æ®åˆ†ä¸¤å¤§å—ç»™å‡ºã€‚ç¬¬ä¸€å—æœ‰ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹ä¸ç›¸å®¹çš„ç‰©å“ã€‚ç¬¬äºŒå—æœ‰ M è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ç®±è´§ç‰©çš„æ¸…å•ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n1K G[1] G[2] ... G[K] å…¶ä¸­ K (â‰¤1000) æ˜¯ç‰©å“ä»¶æ•°ï¼ŒG[i] æ˜¯ç‰©å“çš„ç¼–å·ã€‚ç®€å•èµ·è§ï¼Œæ¯ä»¶ç‰©å“ç”¨ä¸€ä¸ª 5 ä½æ•°çš„ç¼–å·ä»£è¡¨ã€‚ä¸¤ä¸ªæ•°å­—ä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹æ¯ç®±è´§ç‰©æ¸…å•ï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥å®‰å…¨è¿è¾“ã€‚å¦‚æœæ²¡æœ‰ä¸ç›¸å®¹ç‰©å“ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º Yesï¼Œå¦åˆ™è¾“å‡º Noã€‚\næ ·ä¾‹è¾“å…¥ 16 3 220001 20002 320003 20004 420005 20006 520003 20001 620005 20004 720004 20006 84 00001 20004 00002 20003 95 98823 20002 20003 20006 10010 103 12345 67890 23333 æ ·ä¾‹è¾“å‡º 1No 2Yes 3Yes æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2 3int a[mxn]; 4 5int main() 6{ 7 int n, m; 8 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 9 10 map\u0026lt;int, vector\u0026lt;int\u0026gt; \u0026gt; mmp; 11 12 for (int i=0; i\u0026lt;n; i++) 13 { 14 int x, y; 15 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); 16 mmp[x].push_back(y); 17 mmp[y].push_back(x); 18 } 19 20 while (m--) 21 { 22 memset(a, 0, sizeof a); 23 int k; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); 24 25 vector\u0026lt;int\u0026gt; v(k); 26 for (int i=0; i\u0026lt;k; i++) 27 { 28 scanf(\u0026#34;%d\u0026#34;, \u0026amp;v[i]); 29 a[v[i]] = 1; 30 } 31 32 int f = 0; 33 for (int i=0; i\u0026lt;v.size(); i++) 34 { 35 for (int j=0; j\u0026lt;mmp[v[i]].size(); j++) 36 { 37 if (a[mmp[v[i]][j]]) 38 { 39 f = 1; 40 break; 41 } 42 } 43 if(f) break; 44 } 45 printf(\u0026#34;%s\\n\u0026#34;, f ? \u0026#34;No\u0026#34; :\u0026#34;Yes\u0026#34;); 46 } 47 48 return 0; 49} ","permalink":"https://blog.lordash.de/posts/solution/patb-1090-%E5%8D%B1%E9%99%A9%E5%93%81%E8%A3%85%E7%AE%B1/","summary":"å±é™©å“è£…ç®± (PATB-1090) é¢˜é¢ é›†è£…ç®±è¿è¾“è´§ç‰©æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç‰¹åˆ«å°å¿ƒï¼Œä¸èƒ½æŠŠä¸ç›¸å®¹çš„è´§ç‰©è£…åœ¨ä¸€åªç®±å­é‡Œã€‚æ¯”å¦‚æ°§åŒ–å‰‚ç»å¯¹ä¸èƒ½è·Ÿæ˜“ç‡ƒæ¶²ä½“åŒç®±ï¼Œå¦åˆ™å¾ˆå®¹æ˜“é€ æˆçˆ†ç‚¸ã€‚","title":"PATB-1090 å±é™©å“è£…ç®±"},{"content":"ç‹¼äººæ€-ç®€å•ç‰ˆ (PATB-1089) é¢˜é¢ ä»¥ä¸‹æ–‡å­—æ‘˜è‡ªã€Šçµæœºä¸€åŠ¨Â·å¥½ç©çš„æ•°å­¦ã€‹ï¼šâ€œç‹¼äººæ€â€æ¸¸æˆåˆ†ä¸ºç‹¼äººã€å¥½äººä¸¤å¤§é˜µè¥ã€‚åœ¨ä¸€å±€â€œç‹¼äººæ€â€æ¸¸æˆä¸­ï¼Œ1 å·ç©å®¶è¯´ï¼šâ€œ2 å·æ˜¯ç‹¼äººâ€ï¼Œ2 å·ç©å®¶è¯´ï¼šâ€œ3 å·æ˜¯å¥½äººâ€ï¼Œ3 å·ç©å®¶è¯´ï¼šâ€œ4 å·æ˜¯ç‹¼äººâ€ï¼Œ4 å·ç©å®¶è¯´ï¼šâ€œ5 å·æ˜¯å¥½äººâ€ï¼Œ5 å·ç©å®¶è¯´ï¼šâ€œ4 å·æ˜¯å¥½äººâ€ã€‚å·²çŸ¥è¿™ 5 åç©å®¶ä¸­æœ‰ 2 äººæ‰®æ¼”ç‹¼äººè§’è‰²ï¼Œæœ‰ 2 äººè¯´çš„ä¸æ˜¯å®è¯ï¼Œæœ‰ç‹¼äººæ’’è°ä½†å¹¶ä¸æ˜¯æ‰€æœ‰ç‹¼äººéƒ½åœ¨æ’’è°ã€‚æ‰®æ¼”ç‹¼äººè§’è‰²çš„æ˜¯å“ªä¸¤å·ç©å®¶ï¼Ÿ\næœ¬é¢˜æ˜¯è¿™ä¸ªé—®é¢˜çš„å‡çº§ç‰ˆï¼šå·²çŸ¥ N åç©å®¶ä¸­æœ‰ 2 äººæ‰®æ¼”ç‹¼äººè§’è‰²ï¼Œæœ‰ 2 äººè¯´çš„ä¸æ˜¯å®è¯ï¼Œæœ‰ç‹¼äººæ’’è°ä½†å¹¶ä¸æ˜¯æ‰€æœ‰ç‹¼äººéƒ½åœ¨æ’’è°ã€‚è¦æ±‚ä½ æ‰¾å‡ºæ‰®æ¼”ç‹¼äººè§’è‰²çš„æ˜¯å“ªå‡ å·ç©å®¶ï¼Ÿ\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆ5â‰¤Nâ‰¤100ï¼‰ã€‚éšå N è¡Œï¼Œç¬¬ i è¡Œç»™å‡ºç¬¬ i å·ç©å®¶è¯´çš„è¯ï¼ˆ1â‰¤iâ‰¤Nï¼‰ï¼Œå³ä¸€ä¸ªç©å®¶ç¼–å·ï¼Œç”¨æ­£å·è¡¨ç¤ºå¥½äººï¼Œè´Ÿå·è¡¨ç¤ºç‹¼äººã€‚\nè¾“å‡º å¦‚æœæœ‰è§£ï¼Œåœ¨ä¸€è¡Œä¸­æŒ‰é€’å¢é¡ºåºè¾“å‡º 2 ä¸ªç‹¼äººçš„ç¼–å·ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚å¦‚æœè§£ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºæœ€å°åºåˆ—è§£ â€”â€” å³å¯¹äºä¸¤ä¸ªåºåˆ— A=a[1],\u0026hellip;,a[M] å’Œ B=b[1],\u0026hellip;,b[M]ï¼Œè‹¥å­˜åœ¨ 0â‰¤k\u0026lt;M ä½¿å¾— a[i]=b[i] ï¼ˆiâ‰¤kï¼‰ï¼Œä¸” a[k+1]\u0026lt;b[k+1]ï¼Œåˆ™ç§°åºåˆ— A å°äºåºåˆ— Bã€‚è‹¥æ— è§£åˆ™è¾“å‡º No Solutionã€‚\næ ·ä¾‹è¾“å…¥1 15 2-2 3+3 4-4 5+5 6+4 æ ·ä¾‹è¾“å‡º1 11 4 æ ·ä¾‹è¾“å…¥2 16 2+6 3+3 4+1 5-5 6-2 7+4 æ ·ä¾‹è¾“å‡º2 11 5 æ ·ä¾‹è¾“å…¥3 15 2-2 3-3 4-4 5-5 6-1 æ ·ä¾‹è¾“å‡º3 1No Solution æç¤º æ ·ä¾‹2è§£ä¸å”¯ä¸€\næ€è·¯ ä»£ç  1#define Sg(u) ((u) \u0026gt; eps ? 1 : ((u) \u0026lt; -eps ? -1 : 0)) 2#define Abs(u) (Sg(u) \u0026gt;= 0 ? (u) : -(u)) 3const DB eps = 1e-8; 4 5const int mxn = 1e5 + 5; 6 7int a[mxn], ok[mxn], lie[mxn]; 8 9int main() 10{ 11 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 12 13 for (int i=1; i\u0026lt;=n; i++) 14 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 15 16 for(int i=1; i\u0026lt;=n; i++) 17 { 18 for(int j=i+1; j\u0026lt;=n; j++) 19 { 20 for(int k=1; k\u0026lt;=n; k++) 21 ok[k] = 1; 22 ok[i] = ok[j] = -1; 23 24 int num = 0; 25 for(int k=1; k\u0026lt;=n; k++) 26 { 27 if(a[k] * ok[Abs(a[k])] \u0026lt; 0) 28 lie[num++] = k; 29 } 30 31 if(num == 2 \u0026amp;\u0026amp; ok[lie[0]] + ok[lie[1]] == 0) 32 { 33 printf(\u0026#34;%d %d\\n\u0026#34;, i, j); 34 return 0; 35 } 36 } 37 } 38 printf(\u0026#34;No Solution\\n\u0026#34;); 39 40 return 0; 41} ","permalink":"https://blog.lordash.de/posts/solution/patb-1089-%E7%8B%BC%E4%BA%BA%E6%9D%80-%E7%AE%80%E5%8D%95%E7%89%88/","summary":"ç‹¼äººæ€-ç®€å•ç‰ˆ (PATB-1089) é¢˜é¢ ä»¥ä¸‹æ–‡å­—æ‘˜è‡ªã€Šçµæœºä¸€åŠ¨Â·å¥½ç©çš„æ•°å­¦ã€‹ï¼šâ€œç‹¼äººæ€â€æ¸¸æˆåˆ†ä¸ºç‹¼äººã€å¥½äººä¸¤å¤§é˜µè¥ã€‚åœ¨ä¸€å±€â€œç‹¼äººæ€â€æ¸¸æˆä¸­ï¼Œ1 å·ç©å®¶è¯´ï¼šâ€œ2 å·æ˜¯","title":"PATB-1089 ç‹¼äººæ€-ç®€å•ç‰ˆ"},{"content":"ä¸‰äººè¡Œ (PATB-1088) é¢˜é¢ å­æ›°ï¼šâ€œä¸‰äººè¡Œï¼Œå¿…æœ‰æˆ‘å¸ˆç„‰ã€‚æ‹©å…¶å–„è€…è€Œä»ä¹‹ï¼Œå…¶ä¸å–„è€…è€Œæ”¹ä¹‹ã€‚â€\næœ¬é¢˜ç»™å®šç”²ã€ä¹™ã€ä¸™ä¸‰ä¸ªäººçš„èƒ½åŠ›å€¼å…³ç³»ä¸ºï¼šç”²çš„èƒ½åŠ›å€¼ç¡®å®šæ˜¯ 2 ä½æ­£æ•´æ•°ï¼›æŠŠç”²çš„èƒ½åŠ›å€¼çš„ 2 ä¸ªæ•°å­—è°ƒæ¢ä½ç½®å°±æ˜¯ä¹™çš„èƒ½åŠ›å€¼ï¼›ç”²ä¹™ä¸¤äººèƒ½åŠ›å·®æ˜¯ä¸™çš„èƒ½åŠ›å€¼çš„ X å€ï¼›ä¹™çš„èƒ½åŠ›å€¼æ˜¯ä¸™çš„ Y å€ã€‚è¯·ä½ æŒ‡å‡ºè°æ¯”ä½ å¼ºåº”â€œä»ä¹‹â€ï¼Œè°æ¯”ä½ å¼±åº”â€œæ”¹ä¹‹â€ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸‰ä¸ªæ•°ï¼Œä¾æ¬¡ä¸ºï¼šMï¼ˆä½ è‡ªå·±çš„èƒ½åŠ›å€¼ï¼‰ã€X å’Œ Yã€‚ä¸‰ä¸ªæ•°å­—å‡ä¸ºä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•°ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­é¦–å…ˆè¾“å‡ºç”²çš„èƒ½åŠ›å€¼ï¼Œéšåä¾æ¬¡è¾“å‡ºç”²ã€ä¹™ã€ä¸™ä¸‰äººä¸ä½ çš„å…³ç³»ï¼šå¦‚æœå…¶æ¯”ä½ å¼ºï¼Œè¾“å‡º Congï¼›å¹³ç­‰åˆ™è¾“å‡º Pingï¼›æ¯”ä½ å¼±åˆ™è¾“å‡º Gaiã€‚å…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ³¨æ„ï¼šå¦‚æœè§£ä¸å”¯ä¸€ï¼Œåˆ™ä»¥ç”²çš„æœ€å¤§è§£ä¸ºå‡†è¿›è¡Œåˆ¤æ–­ï¼›å¦‚æœè§£ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º No Solutionã€‚\næ ·ä¾‹è¾“å…¥1 148 3 7 æ ·ä¾‹è¾“å‡º1 148 Ping Cong Gai æ ·ä¾‹è¾“å…¥2 148 11 6 æ ·ä¾‹è¾“å‡º2 1No Solution æç¤º æ— \næ€è·¯ ä»£ç  1#define Sg(u) ((u) \u0026gt; eps ? 1 : ((u) \u0026lt; -eps ? -1 : 0)) 2#define Abs(u) (Sg(u) \u0026gt;= 0 ? (u) : -(u)) 3typedef double DB; 4const DB eps = 1e-8; 5 6char s[][5] = {\u0026#34;Cong\u0026#34;, \u0026#34;Ping\u0026#34;, \u0026#34;Gai\u0026#34;}; 7 8int main() 9{ 10 int m, x, y; 11 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;m, \u0026amp;x, \u0026amp;y); 12 13 int a, b, f = 0; DB c; 14 for(int i=99; i\u0026gt;=10; i--) 15 { 16 int j = i%10 * 10 + i/10; 17 if(Abs(i-j)*y == j*x) 18 { 19 a = i, b = j, c = 1.0*Abs(i-j)/x; 20 f = 1; 21 break; 22 } 23 } 24 if(f) 25 printf(\u0026#34;%d %s %s %s\\n\u0026#34;, a, s[Sg(m-a)+1], s[Sg(m-b)+1], s[Sg(m-c)+1]); 26 else 27 printf(\u0026#34;No Solution\\n\u0026#34;); 28 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/patb-1088-%E4%B8%89%E4%BA%BA%E8%A1%8C/","summary":"ä¸‰äººè¡Œ (PATB-1088) é¢˜é¢ å­æ›°ï¼šâ€œä¸‰äººè¡Œï¼Œå¿…æœ‰æˆ‘å¸ˆç„‰ã€‚æ‹©å…¶å–„è€…è€Œä»ä¹‹ï¼Œå…¶ä¸å–„è€…è€Œæ”¹ä¹‹ã€‚â€ æœ¬é¢˜ç»™å®šç”²ã€ä¹™ã€ä¸™ä¸‰ä¸ªäººçš„èƒ½åŠ›å€¼å…³ç³»ä¸ºï¼šç”²çš„èƒ½åŠ›å€¼ç¡®å®šæ˜¯ 2 ä½æ­£æ•´æ•°","title":"PATB-1088 ä¸‰äººè¡Œ"},{"content":"æœ‰å¤šå°‘ä¸åŒçš„å€¼ (PATB-1087) é¢˜é¢ å½“è‡ªç„¶æ•° n ä¾æ¬¡å– 1ã€2ã€3ã€â€¦â€¦ã€N æ—¶ï¼Œç®—å¼ âŒŠn/2âŒ‹+âŒŠn/3âŒ‹+âŒŠn/5âŒ‹ æœ‰å¤šå°‘ä¸ªä¸åŒçš„å€¼ï¼Ÿï¼ˆæ³¨ï¼šâŒŠxâŒ‹ ä¸ºå–æ•´å‡½æ•°ï¼Œè¡¨ç¤ºä¸è¶…è¿‡ x çš„æœ€å¤§è‡ªç„¶æ•°ï¼Œå³ x çš„æ•´æ•°éƒ¨åˆ†ã€‚ï¼‰\nè¾“å…¥ è¾“å…¥ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆ2â‰¤Nâ‰¤104ï¼‰ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºé¢˜é¢ä¸­ç®—å¼å–åˆ°çš„ä¸åŒå€¼çš„ä¸ªæ•°ã€‚\næ ·ä¾‹è¾“å…¥ 12017 æ ·ä¾‹è¾“å‡º 11480 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 set\u0026lt;int\u0026gt; sst; 5 for(int i=1; i\u0026lt;=n; i++) 6 sst.insert(i/2 + i/3 + i/5); 7 8 printf(\u0026#34;%d\\n\u0026#34;, sst.size()); 9 10 return 0; 11} ","permalink":"https://blog.lordash.de/posts/solution/patb-1087-%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC/","summary":"æœ‰å¤šå°‘ä¸åŒçš„å€¼ (PATB-1087) é¢˜é¢ å½“è‡ªç„¶æ•° n ä¾æ¬¡å– 1ã€2ã€3ã€â€¦â€¦ã€N æ—¶ï¼Œç®—å¼ âŒŠn/2âŒ‹+âŒŠn/3âŒ‹+âŒŠn/5âŒ‹ æœ‰å¤šå°‘ä¸ªä¸åŒçš„å€¼ï¼Ÿï¼ˆæ³¨ï¼šâŒŠxâŒ‹ ä¸ºå–æ•´å‡½æ•°ï¼Œ","title":"PATB-1087 æœ‰å¤šå°‘ä¸åŒçš„å€¼"},{"content":"å°±ä¸å‘Šè¯‰ä½  (PATB-1086) é¢˜é¢ åšä½œä¸šçš„æ—¶å€™ï¼Œé‚»åº§çš„å°ç›†å‹é—®ä½ ï¼šâ€œäº”ä¹˜ä»¥ä¸ƒç­‰äºå¤šå°‘ï¼Ÿâ€ä½ åº”è¯¥ä¸å¤±ç¤¼è²Œåœ°å›´ç¬‘ç€å‘Šè¯‰ä»–ï¼šâ€œäº”åä¸‰ã€‚â€æœ¬é¢˜å°±è¦æ±‚ä½ ï¼Œå¯¹ä»»ä½•ä¸€å¯¹ç»™å®šçš„æ­£æ•´æ•°ï¼Œå€’ç€è¾“å‡ºå®ƒä»¬çš„ä¹˜ç§¯ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° A å’Œ Bï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­å€’ç€è¾“å‡º A å’Œ B çš„ä¹˜ç§¯ã€‚\næ ·ä¾‹è¾“å…¥ 15 7 æ ·ä¾‹è¾“å‡º 153 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int a, b, c, d=0; 4 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); 5 c = a * b; 6 7 while(c) 8 { 9 d = d * 10 + c%10; 10 c /= 10; 11 } 12 printf(\u0026#34;%d\\n\u0026#34;, d); 13 14 return 0; 15} ","permalink":"https://blog.lordash.de/posts/solution/patb-1086-%E5%B0%B1%E4%B8%8D%E5%91%8A%E8%AF%89%E4%BD%A0/","summary":"å°±ä¸å‘Šè¯‰ä½  (PATB-1086) é¢˜é¢ åšä½œä¸šçš„æ—¶å€™ï¼Œé‚»åº§çš„å°ç›†å‹é—®ä½ ï¼šâ€œäº”ä¹˜ä»¥ä¸ƒç­‰äºå¤šå°‘ï¼Ÿâ€ä½ åº”è¯¥ä¸å¤±ç¤¼è²Œåœ°å›´ç¬‘ç€å‘Šè¯‰ä»–ï¼šâ€œäº”åä¸‰ã€‚â€æœ¬é¢˜å°±è¦æ±‚ä½ ï¼Œå¯¹ä»»ä½•ä¸€å¯¹ç»™å®š","title":"PATB-1086 å°±ä¸å‘Šè¯‰ä½ "},{"content":"PATå•ä½æ’è¡Œ (PATB-1085) é¢˜é¢ æ¯æ¬¡ PAT è€ƒè¯•ç»“æŸåï¼Œè€ƒè¯•ä¸­å¿ƒéƒ½ä¼šå‘å¸ƒä¸€ä¸ªè€ƒç”Ÿå•ä½æ’è¡Œæ¦œã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤105ï¼‰ï¼Œå³è€ƒç”Ÿäººæ•°ã€‚éšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ä¸‹åˆ—æ ¼å¼ç»™å‡ºä¸€ä¸ªè€ƒç”Ÿçš„ä¿¡æ¯ï¼š\n1å‡†è€ƒè¯å· å¾—åˆ† å­¦æ ¡ å…¶ä¸­å‡†è€ƒè¯å·æ˜¯ç”± 6 ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå…¶é¦–å­—æ¯è¡¨ç¤ºè€ƒè¯•çš„çº§åˆ«ï¼šBä»£è¡¨ä¹™çº§ï¼ŒAä»£è¡¨ç”²çº§ï¼ŒTä»£è¡¨é¡¶çº§ï¼›å¾—åˆ†æ˜¯ [0, 100] åŒºé—´å†…çš„æ•´æ•°ï¼›å­¦æ ¡æ˜¯ç”±ä¸è¶…è¿‡ 6 ä¸ªè‹±æ–‡å­—æ¯ç»„æˆçš„å•ä½ç ï¼ˆå¤§å°å†™æ— å…³ï¼‰ã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯æ¯ä¸ªè€ƒç”Ÿçš„å‡†è€ƒè¯å·æ˜¯ä¸åŒçš„ã€‚\nè¾“å‡º é¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡ºå•ä½ä¸ªæ•°ã€‚éšåæŒ‰ä»¥ä¸‹æ ¼å¼éé™åºè¾“å‡ºå•ä½çš„æ’è¡Œæ¦œï¼š\n1æ’å å­¦æ ¡ åŠ æƒæ€»åˆ† è€ƒç”Ÿäººæ•° å…¶ä¸­æ’åæ˜¯è¯¥å•ä½çš„æ’åï¼ˆä» 1 å¼€å§‹ï¼‰ï¼›å­¦æ ¡æ˜¯å…¨éƒ¨æŒ‰å°å†™å­—æ¯è¾“å‡ºçš„å•ä½ç ï¼›åŠ æƒæ€»åˆ†å®šä¹‰ä¸ºä¹™çº§æ€»åˆ†/1.5 + ç”²çº§æ€»åˆ† + é¡¶çº§æ€»åˆ†*1.5çš„æ•´æ•°éƒ¨åˆ†ï¼›è€ƒç”Ÿäººæ•°æ˜¯è¯¥å±äºå•ä½çš„è€ƒç”Ÿçš„æ€»äººæ•°ã€‚\nå­¦æ ¡é¦–å…ˆæŒ‰åŠ æƒæ€»åˆ†æ’è¡Œã€‚å¦‚æœ‰å¹¶åˆ—ï¼Œåˆ™åº”å¯¹åº”ç›¸åŒçš„æ’åï¼Œå¹¶æŒ‰è€ƒç”Ÿäººæ•°å‡åºè¾“å‡ºã€‚å¦‚æœä»ç„¶å¹¶åˆ—ï¼Œåˆ™æŒ‰å•ä½ç çš„å­—å…¸åºè¾“å‡ºã€‚\næ ·ä¾‹è¾“å…¥ 110 2A57908 85 Au 3B57908 54 LanX 4A37487 60 au 5T28374 67 CMU 6T32486 24 hypu 7A66734 92 cmu 8B76378 71 AU 9A47780 45 lanx 10A72809 100 pku 11A03274 45 hypu æ ·ä¾‹è¾“å‡º 15 21 cmu 192 2 31 au 192 3 43 pku 100 1 54 hypu 81 2 64 lanx 81 2 æç¤º æ— \næ€è·¯ ä»£ç  1typedef double DB; 2const int mxn = 1e5 + 5; 3 4struct P{ 5 string s; 6 DB sum; 7 int num; 8}a[mxn]; 9 10bool cmp(P a, P b) 11{ 12 if(a.sum != b.sum) 13 return a.sum \u0026gt; b.sum; 14 if(a.num != b.num) 15 return a.num \u0026lt; b.num; 16 return a.s \u0026lt; b.s; 17} 18 19int main() 20{ 21 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 22 23 map\u0026lt;string, int\u0026gt; mmp; 24 string x, y; 25 int cnt = 0; 26 DB t; 27 28 for (int i=0; i\u0026lt;n; i++) 29 { 30 cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; t \u0026gt;\u0026gt; y; 31 for(int j=0; j\u0026lt;y.length(); j++) 32 y[j] = tolower(y[j]); 33 34 if(mmp.count(y)==0) 35 { 36 mmp[y] = cnt++; 37 a[mmp[y]].s = y; 38 } 39 40 if(x.at(0) == \u0026#39;B\u0026#39;) 41 t /= 1.5; 42 else if(x.at(0) == \u0026#39;T\u0026#39;) 43 t *= 1.5; 44 45 a[mmp[y]].sum += t; 46 a[mmp[y]].num++; 47 } 48 for(int i=0; i\u0026lt;cnt; i++) 49 a[i].sum = floor(a[i].sum); 50 51 printf(\u0026#34;%d\\n\u0026#34;, cnt); 52 sort(a, a+cnt, cmp); 53 54 int rank = 1; 55 for(int i=0; i\u0026lt;cnt; i++) 56 { 57 if(i \u0026amp;\u0026amp; a[i-1].sum != a[i].sum) 58 rank = i+1; 59 printf(\u0026#34;%d %s %.0lf %d\\n\u0026#34;, rank, a[i].s.c_str(), a[i].sum, a[i].num); 60 } 61 62 return 0; 63} ","permalink":"https://blog.lordash.de/posts/solution/patb-1085-pat%E5%8D%95%E4%BD%8D%E6%8E%92%E8%A1%8C/","summary":"PATå•ä½æ’è¡Œ (PATB-1085) é¢˜é¢ æ¯æ¬¡ PAT è€ƒè¯•ç»“æŸåï¼Œè€ƒè¯•ä¸­å¿ƒéƒ½ä¼šå‘å¸ƒä¸€ä¸ªè€ƒç”Ÿå•ä½æ’è¡Œæ¦œã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªåŠŸèƒ½ã€‚ è¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤105ï¼‰","title":"PATB-1085 PATå•ä½æ’è¡Œ"},{"content":"å¤–è§‚æ•°åˆ— (PATB-1084) é¢˜é¢ å¤–è§‚æ•°åˆ—æ˜¯æŒ‡å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹çš„æ•´æ•°åºåˆ—ï¼š\n1d, d1, d111, d113, d11231, d112213111, ... å®ƒä»ä¸ç­‰äº 1 çš„æ•°å­— d å¼€å§‹ï¼Œåºåˆ—çš„ç¬¬ n+1 é¡¹æ˜¯å¯¹ç¬¬ n é¡¹çš„æè¿°ã€‚æ¯”å¦‚ç¬¬ 2 é¡¹è¡¨ç¤ºç¬¬ 1 é¡¹æœ‰ 1 ä¸ª dï¼Œæ‰€ä»¥å°±æ˜¯ d1ï¼›ç¬¬ 2 é¡¹æ˜¯ 1 ä¸ª dï¼ˆå¯¹åº” d1ï¼‰å’Œ 1 ä¸ª 1ï¼ˆå¯¹åº” 11ï¼‰ï¼Œæ‰€ä»¥ç¬¬ 3 é¡¹å°±æ˜¯ d111ã€‚åˆæ¯”å¦‚ç¬¬ 4 é¡¹æ˜¯ d113ï¼Œå…¶æè¿°å°±æ˜¯ 1 ä¸ª dï¼Œ2 ä¸ª 1ï¼Œ1 ä¸ª 3ï¼Œæ‰€ä»¥ä¸‹ä¸€é¡¹å°±æ˜¯ d11231ã€‚å½“ç„¶è¿™ä¸ªå®šä¹‰å¯¹ d = 1 ä¹Ÿæˆç«‹ã€‚æœ¬é¢˜è¦æ±‚ä½ æ¨ç®—ä»»æ„ç»™å®šæ•°å­— d çš„å¤–è§‚æ•°åˆ—çš„ç¬¬ N é¡¹ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º [0,9] èŒƒå›´å†…çš„ä¸€ä¸ªæ•´æ•° dã€ä»¥åŠä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 40ï¼‰ï¼Œç”¨ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ•°å­— d çš„å¤–è§‚æ•°åˆ—çš„ç¬¬ N é¡¹ã€‚\næ ·ä¾‹è¾“å…¥ 11 8 æ ·ä¾‹è¾“å‡º 11123123111 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 string s; int n, j; 4 cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; n; 5 6 for (int k=1; k\u0026lt;n; k++) 7 { 8 string t; 9 for (int i=0; i\u0026lt;s.length(); i=j) 10 { 11 for (j=i; j\u0026lt;s.length() \u0026amp;\u0026amp; s[j]==s[i]; j++); 12 t += s[i] + to_string(j - i); 13 } 14 s = t; 15 } 16 printf(\u0026#34;%s\\n\u0026#34;, s.c_str()); 17 18 return 0; 19} ","permalink":"https://blog.lordash.de/posts/solution/patb-1084-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/","summary":"å¤–è§‚æ•°åˆ— (PATB-1084) é¢˜é¢ å¤–è§‚æ•°åˆ—æ˜¯æŒ‡å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹çš„æ•´æ•°åºåˆ—ï¼š 1d, d1, d111, d113, d11231, d112213111, ... å®ƒä»ä¸ç­‰äº 1 çš„æ•°å­— d å¼€å§‹ï¼Œåºåˆ—çš„ç¬¬ n+1 é¡¹æ˜¯å¯¹ç¬¬ n é¡¹çš„æè¿°ã€‚æ¯”å¦‚ç¬¬ 2 é¡¹è¡¨ç¤ºç¬¬ 1 é¡¹","title":"PATB-1084 å¤–è§‚æ•°åˆ—"},{"content":"æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·® (PATB-1083) é¢˜é¢ ç»™å®š N å¼ å¡ç‰‡ï¼Œæ­£é¢åˆ†åˆ«å†™ä¸Š 1ã€2ã€â€¦â€¦ã€Nï¼Œç„¶åå…¨éƒ¨ç¿»é¢ï¼Œæ´—ç‰Œï¼Œåœ¨èƒŒé¢åˆ†åˆ«å†™ä¸Š 1ã€2ã€â€¦â€¦ã€Nã€‚å°†æ¯å¼ ç‰Œçš„æ­£åä¸¤é¢æ•°å­—ç›¸å‡ï¼ˆå¤§å‡å°ï¼‰ï¼Œå¾—åˆ° N ä¸ªéè´Ÿå·®å€¼ï¼Œå…¶ä¸­æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·®ï¼Ÿ\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆ2 â‰¤ N â‰¤ 10 000ï¼‰ï¼Œéšåä¸€è¡Œç»™å‡º 1 åˆ° N çš„ä¸€ä¸ªæ´—ç‰Œåçš„æ’åˆ—ï¼Œç¬¬ i ä¸ªæ•°è¡¨ç¤ºæ­£é¢å†™äº† i çš„é‚£å¼ å¡ç‰‡èƒŒé¢çš„æ•°å­—ã€‚\nè¾“å‡º æŒ‰ç…§â€œå·®å€¼ é‡å¤æ¬¡æ•°â€çš„æ ¼å¼ä»å¤§åˆ°å°è¾“å‡ºé‡å¤çš„å·®å€¼åŠå…¶é‡å¤çš„æ¬¡æ•°ï¼Œæ¯è¡Œè¾“å‡ºä¸€ä¸ªç»“æœã€‚\næ ·ä¾‹è¾“å…¥ 18 23 5 8 6 2 1 4 7 æ ·ä¾‹è¾“å‡º 15 2 23 3 32 2 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2 3int a[mxn], p[mxn]; 4 5int main() 6{ 7 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 9 for(int i=1; i\u0026lt;=n; i++) 10 { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 12 p[Abs(a[i]-i)]++; 13 } 14 15 for(int i=10000; i\u0026gt;=0; i--) 16 { 17 if(p[i]\u0026gt;1) 18 printf(\u0026#34;%d %d\\n\u0026#34;, i, p[i]); 19 } 20 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1083-%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%B7%AE/","summary":"æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·® (PATB-1083) é¢˜é¢ ç»™å®š N å¼ å¡ç‰‡ï¼Œæ­£é¢åˆ†åˆ«å†™ä¸Š 1ã€2ã€â€¦â€¦ã€Nï¼Œç„¶åå…¨éƒ¨ç¿»é¢ï¼Œæ´—ç‰Œï¼Œåœ¨èƒŒé¢åˆ†åˆ«å†™ä¸Š 1ã€2ã€â€¦â€¦ã€Nã€‚å°†æ¯å¼ ç‰Œçš„æ­£åä¸¤é¢æ•°å­—","title":"PATB-1083 æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·®"},{"content":"å°„å‡»æ¯”èµ› (PATB-1082) é¢˜é¢ æœ¬é¢˜ç›®ç»™å‡ºçš„å°„å‡»æ¯”èµ›çš„è§„åˆ™éå¸¸ç®€å•ï¼Œè°æ‰“çš„å¼¹æ´è·ç¦»é¶å¿ƒæœ€è¿‘ï¼Œè°å°±æ˜¯å† å†›ï¼›è°å·®å¾—æœ€è¿œï¼Œè°å°±æ˜¯èœé¸Ÿã€‚æœ¬é¢˜ç»™å‡ºä¸€ç³»åˆ—å¼¹æ´çš„å¹³é¢åæ ‡(x,y)ï¼Œè¯·ä½ ç¼–å†™ç¨‹åºæ‰¾å‡ºå† å†›å’Œèœé¸Ÿã€‚æˆ‘ä»¬å‡è®¾é¶å¿ƒåœ¨åŸç‚¹(0,0)ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 10 000ï¼‰ã€‚éšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ä¸‹åˆ—æ ¼å¼ç»™å‡ºï¼š\n1ID x y å…¶ä¸­ ID æ˜¯è¿åŠ¨å‘˜çš„ç¼–å·ï¼ˆç”± 4 ä½æ•°å­—ç»„æˆï¼‰ï¼›x å’Œ y æ˜¯å…¶æ‰“å‡ºçš„å¼¹æ´çš„å¹³é¢åæ ‡(x,y)ï¼Œå‡ä¸ºæ•´æ•°ï¼Œä¸” 0 â‰¤ |x|, |y| â‰¤ 100ã€‚é¢˜ç›®ä¿è¯æ¯ä¸ªè¿åŠ¨å‘˜çš„ç¼–å·ä¸é‡å¤ï¼Œä¸”æ¯äººåªæ‰“ 1 æªã€‚\nè¾“å‡º è¾“å‡ºå† å†›å’Œèœé¸Ÿçš„ç¼–å·ï¼Œä¸­é—´ç©º 1 æ ¼ã€‚é¢˜ç›®ä¿è¯ä»–ä»¬æ˜¯å”¯ä¸€çš„ã€‚\næ ·ä¾‹è¾“å…¥ 13 20001 5 7 31020 -1 3 40233 0 -1 æ ·ä¾‹è¾“å‡º 10233 0001 æç¤º æ— \næ€è·¯ ä»£ç  1typedef double DB; 2 3struct PT 4{ 5 DB x, y; 6 PT() : x(0), y(0) {}; 7 PT(DB _x, DB _y) : x(_x), y(_y) {}; 8}; 9 10DB dist(PT p1, PT p2) 11{ 12 return sqrt(Sq(p1.x - p2.x) + Sq(p1.y - p2.y)); 13} 14 15struct P{ 16 int id; 17 DB ans; 18}a[mxn]; 19 20bool cmp(P a, P b) 21{ 22 return a.ans \u0026lt; b.ans; 23} 24 25int main() 26{ 27 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 28 29 PT p; 30 for(int i=0; i\u0026lt;n; i++) 31 { 32 scanf(\u0026#34;%d %lf %lf\u0026#34;, \u0026amp;a[i].id, \u0026amp;p.x, \u0026amp;p.y); 33 a[i].ans = dist(p, PT{0, 0}); 34 } 35 sort(a, a+n, cmp); 36 printf(\u0026#34;%04d %04d\\n\u0026#34;, a[0].id, a[n-1].id); 37 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/patb-1082-%E5%B0%84%E5%87%BB%E6%AF%94%E8%B5%9B/","summary":"å°„å‡»æ¯”èµ› (PATB-1082) é¢˜é¢ æœ¬é¢˜ç›®ç»™å‡ºçš„å°„å‡»æ¯”èµ›çš„è§„åˆ™éå¸¸ç®€å•ï¼Œè°æ‰“çš„å¼¹æ´è·ç¦»é¶å¿ƒæœ€è¿‘ï¼Œè°å°±æ˜¯å† å†›ï¼›è°å·®å¾—æœ€è¿œï¼Œè°å°±æ˜¯èœé¸Ÿã€‚æœ¬é¢˜ç»™å‡ºä¸€ç³»åˆ—å¼¹æ´çš„å¹³é¢åæ ‡(","title":"PATB-1082 å°„å‡»æ¯”èµ›"},{"content":"æ£€æŸ¥å¯†ç  (PATB-1081) é¢˜é¢ æœ¬é¢˜è¦æ±‚ä½ å¸®åŠ©æŸç½‘ç«™çš„ç”¨æˆ·æ³¨å†Œæ¨¡å—å†™ä¸€ä¸ªå¯†ç åˆæ³•æ€§æ£€æŸ¥çš„å°åŠŸèƒ½ã€‚è¯¥ç½‘ç«™è¦æ±‚ç”¨æˆ·è®¾ç½®çš„å¯†ç å¿…é¡»ç”±ä¸å°‘äº6ä¸ªå­—ç¬¦ç»„æˆï¼Œå¹¶ä¸”åªèƒ½æœ‰è‹±æ–‡å­—æ¯ã€æ•°å­—å’Œå°æ•°ç‚¹ .ï¼Œè¿˜å¿…é¡»æ—¢æœ‰å­—æ¯ä¹Ÿæœ‰æ•°å­—ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç”¨æˆ·è®¾ç½®çš„å¯†ç ï¼Œä¸ºä¸è¶…è¿‡ 80 ä¸ªå­—ç¬¦çš„éç©ºå­—ç¬¦ä¸²ï¼Œä»¥å›è½¦ç»“æŸã€‚\nè¾“å‡º å¯¹æ¯ä¸ªç”¨æˆ·çš„å¯†ç ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç³»ç»Ÿåé¦ˆä¿¡æ¯ï¼Œåˆ†ä»¥ä¸‹5ç§ï¼š\nå¦‚æœå¯†ç åˆæ³•ï¼Œè¾“å‡ºYour password is wan mei.ï¼› å¦‚æœå¯†ç å¤ªçŸ­ï¼Œä¸è®ºåˆæ³•ä¸å¦ï¼Œéƒ½è¾“å‡ºYour password is tai duan le.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†å­˜åœ¨ä¸åˆæ³•å­—ç¬¦ï¼Œåˆ™è¾“å‡ºYour password is tai luan le.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†åªæœ‰å­—æ¯æ²¡æœ‰æ•°å­—ï¼Œåˆ™è¾“å‡ºYour password needs shu zi.ï¼› å¦‚æœå¯†ç é•¿åº¦åˆæ³•ï¼Œä½†åªæœ‰æ•°å­—æ²¡æœ‰å­—æ¯ï¼Œåˆ™è¾“å‡ºYour password needs zi mu.ã€‚ æ ·ä¾‹è¾“å…¥ 15 2123s 3zheshi.wodepw 41234.5678 5WanMei23333 6pass*word.6 æ ·ä¾‹è¾“å‡º 1Your password is tai duan le. 2Your password needs shu zi. 3Your password needs zi mu. 4Your password is wan mei. 5Your password is tai luan le. æç¤º æ— \næ€è·¯ ä»£ç  1char s[100]; 2 3int main() 4{ 5 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 getchar(); 7 8 for(int i=0; i\u0026lt;n; i++) 9 { 10 fgets(s, 100, stdin); 11 int sl = strlen(s) - 1; 12 13 if(sl \u0026lt; 6){ 14 printf(\u0026#34;Your password is tai duan le.\\n\u0026#34;); 15 continue; 16 } 17 18 int ok = 1, a = 0, b = 0; 19 for(int j=0; j\u0026lt;sl; j++) 20 { 21 if(isdigit(s[j])) 22 a++; 23 else if(isalpha(s[j])) 24 b++; 25 else if(s[j]!=\u0026#39;.\u0026#39;) 26 ok = 0; 27 } 28 29 if(ok == 0 || (a==0 \u0026amp;\u0026amp; b==0)) 30 printf(\u0026#34;Your password is tai luan le.\\n\u0026#34;); 31 else if(a==0 \u0026amp;\u0026amp; b) 32 printf(\u0026#34;Your password needs shu zi.\\n\u0026#34;); 33 else if(b==0 \u0026amp;\u0026amp; a) 34 printf(\u0026#34;Your password needs zi mu.\\n\u0026#34;); 35 else if(a \u0026amp;\u0026amp; b) 36 printf(\u0026#34;Your password is wan mei.\\n\u0026#34;); 37 } 38 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/solution/patb-1081-%E6%A3%80%E6%9F%A5%E5%AF%86%E7%A0%81/","summary":"æ£€æŸ¥å¯†ç  (PATB-1081) é¢˜é¢ æœ¬é¢˜è¦æ±‚ä½ å¸®åŠ©æŸç½‘ç«™çš„ç”¨æˆ·æ³¨å†Œæ¨¡å—å†™ä¸€ä¸ªå¯†ç åˆæ³•æ€§æ£€æŸ¥çš„å°åŠŸèƒ½ã€‚è¯¥ç½‘ç«™è¦æ±‚ç”¨æˆ·è®¾ç½®çš„å¯†ç å¿…é¡»ç”±ä¸å°‘äº6ä¸ªå­—ç¬¦ç»„æˆï¼Œå¹¶ä¸”åªèƒ½æœ‰è‹±","title":"PATB-1081 æ£€æŸ¥å¯†ç "},{"content":"MOOCæœŸç»ˆæˆç»© (PATB-1080) é¢˜é¢ å¯¹äºåœ¨ä¸­å›½å¤§å­¦MOOCï¼ˆhttp://www.icourse163.org/ ï¼‰å­¦ä¹ â€œæ•°æ®ç»“æ„â€è¯¾ç¨‹çš„å­¦ç”Ÿï¼Œæƒ³è¦è·å¾—ä¸€å¼ åˆæ ¼è¯ä¹¦ï¼Œå¿…é¡»é¦–å…ˆè·å¾—ä¸å°‘äº200åˆ†çš„åœ¨çº¿ç¼–ç¨‹ä½œä¸šåˆ†ï¼Œç„¶åæ€»è¯„è·å¾—ä¸å°‘äº60åˆ†ï¼ˆæ»¡åˆ†100ï¼‰ã€‚æ€»è¯„æˆç»©çš„è®¡ç®—å…¬å¼ä¸º G=(Gmidâˆ’termÃ—40%+GfinalÃ—60%)ï¼Œå¦‚æœ Gmidâˆ’term\u0026gt;Gfinalï¼›å¦åˆ™æ€»è¯„ G å°±æ˜¯ Gfinalã€‚è¿™é‡Œ Gmidâˆ’term å’Œ Gfinal åˆ†åˆ«ä¸ºå­¦ç”Ÿçš„æœŸä¸­å’ŒæœŸæœ«æˆç»©ã€‚\nç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæ¯æ¬¡è€ƒè¯•éƒ½äº§ç”Ÿä¸€å¼ ç‹¬ç«‹çš„æˆç»©å•ã€‚æœ¬é¢˜å°±è¯·ä½ ç¼–å†™ç¨‹åºï¼ŒæŠŠä¸åŒçš„æˆç»©å•åˆä¸ºä¸€å¼ ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º3ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ Pï¼ˆåšäº†åœ¨çº¿ç¼–ç¨‹ä½œä¸šçš„å­¦ç”Ÿæ•°ï¼‰ã€Mï¼ˆå‚åŠ äº†æœŸä¸­è€ƒè¯•çš„å­¦ç”Ÿæ•°ï¼‰ã€Nï¼ˆå‚åŠ äº†æœŸæœ«è€ƒè¯•çš„å­¦ç”Ÿæ•°ï¼‰ã€‚æ¯ä¸ªæ•°éƒ½ä¸è¶…è¿‡10000ã€‚\næ¥ä¸‹æ¥æœ‰ä¸‰å—è¾“å…¥ã€‚ç¬¬ä¸€å—åŒ…å« P ä¸ªåœ¨çº¿ç¼–ç¨‹æˆç»© Gpï¼›ç¬¬äºŒå—åŒ…å« M ä¸ªæœŸä¸­è€ƒè¯•æˆç»© Gmidâˆ’termï¼›ç¬¬ä¸‰å—åŒ…å« N ä¸ªæœŸæœ«è€ƒè¯•æˆç»© Gfinalã€‚æ¯ä¸ªæˆç»©å ä¸€è¡Œï¼Œæ ¼å¼ä¸ºï¼šå­¦ç”Ÿå­¦å· åˆ†æ•°ã€‚å…¶ä¸­å­¦ç”Ÿå­¦å·ä¸ºä¸è¶…è¿‡20ä¸ªå­—ç¬¦çš„è‹±æ–‡å­—æ¯å’Œæ•°å­—ï¼›åˆ†æ•°æ˜¯éè´Ÿæ•´æ•°ï¼ˆç¼–ç¨‹æ€»åˆ†æœ€é«˜ä¸º900åˆ†ï¼ŒæœŸä¸­å’ŒæœŸæœ«çš„æœ€é«˜åˆ†ä¸º100åˆ†ï¼‰ã€‚\nè¾“å‡º æ‰“å°å‡ºè·å¾—åˆæ ¼è¯ä¹¦çš„å­¦ç”Ÿåå•ã€‚æ¯ä¸ªå­¦ç”Ÿå ä¸€è¡Œï¼Œæ ¼å¼ä¸ºï¼š\nå­¦ç”Ÿå­¦å· Gp Gmidâˆ’term Gfinal G\nå¦‚æœæœ‰çš„æˆç»©ä¸å­˜åœ¨ï¼ˆä¾‹å¦‚æŸäººæ²¡å‚åŠ æœŸä¸­è€ƒè¯•ï¼‰ï¼Œåˆ™åœ¨ç›¸åº”çš„ä½ç½®è¾“å‡ºâ€œâˆ’1â€ã€‚è¾“å‡ºé¡ºåºä¸ºæŒ‰ç…§æ€»è¯„åˆ†æ•°ï¼ˆå››èˆäº”å…¥ç²¾ç¡®åˆ°æ•´æ•°ï¼‰é€’å‡ã€‚è‹¥æœ‰å¹¶åˆ—ï¼Œåˆ™æŒ‰å­¦å·é€’å¢ã€‚é¢˜ç›®ä¿è¯å­¦å·æ²¡æœ‰é‡å¤ï¼Œä¸”è‡³å°‘å­˜åœ¨1ä¸ªåˆæ ¼çš„å­¦ç”Ÿã€‚\næ ·ä¾‹è¾“å…¥ 16 6 7 201234 880 3a1903 199 4ydjh2 200 5wehu8 300 6dx86w 220 7missing 400 8ydhfu77 99 9wehu8 55 10ydjh2 98 11dx86w 88 12a1903 86 1301234 39 14ydhfu77 88 15a1903 66 1601234 58 17wehu8 84 18ydjh2 82 19missing 99 20dx86w 81 æ ·ä¾‹è¾“å‡º 1missing 400 -1 99 99 2ydjh2 200 98 82 88 3dx86w 220 88 81 84 4wehu8 300 55 84 84 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2 3struct P{ 4 string s; 5 int gp, gm, gf, g; 6}a[mxn], ans[mxn], t; 7 8bool cmp(P a, P b){ 9 return a.g != b.g ? a.g \u0026gt; b.g : a.s \u0026lt; b.s; 10} 11 12int main() 13{ 14 int p, m, n; 15 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;p, \u0026amp;m, \u0026amp;n); 16 17 int num = 0; 18 map\u0026lt;string, int\u0026gt; mmp; 19 20 for(int i=0; i\u0026lt;p; i++) 21 { 22 cin \u0026gt;\u0026gt; t.s \u0026gt;\u0026gt; t.gp; 23 if(t.gp \u0026gt;= 200) 24 { 25 a[num] = P{t.s, t.gp, -1, -1, 0}; 26 mmp[t.s] = num++; 27 } 28 } 29 30 for(int i=0; i\u0026lt;m; i++) 31 { 32 cin \u0026gt;\u0026gt; t.s \u0026gt;\u0026gt; t.gm; 33 if(mmp.count(t.s) != 0) 34 a[mmp[t.s]].gm = t.gm; 35 } 36 37 for(int i=0; i\u0026lt;n; i++) 38 { 39 cin \u0026gt;\u0026gt; t.s \u0026gt;\u0026gt; t.gf; 40 if(mmp.count(t.s) != 0) 41 { 42 int id = mmp[t.s]; 43 a[id].g = a[id].gf = t.gf; 44 if(a[id].gm \u0026gt; a[id].gf) 45 a[id].g = (int)(0.4*a[id].gm + 0.6*a[id].gf + 0.5); 46 } 47 } 48 49 int cnt = 0; 50 for(int i=0; i\u0026lt;num; i++) 51 { 52 if(a[i].g \u0026gt;= 60) 53 ans[cnt++] = a[i]; 54 } 55 56 sort(ans, ans+cnt, cmp); 57 for(int i=0; i\u0026lt;cnt; i++) 58 printf(\u0026#34;%s %d %d %d %d\\n\u0026#34;, ans[i].s.c_str(), ans[i].gp, ans[i].gm, ans[i].gf, ans[i].g); 59 60 return 0; 61} ","permalink":"https://blog.lordash.de/posts/solution/patb-1080-mooc%E6%9C%9F%E7%BB%88%E6%88%90%E7%BB%A9/","summary":"MOOCæœŸç»ˆæˆç»© (PATB-1080) é¢˜é¢ å¯¹äºåœ¨ä¸­å›½å¤§å­¦MOOCï¼ˆhttp://www.icourse163.org/ ï¼‰å­¦ä¹ â€œæ•°æ®ç»“æ„â€è¯¾ç¨‹çš„å­¦ç”Ÿï¼Œæƒ³è¦è·å¾—ä¸€å¼ ","title":"PATB-1080 MOOCæœŸç»ˆæˆç»©"},{"content":"ä¸€ã€å‡†å¤‡ åŸºæœ¬ä¿¡æ¯\næ“ä½œç³»ç»Ÿ: Windows10 jdkç‰ˆæœ¬: 1.8 Hadoopç‰ˆæœ¬: 2.9.2 ä¸‹è½½å¹¶è§£å‹\nScalaï¼š å®˜ç½‘ æˆ–è€… scala-2.13.2.zip Sparkï¼šå®˜ç½‘ æˆ–è€… spark-3.0.0-preview2-bin-hadoop2.7.tgz äºŒã€Scala é…ç½® æ–°å»ºç³»ç»Ÿå˜é‡ SCALA_HOME è‡³æ‰€åœ¨ç›®å½•ï¼Œå¦‚ D:\\environment\\scala-2.13.2\nåœ¨ path ä¸­æ·»åŠ  %SCALA_HOME%\\bin\næµ‹è¯• å¯åŠ¨å‘½ä»¤è¡Œï¼Œè¿è¡Œ scala -version ï¼Œå‡ºç°ä»¥ä¸‹ç»“æœè¯´æ˜æˆåŠŸ\nä¸‰ã€Spark å¯åŠ¨å‘½ä»¤è¡Œï¼Œé…ç½®ç¯å¢ƒå˜é‡æˆ–è€…cd è‡³ Sparkçš„ bin ç›®å½•ä¸‹ï¼Œè¿è¡Œ spark-shell å‡ºç°ä»¥ä¸‹ç»“æœè¯´æ˜æˆåŠŸã€‚è‹¥å‡ºç°é”™è¯¯ï¼Œåˆ™ä¾æ®é”™è¯¯æç¤ºå®‰è£…Pythonæˆ–è€…Hadoopã€‚\n","permalink":"https://blog.lordash.de/posts/configure/949fb3f2e5a83ea5/","summary":"ä¸€ã€å‡†å¤‡ åŸºæœ¬ä¿¡æ¯ æ“ä½œç³»ç»Ÿ: Windows10 jdkç‰ˆæœ¬: 1.8 Hadoopç‰ˆæœ¬: 2.9.2 ä¸‹è½½å¹¶è§£å‹ Scalaï¼š å®˜ç½‘ æˆ–è€… scala-2.13.2.zip Sparkï¼šå®˜ç½‘ æˆ–è€… spark-3.0.0-preview2-bin-hadoop2.7.tgz äºŒã€Scala é…ç½® æ–°å»ºç³»","title":"Win10é…ç½®Scalaå’ŒSpark"},{"content":"å»¶è¿Ÿçš„å›æ–‡æ•° (PATB-1079) é¢˜é¢ ç»™å®šä¸€ä¸ª k+1 ä½çš„æ­£æ•´æ•° Nï¼Œå†™æˆ akâ‹¯a1a0 çš„å½¢å¼ï¼Œå…¶ä¸­å¯¹æ‰€æœ‰ i æœ‰ 0â‰¤ai\u0026lt;10 ä¸” ak\u0026gt;0ã€‚N è¢«ç§°ä¸ºä¸€ä¸ªå›æ–‡æ•°ï¼Œå½“ä¸”ä»…å½“å¯¹æ‰€æœ‰ i æœ‰ ai=akâˆ’iã€‚é›¶ä¹Ÿè¢«å®šä¹‰ä¸ºä¸€ä¸ªå›æ–‡æ•°ã€‚\néå›æ–‡æ•°ä¹Ÿå¯ä»¥é€šè¿‡ä¸€ç³»åˆ—æ“ä½œå˜å‡ºå›æ–‡æ•°ã€‚é¦–å…ˆå°†è¯¥æ•°å­—é€†è½¬ï¼Œå†å°†é€†è½¬æ•°ä¸è¯¥æ•°ç›¸åŠ ï¼Œå¦‚æœå’Œè¿˜ä¸æ˜¯ä¸€ä¸ªå›æ–‡æ•°ï¼Œå°±é‡å¤è¿™ä¸ªé€†è½¬å†ç›¸åŠ çš„æ“ä½œï¼Œç›´åˆ°ä¸€ä¸ªå›æ–‡æ•°å‡ºç°ã€‚å¦‚æœä¸€ä¸ªéå›æ–‡æ•°å¯ä»¥å˜å‡ºå›æ–‡æ•°ï¼Œå°±ç§°è¿™ä¸ªæ•°ä¸ºå»¶è¿Ÿçš„å›æ–‡æ•°ã€‚ï¼ˆå®šä¹‰ç¿»è¯‘è‡ª https://en.wikipedia.org/wiki/Palindromic_number ï¼‰\nç»™å®šä»»æ„ä¸€ä¸ªæ­£æ•´æ•°ï¼Œæœ¬é¢˜è¦æ±‚ä½ æ‰¾åˆ°å…¶å˜å‡ºçš„é‚£ä¸ªå›æ–‡æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡1000ä½çš„æ­£æ•´æ•°ã€‚\nè¾“å‡º å¯¹ç»™å®šçš„æ•´æ•°ï¼Œä¸€è¡Œä¸€è¡Œè¾“å‡ºå…¶å˜å‡ºå›æ–‡æ•°çš„è¿‡ç¨‹ã€‚æ¯è¡Œæ ¼å¼å¦‚ä¸‹\n1A + B = C å…¶ä¸­ A æ˜¯åŸå§‹çš„æ•°å­—ï¼ŒB æ˜¯ A çš„é€†è½¬æ•°ï¼ŒC æ˜¯å®ƒä»¬çš„å’Œã€‚A ä»è¾“å…¥çš„æ•´æ•°å¼€å§‹ã€‚é‡å¤æ“ä½œç›´åˆ° C åœ¨ 10 æ­¥ä»¥å†…å˜æˆå›æ–‡æ•°ï¼Œè¿™æ—¶åœ¨ä¸€è¡Œä¸­è¾“å‡º C is a palindromic number.ï¼›æˆ–è€…å¦‚æœ 10 æ­¥éƒ½æ²¡èƒ½å¾—åˆ°å›æ–‡æ•°ï¼Œæœ€åå°±åœ¨ä¸€è¡Œä¸­è¾“å‡º Not found in 10 iterations.ã€‚\næ ·ä¾‹è¾“å…¥1 197152 æ ·ä¾‹è¾“å‡º1 197152 + 25179 = 122331 2122331 + 133221 = 255552 3255552 is a palindromic number. æ ·ä¾‹è¾“å…¥2 1196 æ ·ä¾‹è¾“å‡º2 1196 + 691 = 887 2887 + 788 = 1675 31675 + 5761 = 7436 47436 + 6347 = 13783 513783 + 38731 = 52514 652514 + 41525 = 94039 794039 + 93049 = 187088 8187088 + 880781 = 1067869 91067869 + 9687601 = 10755470 1010755470 + 07455701 = 18211171 11Not found in 10 iterations. æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[mxn]; 3 4void add(char *s, char *t) 5{ 6 int len=strlen(s), p=0; 7 for(int i=0; i\u0026lt;len; i++){ 8 int x = s[i]-\u0026#39;0\u0026#39; + t[i]-\u0026#39;0\u0026#39; + p; 9 p = x / 10; 10 s[i] = x % 10 + \u0026#39;0\u0026#39;; 11 } 12 if(p) 13 s[len++]=\u0026#39;1\u0026#39;; 14 s[len]=\u0026#39;\\0\u0026#39;; 15 reverse(s, s+len); 16} 17 18int main() 19{ 20 scanf(\u0026#34;%s\u0026#34;, s); 21 22 int num = 0; 23 while(1) 24 { 25 reverse_copy(s, s+strlen(s), t); 26 if(strcmp(s, t) == 0){ 27 printf(\u0026#34;%s is a palindromic number.\\n\u0026#34;, s); 28 break; 29 } 30 printf(\u0026#34;%s + %s = \u0026#34;, s, t); 31 add(s, t); 32 printf(\u0026#34;%s\\n\u0026#34;, s); 33 if(++num \u0026gt;= 10){ 34 printf(\u0026#34;Not found in 10 iterations.\\n\u0026#34;); 35 break; 36 } 37 } 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/patb-1079-%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"å»¶è¿Ÿçš„å›æ–‡æ•° (PATB-1079) é¢˜é¢ ç»™å®šä¸€ä¸ª k+1 ä½çš„æ­£æ•´æ•° Nï¼Œå†™æˆ akâ‹¯a1a0 çš„å½¢å¼ï¼Œå…¶ä¸­å¯¹æ‰€æœ‰ i æœ‰ 0â‰¤ai\u0026lt;10 ä¸” ak\u0026gt;0ã€‚N è¢«ç§°ä¸ºä¸€ä¸ªå›æ–‡æ•°ï¼Œ","title":"PATB-1079 å»¶è¿Ÿçš„å›æ–‡æ•°"},{"content":"å­—ç¬¦ä¸²å‹ç¼©ä¸è§£å‹ (PATB-1078) é¢˜é¢ æ–‡æœ¬å‹ç¼©æœ‰å¾ˆå¤šç§æ–¹æ³•ï¼Œè¿™é‡Œæˆ‘ä»¬åªè€ƒè™‘æœ€ç®€å•çš„ä¸€ç§ï¼šæŠŠç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„ä¸€ä¸ªè¿ç»­çš„ç‰‡æ®µç”¨è¿™ä¸ªå­—ç¬¦å’Œç‰‡æ®µä¸­å«æœ‰è¿™ä¸ªå­—ç¬¦çš„ä¸ªæ•°æ¥è¡¨ç¤ºã€‚ä¾‹å¦‚ ccccc å°±ç”¨ 5c æ¥è¡¨ç¤ºã€‚å¦‚æœå­—ç¬¦æ²¡æœ‰é‡å¤ï¼Œå°±åŸæ ·è¾“å‡ºã€‚ä¾‹å¦‚ aba å‹ç¼©åä»ç„¶æ˜¯ abaã€‚\nè§£å‹æ–¹æ³•å°±æ˜¯åè¿‡æ¥ï¼ŒæŠŠå½¢å¦‚ 5c è¿™æ ·çš„è¡¨ç¤ºæ¢å¤ä¸º cccccã€‚\næœ¬é¢˜éœ€è¦ä½ æ ¹æ®å‹ç¼©æˆ–è§£å‹çš„è¦æ±‚ï¼Œå¯¹ç»™å®šå­—ç¬¦ä¸²è¿›è¡Œå¤„ç†ã€‚è¿™é‡Œæˆ‘ä»¬ç®€å•åœ°å‡è®¾åŸå§‹å­—ç¬¦ä¸²æ˜¯å®Œå…¨ç”±è‹±æ–‡å­—æ¯å’Œç©ºæ ¼ç»„æˆçš„éç©ºå­—ç¬¦ä¸²ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ˜¯ C å°±è¡¨ç¤ºä¸‹é¢çš„å­—ç¬¦ä¸²éœ€è¦è¢«å‹ç¼©ï¼›å¦‚æœæ˜¯ D å°±è¡¨ç¤ºä¸‹é¢çš„å­—ç¬¦ä¸²éœ€è¦è¢«è§£å‹ã€‚ç¬¬äºŒè¡Œç»™å‡ºéœ€è¦è¢«å‹ç¼©æˆ–è§£å‹çš„ä¸è¶…è¿‡ 1000 ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œä»¥å›è½¦ç»“å°¾ã€‚é¢˜ç›®ä¿è¯å­—ç¬¦é‡å¤ä¸ªæ•°åœ¨æ•´å‹èŒƒå›´å†…ï¼Œä¸”è¾“å‡ºæ–‡ä»¶ä¸è¶…è¿‡ 1MBã€‚\nè¾“å‡º æ ¹æ®è¦æ±‚å‹ç¼©æˆ–è§£å‹å­—ç¬¦ä¸²ï¼Œå¹¶åœ¨ä¸€è¡Œä¸­è¾“å‡ºç»“æœã€‚\næ ·ä¾‹è¾“å…¥ 1C 2TTTTThhiiiis isssss a tesssst CAaaa as æ ·ä¾‹è¾“å‡º 15T2h4is i5s a3 te4st CA3a as æ ·ä¾‹è¾“å…¥ 1D 25T2h4is i5s a3 te4st CA3a as10Z æ ·ä¾‹è¾“å‡º 1TTTTThhiiiis isssss a tesssst CAaaa asZZZZZZZZZZ æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], c; 3 4int main() 5{ 6 scanf(\u0026#34;%c%*c\u0026#34;, \u0026amp;c); 7 fgets(s, mxn, stdin); 8 int len = strlen(s); 9 10 if(c == \u0026#39;C\u0026#39;) 11 { 12 int num=1, i=0; 13 char t = s[i]; 14 15 for(i++; i\u0026lt;len; i++) 16 { 17 if(s[i] == t){ 18 num++; 19 continue; 20 } 21 if(num\u0026gt;1) printf(\u0026#34;%d\u0026#34;, num); 22 printf(\u0026#34;%c\u0026#34;, t); 23 t = s[i]; 24 num = 1; 25 } 26 if(num\u0026gt;1) printf(\u0026#34;%d\u0026#34;, num); 27 printf(\u0026#34;%c\u0026#34;, t); 28 } 29 else 30 { 31 int num=0, i=0; 32 for(i=0; s[i]==\u0026#39; \u0026#39;; i++) 33 printf(\u0026#34;%c\u0026#34;, s[i]); 34 35 for(; i\u0026lt;len; i++) 36 { 37 if(isdigit(s[i])) 38 num = num*10 + s[i]-\u0026#39;0\u0026#39;; 39 else{ 40 while(num--) printf(\u0026#34;%c\u0026#34;, s[i]); 41 num = isdigit(s[i+1]) ? 0 : 1; 42 } 43 } 44 } 45 return 0; 46} ","permalink":"https://blog.lordash.de/posts/solution/patb-1078-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/","summary":"å­—ç¬¦ä¸²å‹ç¼©ä¸è§£å‹ (PATB-1078) é¢˜é¢ æ–‡æœ¬å‹ç¼©æœ‰å¾ˆå¤šç§æ–¹æ³•ï¼Œè¿™é‡Œæˆ‘ä»¬åªè€ƒè™‘æœ€ç®€å•çš„ä¸€ç§ï¼šæŠŠç”±ç›¸åŒå­—ç¬¦ç»„æˆçš„ä¸€ä¸ªè¿ç»­çš„ç‰‡æ®µç”¨è¿™ä¸ªå­—ç¬¦å’Œç‰‡æ®µä¸­å«æœ‰è¿™ä¸ªå­—ç¬¦çš„ä¸ªæ•°","title":"PATB-1078 å­—ç¬¦ä¸²å‹ç¼©ä¸è§£å‹"},{"content":"äº’è¯„æˆç»©è®¡ç®— (PATB-1077) é¢˜é¢ åœ¨æµ™å¤§çš„è®¡ç®—æœºä¸“ä¸šè¯¾ä¸­ï¼Œç»å¸¸æœ‰äº’è¯„åˆ†ç»„æŠ¥å‘Šè¿™ä¸ªç¯èŠ‚ã€‚ä¸€ä¸ªç»„ä¸Šå°ä»‹ç»è‡ªå·±çš„å·¥ä½œï¼Œå…¶ä»–ç»„åœ¨å°ä¸‹ä¸ºå…¶è¡¨ç°è¯„åˆ†ã€‚æœ€åè¿™ä¸ªç»„çš„äº’è¯„æˆç»©æ˜¯è¿™æ ·è®¡ç®—çš„ï¼šæ‰€æœ‰å…¶ä»–ç»„çš„è¯„åˆ†ä¸­ï¼Œå»æ‰ä¸€ä¸ªæœ€é«˜åˆ†å’Œä¸€ä¸ªæœ€ä½åˆ†ï¼Œå‰©ä¸‹çš„åˆ†æ•°å–å¹³å‡åˆ†è®°ä¸º G1ï¼›è€å¸ˆç»™è¿™ä¸ªç»„çš„è¯„åˆ†è®°ä¸º G2ã€‚è¯¥ç»„å¾—åˆ†ä¸º (G1+G2)/2ï¼Œæœ€åç»“æœå››èˆäº”å…¥åä¿ç•™æ•´æ•°åˆ†ã€‚æœ¬é¢˜å°±è¦æ±‚ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆè®¡ç®—æ¯ä¸ªç»„çš„äº’è¯„æˆç»©ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆ\u0026gt; 3ï¼‰å’Œ Mï¼Œåˆ†åˆ«æ˜¯åˆ†ç»„æ•°å’Œæ»¡åˆ†ï¼Œå‡ä¸è¶…è¿‡ 100ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºè¯¥ç»„å¾—åˆ°çš„ N ä¸ªåˆ†æ•°ï¼ˆå‡ä¿è¯ä¸ºæ•´å‹èŒƒå›´å†…çš„æ•´æ•°ï¼‰ï¼Œå…¶ä¸­ç¬¬ 1 ä¸ªæ˜¯è€å¸ˆç»™å‡ºçš„è¯„åˆ†ï¼Œåé¢ Nâˆ’1 ä¸ªæ˜¯å…¶ä»–ç»„ç»™çš„è¯„åˆ†ã€‚åˆæ³•çš„è¾“å…¥åº”è¯¥æ˜¯ [0,M] åŒºé—´å†…çš„æ•´æ•°ï¼Œè‹¥ä¸åœ¨åˆæ³•åŒºé—´å†…ï¼Œåˆ™è¯¥åˆ†æ•°é¡»è¢«å¿½ç•¥ã€‚é¢˜ç›®ä¿è¯è€å¸ˆçš„è¯„åˆ†éƒ½æ˜¯åˆæ³•çš„ï¼Œå¹¶ä¸”æ¯ä¸ªç»„è‡³å°‘ä¼šæœ‰ 3 ä¸ªæ¥è‡ªåŒå­¦çš„åˆæ³•è¯„åˆ†ã€‚\nè¾“å‡º ä¸ºæ¯ä¸ªç»„è¾“å‡ºå…¶æœ€ç»ˆå¾—åˆ†ã€‚æ¯ä¸ªå¾—åˆ†å ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 16 50 242 49 49 35 38 41 336 51 50 28 -1 30 440 36 41 33 47 49 530 250 -25 27 45 31 648 0 0 50 50 1234 743 41 36 29 42 29 æ ·ä¾‹è¾“å‡º 142 233 341 431 537 639 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n, m; 4 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 5 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 int mx=-1, mi=m+1, t, g1, g2=0, num=-2; 9 for(int j=0; j\u0026lt;n; j++) 10 { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 12 if(j){ 13 if(t\u0026lt;0 || t\u0026gt;m) continue; 14 g2 += t; 15 mx = max(mx, t); 16 mi = min(mi, t); 17 num++; 18 } 19 else 20 g1 = t; 21 } 22 g2 = g2-mx-mi; 23 printf(\u0026#34;%d\\n\u0026#34;, (int)round((g1+1.0*g2/num)*0.5)); 24 } 25 return 0; 26} ","permalink":"https://blog.lordash.de/posts/solution/patb-1077-%E4%BA%92%E8%AF%84%E6%88%90%E7%BB%A9%E8%AE%A1%E7%AE%97/","summary":"äº’è¯„æˆç»©è®¡ç®— (PATB-1077) é¢˜é¢ åœ¨æµ™å¤§çš„è®¡ç®—æœºä¸“ä¸šè¯¾ä¸­ï¼Œç»å¸¸æœ‰äº’è¯„åˆ†ç»„æŠ¥å‘Šè¿™ä¸ªç¯èŠ‚ã€‚ä¸€ä¸ªç»„ä¸Šå°ä»‹ç»è‡ªå·±çš„å·¥ä½œï¼Œå…¶ä»–ç»„åœ¨å°ä¸‹ä¸ºå…¶è¡¨ç°è¯„åˆ†ã€‚æœ€åè¿™ä¸ªç»„çš„äº’è¯„æˆ","title":"PATB-1077 äº’è¯„æˆç»©è®¡ç®—"},{"content":"Wifiå¯†ç  (PATB-1076) é¢˜é¢ ä¸‹é¢æ˜¯å¾®åšä¸Šæµä¼ çš„ä¸€å¼ ç…§ç‰‡ï¼šâ€œå„ä½äº²çˆ±çš„åŒå­¦ä»¬ï¼Œé‰´äºå¤§å®¶æœ‰æ—¶éœ€è¦ä½¿ç”¨ wifiï¼Œåˆæ€•è€½è¯¯äº²ä»¬çš„å­¦ä¹ ï¼Œç°å°† wifi å¯†ç è®¾ç½®ä¸ºä¸‹åˆ—æ•°å­¦é¢˜ç­”æ¡ˆï¼šA-1ï¼›B-2ï¼›C-3ï¼›D-4ï¼›è¯·åŒå­¦ä»¬è‡ªå·±ä½œç­”ï¼Œæ¯ä¸¤æ—¥ä¸€æ¢ã€‚è°¢è°¢åˆä½œï¼ï¼~â€â€”â€” è€å¸ˆä»¬ä¸ºäº†ä¿ƒè¿›å­¦ç”Ÿå­¦ä¹ ä¹Ÿæ˜¯æ‹¼äº†â€¦â€¦ æœ¬é¢˜å°±è¦æ±‚ä½ å†™ç¨‹åºæŠŠä¸€ç³»åˆ—é¢˜ç›®çš„ç­”æ¡ˆæŒ‰ç…§å·å­ä¸Šç»™å‡ºçš„å¯¹åº”å…³ç³»ç¿»è¯‘æˆ wifi çš„å¯†ç ã€‚è¿™é‡Œç®€å•å‡è®¾æ¯é“é€‰æ‹©é¢˜éƒ½æœ‰ 4 ä¸ªé€‰é¡¹ï¼Œæœ‰ä¸”åªæœ‰ 1 ä¸ªæ­£ç¡®ç­”æ¡ˆã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ç…§ ç¼–å·-ç­”æ¡ˆ çš„æ ¼å¼ç»™å‡ºä¸€é“é¢˜çš„ 4 ä¸ªé€‰é¡¹ï¼ŒT è¡¨ç¤ºæ­£ç¡®é€‰é¡¹ï¼ŒF è¡¨ç¤ºé”™è¯¯é€‰é¡¹ã€‚é€‰é¡¹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡º wifi å¯†ç ã€‚\næ ·ä¾‹è¾“å…¥ 18 2A-T B-F C-F D-F 3C-T B-F A-F D-F 4A-F D-F C-F B-T 5B-T A-F C-F D-F 6B-F D-T A-F C-F 7A-T C-F B-F D-F 8D-T B-F C-F A-F 9C-T A-F B-F D-F æ ·ä¾‹è¾“å‡º 113224143 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 5 for(int i=0; i\u0026lt;n; i++) 6 { 7 for(int j=0; j\u0026lt;4; j++) 8 { 9 char a, b; 10 scanf(\u0026#34; %c-%c\u0026#34;, \u0026amp;a, \u0026amp;b); 11 if(b==\u0026#39;T\u0026#39;) 12 printf(\u0026#34;%d\u0026#34;, a-\u0026#39;A\u0026#39;+1); 13 } 14 } 15 return 0; 16} ","permalink":"https://blog.lordash.de/posts/solution/patb-1076-wifi%E5%AF%86%E7%A0%81/","summary":"Wifiå¯†ç  (PATB-1076) é¢˜é¢ ä¸‹é¢æ˜¯å¾®åšä¸Šæµä¼ çš„ä¸€å¼ ç…§ç‰‡ï¼šâ€œå„ä½äº²çˆ±çš„åŒå­¦ä»¬ï¼Œé‰´äºå¤§å®¶æœ‰æ—¶éœ€è¦ä½¿ç”¨ wifiï¼Œåˆæ€•è€½è¯¯äº²ä»¬çš„å­¦ä¹ ï¼Œç°å°† wifi å¯†ç è®¾ç½®ä¸ºä¸‹åˆ—æ•°å­¦","title":"PATB-1076 Wifiå¯†ç "},{"content":"é“¾è¡¨å…ƒç´ åˆ†ç±» (PATB-1075) é¢˜é¢ ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œè¯·ç¼–å†™ç¨‹åºå°†é“¾è¡¨å…ƒç´ è¿›è¡Œåˆ†ç±»æ’åˆ—ï¼Œä½¿å¾—æ‰€æœ‰è´Ÿå€¼å…ƒç´ éƒ½æ’åœ¨éè´Ÿå€¼å…ƒç´ çš„å‰é¢ï¼Œè€Œ [0, K] åŒºé—´å†…çš„å…ƒç´ éƒ½æ’åœ¨å¤§äº K çš„å…ƒç´ å‰é¢ã€‚ä½†æ¯ä¸€ç±»å†…éƒ¨å…ƒç´ çš„é¡ºåºæ˜¯ä¸èƒ½æ”¹å˜çš„ã€‚ä¾‹å¦‚ï¼šç»™å®šé“¾è¡¨ä¸º 18â†’7â†’-4â†’0â†’5â†’-6â†’10â†’11â†’-2ï¼ŒK ä¸º 10ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º -4â†’-6â†’-2â†’7â†’0â†’5â†’10â†’18â†’11ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºï¼šç¬¬ 1 ä¸ªç»“ç‚¹çš„åœ°å€ï¼›ç»“ç‚¹æ€»ä¸ªæ•°ï¼Œå³æ­£æ•´æ•°N (â‰¤10^5)ï¼›ä»¥åŠæ­£æ•´æ•°K (â‰¤10^3)ã€‚ç»“ç‚¹çš„åœ°å€æ˜¯ 5 ä½éè´Ÿæ•´æ•°ï¼ŒNULL åœ°å€ç”¨ âˆ’1 è¡¨ç¤ºã€‚\næ¥ä¸‹æ¥æœ‰ N è¡Œï¼Œæ¯è¡Œæ ¼å¼ä¸ºï¼š\n1Address Data Next å…¶ä¸­ Address æ˜¯ç»“ç‚¹åœ°å€ï¼›Data æ˜¯è¯¥ç»“ç‚¹ä¿å­˜çš„æ•°æ®ï¼Œä¸º [âˆ’10^5,10^5] åŒºé—´å†…çš„æ•´æ•°ï¼›Next æ˜¯ä¸‹ä¸€ç»“ç‚¹çš„åœ°å€ã€‚é¢˜ç›®ä¿è¯ç»™å‡ºçš„é“¾è¡¨ä¸ä¸ºç©ºã€‚\nè¾“å‡º å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼ŒæŒ‰é“¾è¡¨ä»å¤´åˆ°å°¾çš„é¡ºåºè¾“å‡ºé‡æ’åçš„ç»“æœé“¾è¡¨ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹å ä¸€è¡Œï¼Œæ ¼å¼ä¸è¾“å…¥ç›¸åŒã€‚\næ ·ä¾‹è¾“å…¥ 100100 9 10 223333 10 27777 300000 0 99999 400100 18 12309 568237 -6 23333 633218 -4 00000 748652 -2 -1 899999 5 68237 927777 11 48652 1012309 7 33218 æ ·ä¾‹è¾“å‡º 133218 -4 68237 268237 -6 48652 348652 -2 12309 412309 7 00000 500000 0 99999 699999 5 23333 723333 10 00100 800100 18 27777 927777 11 -1 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int val[mxn], nxt[mxn]; 3int tmp[mxn], ans[mxn], vis[mxn]; 4 5int main() 6{ 7 int s, n, k, x; 8 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;s, \u0026amp;n, \u0026amp;k); 9 10 for (int i=0; i\u0026lt;n; i++) 11 { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 13 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;val[x], \u0026amp;nxt[x]); 14 } 15 16 int cnt=0, num=0; 17 for (int t=s; t!=-1; t=nxt[t]) { 18 tmp[cnt++] = t; 19 } 20 21 for (int i=0; i\u0026lt;cnt; i++) 22 { 23 if(val[tmp[i]] \u0026lt; 0) 24 { 25 ans[num++] = tmp[i]; 26 vis[tmp[i]]++; 27 } 28 } 29 for (int i=0; i\u0026lt;cnt; i++) 30 { 31 if(vis[tmp[i]]==0 \u0026amp;\u0026amp; val[tmp[i]] \u0026lt;= k) 32 { 33 ans[num++] = tmp[i]; 34 vis[tmp[i]]++; 35 } 36 } 37 for (int i=0; i\u0026lt;cnt; i++) 38 { 39 if(vis[tmp[i]]==0) 40 ans[num++] = tmp[i]; 41 } 42 43 for (int i=0; i\u0026lt;num-1; i++) 44 printf(\u0026#34;%05d %d %05d\\n\u0026#34;, ans[i], val[ans[i]], ans[i+1]); 45 46 printf(\u0026#34;%05d %d -1\u0026#34;, ans[num-1], val[ans[num-1]]); 47 return 0; 48} ","permalink":"https://blog.lordash.de/posts/solution/patb-1075-%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E5%88%86%E7%B1%BB/","summary":"é“¾è¡¨å…ƒç´ åˆ†ç±» (PATB-1075) é¢˜é¢ ç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œè¯·ç¼–å†™ç¨‹åºå°†é“¾è¡¨å…ƒç´ è¿›è¡Œåˆ†ç±»æ’åˆ—ï¼Œä½¿å¾—æ‰€æœ‰è´Ÿå€¼å…ƒç´ éƒ½æ’åœ¨éè´Ÿå€¼å…ƒç´ çš„å‰é¢ï¼Œè€Œ [0, K] åŒºé—´å†…çš„å…ƒç´ éƒ½æ’åœ¨å¤§äº K çš„","title":"PATB-1075 é“¾è¡¨å…ƒç´ åˆ†ç±»"},{"content":"å®‡å®™æ— æ•ŒåŠ æ³•å™¨ (PATB-1074) é¢˜é¢ åœ°çƒäººä¹ æƒ¯ä½¿ç”¨åè¿›åˆ¶æ•°ï¼Œå¹¶ä¸”é»˜è®¤ä¸€ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯åè¿›åˆ¶çš„ã€‚è€Œåœ¨ PAT æ˜Ÿäººå¼€æŒ‚çš„ä¸–ç•Œé‡Œï¼Œæ¯ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯ä¸åŒè¿›åˆ¶çš„ï¼Œè¿™ç§ç¥å¥‡çš„æ•°å­—ç§°ä¸ºâ€œPATæ•°â€ã€‚æ¯ä¸ª PAT æ˜Ÿäººéƒ½å¿…é¡»ç†Ÿè®°å„ä½æ•°å­—çš„è¿›åˆ¶è¡¨ï¼Œä¾‹å¦‚â€œâ€¦â€¦0527â€å°±è¡¨ç¤ºæœ€ä½ä½æ˜¯ 7 è¿›åˆ¶æ•°ã€ç¬¬ 2 ä½æ˜¯ 2 è¿›åˆ¶æ•°ã€ç¬¬ 3 ä½æ˜¯ 5 è¿›åˆ¶æ•°ã€ç¬¬ 4 ä½æ˜¯ 10 è¿›åˆ¶æ•°ï¼Œç­‰ç­‰ã€‚æ¯ä¸€ä½çš„è¿›åˆ¶ d æˆ–è€…æ˜¯ 0ï¼ˆè¡¨ç¤ºåè¿›åˆ¶ï¼‰ã€æˆ–è€…æ˜¯ [2ï¼Œ9] åŒºé—´å†…çš„æ•´æ•°ã€‚ç†è®ºä¸Šè¿™ä¸ªè¿›åˆ¶è¡¨åº”è¯¥åŒ…å«æ— ç©·å¤šä½æ•°å­—ï¼Œä½†ä»å®é™…åº”ç”¨å‡ºå‘ï¼ŒPAT æ˜Ÿäººé€šå¸¸åªéœ€è¦è®°ä½å‰ 20 ä½å°±å¤Ÿç”¨äº†ï¼Œä»¥åå„ä½é»˜è®¤ä¸º 10 è¿›åˆ¶ã€‚\nåœ¨è¿™æ ·çš„æ•°å­—ç³»ç»Ÿä¸­ï¼Œå³ä½¿æ˜¯ç®€å•çš„åŠ æ³•è¿ç®—ä¹Ÿå˜å¾—ä¸ç®€å•ã€‚ä¾‹å¦‚å¯¹åº”è¿›åˆ¶è¡¨â€œ0527â€ï¼Œè¯¥å¦‚ä½•è®¡ç®—â€œ6203 + 415â€å‘¢ï¼Ÿæˆ‘ä»¬å¾—é¦–å…ˆè®¡ç®—æœ€ä½ä½ï¼š3 + 5 = 8ï¼›å› ä¸ºæœ€ä½ä½æ˜¯ 7 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 1 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 2 ä½æ˜¯ï¼š0 + 1 + 1ï¼ˆè¿›ä½ï¼‰= 2ï¼›å› ä¸ºæ­¤ä½æ˜¯ 2 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 0 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 3 ä½æ˜¯ï¼š2 + 4 + 1ï¼ˆè¿›ä½ï¼‰= 7ï¼›å› ä¸ºæ­¤ä½æ˜¯ 5 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾—åˆ° 2 å’Œ 1 ä¸ªè¿›ä½ã€‚ç¬¬ 4 ä½æ˜¯ï¼š6 + 1ï¼ˆè¿›ä½ï¼‰= 7ï¼›å› ä¸ºæ­¤ä½æ˜¯ 10 è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±å¾—åˆ° 7ã€‚æœ€åæˆ‘ä»¬å¾—åˆ°ï¼š6203 + 415 = 7201ã€‚\nè¾“å…¥ è¾“å…¥é¦–å…ˆåœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ª N ä½çš„è¿›åˆ¶è¡¨ï¼ˆ0 \u0026lt; N â‰¤ 20ï¼‰ï¼Œä»¥å›è½¦ç»“æŸã€‚ éšåä¸¤è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ N ä½çš„éè´Ÿçš„ PAT æ•°ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºä¸¤ä¸ª PAT æ•°ä¹‹å’Œã€‚\næ ·ä¾‹è¾“å…¥ 130527 206203 3415 æ ·ä¾‹è¾“å‡º 17201 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], a[mxn], b[mxn], ans[mxn]; 3 4void init(char *s, int n) 5{ 6 int m = strlen(s); 7 for(int i=0; i+i\u0026lt;m; i++) 8 swap(s[i], s[m-i-1]); 9 for(int i=m; i\u0026lt;n; i++) 10 s[i] = \u0026#39;0\u0026#39;; 11 s[n] = \u0026#39;\\0\u0026#39;; 12} 13 14int main() 15{ 16 scanf(\u0026#34;%s %s %s\u0026#34;, s, a ,b); 17 int sl = strlen(s); 18 init(s, sl); init(a, sl); init(b, sl); 19 20 int i=0, p=0; 21 for(; i\u0026lt;sl; i++) 22 { 23 s[i] += s[i]-\u0026#39;0\u0026#39; ? 0 : 10; 24 ans[i] = (a[i]-\u0026#39;0\u0026#39; + b[i]-\u0026#39;0\u0026#39; + p) % (s[i]-\u0026#39;0\u0026#39;) +\u0026#39;0\u0026#39;; 25 p = (a[i]-\u0026#39;0\u0026#39; + b[i]-\u0026#39;0\u0026#39; + p) / (s[i]-\u0026#39;0\u0026#39;); 26 } 27 if(p) ans[i++] = \u0026#39;1\u0026#39;; 28 29 int f = 1; 30 while(i--) 31 { 32 if(f \u0026amp;\u0026amp; ans[i] == \u0026#39;0\u0026#39;) 33 continue; 34 f = 0; 35 printf(\u0026#34;%c\u0026#34;, ans[i]); 36 } 37 if(f) printf(\u0026#34;0\u0026#34;); 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/patb-1074-%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E5%8A%A0%E6%B3%95%E5%99%A8/","summary":"å®‡å®™æ— æ•ŒåŠ æ³•å™¨ (PATB-1074) é¢˜é¢ åœ°çƒäººä¹ æƒ¯ä½¿ç”¨åè¿›åˆ¶æ•°ï¼Œå¹¶ä¸”é»˜è®¤ä¸€ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯åè¿›åˆ¶çš„ã€‚è€Œåœ¨ PAT æ˜Ÿäººå¼€æŒ‚çš„ä¸–ç•Œé‡Œï¼Œæ¯ä¸ªæ•°å­—çš„æ¯ä¸€ä½éƒ½æ˜¯ä¸åŒè¿›åˆ¶çš„ï¼Œè¿™","title":"PATB-1074 å®‡å®™æ— æ•ŒåŠ æ³•å™¨"},{"content":"å¤šé€‰é¢˜å¸¸è§è®¡åˆ†æ³• (PATB-1073) é¢˜é¢ æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ‰å¾ˆå¤šä¸åŒçš„è®¡åˆ†æ–¹æ³•ã€‚æœ‰ä¸€ç§æœ€å¸¸è§çš„è®¡åˆ†æ–¹æ³•æ˜¯ï¼šå¦‚æœè€ƒç”Ÿé€‰æ‹©äº†éƒ¨åˆ†æ­£ç¡®é€‰é¡¹ï¼Œå¹¶ä¸”æ²¡æœ‰é€‰æ‹©ä»»ä½•é”™è¯¯é€‰é¡¹ï¼Œåˆ™å¾—åˆ° 50% åˆ†æ•°ï¼›å¦‚æœè€ƒç”Ÿé€‰æ‹©äº†ä»»ä½•ä¸€ä¸ªé”™è¯¯çš„é€‰é¡¹ï¼Œåˆ™ä¸èƒ½å¾—åˆ†ã€‚æœ¬é¢˜å°±è¯·ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆæ‰¹æ”¹å¤šé€‰é¢˜ï¼Œå¹¶ä¸”æŒ‡å‡ºå“ªé“é¢˜çš„å“ªä¸ªé€‰é¡¹é”™çš„äººæœ€å¤šã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰å’Œ Mï¼ˆâ‰¤100ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œå¤šé€‰é¢˜çš„ä¸ªæ•°ã€‚éšå M è¡Œï¼Œæ¯è¡Œé¡ºæ¬¡ç»™å‡ºä¸€é“é¢˜çš„æ»¡åˆ†å€¼ï¼ˆä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€é€‰é¡¹ä¸ªæ•°ï¼ˆä¸å°‘äº 2 ä¸”ä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€æ­£ç¡®é€‰é¡¹ä¸ªæ•°ï¼ˆä¸è¶…è¿‡é€‰é¡¹ä¸ªæ•°çš„æ­£æ•´æ•°ï¼‰ã€æ‰€æœ‰æ­£ç¡®é€‰é¡¹ã€‚æ³¨æ„æ¯é¢˜çš„é€‰é¡¹ä»å°å†™è‹±æ–‡å­—æ¯ a å¼€å§‹é¡ºæ¬¡æ’åˆ—ã€‚å„é¡¹é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚æœ€å N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªå­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µï¼Œå…¶æ¯é¢˜ç­”æ¡ˆæ ¼å¼ä¸º (é€‰ä¸­çš„é€‰é¡¹ä¸ªæ•° é€‰é¡¹1 â€¦â€¦)ï¼ŒæŒ‰é¢˜ç›®é¡ºåºç»™å‡ºã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µæ˜¯åˆæ³•çš„ï¼Œå³ä¸å­˜åœ¨é€‰ä¸­çš„é€‰é¡¹æ•°è¶…è¿‡å®é™…é€‰é¡¹æ•°çš„æƒ…å†µã€‚\nè¾“å‡º æŒ‰ç…§è¾“å…¥çš„é¡ºåºç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å¾—åˆ†ï¼Œæ¯ä¸ªåˆ†æ•°å ä¸€è¡Œï¼Œè¾“å‡ºå°æ•°ç‚¹å 1 ä½ã€‚æœ€åè¾“å‡ºé”™å¾—æœ€å¤šçš„é¢˜ç›®é€‰é¡¹çš„ä¿¡æ¯ï¼Œæ ¼å¼ä¸ºï¼šé”™è¯¯æ¬¡æ•° é¢˜ç›®ç¼–å·ï¼ˆé¢˜ç›®æŒ‰ç…§è¾“å…¥çš„é¡ºåºä»1å¼€å§‹ç¼–å·ï¼‰-é€‰é¡¹å·ã€‚å¦‚æœæœ‰å¹¶åˆ—ï¼Œåˆ™æ¯è¡Œä¸€ä¸ªé€‰é¡¹ï¼ŒæŒ‰é¢˜ç›®ç¼–å·é€’å¢é¡ºåºè¾“å‡ºï¼›å†å¹¶åˆ—åˆ™æŒ‰é€‰é¡¹å·é€’å¢é¡ºåºè¾“å‡ºã€‚è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½æ²¡æœ‰äººé”™ï¼Œåˆ™åœ¨æœ€åä¸€è¡Œè¾“å‡º Too simpleã€‚\næ ·ä¾‹è¾“å…¥1 13 4 23 4 2 a c 32 5 1 b 45 3 2 b c 51 5 4 a b d e 6(2 a c) (3 b d e) (2 a c) (3 a b e) 7(2 a c) (1 b) (2 a b) (4 a b d e) 8(2 b d) (1 e) (1 c) (4 a b c d) æ ·ä¾‹è¾“å‡º1 13.5 26.0 32.5 42 2-e 52 3-a 62 3-b æ ·ä¾‹è¾“å…¥2 12 2 23 4 2 a c 32 5 1 b 4(2 a c) (1 b) 5(2 a c) (1 b) æ ·ä¾‹è¾“å‡º2 15.0 25.0 3Too simple æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2struct P { 3 DB s; 4 int t; 5}a[mxn]; 6 7int p[] = {1, 2, 4, 8, 16}; 8int err[mxn][5]; 9 10int main() 11{ 12 int n, m; 13 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 14 15 int x; char ch; 16 for(int i=1; i\u0026lt;=m; i++) 17 { 18 scanf(\u0026#34;%lf %*d %d\u0026#34;, \u0026amp;a[i].s, \u0026amp;x); 19 for(int j=0; j\u0026lt;x; j++) 20 { 21 scanf(\u0026#34; %c\u0026#34;, \u0026amp;ch); 22 a[i].t += p[ch-\u0026#39;a\u0026#39;]; 23 } 24 } 25 getchar(); 26 for(int i=0; i\u0026lt;n; i++) 27 { 28 DB sum=0; int ans=0, num=0; 29 while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch) \u0026amp;\u0026amp; ch != \u0026#39;\\n\u0026#39;) 30 { 31 if(ch == \u0026#39;)\u0026#39;) 32 { 33 num++; 34 if(ans==a[num].t) 35 sum += a[num].s; 36 else if((ans | a[num].t)==a[num].t) 37 sum += a[num].s * 0.5; 38 39 for(int j=0; j\u0026lt;5; j++) 40 if(((ans ^ a[num].t) \u0026amp; p[j]) == p[j]) 41 err[num][j]++; 42 43 ans = 0; 44 } 45 if(isalpha(ch)) ans += p[ch-\u0026#39;a\u0026#39;]; 46 } 47 printf(\u0026#34;%.1lf\\n\u0026#34;, sum); 48 } 49 50 int mx = 0; 51 for(int i=1; i\u0026lt;=m; i++) 52 for(int j=0; j\u0026lt;5; j++) 53 if(mx \u0026lt; err[i][j]) mx = err[i][j]; 54 55 if(mx == 0) 56 { 57 printf(\u0026#34;Too simple\\n\u0026#34;); 58 return 0; 59 } 60 61 for(int i=1; i\u0026lt;=m; i++) 62 for(int j=0; j\u0026lt;5; j++) 63 if(mx == err[i][j]) 64 printf(\u0026#34;%d %d-%c\\n\u0026#34;, mx, i, j+\u0026#39;a\u0026#39;); 65 66 return 0; 67} ","permalink":"https://blog.lordash.de/posts/solution/patb-1073-%E5%A4%9A%E9%80%89%E9%A2%98%E5%B8%B8%E8%A7%81%E8%AE%A1%E5%88%86%E6%B3%95/","summary":"å¤šé€‰é¢˜å¸¸è§è®¡åˆ†æ³• (PATB-1073) é¢˜é¢ æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ‰å¾ˆå¤šä¸åŒçš„è®¡åˆ†æ–¹æ³•ã€‚æœ‰ä¸€ç§æœ€å¸¸è§çš„è®¡åˆ†æ–¹æ³•æ˜¯ï¼šå¦‚æœè€ƒç”Ÿé€‰æ‹©äº†éƒ¨åˆ†æ­£ç¡®é€‰é¡¹ï¼Œå¹¶ä¸”æ²¡æœ‰é€‰æ‹©ä»»","title":"PATB-1073 å¤šé€‰é¢˜å¸¸è§è®¡åˆ†æ³•"},{"content":"å¼€å­¦å¯„è¯­ (PATB-1072) é¢˜é¢ ä¸‹å›¾æ˜¯ä¸Šæµ·æŸæ ¡çš„æ–°å­¦æœŸå¼€å­¦å¯„è¯­ï¼šå¤©å°†é™å¤§ä»»äºæ–¯äººä¹Ÿï¼Œå¿…å…ˆåˆ å…¶å¾®åšï¼Œå¸å…¶ QQï¼Œå°å…¶ç”µè„‘ï¼Œå¤ºå…¶æ‰‹æœºï¼Œæ”¶å…¶ ipadï¼Œæ–­å…¶ wifiï¼Œä½¿å…¶ç™¾æ— èŠèµ–ï¼Œç„¶åï¼Œå‡€é¢ã€ç†å‘ã€æ•´è¡£ï¼Œç„¶åæ€è¿‡ã€è¯»ä¹¦ã€é”»ç‚¼ã€æ˜æ™ºã€å¼€æ‚Ÿã€ç²¾è¿›ã€‚è€Œåå¿…æˆå¤§å™¨ä¹Ÿï¼\næœ¬é¢˜è¦æ±‚ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è¿™æ‰€å­¦æ ¡çš„è€å¸ˆæ£€æŸ¥æ‰€æœ‰å­¦ç”Ÿçš„ç‰©å“ï¼Œä»¥åŠ©å…¶æˆå¤§å™¨ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰å’Œ Mï¼ˆâ‰¤ 6ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œéœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“ç§ç±»æ•°ã€‚ç¬¬äºŒè¡Œç»™å‡º M ä¸ªéœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“ç¼–å·ï¼Œå…¶ä¸­ç¼–å·ä¸º 4 ä½æ•°å­—ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½å­¦ç”Ÿçš„å§“åç¼©å†™ï¼ˆç”± 1-4 ä¸ªå¤§å†™è‹±æ–‡å­—æ¯ç»„æˆï¼‰ã€ä¸ªäººç‰©å“æ•°é‡ Kï¼ˆ0 â‰¤ K â‰¤ 10ï¼‰ã€ä»¥åŠ K ä¸ªç‰©å“çš„ç¼–å·ã€‚\nè¾“å‡º é¡ºæ¬¡æ£€æŸ¥æ¯ä¸ªå­¦ç”Ÿæºå¸¦çš„ç‰©å“ï¼Œå¦‚æœæœ‰éœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“å­˜åœ¨ï¼Œåˆ™æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºè¯¥ç”Ÿçš„ä¿¡æ¯å’Œå…¶éœ€è¦è¢«æŸ¥ç¼´çš„ç‰©å“çš„ä¿¡æ¯ï¼ˆæ³¨æ„è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ï¼‰ï¼š\n1å§“åç¼©å†™: ç‰©å“ç¼–å·1 ç‰©å“ç¼–å·2 â€¦â€¦ æœ€åä¸€è¡Œè¾“å‡ºå­˜åœ¨é—®é¢˜çš„å­¦ç”Ÿçš„æ€»äººæ•°å’Œè¢«æŸ¥ç¼´ç‰©å“çš„æ€»æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 14 2 22333 6666 3CYLL 3 1234 2345 3456 4U 4 9966 6666 8888 6666 5GG 2 2333 7777 6JJ 3 0012 6666 2333 æ ·ä¾‹è¾“å‡º 1U: 6666 6666 2GG: 2333 3JJ: 6666 2333 43 5 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e4 + 5; 2int a[mxn]; 3 4int main() 5{ 6 int n, m; 7 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 8 9 for(int i=0; i\u0026lt;m; i++) 10 { 11 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 12 a[x]++; 13 } 14 15 int ans1=0, ans2=0; char t[5]; 16 for(int i=0; i\u0026lt;n; i++) 17 { 18 int num, x, f = 1; 19 scanf(\u0026#34;%s %d\u0026#34;, t, \u0026amp;num); 20 while(num--) 21 { 22 scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 23 if(a[x]) 24 { 25 if(f){ 26 printf(\u0026#34;%s:\u0026#34;, t); 27 ans1++; 28 f = 0; 29 } 30 printf(\u0026#34; %04d\u0026#34;, x); 31 ans2++; 32 } 33 } 34 if(f == 0) printf(\u0026#34;\\n\u0026#34;); 35 } 36 printf(\u0026#34;%d %d\\n\u0026#34;, ans1, ans2); 37 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/patb-1072-%E5%BC%80%E5%AD%A6%E5%AF%84%E8%AF%AD/","summary":"å¼€å­¦å¯„è¯­ (PATB-1072) é¢˜é¢ ä¸‹å›¾æ˜¯ä¸Šæµ·æŸæ ¡çš„æ–°å­¦æœŸå¼€å­¦å¯„è¯­ï¼šå¤©å°†é™å¤§ä»»äºæ–¯äººä¹Ÿï¼Œå¿…å…ˆåˆ å…¶å¾®åšï¼Œå¸å…¶ QQï¼Œå°å…¶ç”µè„‘ï¼Œå¤ºå…¶æ‰‹æœºï¼Œæ”¶å…¶ ipadï¼Œæ–­å…¶ wifiï¼Œä½¿","title":"PATB-1072 å¼€å­¦å¯„è¯­"},{"content":"å°èµŒæ€¡æƒ… (PATB-1071) é¢˜é¢ å¸¸è¨€é“â€œå°èµŒæ€¡æƒ…â€ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„å°æ¸¸æˆï¼šé¦–å…ˆç”±è®¡ç®—æœºç»™å‡ºç¬¬ä¸€ä¸ªæ•´æ•°ï¼›ç„¶åç©å®¶ä¸‹æ³¨èµŒç¬¬äºŒä¸ªæ•´æ•°å°†ä¼šæ¯”ç¬¬ä¸€ä¸ªæ•°å¤§è¿˜æ˜¯å°ï¼›ç©å®¶ä¸‹æ³¨ t ä¸ªç­¹ç åï¼Œè®¡ç®—æœºç»™å‡ºç¬¬äºŒä¸ªæ•°ã€‚è‹¥ç©å®¶çŒœå¯¹äº†ï¼Œåˆ™ç³»ç»Ÿå¥–åŠ±ç©å®¶ t ä¸ªç­¹ç ï¼›å¦åˆ™æ‰£é™¤ç©å®¶ t ä¸ªç­¹ç ã€‚\næ³¨æ„ï¼šç©å®¶ä¸‹æ³¨çš„ç­¹ç æ•°ä¸èƒ½è¶…è¿‡è‡ªå·±å¸æˆ·ä¸Šæ‹¥æœ‰çš„ç­¹ç æ•°ã€‚å½“ç©å®¶è¾“å…‰äº†å…¨éƒ¨ç­¹ç åï¼Œæ¸¸æˆå°±ç»“æŸã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡º 2 ä¸ªæ­£æ•´æ•° T å’Œ Kï¼ˆâ‰¤ 100ï¼‰ï¼Œåˆ†åˆ«æ˜¯ç³»ç»Ÿåœ¨åˆå§‹çŠ¶æ€ä¸‹èµ é€ç»™ç©å®¶çš„ç­¹ç æ•°ã€ä»¥åŠéœ€è¦å¤„ç†çš„æ¸¸æˆæ¬¡æ•°ã€‚éšå K è¡Œï¼Œæ¯è¡Œå¯¹åº”ä¸€æ¬¡æ¸¸æˆï¼Œé¡ºåºç»™å‡º 4 ä¸ªæ•°å­—ï¼š\n1n1 b t n2 å…¶ä¸­ n1 å’Œ n2 æ˜¯è®¡ç®—æœºå…ˆåç»™å‡ºçš„ä¸¤ä¸ª[0, 9]å†…çš„æ•´æ•°ï¼Œä¿è¯ä¸¤ä¸ªæ•°å­—ä¸ç›¸ç­‰ã€‚b ä¸º 0 è¡¨ç¤ºç©å®¶èµŒå°ï¼Œä¸º 1 è¡¨ç¤ºç©å®¶èµŒå¤§ã€‚t è¡¨ç¤ºç©å®¶ä¸‹æ³¨çš„ç­¹ç æ•°ï¼Œä¿è¯åœ¨æ•´å‹èŒƒå›´å†…ã€‚\nè¾“å‡º å¯¹æ¯ä¸€æ¬¡æ¸¸æˆï¼Œæ ¹æ®ä¸‹åˆ—æƒ…å†µå¯¹åº”è¾“å‡ºï¼ˆå…¶ä¸­ t æ˜¯ç©å®¶ä¸‹æ³¨é‡ï¼Œx æ˜¯ç©å®¶å½“å‰æŒæœ‰çš„ç­¹ç é‡ï¼‰ï¼š\nç©å®¶èµ¢ï¼Œè¾“å‡º Win t! Total = x.ï¼› ç©å®¶è¾“ï¼Œè¾“å‡º Lose t. Total = x.ï¼› ç©å®¶ä¸‹æ³¨è¶…è¿‡æŒæœ‰çš„ç­¹ç é‡ï¼Œè¾“å‡º Not enough tokens. Total = x.ï¼› ç©å®¶è¾“å…‰åï¼Œè¾“å‡º Game Over. å¹¶ç»“æŸç¨‹åºã€‚ æ ·ä¾‹è¾“å…¥1 1100 4 28 0 100 2 33 1 50 1 45 1 200 6 57 0 200 8 æ ·ä¾‹è¾“å‡º 1Win 100! Total = 200. 2Lose 50. Total = 150. 3Not enough tokens. Total = 150. 4Not enough tokens. Total = 150. æ ·ä¾‹è¾“å…¥2 1100 4 28 0 100 2 33 1 200 1 45 1 200 6 57 0 200 8 æ ·ä¾‹è¾“å‡º 1Win 100! Total = 200. 2Lose 200. Total = 0. 3Game Over. æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int sum, n; 4 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;sum, \u0026amp;n); 5 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 int n1, b, t, n2; 9 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;n1, \u0026amp;b, \u0026amp;t, \u0026amp;n2); 10 if(t \u0026gt; sum) 11 { 12 printf(\u0026#34;Not enough tokens. Total = %d.\\n\u0026#34;, sum); 13 continue; 14 } 15 if(b == (n1\u0026lt;n2)) 16 { 17 sum += t; 18 printf(\u0026#34;Win %d! Total = %d.\\n\u0026#34;, t, sum); 19 } 20 else 21 { 22 sum -= t; 23 printf(\u0026#34;Lose %d. Total = %d.\\n\u0026#34;, t, sum); 24 } 25 if(sum == 0) 26 { 27 printf(\u0026#34;Game Over.\\n\u0026#34;); 28 break; 29 } 30 } 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1071-%E5%B0%8F%E8%B5%8C%E6%80%A1%E6%83%85/","summary":"å°èµŒæ€¡æƒ… (PATB-1071) é¢˜é¢ å¸¸è¨€é“â€œå°èµŒæ€¡æƒ…â€ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„å°æ¸¸æˆï¼šé¦–å…ˆç”±è®¡ç®—æœºç»™å‡ºç¬¬ä¸€ä¸ªæ•´æ•°ï¼›ç„¶åç©å®¶ä¸‹æ³¨èµŒç¬¬äºŒä¸ªæ•´æ•°å°†ä¼šæ¯”ç¬¬ä¸€ä¸ªæ•°å¤§è¿˜æ˜¯å°ï¼›ç©å®¶ä¸‹","title":"PATB-1071 å°èµŒæ€¡æƒ…"},{"content":"ç»“ç»³ (PATB-1070) é¢˜é¢ ç»™å®šä¸€æ®µä¸€æ®µçš„ç»³å­ï¼Œä½ éœ€è¦æŠŠå®ƒä»¬ä¸²æˆä¸€æ¡ç»³ã€‚æ¯æ¬¡ä¸²è¿çš„æ—¶å€™ï¼Œæ˜¯æŠŠä¸¤æ®µç»³å­å¯¹æŠ˜ï¼Œå†å¦‚ä¸‹å›¾æ‰€ç¤ºå¥—æ¥åœ¨ä¸€èµ·ã€‚è¿™æ ·å¾—åˆ°çš„ç»³å­åˆè¢«å½“æˆæ˜¯å¦ä¸€æ®µç»³å­ï¼Œå¯ä»¥å†æ¬¡å¯¹æŠ˜å»è·Ÿå¦ä¸€æ®µç»³å­ä¸²è¿ã€‚æ¯æ¬¡ä¸²è¿åï¼ŒåŸæ¥ä¸¤æ®µç»³å­çš„é•¿åº¦å°±ä¼šå‡åŠã€‚\nç»™å®š N æ®µç»³å­çš„é•¿åº¦ï¼Œä½ éœ€è¦æ‰¾å‡ºå®ƒä»¬èƒ½ä¸²æˆçš„ç»³å­çš„æœ€å¤§é•¿åº¦ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºæ­£æ•´æ•° N (2â‰¤Nâ‰¤10^4)ï¼›ç¬¬ 2 è¡Œç»™å‡º N ä¸ªæ­£æ•´æ•°ï¼Œå³åŸå§‹ç»³æ®µçš„é•¿åº¦ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æ‰€æœ‰æ•´æ•°éƒ½ä¸è¶…è¿‡10^4ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºèƒ½å¤Ÿä¸²æˆçš„ç»³å­çš„æœ€å¤§é•¿åº¦ã€‚ç»“æœå‘ä¸‹å–æ•´ï¼Œå³å–ä¸ºä¸è¶…è¿‡æœ€å¤§é•¿åº¦çš„æœ€è¿‘æ•´æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 18 210 15 12 3 4 13 1 15 æ ·ä¾‹è¾“å‡º 114 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e4 + 5; 2DB a[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 for(int i=0; i\u0026lt;n; i++) 9 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[i]); 10 sort(a, a+n); 11 12 DB sum = a[0]; 13 for(int i=1; i\u0026lt;n; i++) 14 sum = sum/2 + a[i]/2; 15 printf(\u0026#34;%d\\n\u0026#34;, (int)sum); 16 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/patb-1070-%E7%BB%93%E7%BB%B3/","summary":"ç»“ç»³ (PATB-1070) é¢˜é¢ ç»™å®šä¸€æ®µä¸€æ®µçš„ç»³å­ï¼Œä½ éœ€è¦æŠŠå®ƒä»¬ä¸²æˆä¸€æ¡ç»³ã€‚æ¯æ¬¡ä¸²è¿çš„æ—¶å€™ï¼Œæ˜¯æŠŠä¸¤æ®µç»³å­å¯¹æŠ˜ï¼Œå†å¦‚ä¸‹å›¾æ‰€ç¤ºå¥—æ¥åœ¨ä¸€èµ·ã€‚è¿™æ ·å¾—åˆ°çš„ç»³å­åˆè¢«å½“æˆæ˜¯å¦ä¸€","title":"PATB-1070 ç»“ç»³"},{"content":"å¾®åšè½¬å‘æŠ½å¥– (PATB-1069) é¢˜é¢ å°æ˜ PAT è€ƒäº†æ»¡åˆ†ï¼Œé«˜å…´ä¹‹ä½™å†³å®šå‘èµ·å¾®åšè½¬å‘æŠ½å¥–æ´»åŠ¨ï¼Œä»è½¬å‘çš„ç½‘å‹ä¸­æŒ‰é¡ºåºæ¯éš” N ä¸ªäººå°±å‘å‡ºä¸€ä¸ªçº¢åŒ…ã€‚è¯·ä½ ç¼–å†™ç¨‹åºå¸®åŠ©ä»–ç¡®å®šä¸­å¥–åå•ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸‰ä¸ªæ­£æ•´æ•° Mï¼ˆâ‰¤ 1000ï¼‰ã€N å’Œ Sï¼Œåˆ†åˆ«æ˜¯è½¬å‘çš„æ€»é‡ã€å°æ˜å†³å®šçš„ä¸­å¥–é—´éš”ã€ä»¥åŠç¬¬ä¸€ä½ä¸­å¥–è€…çš„åºå·ï¼ˆç¼–å·ä» 1 å¼€å§‹ï¼‰ã€‚éšå M è¡Œï¼Œé¡ºåºç»™å‡ºè½¬å‘å¾®åšçš„ç½‘å‹çš„æ˜µç§°ï¼ˆä¸è¶…è¿‡ 20 ä¸ªå­—ç¬¦ã€ä¸åŒ…å«ç©ºæ ¼å›è½¦çš„éç©ºå­—ç¬¦ä¸²ï¼‰ã€‚\næ³¨æ„ï¼šå¯èƒ½æœ‰äººè½¬å‘å¤šæ¬¡ï¼Œä½†ä¸èƒ½ä¸­å¥–å¤šæ¬¡ã€‚æ‰€ä»¥å¦‚æœå¤„äºå½“å‰ä¸­å¥–ä½ç½®çš„ç½‘å‹å·²ç»ä¸­è¿‡å¥–ï¼Œåˆ™è·³è¿‡ä»–é¡ºæ¬¡å–ä¸‹ä¸€ä½ã€‚\nè¾“å‡º æŒ‰ç…§è¾“å…¥çš„é¡ºåºè¾“å‡ºä¸­å¥–åå•ï¼Œæ¯ä¸ªæ˜µç§°å ä¸€è¡Œã€‚å¦‚æœæ²¡æœ‰äººä¸­å¥–ï¼Œåˆ™è¾“å‡º Keep going...ã€‚\næ ·ä¾‹è¾“å…¥1 19 3 2 2Imgonnawin! 3PickMe 4PickMeMeMeee 5LookHere 6Imgonnawin! 7TryAgainAgain 8TryAgainAgain 9Imgonnawin! 10TryAgainAgain æ ·ä¾‹è¾“å‡º1 1PickMe 2Imgonnawin! 3TryAgainAgain æ ·ä¾‹è¾“å…¥2 12 3 5 2Imgonnawin! 3PickMe æ ·ä¾‹è¾“å‡º2 1Keep going... æç¤º æ— \næ€è·¯ ä»£ç  1ULL bkdr(char* s) 2{ 3 ULL seed = 131, h = 0; 4 while (*s) 5 h = h * seed + (*s++); 6 return h; 7} 8 9int main() 10{ 11 int m, n, s; 12 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;m, \u0026amp;n, \u0026amp;s); 13 14 map\u0026lt;ULL, int\u0026gt; mmp; 15 int now=0, num=0; char t[25]; 16 17 for(int i=1; i\u0026lt;=m; i++) 18 { 19 scanf(\u0026#34;%s\u0026#34;, t); now++; 20 if(now\u0026gt;=s \u0026amp;\u0026amp; (now-s)%n==0) 21 { 22 int x = bkdr(t); 23 if(mmp.count(x) == 0) 24 { 25 printf(\u0026#34;%s\\n\u0026#34;, t); 26 num++, mmp[x]++; 27 } 28 else 29 now--; 30 } 31 } 32 if(num == 0) printf(\u0026#34;Keep going...\\n\u0026#34;); 33 34 return 0; 35} ","permalink":"https://blog.lordash.de/posts/solution/patb-1069-%E5%BE%AE%E5%8D%9A%E8%BD%AC%E5%8F%91%E6%8A%BD%E5%A5%96/","summary":"å¾®åšè½¬å‘æŠ½å¥– (PATB-1069) é¢˜é¢ å°æ˜ PAT è€ƒäº†æ»¡åˆ†ï¼Œé«˜å…´ä¹‹ä½™å†³å®šå‘èµ·å¾®åšè½¬å‘æŠ½å¥–æ´»åŠ¨ï¼Œä»è½¬å‘çš„ç½‘å‹ä¸­æŒ‰é¡ºåºæ¯éš” N ä¸ªäººå°±å‘å‡ºä¸€ä¸ªçº¢åŒ…ã€‚è¯·ä½ ç¼–å†™ç¨‹åºå¸®åŠ©ä»–ç¡®å®šä¸­å¥–","title":"PATB-1069 å¾®åšè½¬å‘æŠ½å¥–"},{"content":"ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢ (PATB-1068) é¢˜é¢ å¯¹äºè®¡ç®—æœºè€Œè¨€ï¼Œé¢œè‰²ä¸è¿‡æ˜¯åƒç´ ç‚¹å¯¹åº”çš„ä¸€ä¸ª 24 ä½çš„æ•°å€¼ã€‚ç°ç»™å®šä¸€å¹…åˆ†è¾¨ç‡ä¸º MÃ—N çš„ç”»ï¼Œè¦æ±‚ä½ æ‰¾å‡ºä¸‡ç»¿ä¸›ä¸­çš„ä¸€ç‚¹çº¢ï¼Œå³æœ‰ç‹¬ä¸€æ— äºŒé¢œè‰²çš„é‚£ä¸ªåƒç´ ç‚¹ï¼Œå¹¶ä¸”è¯¥ç‚¹çš„é¢œè‰²ä¸å…¶å‘¨å›´ 8 ä¸ªç›¸é‚»åƒç´ çš„é¢œè‰²å·®å……åˆ†å¤§ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸‰ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«æ˜¯ M å’Œ Nï¼ˆâ‰¤ 1000ï¼‰ï¼Œå³å›¾åƒçš„åˆ†è¾¨ç‡ï¼›ä»¥åŠ TOLï¼Œæ˜¯æ‰€æ±‚åƒç´ ç‚¹ä¸ç›¸é‚»ç‚¹çš„é¢œè‰²å·®é˜ˆå€¼ï¼Œè‰²å·®è¶…è¿‡ TOL çš„ç‚¹æ‰è¢«è€ƒè™‘ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡º M ä¸ªåƒç´ çš„é¢œè‰²å€¼ï¼ŒèŒƒå›´åœ¨ [0,2^24) å†…ã€‚æ‰€æœ‰åŒè¡Œæ•°å­—é—´ç”¨ç©ºæ ¼æˆ– TAB åˆ†å¼€ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ (x, y): color çš„æ ¼å¼è¾“å‡ºæ‰€æ±‚åƒç´ ç‚¹çš„ä½ç½®ä»¥åŠé¢œè‰²å€¼ï¼Œå…¶ä¸­ä½ç½® x å’Œ y åˆ†åˆ«æ˜¯è¯¥åƒç´ åœ¨å›¾åƒçŸ©é˜µä¸­çš„åˆ—ã€è¡Œç¼–å·ï¼ˆä» 1 å¼€å§‹ç¼–å·ï¼‰ã€‚å¦‚æœè¿™æ ·çš„ç‚¹ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡º Not Uniqueï¼›å¦‚æœè¿™æ ·çš„ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º Not Existã€‚\næ ·ä¾‹è¾“å…¥1 18 6 200 20 0 0 0 0 0 0 0 365280 65280 65280 16711479 65280 65280 65280 65280 416711479 65280 65280 65280 16711680 65280 65280 65280 565280 65280 65280 65280 65280 65280 165280 165280 665280 65280 16777015 65280 65280 165280 65480 165280 716777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 æ ·ä¾‹è¾“å‡º1 1(5, 3): 16711680 æ ·ä¾‹è¾“å…¥2 14 5 2 20 0 0 0 30 0 3 0 40 0 0 0 50 5 0 0 60 0 0 0 æ ·ä¾‹è¾“å‡º2 1Not Unique æ ·ä¾‹è¾“å…¥3 13 3 5 21 2 3 33 4 5 45 6 7 æ ·ä¾‹è¾“å‡º3 1Not Exist æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e3 + 5; 2int dir[][2] = { 3 {-1,-1}, {-1, 0}, {-1, 1}, 4 { 0,-1}, { 0, 1}, 5 { 1,-1}, { 1, 0}, { 1, 1}, 6}; 7int n, m, tol, a[mxn][mxn]; 8 9bool ok(int x, int y) 10{ 11 for(int i=0; i\u0026lt;8; i++) 12 { 13 int tx = x+dir[i][0]; 14 int ty = y+dir[i][1]; 15 if(tx \u0026lt; 0 || tx \u0026gt;= n) continue; 16 if(ty \u0026lt; 0 || ty \u0026gt;= m) continue; 17 if(Abs(a[x][y] - a[tx][ty]) \u0026lt;= tol) 18 return 0; 19 } 20 return 1; 21} 22 23int main() 24{ 25 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;m, \u0026amp;n, \u0026amp;tol); 26 map\u0026lt;int, int\u0026gt; mmp; 27 28 for(int i=0; i\u0026lt;n; i++) 29 { 30 for(int j=0; j\u0026lt;m; j++) 31 { 32 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); 33 mmp[a[i][j]]++; 34 } 35 } 36 37 int di, dj, num = 0; 38 for(int i=0; i\u0026lt;n; i++) 39 { 40 for(int j=0; j\u0026lt;m; j++) 41 { 42 if(ok(i, j) \u0026amp;\u0026amp; mmp[a[i][j]]==1){ 43 num++; 44 if(num \u0026gt; 1) break; 45 di = i, dj = j; 46 } 47 } 48 if(num \u0026gt; 1) break; 49 } 50 51 if(num==0) 52 printf(\u0026#34;Not Exist\\n\u0026#34;); 53 else if(num==1) 54 printf(\u0026#34;(%d, %d): %d\\n\u0026#34;, dj+1, di+1, a[di][dj]); 55 else 56 printf(\u0026#34;Not Unique\\n\u0026#34;); 57 58 return 0; 59} ","permalink":"https://blog.lordash.de/posts/solution/patb-1068-%E4%B8%87%E7%BB%BF%E4%B8%9B%E4%B8%AD%E4%B8%80%E7%82%B9%E7%BA%A2/","summary":"ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢ (PATB-1068) é¢˜é¢ å¯¹äºè®¡ç®—æœºè€Œè¨€ï¼Œé¢œè‰²ä¸è¿‡æ˜¯åƒç´ ç‚¹å¯¹åº”çš„ä¸€ä¸ª 24 ä½çš„æ•°å€¼ã€‚ç°ç»™å®šä¸€å¹…åˆ†è¾¨ç‡ä¸º MÃ—N çš„ç”»ï¼Œè¦æ±‚ä½ æ‰¾å‡ºä¸‡ç»¿ä¸›ä¸­çš„ä¸€ç‚¹çº¢ï¼Œå³æœ‰ç‹¬ä¸€","title":"PATB-1068 ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢"},{"content":"è¯•å¯†ç  (PATB-1067) é¢˜é¢ å½“ä½ è¯•å›¾ç™»å½•æŸä¸ªç³»ç»Ÿå´å¿˜äº†å¯†ç æ—¶ï¼Œç³»ç»Ÿä¸€èˆ¬åªä¼šå…è®¸ä½ å°è¯•æœ‰é™å¤šæ¬¡ï¼Œå½“è¶…å‡ºå…è®¸æ¬¡æ•°æ—¶ï¼Œè´¦å·å°±ä¼šè¢«é”æ­»ã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªå°åŠŸèƒ½ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªå¯†ç ï¼ˆé•¿åº¦ä¸è¶…è¿‡ 20 çš„ã€ä¸åŒ…å«ç©ºæ ¼ã€Tabã€å›è½¦çš„éç©ºå­—ç¬¦ä¸²ï¼‰å’Œä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 10ï¼‰ï¼Œåˆ†åˆ«æ˜¯æ­£ç¡®çš„å¯†ç å’Œç³»ç»Ÿå…è®¸å°è¯•çš„æ¬¡æ•°ã€‚éšåæ¯è¡Œç»™å‡ºä¸€ä¸ªä»¥å›è½¦ç»“æŸçš„éç©ºå­—ç¬¦ä¸²ï¼Œæ˜¯ç”¨æˆ·å°è¯•è¾“å…¥çš„å¯†ç ã€‚è¾“å…¥ä¿è¯è‡³å°‘æœ‰ä¸€æ¬¡å°è¯•ã€‚å½“è¯»åˆ°ä¸€è¡Œåªæœ‰å•ä¸ª # å­—ç¬¦æ—¶ï¼Œè¾“å…¥ç»“æŸï¼Œå¹¶ä¸”è¿™ä¸€è¡Œä¸æ˜¯ç”¨æˆ·çš„è¾“å…¥ã€‚\nè¾“å‡º å¯¹ç”¨æˆ·çš„æ¯ä¸ªè¾“å…¥ï¼Œå¦‚æœæ˜¯æ­£ç¡®çš„å¯†ç ä¸”å°è¯•æ¬¡æ•°ä¸è¶…è¿‡ Nï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º Welcome inï¼Œå¹¶ç»“æŸç¨‹åºï¼›å¦‚æœæ˜¯é”™è¯¯çš„ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­æŒ‰æ ¼å¼è¾“å‡º Wrong password: ç”¨æˆ·è¾“å…¥çš„é”™è¯¯å¯†ç ï¼›å½“é”™è¯¯å°è¯•è¾¾åˆ° N æ¬¡æ—¶ï¼Œå†è¾“å‡ºä¸€è¡Œ Account lockedï¼Œå¹¶ç»“æŸç¨‹åºã€‚\næ ·ä¾‹è¾“å…¥1 1Correct%pw 3 2correct%pw 3Correct@PW 4whatisthepassword! 5Correct%pw 6# æ ·ä¾‹è¾“å‡º1 1Wrong password: correct%pw 2Wrong password: Correct@PW 3Wrong password: whatisthepassword! 4Account locked æ ·ä¾‹è¾“å…¥2 1cool@gplt 3 2coolman@gplt 3coollady@gplt 4cool@gplt 5try again 6# æ ·ä¾‹è¾“å‡º2 1Wrong password: coolman@gplt 2Wrong password: coollady@gplt 3Welcome in æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[mxn]; 3 4int main() 5{ 6 int n, num = 0; 7 scanf(\u0026#34;%s %d%*c\u0026#34;, s, \u0026amp;n); 8 9 while(1) 10 { 11 fgets(t, mxn, stdin); 12 t[strlen(t)-1] = \u0026#39;\\0\u0026#39;; 13 if(strcmp(t, \u0026#34;#\u0026#34;)==0) break; 14 if(++num \u0026gt; n) continue; 15 if(strcmp(s, t)==0) 16 { 17 printf(\u0026#34;Welcome in\\n\u0026#34;); 18 break; 19 } 20 else 21 { 22 printf(\u0026#34;Wrong password: %s\\n\u0026#34;, t); 23 if (num == n){ 24 printf(\u0026#34;Account locked\\n\u0026#34;); 25 break; 26 } 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/patb-1067-%E8%AF%95%E5%AF%86%E7%A0%81/","summary":"è¯•å¯†ç  (PATB-1067) é¢˜é¢ å½“ä½ è¯•å›¾ç™»å½•æŸä¸ªç³»ç»Ÿå´å¿˜äº†å¯†ç æ—¶ï¼Œç³»ç»Ÿä¸€èˆ¬åªä¼šå…è®¸ä½ å°è¯•æœ‰é™å¤šæ¬¡ï¼Œå½“è¶…å‡ºå…è®¸æ¬¡æ•°æ—¶ï¼Œè´¦å·å°±ä¼šè¢«é”æ­»ã€‚æœ¬é¢˜å°±è¯·ä½ å®ç°è¿™ä¸ªå°åŠŸèƒ½ã€‚ è¾“","title":"PATB-1067 è¯•å¯†ç "},{"content":"å›¾åƒè¿‡æ»¤ (PATB-1066) é¢˜é¢ å›¾åƒè¿‡æ»¤æ˜¯æŠŠå›¾åƒä¸­ä¸é‡è¦çš„åƒç´ éƒ½æŸ“æˆèƒŒæ™¯è‰²ï¼Œä½¿å¾—é‡è¦éƒ¨åˆ†è¢«å‡¸æ˜¾å‡ºæ¥ã€‚ç°ç»™å®šä¸€å¹…é»‘ç™½å›¾åƒï¼Œè¦æ±‚ä½ å°†ç°åº¦å€¼ä½äºæŸæŒ‡å®šåŒºé—´å†…çš„æ‰€æœ‰åƒç´ é¢œè‰²éƒ½ç”¨ä¸€ç§æŒ‡å®šçš„é¢œè‰²æ›¿æ¢ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€å¹…å›¾åƒçš„åˆ†è¾¨ç‡ï¼Œå³ä¸¤ä¸ªæ­£æ•´æ•° M å’Œ Nï¼ˆ0\u0026lt;M,Nâ‰¤500ï¼‰ï¼Œå¦å¤–æ˜¯å¾…è¿‡æ»¤çš„ç°åº¦å€¼åŒºé—´ç«¯ç‚¹ A å’Œ Bï¼ˆ0â‰¤A\u0026lt;Bâ‰¤255ï¼‰ã€ä»¥åŠæŒ‡å®šçš„æ›¿æ¢ç°åº¦å€¼ã€‚éšå M è¡Œï¼Œæ¯è¡Œç»™å‡º N ä¸ªåƒç´ ç‚¹çš„ç°åº¦å€¼ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æ‰€æœ‰ç°åº¦å€¼éƒ½åœ¨ [0, 255] åŒºé—´å†…ã€‚\nè¾“å‡º è¾“å‡ºæŒ‰è¦æ±‚è¿‡æ»¤åçš„å›¾åƒã€‚å³è¾“å‡º M è¡Œï¼Œæ¯è¡Œ N ä¸ªåƒç´ ç°åº¦å€¼ï¼Œæ¯ä¸ªç°åº¦å€¼å  3 ä½ï¼ˆä¾‹å¦‚é»‘è‰²è¦æ˜¾ç¤ºä¸º 000ï¼‰ï¼Œå…¶é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 13 5 100 150 0 23 189 254 101 119 3150 233 151 99 100 488 123 149 0 255 æ ·ä¾‹è¾“å‡º 1003 189 254 000 000 2000 233 151 099 000 3088 000 000 000 255 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n, m, l, r, x; 4 scanf(\u0026#34;%d %d %d %d %d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;l, \u0026amp;r, \u0026amp;x); 5 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 for(int j=0; j\u0026lt;m; j++) 9 { 10 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 11 if(j) printf(\u0026#34; \u0026#34;); 12 if(l\u0026lt;=t \u0026amp;\u0026amp; t\u0026lt;=r) 13 printf(\u0026#34;%03d\u0026#34;, x); 14 else 15 printf(\u0026#34;%03d\u0026#34;, t); 16 } 17 printf(\u0026#34;\\n\u0026#34;); 18 } 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/patb-1066-%E5%9B%BE%E5%83%8F%E8%BF%87%E6%BB%A4/","summary":"å›¾åƒè¿‡æ»¤ (PATB-1066) é¢˜é¢ å›¾åƒè¿‡æ»¤æ˜¯æŠŠå›¾åƒä¸­ä¸é‡è¦çš„åƒç´ éƒ½æŸ“æˆèƒŒæ™¯è‰²ï¼Œä½¿å¾—é‡è¦éƒ¨åˆ†è¢«å‡¸æ˜¾å‡ºæ¥ã€‚ç°ç»™å®šä¸€å¹…é»‘ç™½å›¾åƒï¼Œè¦æ±‚ä½ å°†ç°åº¦å€¼ä½äºæŸæŒ‡å®šåŒºé—´å†…çš„æ‰€æœ‰åƒ","title":"PATB-1066 å›¾åƒè¿‡æ»¤"},{"content":"å•èº«ç‹— (PATB-1065) é¢˜é¢ â€œå•èº«ç‹—â€æ˜¯ä¸­æ–‡å¯¹äºå•èº«äººå£«çš„ä¸€ç§çˆ±ç§°ã€‚æœ¬é¢˜è¯·ä½ ä»ä¸Šä¸‡äººçš„å¤§å‹æ´¾å¯¹ä¸­æ‰¾å‡ºè½å•çš„å®¢äººï¼Œä»¥ä¾¿ç»™äºˆç‰¹æ®Šå…³çˆ±ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 50 000ï¼‰ï¼Œæ˜¯å·²çŸ¥å¤«å¦»/ä¼´ä¾£çš„å¯¹æ•°ï¼›éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€å¯¹å¤«å¦»/ä¼´ä¾£â€”â€”ä¸ºæ–¹ä¾¿èµ·è§ï¼Œæ¯äººå¯¹åº”ä¸€ä¸ª ID å·ï¼Œä¸º 5 ä½æ•°å­—ï¼ˆä» 00000 åˆ° 99999ï¼‰ï¼ŒID é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼›ä¹‹åç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Mï¼ˆâ‰¤ 10 000ï¼‰ï¼Œä¸ºå‚åŠ æ´¾å¯¹çš„æ€»äººæ•°ï¼›éšåä¸€è¡Œç»™å‡ºè¿™ M ä½å®¢äººçš„ IDï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯æ— äººé‡å©šæˆ–è„šè¸©ä¸¤æ¡èˆ¹ã€‚\nè¾“å‡º é¦–å…ˆç¬¬ä¸€è¡Œè¾“å‡ºè½å•å®¢äººçš„æ€»äººæ•°ï¼›éšåç¬¬äºŒè¡ŒæŒ‰ ID é€’å¢é¡ºåºåˆ—å‡ºè½å•çš„å®¢äººã€‚ID é—´ç”¨ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œçš„é¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 13 211111 22222 333333 44444 455555 66666 57 655555 44444 10000 88888 22222 11111 23333 æ ·ä¾‹è¾“å‡º 15 210000 23333 44444 55555 88888 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e6 + 5; 2int a[mxn], b[mxn], ans[mxn], vis[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 memset(a, -1, sizeof a); 8 9 for(int i=0; i\u0026lt;n; i++) 10 { 11 int x, y; 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); 13 a[x] = y; 14 a[y] = x; 15 } 16 int m, num = 0; 17 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 18 19 for(int i=0; i\u0026lt;m; i++) 20 { 21 scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); 22 vis[b[i]] = 1; 23 } 24 for(int i=0; i\u0026lt;m; i++) 25 { 26 if(a[b[i]]==-1 || vis[a[b[i]]] == 0) 27 ans[num++] = b[i]; 28 } 29 sort(ans, ans+num); 30 31 printf(\u0026#34;%d\\n\u0026#34;, num); 32 for(int i=0; i\u0026lt;num; i++) 33 { 34 if(i) printf(\u0026#34; \u0026#34;); 35 printf(\u0026#34;%05d\u0026#34;, ans[i]); 36 } 37 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/patb-1065-%E5%8D%95%E8%BA%AB%E7%8B%97/","summary":"å•èº«ç‹— (PATB-1065) é¢˜é¢ â€œå•èº«ç‹—â€æ˜¯ä¸­æ–‡å¯¹äºå•èº«äººå£«çš„ä¸€ç§çˆ±ç§°ã€‚æœ¬é¢˜è¯·ä½ ä»ä¸Šä¸‡äººçš„å¤§å‹æ´¾å¯¹ä¸­æ‰¾å‡ºè½å•çš„å®¢äººï¼Œä»¥ä¾¿ç»™äºˆç‰¹æ®Šå…³çˆ±ã€‚ è¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´","title":"PATB-1065 å•èº«ç‹—"},{"content":"æœ‹å‹æ•° (PATB-1064) é¢˜é¢ å¦‚æœä¸¤ä¸ªæ•´æ•°å„ä½æ•°å­—çš„å’Œæ˜¯ä¸€æ ·çš„ï¼Œåˆ™è¢«ç§°ä¸ºæ˜¯â€œæœ‹å‹æ•°â€ï¼Œè€Œé‚£ä¸ªå…¬å…±çš„å’Œå°±æ˜¯å®ƒä»¬çš„â€œæœ‹å‹è¯å·â€ã€‚ä¾‹å¦‚ 123 å’Œ 51 å°±æ˜¯æœ‹å‹æ•°ï¼Œå› ä¸º 1+2+3 = 5+1 = 6ï¼Œè€Œ 6 å°±æ˜¯å®ƒä»¬çš„æœ‹å‹è¯å·ã€‚ç»™å®šä¸€äº›æ•´æ•°ï¼Œè¦æ±‚ä½ ç»Ÿè®¡ä¸€ä¸‹å®ƒä»¬ä¸­æœ‰å¤šå°‘ä¸ªä¸åŒçš„æœ‹å‹è¯å·ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nã€‚éšåä¸€è¡Œç»™å‡º N ä¸ªæ­£æ•´æ•°ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯æ‰€æœ‰æ•°å­—å°äº 10^4ã€‚\nè¾“å‡º é¦–å…ˆç¬¬ä¸€è¡Œè¾“å‡ºç»™å®šæ•°å­—ä¸­ä¸åŒçš„æœ‹å‹è¯å·çš„ä¸ªæ•°ï¼›éšåä¸€è¡ŒæŒ‰é€’å¢é¡ºåºè¾“å‡ºè¿™äº›æœ‹å‹è¯å·ï¼Œæ•°å­—é—´éš”ä¸€ä¸ªç©ºæ ¼ï¼Œä¸”è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 18 2123 899 51 998 27 33 36 12 æ ·ä¾‹è¾“å‡º 14 23 6 9 26 æç¤º æ— \næ€è·¯ ä»£ç  1int a[40]; 2 3int main() 4{ 5 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 7 int num = 0; 8 for(int i=0; i\u0026lt;n; i++) 9 { 10 int x, sum = 0; 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 12 while(x){ 13 sum += x % 10; 14 x /= 10; 15 } 16 if(a[sum] == 0){ 17 a[sum]++; 18 num++; 19 } 20 } 21 22 printf(\u0026#34;%d\\n\u0026#34;, num); 23 int nf = 0; 24 for(int i=0; i\u0026lt;40; i++){ 25 if(a[i]) 26 { 27 if(nf) 28 printf(\u0026#34; \u0026#34;); 29 else 30 nf = 1; 31 printf(\u0026#34;%d\u0026#34;, i); 32 } 33 } 34 35 return 0; 36} ","permalink":"https://blog.lordash.de/posts/solution/patb-1064-%E6%9C%8B%E5%8F%8B%E6%95%B0/","summary":"æœ‹å‹æ•° (PATB-1064) é¢˜é¢ å¦‚æœä¸¤ä¸ªæ•´æ•°å„ä½æ•°å­—çš„å’Œæ˜¯ä¸€æ ·çš„ï¼Œåˆ™è¢«ç§°ä¸ºæ˜¯â€œæœ‹å‹æ•°â€ï¼Œè€Œé‚£ä¸ªå…¬å…±çš„å’Œå°±æ˜¯å®ƒä»¬çš„â€œæœ‹å‹è¯å·â€ã€‚ä¾‹å¦‚ 123 å’Œ 51 å°±æ˜¯æœ‹å‹æ•°ï¼Œå› ä¸º 1+2+3 = 5+1 =","title":"PATB-1064 æœ‹å‹æ•°"},{"content":"è®¡ç®—è°±åŠå¾„ (PATB-1063) é¢˜é¢ åœ¨æ•°å­¦ä¸­ï¼ŒçŸ©é˜µçš„â€œè°±åŠå¾„â€æ˜¯æŒ‡å…¶ç‰¹å¾å€¼çš„æ¨¡é›†åˆçš„ä¸Šç¡®ç•Œã€‚æ¢è¨€ä¹‹ï¼Œå¯¹äºç»™å®šçš„ n ä¸ªå¤æ•°ç©ºé—´çš„ç‰¹å¾å€¼ { a1+b1i,â‹¯,an+bni }ï¼Œå®ƒä»¬çš„æ¨¡ä¸ºå®éƒ¨ä¸è™šéƒ¨çš„å¹³æ–¹å’Œçš„å¼€æ–¹ï¼Œè€Œâ€œè°±åŠå¾„â€å°±æ˜¯æœ€å¤§æ¨¡ã€‚\nç°åœ¨ç»™å®šä¸€äº›å¤æ•°ç©ºé—´çš„ç‰¹å¾å€¼ï¼Œè¯·ä½ è®¡ç®—å¹¶è¾“å‡ºè¿™äº›ç‰¹å¾å€¼çš„è°±åŠå¾„ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤ 10 000ï¼‰æ˜¯è¾“å…¥çš„ç‰¹å¾å€¼çš„ä¸ªæ•°ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡º 1 ä¸ªç‰¹å¾å€¼çš„å®éƒ¨å’Œè™šéƒ¨ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å®éƒ¨å’Œè™šéƒ¨å‡ä¸ºç»å¯¹å€¼ä¸è¶…è¿‡ 1000 çš„æ•´æ•°ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºè°±åŠå¾„ï¼Œå››èˆäº”å…¥ä¿ç•™å°æ•°ç‚¹å 2 ä½ã€‚\næ ·ä¾‹è¾“å…¥ 15 20 1 32 0 4-1 0 53 3 60 -3 æ ·ä¾‹è¾“å‡º 14.24 æç¤º æ— \næ€è·¯ ä»£ç  1#define Sq(u) ((u) * (u)) 2typedef double DB; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 DB mx = 0; 9 for(int i=0; i\u0026lt;n; i++) 10 { 11 int a, b; 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); 13 mx = max(mx, sqrt(Sq(a)+Sq(b))); 14 } 15 printf(\u0026#34;%.2lf\\n\u0026#34;, mx); 16 return 0; 17} ","permalink":"https://blog.lordash.de/posts/solution/patb-1063-%E8%AE%A1%E7%AE%97%E8%B0%B1%E5%8D%8A%E5%BE%84/","summary":"è®¡ç®—è°±åŠå¾„ (PATB-1063) é¢˜é¢ åœ¨æ•°å­¦ä¸­ï¼ŒçŸ©é˜µçš„â€œè°±åŠå¾„â€æ˜¯æŒ‡å…¶ç‰¹å¾å€¼çš„æ¨¡é›†åˆçš„ä¸Šç¡®ç•Œã€‚æ¢è¨€ä¹‹ï¼Œå¯¹äºç»™å®šçš„ n ä¸ªå¤æ•°ç©ºé—´çš„ç‰¹å¾å€¼ { a1+b1i,â‹¯,an+bn","title":"PATB-1063 è®¡ç®—è°±åŠå¾„"},{"content":"æœ€ç®€åˆ†æ•° (PATB-1062) é¢˜é¢ ä¸€ä¸ªåˆ†æ•°ä¸€èˆ¬å†™æˆä¸¤ä¸ªæ•´æ•°ç›¸é™¤çš„å½¢å¼ï¼šN/Mï¼Œå…¶ä¸­ M ä¸ä¸º0ã€‚æœ€ç®€åˆ†æ•°æ˜¯æŒ‡åˆ†å­å’Œåˆ†æ¯æ²¡æœ‰å…¬çº¦æ•°çš„åˆ†æ•°è¡¨ç¤ºå½¢å¼ã€‚\nç°ç»™å®šä¸¤ä¸ªä¸ç›¸ç­‰çš„æ­£åˆ†æ•° N1/M1 å’Œ N2/M2ï¼Œè¦æ±‚ä½ æŒ‰ä»å°åˆ°å¤§çš„é¡ºåºåˆ—å‡ºå®ƒä»¬ä¹‹é—´åˆ†æ¯ä¸º K çš„æœ€ç®€åˆ†æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ N/M çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªæ­£åˆ†æ•°ï¼Œéšåæ˜¯ä¸€ä¸ªæ­£æ•´æ•°åˆ†æ¯ Kï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯ç»™å‡ºçš„æ‰€æœ‰æ•´æ•°éƒ½ä¸è¶…è¿‡ 1000ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­æŒ‰ N/M çš„æ ¼å¼åˆ—å‡ºä¸¤ä¸ªç»™å®šåˆ†æ•°ä¹‹é—´åˆ†æ¯ä¸º K çš„æ‰€æœ‰æœ€ç®€åˆ†æ•°ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºï¼Œå…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚é¢˜ç›®ä¿è¯è‡³å°‘æœ‰ 1 ä¸ªè¾“å‡ºã€‚\næ ·ä¾‹è¾“å…¥ 17/18 13/20 12 æ ·ä¾‹è¾“å‡º 15/12 7/12 æç¤º æ— \næ€è·¯ ä»£ç  1int gcd(int a, int b){ 2 return b ? gcd(b, a%b) : a; 3} 4 5int main() 6{ 7 int n1, m1, n2, m2, k; 8 scanf(\u0026#34;%d/%d %d/%d %d\u0026#34;, \u0026amp;n1, \u0026amp;m1, \u0026amp;n2, \u0026amp;m2, \u0026amp;k); 9 10 int g = gcd(k, gcd(m1, m2)); 11 int l = m1 / g * m2 / g * k; 12 13 int b=l/m1*n1, e=l/m2*n2, nf=0; 14 if(b \u0026gt; e) swap(b, e); 15 16 for(int i=b+1; i\u0026lt;e; i++) 17 { 18 if(i%(l/k)==0 \u0026amp;\u0026amp; gcd(i/(l/k), k)==1) 19 { 20 if(nf) 21 printf(\u0026#34; \u0026#34;); 22 else 23 nf = 1; 24 printf(\u0026#34;%d/%d\u0026#34;, i/(l/k), k); 25 i += l/k-1; 26 } 27 } 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/patb-1062-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/","summary":"æœ€ç®€åˆ†æ•° (PATB-1062) é¢˜é¢ ä¸€ä¸ªåˆ†æ•°ä¸€èˆ¬å†™æˆä¸¤ä¸ªæ•´æ•°ç›¸é™¤çš„å½¢å¼ï¼šN/Mï¼Œå…¶ä¸­ M ä¸ä¸º0ã€‚æœ€ç®€åˆ†æ•°æ˜¯æŒ‡åˆ†å­å’Œåˆ†æ¯æ²¡æœ‰å…¬çº¦æ•°çš„åˆ†æ•°è¡¨ç¤ºå½¢å¼ã€‚ ç°ç»™å®šä¸¤ä¸ªä¸ç›¸ç­‰çš„æ­£","title":"PATB-1062 æœ€ç®€åˆ†æ•°"},{"content":"åˆ¤æ–­é¢˜ (PATB-1061) é¢˜é¢ åˆ¤æ–­é¢˜çš„è¯„åˆ¤å¾ˆç®€å•ï¼Œæœ¬é¢˜å°±è¦æ±‚ä½ å†™ä¸ªç®€å•çš„ç¨‹åºå¸®åŠ©è€å¸ˆåˆ¤é¢˜å¹¶ç»Ÿè®¡å­¦ç”Ÿä»¬åˆ¤æ–­é¢˜çš„å¾—åˆ†ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•° N å’Œ Mï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œåˆ¤æ–­é¢˜æ•°é‡ã€‚ç¬¬äºŒè¡Œç»™å‡º M ä¸ªä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼Œæ˜¯æ¯é“é¢˜çš„æ»¡åˆ†å€¼ã€‚ç¬¬ä¸‰è¡Œç»™å‡ºæ¯é“é¢˜å¯¹åº”çš„æ­£ç¡®ç­”æ¡ˆï¼Œ0 ä»£è¡¨â€œéâ€ï¼Œ1 ä»£è¡¨â€œæ˜¯â€ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªå­¦ç”Ÿçš„è§£ç­”ã€‚æ•°å­—é—´å‡ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º æŒ‰ç…§è¾“å…¥çš„é¡ºåºè¾“å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å¾—åˆ†ï¼Œæ¯ä¸ªåˆ†æ•°å ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 13 6 22 1 3 3 4 5 30 0 1 0 1 1 40 1 1 0 0 1 51 0 1 0 1 0 61 1 0 0 1 1 æ ·ä¾‹è¾“å‡º 113 211 312 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int p[mxn], a[mxn]; 3 4int main() 5{ 6 int n, m; 7 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 8 9 for(int i=0; i\u0026lt;m; i++) 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;p[i]); 11 for(int i=0; i\u0026lt;m; i++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 13 14 while(n--) 15 { 16 int ans = 0, sum = 0; 17 for(int i=0; i\u0026lt;m; i++){ 18 scanf(\u0026#34;%d\u0026#34;, \u0026amp;ans); 19 sum += (a[i]==ans) ? p[i] : 0; 20 } 21 printf(\u0026#34;%d\\n\u0026#34;, sum); 22 } 23 return 0; 24} ","permalink":"https://blog.lordash.de/posts/solution/patb-1061-%E5%88%A4%E6%96%AD%E9%A2%98/","summary":"åˆ¤æ–­é¢˜ (PATB-1061) é¢˜é¢ åˆ¤æ–­é¢˜çš„è¯„åˆ¤å¾ˆç®€å•ï¼Œæœ¬é¢˜å°±è¦æ±‚ä½ å†™ä¸ªç®€å•çš„ç¨‹åºå¸®åŠ©è€å¸ˆåˆ¤é¢˜å¹¶ç»Ÿè®¡å­¦ç”Ÿä»¬åˆ¤æ–­é¢˜çš„å¾—åˆ†ã€‚ è¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•° N å’Œ","title":"PATB-1061 åˆ¤æ–­é¢˜"},{"content":"çˆ±ä¸é¡¿æ•° (PATB-1060) é¢˜é¢ è‹±å›½å¤©æ–‡å­¦å®¶çˆ±ä¸é¡¿å¾ˆå–œæ¬¢éª‘è½¦ã€‚æ®è¯´ä»–ä¸ºäº†ç‚«è€€è‡ªå·±çš„éª‘è½¦åŠŸåŠ›ï¼Œè¿˜å®šä¹‰äº†ä¸€ä¸ªâ€œçˆ±ä¸é¡¿æ•°â€ E ï¼Œå³æ»¡è¶³æœ‰ E å¤©éª‘è½¦è¶…è¿‡ E è‹±é‡Œçš„æœ€å¤§æ•´æ•° Eã€‚æ®è¯´çˆ±ä¸é¡¿è‡ªå·±çš„ E ç­‰äº87ã€‚\nç°ç»™å®šæŸäºº N å¤©çš„éª‘è½¦è·ç¦»ï¼Œè¯·ä½ ç®—å‡ºå¯¹åº”çš„çˆ±ä¸é¡¿æ•° Eï¼ˆâ‰¤Nï¼‰ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° N (â‰¤10^5)ï¼Œå³è¿ç»­éª‘è½¦çš„å¤©æ•°ï¼›ç¬¬äºŒè¡Œç»™å‡º N ä¸ªéè´Ÿæ•´æ•°ï¼Œä»£è¡¨æ¯å¤©çš„éª‘è½¦è·ç¦»ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­ç»™å‡º N å¤©çš„çˆ±ä¸é¡¿æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 110 26 7 6 9 3 10 8 2 7 8 æ ·ä¾‹è¾“å‡º 16 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4bool cmp(int a, int b) 5{ 6 return a\u0026gt;b; 7} 8 9int main() 10{ 11 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 12 13 for(int i=1; i\u0026lt;=n; i++) 14 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 15 sort(a+1, a+n+1, cmp); 16 17 int ans = 0; 18 for(int i=1; i\u0026lt;=n; i++) 19 { 20 if(a[i] \u0026gt; i) 21 ans = max(ans, i); 22 } 23 printf(\u0026#34;%d\\n\u0026#34;, ans); 24 return 0; 25} ","permalink":"https://blog.lordash.de/posts/solution/patb-1060-%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0/","summary":"çˆ±ä¸é¡¿æ•° (PATB-1060) é¢˜é¢ è‹±å›½å¤©æ–‡å­¦å®¶çˆ±ä¸é¡¿å¾ˆå–œæ¬¢éª‘è½¦ã€‚æ®è¯´ä»–ä¸ºäº†ç‚«è€€è‡ªå·±çš„éª‘è½¦åŠŸåŠ›ï¼Œè¿˜å®šä¹‰äº†ä¸€ä¸ªâ€œçˆ±ä¸é¡¿æ•°â€ E ï¼Œå³æ»¡è¶³æœ‰ E å¤©éª‘è½¦è¶…è¿‡ E è‹±é‡Œçš„æœ€å¤§æ•´æ•° E","title":"PATB-1060 çˆ±ä¸é¡¿æ•°"},{"content":"Cè¯­è¨€ç«èµ› (PATB-1059) é¢˜é¢ C è¯­è¨€ç«èµ›æ˜¯æµ™æ±Ÿå¤§å­¦è®¡ç®—æœºå­¦é™¢ä¸»æŒçš„ä¸€ä¸ªæ¬¢ä¹çš„ç«èµ›ã€‚æ—¢ç„¶ç«èµ›ä¸»æ—¨æ˜¯ä¸ºäº†å¥½ç©ï¼Œé¢å¥–è§„åˆ™ä¹Ÿå°±åˆ¶å®šå¾—å¾ˆæ»‘ç¨½ï¼š\n0ã€å† å†›å°†èµ¢å¾—ä¸€ä»½â€œç¥ç§˜å¤§å¥–â€ï¼ˆæ¯”å¦‚å¾ˆå·¨å¤§çš„ä¸€æœ¬å­¦ç”Ÿç ”ç©¶è®ºæ–‡é›†â€¦â€¦ï¼‰ã€‚ 1ã€æ’åä¸ºç´ æ•°çš„å­¦ç”Ÿå°†èµ¢å¾—æœ€å¥½çš„å¥–å“ â€”â€” å°é»„äººç©å¶ï¼ 2ã€å…¶ä»–äººå°†å¾—åˆ°å·§å…‹åŠ›ã€‚ ç»™å®šæ¯”èµ›çš„æœ€ç»ˆæ’åä»¥åŠä¸€ç³»åˆ—å‚èµ›è€…çš„ IDï¼Œä½ è¦ç»™å‡ºè¿™äº›å‚èµ›è€…åº”è¯¥è·å¾—çš„å¥–å“ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10^4ï¼‰ï¼Œæ˜¯å‚èµ›è€…äººæ•°ã€‚éšå N è¡Œç»™å‡ºæœ€ç»ˆæ’åï¼Œæ¯è¡ŒæŒ‰æ’åé¡ºåºç»™å‡ºä¸€ä½å‚èµ›è€…çš„ IDï¼ˆ4 ä½æ•°å­—ç»„æˆï¼‰ã€‚æ¥ä¸‹æ¥ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° K ä»¥åŠ K ä¸ªéœ€è¦æŸ¥è¯¢çš„ IDã€‚\nè¾“å‡º å¯¹æ¯ä¸ªè¦æŸ¥è¯¢çš„ IDï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡º ID: å¥–å“ï¼Œå…¶ä¸­å¥–å“æˆ–è€…æ˜¯ Mystery Awardï¼ˆç¥ç§˜å¤§å¥–ï¼‰ã€æˆ–è€…æ˜¯ Minionï¼ˆå°é»„äººï¼‰ã€æˆ–è€…æ˜¯ Chocolateï¼ˆå·§å…‹åŠ›ï¼‰ã€‚å¦‚æœæ‰€æŸ¥ ID æ ¹æœ¬ä¸åœ¨æ’åé‡Œï¼Œæ‰“å° Are you kidding?ï¼ˆè€æˆ‘å‘¢ï¼Ÿï¼‰ã€‚å¦‚æœè¯¥ ID å·²ç»æŸ¥è¿‡äº†ï¼ˆå³å¥–å“å·²ç»é¢†è¿‡äº†ï¼‰ï¼Œæ‰“å° ID: Checkedï¼ˆä¸èƒ½å¤šåƒå¤šå ï¼‰ã€‚\næ ·ä¾‹è¾“å…¥ 16 21111 36666 48888 51234 65555 70001 86 98888 100001 111111 122222 138888 142222 æ ·ä¾‹è¾“å‡º 18888: Minion 20001: Chocolate 31111: Mystery Award 42222: Are you kidding? 58888: Checked 62222: Are you kidding? æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4bool isPrime(int n) 5{ 6 if (n \u0026lt; 2) return 0; 7 if (n == 2 || n == 3) return 1; 8 if (n % 6 != 1 \u0026amp;\u0026amp; n % 6 != 5) return 0; 9 10 int m = sqrt(n); 11 for (int i = 5; i \u0026lt;= m; i += 6) 12 { 13 if (n % i == 0 || n % (i + 2) == 0) 14 return 0; 15 } 16 return 1; 17} 18 19int main() 20{ 21 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 22 23 memset(a, -1, sizeof a); 24 for(int i=1; i\u0026lt;=n; i++) 25 { 26 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 27 a[x] = i; 28 } 29 30 int m; scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 31 for(int i=0; i\u0026lt;m; i++) 32 { 33 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 34 printf(\u0026#34;%04d: \u0026#34;, x); 35 if(a[x] == -1){ 36 printf(\u0026#34;Are you kidding?\\n\u0026#34;); 37 continue; 38 } 39 if(a[x] == -2) 40 printf(\u0026#34;Checked\\n\u0026#34;); 41 else if(a[x] == 1) 42 printf(\u0026#34;Mystery Award\\n\u0026#34;); 43 else if(isPrime(a[x])) 44 printf(\u0026#34;Minion\\n\u0026#34;); 45 else 46 printf(\u0026#34;Chocolate\\n\u0026#34;); 47 48 a[x] = -2; 49 } 50 51 return 0; 52} ","permalink":"https://blog.lordash.de/posts/solution/patb-1059-c%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/","summary":"Cè¯­è¨€ç«èµ› (PATB-1059) é¢˜é¢ C è¯­è¨€ç«èµ›æ˜¯æµ™æ±Ÿå¤§å­¦è®¡ç®—æœºå­¦é™¢ä¸»æŒçš„ä¸€ä¸ªæ¬¢ä¹çš„ç«èµ›ã€‚æ—¢ç„¶ç«èµ›ä¸»æ—¨æ˜¯ä¸ºäº†å¥½ç©ï¼Œé¢å¥–è§„åˆ™ä¹Ÿå°±åˆ¶å®šå¾—å¾ˆæ»‘ç¨½ï¼š 0ã€å† å†›å°†èµ¢å¾—ä¸€ä»½â€œç¥","title":"PATB-1059 Cè¯­è¨€ç«èµ›"},{"content":"é€‰æ‹©é¢˜ (PATB-1058) é¢˜é¢ æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ¬é¢˜å°±è¯·ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆæ‰¹æ”¹å¤šé€‰é¢˜ï¼Œå¹¶ä¸”æŒ‡å‡ºå“ªé“é¢˜é”™çš„äººæœ€å¤šã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰å’Œ Mï¼ˆâ‰¤ 100ï¼‰ï¼Œåˆ†åˆ«æ˜¯å­¦ç”Ÿäººæ•°å’Œå¤šé€‰é¢˜çš„ä¸ªæ•°ã€‚éšå M è¡Œï¼Œæ¯è¡Œé¡ºæ¬¡ç»™å‡ºä¸€é“é¢˜çš„æ»¡åˆ†å€¼ï¼ˆä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€é€‰é¡¹ä¸ªæ•°ï¼ˆä¸å°‘äº 2 ä¸”ä¸è¶…è¿‡ 5 çš„æ­£æ•´æ•°ï¼‰ã€æ­£ç¡®é€‰é¡¹ä¸ªæ•°ï¼ˆä¸è¶…è¿‡é€‰é¡¹ä¸ªæ•°çš„æ­£æ•´æ•°ï¼‰ã€æ‰€æœ‰æ­£ç¡®é€‰é¡¹ã€‚æ³¨æ„æ¯é¢˜çš„é€‰é¡¹ä»å°å†™è‹±æ–‡å­—æ¯ a å¼€å§‹é¡ºæ¬¡æ’åˆ—ã€‚å„é¡¹é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚æœ€å N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªå­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µï¼Œå…¶æ¯é¢˜ç­”æ¡ˆæ ¼å¼ä¸º (é€‰ä¸­çš„é€‰é¡¹ä¸ªæ•° é€‰é¡¹1 â€¦â€¦)ï¼ŒæŒ‰é¢˜ç›®é¡ºåºç»™å‡ºã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å­¦ç”Ÿçš„ç­”é¢˜æƒ…å†µæ˜¯åˆæ³•çš„ï¼Œå³ä¸å­˜åœ¨é€‰ä¸­çš„é€‰é¡¹æ•°è¶…è¿‡å®é™…é€‰é¡¹æ•°çš„æƒ…å†µã€‚\nè¾“å‡º æŒ‰ç…§è¾“å…¥çš„é¡ºåºç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å¾—åˆ†ï¼Œæ¯ä¸ªåˆ†æ•°å ä¸€è¡Œã€‚æ³¨æ„åˆ¤é¢˜æ—¶åªæœ‰é€‰æ‹©å…¨éƒ¨æ­£ç¡®æ‰èƒ½å¾—åˆ°è¯¥é¢˜çš„åˆ†æ•°ã€‚æœ€åä¸€è¡Œè¾“å‡ºé”™å¾—æœ€å¤šçš„é¢˜ç›®çš„é”™è¯¯æ¬¡æ•°å’Œç¼–å·ï¼ˆé¢˜ç›®æŒ‰ç…§è¾“å…¥çš„é¡ºåºä» 1 å¼€å§‹ç¼–å·ï¼‰ã€‚å¦‚æœæœ‰å¹¶åˆ—ï¼Œåˆ™æŒ‰ç¼–å·é€’å¢é¡ºåºè¾“å‡ºã€‚æ•°å­—é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚å¦‚æœæ‰€æœ‰é¢˜ç›®éƒ½æ²¡æœ‰äººé”™ï¼Œåˆ™åœ¨æœ€åä¸€è¡Œè¾“å‡º Too simpleã€‚\næ ·ä¾‹è¾“å…¥ 13 4 23 4 2 a c 32 5 1 b 45 3 2 b c 51 5 4 a b d e 6(2 a c) (2 b d) (2 a c) (3 a b e) 7(2 a c) (1 b) (2 a b) (4 a b d e) 8(2 b d) (1 e) (2 b c) (4 a b c d) æ ·ä¾‹è¾“å‡º 13 26 35 42 2 3 4 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2struct P { 3 int s, t; 4}a[mxn]; 5 6int p[] = {1, 2, 4, 8, 16}; 7int err[mxn]; 8 9int main() 10{ 11 int n, m; 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 13 14 int x; char ch; 15 for(int i=1; i\u0026lt;=m; i++) 16 { 17 scanf(\u0026#34;%d %*d %d\u0026#34;, \u0026amp;a[i].s, \u0026amp;x); 18 for(int j=0; j\u0026lt;x; j++) 19 { 20 scanf(\u0026#34; %c\u0026#34;, \u0026amp;ch); 21 a[i].t += p[ch-\u0026#39;a\u0026#39;]; 22 } 23 } 24 getchar(); 25 for(int i=0; i\u0026lt;n; i++) 26 { 27 int sum = 0, ans = 0, num = 0; 28 while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;ch) \u0026amp;\u0026amp; ch != \u0026#39;\\n\u0026#39;) 29 { 30 if(ch == \u0026#39;)\u0026#39;) 31 { 32 if(ans==a[++num].t) 33 sum += a[num].s; 34 else 35 err[num]++; 36 ans = 0; 37 } 38 if(isalpha(ch)) ans += p[ch-\u0026#39;a\u0026#39;]; 39 } 40 printf(\u0026#34;%d\\n\u0026#34;, sum); 41 } 42 43 int mx = 0; 44 for(int i=1; i\u0026lt;=m; i++) 45 if(mx \u0026lt; err[i]) mx = err[i]; 46 47 if(mx == 0) 48 { 49 printf(\u0026#34;Too simple\\n\u0026#34;); 50 return 0; 51 } 52 printf(\u0026#34;%d\u0026#34;, mx); 53 for(int i=1; i\u0026lt;=m; i++) 54 if(mx == err[i]) printf(\u0026#34; %d\u0026#34;, i); 55 56 return 0; 57} ","permalink":"https://blog.lordash.de/posts/solution/patb-1058-%E9%80%89%E6%8B%A9%E9%A2%98/","summary":"é€‰æ‹©é¢˜ (PATB-1058) é¢˜é¢ æ‰¹æ”¹å¤šé€‰é¢˜æ˜¯æ¯”è¾ƒéº»çƒ¦çš„äº‹æƒ…ï¼Œæœ¬é¢˜å°±è¯·ä½ å†™ä¸ªç¨‹åºå¸®åŠ©è€å¸ˆæ‰¹æ”¹å¤šé€‰é¢˜ï¼Œå¹¶ä¸”æŒ‡å‡ºå“ªé“é¢˜é”™çš„äººæœ€å¤šã€‚ è¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤","title":"PATB-1058 é€‰æ‹©é¢˜"},{"content":"æ•°é›¶å£¹ (PATB-1057) é¢˜é¢ ç»™å®šä¸€ä¸²é•¿åº¦ä¸è¶…è¿‡ 10^5 çš„å­—ç¬¦ä¸²ï¼Œæœ¬é¢˜è¦æ±‚ä½ å°†å…¶ä¸­æ‰€æœ‰è‹±æ–‡å­—æ¯çš„åºå·ï¼ˆå­—æ¯ a-z å¯¹åº”åºå· 1-26ï¼Œä¸åˆ†å¤§å°å†™ï¼‰ç›¸åŠ ï¼Œå¾—åˆ°æ•´æ•° Nï¼Œç„¶åå†åˆ†æä¸€ä¸‹ N çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­æœ‰å¤šå°‘ 0ã€å¤šå°‘ 1ã€‚ä¾‹å¦‚ç»™å®šå­—ç¬¦ä¸² PAT (Basic)ï¼Œå…¶å­—æ¯åºå·ä¹‹å’Œä¸ºï¼š16+1+20+2+1+19+9+3=71ï¼Œè€Œ 71 çš„äºŒè¿›åˆ¶æ˜¯ 1000111ï¼Œå³æœ‰ 3 ä¸ª 0ã€4 ä¸ª 1ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºé•¿åº¦ä¸è¶…è¿‡ 10^5ã€ä»¥å›è½¦ç»“æŸçš„å­—ç¬¦ä¸²ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­å…ˆåè¾“å‡º 0 çš„ä¸ªæ•°å’Œ 1 çš„ä¸ªæ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥ 1PAT (Basic) æ ·ä¾‹è¾“å‡º 13 4 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn]; 3 4int main() 5{ 6 fgets(s, mxn, stdin); 7 int len = strlen(s); 8 9 LL sum = 0; 10 for(int i=0; i\u0026lt;len; i++) 11 sum += isalpha(s[i]) ? (tolower(s[i])-\u0026#39;a\u0026#39;+1) : 0; 12 13 int a=0, b=0; 14 while(sum){ 15 if(sum \u0026amp; 1) 16 b++; 17 else 18 a++; 19 sum \u0026gt;\u0026gt;= 1; 20 } 21 printf(\u0026#34;%d %d\\n\u0026#34;, a, b); 22 return 0; 23} ","permalink":"https://blog.lordash.de/posts/solution/patb-1057-%E6%95%B0%E9%9B%B6%E5%A3%B9/","summary":"æ•°é›¶å£¹ (PATB-1057) é¢˜é¢ ç»™å®šä¸€ä¸²é•¿åº¦ä¸è¶…è¿‡ 10^5 çš„å­—ç¬¦ä¸²ï¼Œæœ¬é¢˜è¦æ±‚ä½ å°†å…¶ä¸­æ‰€æœ‰è‹±æ–‡å­—æ¯çš„åºå·ï¼ˆå­—æ¯ a-z å¯¹åº”åºå· 1-26ï¼Œä¸åˆ†å¤§å°å†™ï¼‰ç›¸åŠ ï¼Œå¾—åˆ°æ•´æ•° Nï¼Œç„¶åå†åˆ†","title":"PATB-1057 æ•°é›¶å£¹"},{"content":"ç»„åˆæ•°çš„å’Œ (PATB-1056) é¢˜é¢ ç»™å®š N ä¸ªé 0 çš„ä¸ªä½æ•°å­—ï¼Œç”¨å…¶ä¸­ä»»æ„ 2 ä¸ªæ•°å­—éƒ½å¯ä»¥ç»„åˆæˆ 1 ä¸ª 2 ä½çš„æ•°å­—ã€‚è¦æ±‚æ‰€æœ‰å¯èƒ½ç»„åˆå‡ºæ¥çš„ 2 ä½æ•°å­—çš„å’Œã€‚ä¾‹å¦‚ç»™å®š 2ã€5ã€8ï¼Œåˆ™å¯ä»¥ç»„åˆå‡ºï¼š25ã€28ã€52ã€58ã€82ã€85ï¼Œå®ƒä»¬çš„å’Œä¸º330ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­å…ˆç»™å‡º Nï¼ˆ1 \u0026lt; N \u0026lt; 10ï¼‰ï¼Œéšåç»™å‡º N ä¸ªä¸åŒçš„é 0 ä¸ªä½æ•°å­—ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º è¾“å‡ºæ‰€æœ‰å¯èƒ½ç»„åˆå‡ºæ¥çš„2ä½æ•°å­—çš„å’Œã€‚\næ ·ä¾‹è¾“å…¥ 13 2 8 5 æ ·ä¾‹è¾“å‡º 1330 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 5 int ans = 0, m; 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 9 ans += m * (n-1) * 11; 10 } 11 printf(\u0026#34;%d\\n\u0026#34;, ans); 12 return 0; 13} ","permalink":"https://blog.lordash.de/posts/solution/patb-1056-%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%92%8C/","summary":"ç»„åˆæ•°çš„å’Œ (PATB-1056) é¢˜é¢ ç»™å®š N ä¸ªé 0 çš„ä¸ªä½æ•°å­—ï¼Œç”¨å…¶ä¸­ä»»æ„ 2 ä¸ªæ•°å­—éƒ½å¯ä»¥ç»„åˆæˆ 1 ä¸ª 2 ä½çš„æ•°å­—ã€‚è¦æ±‚æ‰€æœ‰å¯èƒ½ç»„åˆå‡ºæ¥çš„ 2 ä½æ•°å­—çš„å’Œã€‚ä¾‹å¦‚ç»™å®š 2ã€5ã€8","title":"PATB-1056 ç»„åˆæ•°çš„å’Œ"},{"content":"é›†ä½“ç…§ (PATB-1055) é¢˜é¢ æ‹é›†ä½“ç…§æ—¶é˜Ÿå½¢å¾ˆé‡è¦ï¼Œè¿™é‡Œå¯¹ç»™å®šçš„ N ä¸ªäºº K æ’çš„é˜Ÿå½¢è®¾è®¡æ’é˜Ÿè§„åˆ™å¦‚ä¸‹ï¼š\næ¯æ’äººæ•°ä¸º N/Kï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼Œå¤šå‡ºæ¥çš„äººå…¨éƒ¨ç«™åœ¨æœ€åä¸€æ’ï¼› åæ’æ‰€æœ‰äººçš„ä¸ªå­éƒ½ä¸æ¯”å‰æ’ä»»ä½•äººçŸ®ï¼› æ¯æ’ä¸­æœ€é«˜è€…ç«™ä¸­é—´ï¼ˆä¸­é—´ä½ç½®ä¸º m/2+1ï¼Œå…¶ä¸­ m ä¸ºè¯¥æ’äººæ•°ï¼Œé™¤æ³•å‘ä¸‹å–æ•´ï¼‰ï¼› æ¯æ’å…¶ä»–äººä»¥ä¸­é—´äººä¸ºè½´ï¼ŒæŒ‰èº«é«˜éå¢åºï¼Œå…ˆå³åå·¦äº¤æ›¿å…¥é˜Ÿç«™åœ¨ä¸­é—´äººçš„ä¸¤ä¾§ï¼ˆä¾‹å¦‚5äººèº«é«˜ä¸º190ã€188ã€186ã€175ã€170ï¼Œåˆ™é˜Ÿå½¢ä¸º175ã€188ã€190ã€186ã€170ã€‚è¿™é‡Œå‡è®¾ä½ é¢å¯¹æ‹ç…§è€…ï¼Œæ‰€ä»¥ä½ çš„å·¦è¾¹æ˜¯ä¸­é—´äººçš„å³è¾¹ï¼‰ï¼› è‹¥å¤šäººèº«é«˜ç›¸åŒï¼Œåˆ™æŒ‰åå­—çš„å­—å…¸åºå‡åºæ’åˆ—ã€‚è¿™é‡Œä¿è¯æ— é‡åã€‚ ç°ç»™å®šä¸€ç»„æ‹ç…§äººï¼Œè¯·ç¼–å†™ç¨‹åºè¾“å‡ºä»–ä»¬çš„é˜Ÿå½¢ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10^4ï¼Œæ€»äººæ•°ï¼‰å’Œ Kï¼ˆâ‰¤10ï¼Œæ€»æ’æ•°ï¼‰ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªäººçš„åå­—ï¼ˆä¸åŒ…å«ç©ºæ ¼ã€é•¿åº¦ä¸è¶…è¿‡ 8 ä¸ªè‹±æ–‡å­—æ¯ï¼‰å’Œèº«é«˜ï¼ˆ[30, 300] åŒºé—´å†…çš„æ•´æ•°ï¼‰ã€‚\nè¾“å‡º è¾“å‡ºæ‹ç…§çš„é˜Ÿå½¢ã€‚å³Kæ’äººåï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œè¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚æ³¨æ„ï¼šå‡è®¾ä½ é¢å¯¹æ‹ç…§è€…ï¼Œåæ’çš„äººè¾“å‡ºåœ¨ä¸Šæ–¹ï¼Œå‰æ’è¾“å‡ºåœ¨ä¸‹æ–¹ã€‚\næ ·ä¾‹è¾“å…¥ 110 3 2Tom 188 3Mike 170 4Eva 168 5Tim 160 6Joe 190 7Ann 168 8Bob 175 9Nick 186 10Amy 160 11John 159 æ ·ä¾‹è¾“å‡º 1Bob Tom Joe Nick 2Ann Mike Eva 3Tim Amy John æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2struct P{ 3 char s[10]; 4 int t; 5}a[mxn]; 6 7int li[mxn]; 8 9bool cmp(P a, P b) 10{ 11 if(a.t == b.t) 12 return strcmp(a.s, b.s) \u0026lt; 0; 13 return a.t \u0026gt; b.t; 14} 15 16int main() 17{ 18 int n, k; 19 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;k); 20 21 for(int i=0; i\u0026lt;n; i++) 22 scanf(\u0026#34;%s %d\u0026#34;, a[i].s, \u0026amp;a[i].t); 23 sort(a, a+n, cmp); 24 25 int id = 0; 26 for(int i=0; i\u0026lt;k; i++) 27 { 28 int m = n / k, f = 1; 29 if(!i) m += n % k; 30 int now = m/2 + 1; 31 for(int j=1; j\u0026lt;=m; j++) 32 { 33 li[now] = id++; 34 f = -f; 35 now += f*j; 36 } 37 for(int j=1; j\u0026lt;=m; j++) 38 { 39 if(j\u0026gt;1) printf(\u0026#34; \u0026#34;); 40 printf(\u0026#34;%s\u0026#34;, a[li[j]].s); 41 } 42 printf(\u0026#34;\\n\u0026#34;); 43 } 44 return 0; 45} ","permalink":"https://blog.lordash.de/posts/solution/patb-1055-%E9%9B%86%E4%BD%93%E7%85%A7/","summary":"é›†ä½“ç…§ (PATB-1055) é¢˜é¢ æ‹é›†ä½“ç…§æ—¶é˜Ÿå½¢å¾ˆé‡è¦ï¼Œè¿™é‡Œå¯¹ç»™å®šçš„ N ä¸ªäºº K æ’çš„é˜Ÿå½¢è®¾è®¡æ’é˜Ÿè§„åˆ™å¦‚ä¸‹ï¼š æ¯æ’äººæ•°ä¸º N/Kï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼Œå¤šå‡ºæ¥çš„äººå…¨éƒ¨ç«™åœ¨æœ€åä¸€æ’ï¼› å","title":"PATB-1055 é›†ä½“ç…§"},{"content":"æ±‚å¹³å‡å€¼ (PATB-1054) é¢˜é¢ æœ¬é¢˜çš„åŸºæœ¬è¦æ±‚éå¸¸ç®€å•ï¼šç»™å®š N ä¸ªå®æ•°ï¼Œè®¡ç®—å®ƒä»¬çš„å¹³å‡å€¼ã€‚ä½†å¤æ‚çš„æ˜¯æœ‰äº›è¾“å…¥æ•°æ®å¯èƒ½æ˜¯éæ³•çš„ã€‚ä¸€ä¸ªâ€œåˆæ³•â€çš„è¾“å…¥æ˜¯ [âˆ’1000,1000] åŒºé—´å†…çš„å®æ•°ï¼Œå¹¶ä¸”æœ€å¤šç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚å½“ä½ è®¡ç®—å¹³å‡å€¼çš„æ—¶å€™ï¼Œä¸èƒ½æŠŠé‚£äº›éæ³•çš„æ•°æ®ç®—åœ¨å†…ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤100ï¼‰ã€‚éšåä¸€è¡Œç»™å‡º N ä¸ªå®æ•°ï¼Œæ•°å­—é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªéæ³•è¾“å…¥ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡º ERROR: X is not a legal numberï¼Œå…¶ä¸­ X æ˜¯è¾“å…¥ã€‚æœ€ååœ¨ä¸€è¡Œä¸­è¾“å‡ºç»“æœï¼šThe average of K numbers is Yï¼Œå…¶ä¸­ K æ˜¯åˆæ³•è¾“å…¥çš„ä¸ªæ•°ï¼ŒY æ˜¯å®ƒä»¬çš„å¹³å‡å€¼ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚å¦‚æœå¹³å‡å€¼æ— æ³•è®¡ç®—ï¼Œåˆ™ç”¨ Undefined æ›¿æ¢ Yã€‚å¦‚æœ K ä¸º 1ï¼Œåˆ™è¾“å‡º The average of 1 number is Yã€‚\næ ·ä¾‹è¾“å…¥1 17 25 -3.2 aaa 9999 2.3.4 7.123 2.35 æ ·ä¾‹è¾“å‡º1 1ERROR: aaa is not a legal number 2ERROR: 9999 is not a legal number 3ERROR: 2.3.4 is not a legal number 4ERROR: 7.123 is not a legal number 5The average of 3 numbers is 1.38 æ ·ä¾‹è¾“å…¥2 12 2aaa -9999 æ ·ä¾‹è¾“å‡º2 1ERROR: aaa is not a legal number 2ERROR: -9999 is not a legal number 3The average of 0 numbers is Undefined æç¤º æ— \næ€è·¯ ä»£ç  1typedef double DB; 2const int mxn = 1e5 + 5; 3char s[mxn], t[mxn]; 4 5int main() 6{ 7 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 9 int num=0; DB sum=0, x; 10 for(int i=0; i\u0026lt;n; i++) 11 { 12 int f = 0; 13 scanf(\u0026#34;%s\u0026#34;, s); 14 if(sscanf(s, \u0026#34;%lf\u0026#34;, \u0026amp;x) == 0) 15 f = 1; 16 else 17 { 18 sprintf(t, \u0026#34;%.2lf\u0026#34;, x); 19 if(strlen(s)\u0026gt;strlen(t) || x\u0026lt;-1000 || x\u0026gt;1000) 20 f = 1; 21 else 22 sum += x, num++; 23 } 24 if(f) 25 printf(\u0026#34;ERROR: %s is not a legal number\\n\u0026#34;, s); 26 } 27 if(num\u0026gt;1) 28 printf(\u0026#34;The average of %d numbers is %.2lf\\n\u0026#34;, num, sum/num); 29 else if(num==1) 30 printf(\u0026#34;The average of 1 number is %.2lf\\n\u0026#34;, sum); 31 else 32 printf(\u0026#34;The average of 0 numbers is Undefined\\n\u0026#34;); 33 34 return 0; 35} ","permalink":"https://blog.lordash.de/posts/solution/patb-1054-%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/","summary":"æ±‚å¹³å‡å€¼ (PATB-1054) é¢˜é¢ æœ¬é¢˜çš„åŸºæœ¬è¦æ±‚éå¸¸ç®€å•ï¼šç»™å®š N ä¸ªå®æ•°ï¼Œè®¡ç®—å®ƒä»¬çš„å¹³å‡å€¼ã€‚ä½†å¤æ‚çš„æ˜¯æœ‰äº›è¾“å…¥æ•°æ®å¯èƒ½æ˜¯éæ³•çš„ã€‚ä¸€ä¸ªâ€œåˆæ³•â€çš„è¾“å…¥æ˜¯ [âˆ’1000,","title":"PATB-1054 æ±‚å¹³å‡å€¼"},{"content":"ä½æˆ¿ç©ºç½®ç‡ (PATB-1053) é¢˜é¢ åœ¨ä¸æ‰“æ‰°å±…æ°‘çš„å‰æä¸‹ï¼Œç»Ÿè®¡ä½æˆ¿ç©ºç½®ç‡çš„ä¸€ç§æ–¹æ³•æ˜¯æ ¹æ®æ¯æˆ·ç”¨ç”µé‡çš„è¿ç»­å˜åŒ–è§„å¾‹è¿›è¡Œåˆ¤æ–­ã€‚åˆ¤æ–­æ–¹æ³•å¦‚ä¸‹ï¼š\nåœ¨è§‚å¯ŸæœŸå†…ï¼Œè‹¥å­˜åœ¨è¶…è¿‡ä¸€åŠçš„æ—¥å­ç”¨ç”µé‡ä½äºæŸç»™å®šçš„é˜ˆå€¼ eï¼Œåˆ™è¯¥ä½æˆ¿ä¸ºâ€œå¯èƒ½ç©ºç½®â€ï¼› è‹¥è§‚å¯ŸæœŸè¶…è¿‡æŸç»™å®šé˜ˆå€¼ D å¤©ï¼Œä¸”æ»¡è¶³ä¸Šä¸€ä¸ªæ¡ä»¶ï¼Œåˆ™è¯¥ä½æˆ¿ä¸ºâ€œç©ºç½®â€ã€‚ ç°ç»™å®šæŸå±…æ°‘åŒºçš„ä½æˆ·ç”¨ç”µé‡æ•°æ®ï¼Œè¯·ä½ ç»Ÿè®¡â€œå¯èƒ½ç©ºç½®â€çš„æ¯”ç‡å’Œâ€œç©ºç½®â€æ¯”ç‡ï¼Œå³ä»¥ä¸Šä¸¤ç§çŠ¶æ€çš„ä½æˆ¿å å±…æ°‘åŒºä½æˆ¿æ€»å¥—æ•°çš„ç™¾åˆ†æ¯”ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰ï¼Œä¸ºå±…æ°‘åŒºä½æˆ¿æ€»å¥—æ•°ï¼›æ­£å®æ•° eï¼Œå³ä½ç”µé‡é˜ˆå€¼ï¼›æ­£æ•´æ•° Dï¼Œå³è§‚å¯ŸæœŸé˜ˆå€¼ã€‚éšå N è¡Œï¼Œæ¯è¡ŒæŒ‰ä»¥ä¸‹æ ¼å¼ç»™å‡ºä¸€å¥—ä½æˆ¿çš„ç”¨ç”µé‡æ•°æ®ï¼š\nK E1 E2 \u0026hellip; EK\nå…¶ä¸­ K ä¸ºè§‚å¯Ÿçš„å¤©æ•°ï¼ŒEi ä¸ºç¬¬ i å¤©çš„ç”¨ç”µé‡ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºâ€œå¯èƒ½ç©ºç½®â€çš„æ¯”ç‡å’Œâ€œç©ºç½®â€æ¯”ç‡çš„ç™¾åˆ†æ¯”å€¼ï¼Œå…¶é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ï¼Œä¿ç•™å°æ•°ç‚¹å 1 ä½ã€‚\næ ·ä¾‹è¾“å…¥ 15 0.5 10 26 0.3 0.4 0.5 0.2 0.8 0.6 310 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5 45 0.4 0.3 0.5 0.1 0.7 511 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 611 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 æ ·ä¾‹è¾“å‡º 140.0% 20.0% æç¤º æ ·ä¾‹è§£é‡Šï¼šç¬¬2ã€3æˆ·ä¸ºâ€œå¯èƒ½ç©ºç½®â€ï¼Œç¬¬4æˆ·ä¸ºâ€œç©ºç½®â€ï¼Œå…¶ä»–æˆ·ä¸æ˜¯ç©ºç½®ã€‚\næ€è·¯ ä»£ç  1int main() 2{ 3 int n, d; DB e; 4 scanf(\u0026#34;%d %lf %d\u0026#34;, \u0026amp;n, \u0026amp;e, \u0026amp;d); 5 6 int x=0, y=0; 7 for(int i=0; i\u0026lt;n; i++) 8 { 9 int m, num=0; 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 11 for(int j=0; j\u0026lt;m; j++) 12 { 13 DB t; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;t); 14 if(t\u0026lt;e) num++; 15 } 16 if(num*2\u0026gt;m) 17 if(m\u0026gt;d) y++; 18 else x++; 19 } 20 printf(\u0026#34;%.1lf%% %.1lf%%\\n\u0026#34;, 100.0*x/n, 100.0*y/n); 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1053-%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87/","summary":"ä½æˆ¿ç©ºç½®ç‡ (PATB-1053) é¢˜é¢ åœ¨ä¸æ‰“æ‰°å±…æ°‘çš„å‰æä¸‹ï¼Œç»Ÿè®¡ä½æˆ¿ç©ºç½®ç‡çš„ä¸€ç§æ–¹æ³•æ˜¯æ ¹æ®æ¯æˆ·ç”¨ç”µé‡çš„è¿ç»­å˜åŒ–è§„å¾‹è¿›è¡Œåˆ¤æ–­ã€‚åˆ¤æ–­æ–¹æ³•å¦‚ä¸‹ï¼š åœ¨è§‚å¯ŸæœŸå†…ï¼Œè‹¥å­˜åœ¨è¶…è¿‡ä¸€","title":"PATB-1053 ä½æˆ¿ç©ºç½®ç‡"},{"content":"å–ä¸ªèŒ (PATB-1052) é¢˜é¢ èŒèŒå“’è¡¨æƒ…ç¬¦å·é€šå¸¸ç”±â€œæ‰‹â€ã€â€œçœ¼â€ã€â€œå£â€ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆã€‚ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªè¡¨æƒ…ç¬¦å·æ˜¯æŒ‰ä¸‹åˆ—æ ¼å¼è¾“å‡ºçš„ï¼š\n1[å·¦æ‰‹]([å·¦çœ¼][å£][å³çœ¼])[å³æ‰‹] ç°ç»™å‡ºå¯é€‰ç”¨çš„ç¬¦å·é›†åˆï¼Œè¯·ä½ æŒ‰ç”¨æˆ·çš„è¦æ±‚è¾“å‡ºè¡¨æƒ…ã€‚\nè¾“å…¥ è¾“å…¥é¦–å…ˆåœ¨å‰ä¸‰è¡Œé¡ºåºå¯¹åº”ç»™å‡ºæ‰‹ã€çœ¼ã€å£çš„å¯é€‰ç¬¦å·é›†ã€‚æ¯ä¸ªç¬¦å·æ‹¬åœ¨ä¸€å¯¹æ–¹æ‹¬å· []å†…ã€‚é¢˜ç›®ä¿è¯æ¯ä¸ªé›†åˆéƒ½è‡³å°‘æœ‰ä¸€ä¸ªç¬¦å·ï¼Œå¹¶ä¸è¶…è¿‡ 10 ä¸ªç¬¦å·ï¼›æ¯ä¸ªç¬¦å·åŒ…å« 1 åˆ° 4 ä¸ªéç©ºå­—ç¬¦ã€‚\nä¹‹åä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Kï¼Œä¸ºç”¨æˆ·è¯·æ±‚çš„ä¸ªæ•°ã€‚éšå K è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç”¨æˆ·çš„ç¬¦å·é€‰æ‹©ï¼Œé¡ºåºä¸ºå·¦æ‰‹ã€å·¦çœ¼ã€å£ã€å³çœ¼ã€å³æ‰‹â€”â€”è¿™é‡Œåªç»™å‡ºç¬¦å·åœ¨ç›¸åº”é›†åˆä¸­çš„åºå·ï¼ˆä» 1 å¼€å§‹ï¼‰ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªç”¨æˆ·è¯·æ±‚ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç”Ÿæˆçš„è¡¨æƒ…ã€‚è‹¥ç”¨æˆ·é€‰æ‹©çš„åºå·ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º Are you kidding me? @\\/@ã€‚\næ ·ä¾‹è¾“å…¥ 1[â•®][â•­][o][~\\][/~] [\u0026lt;][\u0026gt;] 2 [â•¯][â•°][^][-][=][\u0026gt;][\u0026lt;][@][âŠ™] 3[Ğ”][â–½][_][Îµ][^] ... 44 51 1 2 2 2 66 8 1 5 5 73 3 4 3 3 82 10 3 9 3 æ ·ä¾‹è¾“å‡º 1â•®(â•¯â–½â•°)â•­ 2\u0026lt;(@Ğ”=)/~ 3o(^Îµ^)o 4Are you kidding me? @\\/@ æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 10 + 5; 2char a[mxn][20], b[mxn][20], c[mxn][20]; 3 4int main() 5{ 6 int an=0, bn=0, cn=0, ch; 7 while((ch = getchar()) != \u0026#39;\\n\u0026#39;) 8 { 9 if(ch == \u0026#39;[\u0026#39;) 10 scanf(\u0026#34;%[^]]\u0026#34;, a[++an]); 11 } 12 while((ch = getchar()) != \u0026#39;\\n\u0026#39;) 13 { 14 if(ch == \u0026#39;[\u0026#39;) 15 scanf(\u0026#34;%[^]]\u0026#34;, b[++bn]); 16 } 17 while((ch = getchar()) != \u0026#39;\\n\u0026#39;) 18 { 19 if(ch == \u0026#39;[\u0026#39;) 20 scanf(\u0026#34;%[^]]\u0026#34;, c[++cn]); 21 } 22 int k, t[5]; 23 scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); 24 25 while(k--){ 26 for(int i=0; i\u0026lt;5; i++) 27 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t[i]); 28 int f = 0; 29 if(t[0]\u0026lt;1 || t[0]\u0026gt;an) f = 1; 30 if(t[1]\u0026lt;1 || t[1]\u0026gt;bn) f = 1; 31 if(t[2]\u0026lt;1 || t[2]\u0026gt;cn) f = 1; 32 if(t[3]\u0026lt;1 || t[3]\u0026gt;bn) f = 1; 33 if(t[4]\u0026lt;1 || t[4]\u0026gt;an) f = 1; 34 if(f){ 35 printf(\u0026#34;Are you kidding me? @\\\\/@\\n\u0026#34;); 36 continue; 37 } 38 printf(\u0026#34;%s(%s%s%s)%s\\n\u0026#34;, a[t[0]], b[t[1]], c[t[2]], b[t[3]], a[t[4]]); 39 } 40 return 0; 41} ","permalink":"https://blog.lordash.de/posts/solution/patb-1052-%E5%8D%96%E4%B8%AA%E8%90%8C/","summary":"å–ä¸ªèŒ (PATB-1052) é¢˜é¢ èŒèŒå“’è¡¨æƒ…ç¬¦å·é€šå¸¸ç”±â€œæ‰‹â€ã€â€œçœ¼â€ã€â€œå£â€ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆã€‚ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾ä¸€ä¸ªè¡¨æƒ…ç¬¦å·æ˜¯æŒ‰ä¸‹åˆ—æ ¼å¼è¾“å‡ºçš„ï¼š 1[å·¦æ‰‹]([å·¦çœ¼","title":"PATB-1052 å–ä¸ªèŒ"},{"content":"å¤æ•°ä¹˜æ³• (PATB-1051) é¢˜é¢ å¤æ•°å¯ä»¥å†™æˆ (A+Bi) çš„å¸¸è§„å½¢å¼ï¼Œå…¶ä¸­ A æ˜¯å®éƒ¨ï¼ŒB æ˜¯è™šéƒ¨ï¼Œi æ˜¯è™šæ•°å•ä½ï¼Œæ»¡è¶³ i^2=âˆ’1ï¼›ä¹Ÿå¯ä»¥å†™æˆæåæ ‡ä¸‹çš„æŒ‡æ•°å½¢å¼ (RÃ—e^(Pi))ï¼Œå…¶ä¸­ R æ˜¯å¤æ•°æ¨¡ï¼ŒP æ˜¯è¾è§’ï¼Œi æ˜¯è™šæ•°å•ä½ï¼Œå…¶ç­‰ä»·äºä¸‰è§’å½¢å¼ R(cos(P)+isin(P))ã€‚\nç°ç»™å®šä¸¤ä¸ªå¤æ•°çš„ R å’Œ Pï¼Œè¦æ±‚è¾“å‡ºä¸¤æ•°ä¹˜ç§¯çš„å¸¸è§„å½¢å¼ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡ºä¸¤ä¸ªå¤æ•°çš„ R1, P1, R2, P2ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ A+Bi çš„æ ¼å¼è¾“å‡ºä¸¤æ•°ä¹˜ç§¯çš„å¸¸è§„å½¢å¼ï¼Œå®éƒ¨å’Œè™šéƒ¨å‡ä¿ç•™ 2 ä½å°æ•°ã€‚æ³¨æ„ï¼šå¦‚æœ B æ˜¯è´Ÿæ•°ï¼Œåˆ™åº”è¯¥å†™æˆ A-|B|i çš„å½¢å¼ã€‚\næ ·ä¾‹è¾“å…¥ 12.3 3.5 5.2 0.4 æ ·ä¾‹è¾“å‡º 1-8.68-8.23i æç¤º æ— \næ€è·¯ ä»£ç  1#define Sg(u) ((u) \u0026gt; eps ? 1 : ((u) \u0026lt; -eps ? -1 : 0)) 2#define Abs(u) (Sg(u) \u0026gt;= 0 ? (u) : -(u)) 3#define Ze(u) (!Sg(u)) 4typedef double DB; 5const DB eps = 5e-3; 6 7int main() 8{ 9 DB r1, p1, r2, p2; 10 scanf(\u0026#34;%lf %lf %lf %lf\u0026#34;, \u0026amp;r1, \u0026amp;p1, \u0026amp;r2, \u0026amp;p2); 11 12 DB a = r1*cos(p1) * r2*cos(p2) - r1*sin(p1) * r2*sin(p2); 13 DB b = r1*cos(p1) * r2*sin(p2) + r2*cos(p2) * r1*sin(p1); 14 15 if(Ze(a)) 16 a = 0.0; 17 printf(\u0026#34;%.2lf\u0026#34;, a); 18 19 if(Ze(b)) 20 b = 0.0; 21 22 if(Sg(b) \u0026gt;= 0) 23 printf(\u0026#34;+\u0026#34;); 24 25 printf(\u0026#34;%.2lfi\\n\u0026#34;, b); 26 27 return 0; 28} ","permalink":"https://blog.lordash.de/posts/solution/patb-1051-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/","summary":"å¤æ•°ä¹˜æ³• (PATB-1051) é¢˜é¢ å¤æ•°å¯ä»¥å†™æˆ (A+Bi) çš„å¸¸è§„å½¢å¼ï¼Œå…¶ä¸­ A æ˜¯å®éƒ¨ï¼ŒB æ˜¯è™šéƒ¨ï¼Œi æ˜¯è™šæ•°å•ä½ï¼Œæ»¡è¶³ i^2=âˆ’1ï¼›ä¹Ÿå¯ä»¥å†™æˆæåæ ‡ä¸‹çš„æŒ‡æ•°å½¢å¼ (RÃ—e^(Pi","title":"PATB-1051 å¤æ•°ä¹˜æ³•"},{"content":"èºæ—‹çŸ©é˜µ (PATB-1050) é¢˜é¢ æœ¬é¢˜è¦æ±‚å°†ç»™å®šçš„ N ä¸ªæ­£æ•´æ•°æŒ‰éé€’å¢çš„é¡ºåºï¼Œå¡«å…¥â€œèºæ—‹çŸ©é˜µâ€ã€‚æ‰€è°“â€œèºæ—‹çŸ©é˜µâ€ï¼Œæ˜¯æŒ‡ä»å·¦ä¸Šè§’ç¬¬ 1 ä¸ªæ ¼å­å¼€å§‹ï¼ŒæŒ‰é¡ºæ—¶é’ˆèºæ—‹æ–¹å‘å¡«å……ã€‚è¦æ±‚çŸ©é˜µçš„è§„æ¨¡ä¸º m è¡Œ n åˆ—ï¼Œæ»¡è¶³æ¡ä»¶ï¼šmÃ—n ç­‰äº Nï¼›mâ‰¥nï¼›ä¸” mâˆ’n å–æ‰€æœ‰å¯èƒ½å€¼ä¸­çš„æœ€å°å€¼ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ 1 è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼Œç¬¬ 2 è¡Œç»™å‡º N ä¸ªå¾…å¡«å……çš„æ­£æ•´æ•°ã€‚æ‰€æœ‰æ•°å­—ä¸è¶…è¿‡ 10^4ï¼Œç›¸é‚»æ•°å­—ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º è¾“å‡ºèºæ—‹çŸ©é˜µã€‚æ¯è¡Œ n ä¸ªæ•°å­—ï¼Œå…± m è¡Œã€‚ç›¸é‚»æ•°å­—ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 112 237 76 20 98 76 42 53 95 60 81 58 93 æ ·ä¾‹è¾“å‡º 198 95 93 242 37 81 353 20 76 458 60 76 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn], ans[mxn]; 3 4int main() 5{ 6 int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 7 8 int n, m; 9 for(int i=sqrt(t); i; i--){ 10 if(t%i == 0){ 11 m = i; 12 n = t/m; 13 break; 14 } 15 } 16 for(int i=0; i\u0026lt;t; i++) 17 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 18 sort(a, a+t); 19 20 int x=0, y=-1; 21 for(t--; t\u0026gt;=0;) 22 { 23 while(y+1\u0026lt;m \u0026amp;\u0026amp; *(ans+x*m+y+1) == 0){ 24 ++y; *(ans+x*m+y) = a[t--]; 25 } 26 27 while(x+1\u0026lt;n \u0026amp;\u0026amp; *(ans+(x+1)*m+y) == 0){ 28 ++x; *(ans+x*m+y) = a[t--]; 29 } 30 31 while(y-1\u0026gt;=0 \u0026amp;\u0026amp; *(ans+x*m+y-1) == 0){ 32 --y; *(ans+x*m+y) = a[t--]; 33 } 34 35 while(x-1\u0026gt;=0 \u0026amp;\u0026amp; *(ans+(x-1)*m+y) == 0){ 36 --x; *(ans+x*m+y) = a[t--]; 37 } 38 } 39 40 for(int i=0; i\u0026lt;n; i++) 41 { 42 for(int j=0; j\u0026lt;m; j++) 43 { 44 if(j) printf(\u0026#34; \u0026#34;); 45 printf(\u0026#34;%d\u0026#34;, *(ans+i*m+j)); 46 } 47 printf(\u0026#34;\\n\u0026#34;); 48 } 49 50 return 0; 51} ","permalink":"https://blog.lordash.de/posts/solution/patb-1050-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","summary":"èºæ—‹çŸ©é˜µ (PATB-1050) é¢˜é¢ æœ¬é¢˜è¦æ±‚å°†ç»™å®šçš„ N ä¸ªæ­£æ•´æ•°æŒ‰éé€’å¢çš„é¡ºåºï¼Œå¡«å…¥â€œèºæ—‹çŸ©é˜µâ€ã€‚æ‰€è°“â€œèºæ—‹çŸ©é˜µâ€ï¼Œæ˜¯æŒ‡ä»å·¦ä¸Šè§’ç¬¬ 1 ä¸ªæ ¼å­å¼€å§‹ï¼ŒæŒ‰é¡ºæ—¶é’ˆèºæ—‹æ–¹å‘å¡«å……","title":"PATB-1050 èºæ—‹çŸ©é˜µ"},{"content":"æ•°åˆ—çš„ç‰‡æ®µå’Œ (PATB-1049) é¢˜é¢ ç»™å®šä¸€ä¸ªæ­£æ•°æ•°åˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­æˆªå–ä»»æ„çš„è¿ç»­çš„å‡ ä¸ªæ•°ï¼Œç§°ä¸ºç‰‡æ®µã€‚ä¾‹å¦‚ï¼Œç»™å®šæ•°åˆ— { 0.1, 0.2, 0.3, 0.4 }ï¼Œæˆ‘ä»¬æœ‰ (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) è¿™ 10 ä¸ªç‰‡æ®µã€‚\nç»™å®šæ­£æ•´æ•°æ•°åˆ—ï¼Œæ±‚å‡ºå…¨éƒ¨ç‰‡æ®µåŒ…å«çš„æ‰€æœ‰çš„æ•°ä¹‹å’Œã€‚å¦‚æœ¬ä¾‹ä¸­ 10 ä¸ªç‰‡æ®µæ€»å’Œæ˜¯ 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 10^5 çš„æ­£æ•´æ•° Nï¼Œè¡¨ç¤ºæ•°åˆ—ä¸­æ•°çš„ä¸ªæ•°ï¼Œç¬¬äºŒè¡Œç»™å‡º N ä¸ªä¸è¶…è¿‡ 1.0 çš„æ­£æ•°ï¼Œæ˜¯æ•°åˆ—ä¸­çš„æ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºè¯¥åºåˆ—æ‰€æœ‰ç‰‡æ®µåŒ…å«çš„æ•°ä¹‹å’Œï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚\næ ·ä¾‹è¾“å…¥ 14 20.1 0.2 0.3 0.4 æ ·ä¾‹è¾“å‡º 15.00 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 4 5 LL ans = 0; DB m; 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;m); 9 ans += (LL)(m * (i+1) * (n-i) * 1000.0); 10 } 11 printf(\u0026#34;%.2lf\\n\u0026#34;, ans / 1000.0); 12 return 0; 13} ","permalink":"https://blog.lordash.de/posts/solution/patb-1049-%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C/","summary":"æ•°åˆ—çš„ç‰‡æ®µå’Œ (PATB-1049) é¢˜é¢ ç»™å®šä¸€ä¸ªæ­£æ•°æ•°åˆ—ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸­æˆªå–ä»»æ„çš„è¿ç»­çš„å‡ ä¸ªæ•°ï¼Œç§°ä¸ºç‰‡æ®µã€‚ä¾‹å¦‚ï¼Œç»™å®šæ•°åˆ— { 0.1, 0.2, 0.3, 0.4 }ï¼Œæˆ‘ä»¬æœ‰ (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2,","title":"PATB-1049 æ•°åˆ—çš„ç‰‡æ®µå’Œ"},{"content":"æ•°å­—åŠ å¯† (PATB-1048) é¢˜é¢ æœ¬é¢˜è¦æ±‚å®ç°ä¸€ç§æ•°å­—åŠ å¯†æ–¹æ³•ã€‚é¦–å…ˆå›ºå®šä¸€ä¸ªåŠ å¯†ç”¨æ­£æ•´æ•° Aï¼Œå¯¹ä»»ä¸€æ­£æ•´æ•° Bï¼Œå°†å…¶æ¯ 1 ä½æ•°å­—ä¸ A çš„å¯¹åº”ä½ç½®ä¸Šçš„æ•°å­—è¿›è¡Œä»¥ä¸‹è¿ç®—ï¼šå¯¹å¥‡æ•°ä½ï¼Œå¯¹åº”ä½çš„æ•°å­—ç›¸åŠ åå¯¹ 13 å–ä½™â€”â€”è¿™é‡Œç”¨ J ä»£è¡¨ 10ã€Q ä»£è¡¨ 11ã€K ä»£è¡¨ 12ï¼›å¯¹å¶æ•°ä½ï¼Œç”¨ B çš„æ•°å­—å‡å» A çš„æ•°å­—ï¼Œè‹¥ç»“æœä¸ºè´Ÿæ•°ï¼Œåˆ™å†åŠ  10ã€‚è¿™é‡Œä»¤ä¸ªä½ä¸ºç¬¬ 1 ä½ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º A å’Œ Bï¼Œå‡ä¸ºä¸è¶…è¿‡ 100 ä½çš„æ­£æ•´æ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºåŠ å¯†åçš„ç»“æœã€‚\næ ·ä¾‹è¾“å…¥ 11234567 368782971 æ ·ä¾‹è¾“å‡º 13695Q8118 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[mxn], ans[mxn]; 3char p[] = \u0026#34;0123456789JQK\u0026#34;; 4 5int main() 6{ 7 scanf(\u0026#34;%s %s\u0026#34;, s+1, t+1); 8 9 s[0] = t[0] = \u0026#39;0\u0026#39;; 10 int n = 0, f = 1; 11 int i = strlen(s+1), j = strlen(t+1); 12 13 while(i\u0026gt;0 || j\u0026gt;0) 14 { 15 if(f) 16 ans[n++] = p[(t[j]-\u0026#39;0\u0026#39;+s[i]-\u0026#39;0\u0026#39;)%13]; 17 else{ 18 int x = t[j] - s[i]; 19 ans[n++] = p[x\u0026lt;0 ? x+10 : x]; 20 } 21 if(i) i--; 22 if(j) j--; 23 f = !f; 24 } 25 26 for(int i=n-1; i\u0026gt;=0; i--) 27 printf(\u0026#34;%c\u0026#34;, ans[i]); 28 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/patb-1048-%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86/","summary":"æ•°å­—åŠ å¯† (PATB-1048) é¢˜é¢ æœ¬é¢˜è¦æ±‚å®ç°ä¸€ç§æ•°å­—åŠ å¯†æ–¹æ³•ã€‚é¦–å…ˆå›ºå®šä¸€ä¸ªåŠ å¯†ç”¨æ­£æ•´æ•° Aï¼Œå¯¹ä»»ä¸€æ­£æ•´æ•° Bï¼Œå°†å…¶æ¯ 1 ä½æ•°å­—ä¸ A çš„å¯¹åº”ä½ç½®ä¸Šçš„æ•°å­—è¿›è¡Œä»¥ä¸‹è¿ç®—ï¼šå¯¹","title":"PATB-1048 æ•°å­—åŠ å¯†"},{"content":"ç¼–ç¨‹å›¢ä½“èµ› (PATB-1047) é¢˜é¢ ç¼–ç¨‹å›¢ä½“èµ›çš„è§„åˆ™ä¸ºï¼šæ¯ä¸ªå‚èµ›é˜Ÿç”±è‹¥å¹²é˜Ÿå‘˜ç»„æˆï¼›æ‰€æœ‰é˜Ÿå‘˜ç‹¬ç«‹æ¯”èµ›ï¼›å‚èµ›é˜Ÿçš„æˆç»©ä¸ºæ‰€æœ‰é˜Ÿå‘˜çš„æˆç»©å’Œï¼›æˆç»©æœ€é«˜çš„é˜Ÿè·èƒœã€‚\nç°ç»™å®šæ‰€æœ‰é˜Ÿå‘˜çš„æ¯”èµ›æˆç»©ï¼Œè¯·ä½ ç¼–å†™ç¨‹åºæ‰¾å‡ºå† å†›é˜Ÿã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10^4ï¼‰ï¼Œå³æ‰€æœ‰å‚èµ›é˜Ÿå‘˜æ€»æ•°ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½é˜Ÿå‘˜çš„æˆç»©ï¼Œæ ¼å¼ä¸ºï¼šé˜Ÿä¼ç¼–å·-é˜Ÿå‘˜ç¼–å· æˆç»©ï¼Œå…¶ä¸­é˜Ÿä¼ç¼–å·ä¸º 1 åˆ° 1000 çš„æ­£æ•´æ•°ï¼Œé˜Ÿå‘˜ç¼–å·ä¸º 1 åˆ° 10 çš„æ­£æ•´æ•°ï¼Œæˆç»©ä¸º 0 åˆ° 100 çš„æ•´æ•°ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºå† å†›é˜Ÿçš„ç¼–å·å’Œæ€»æˆç»©ï¼Œå…¶é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚æ³¨æ„ï¼šé¢˜ç›®ä¿è¯å† å†›é˜Ÿæ˜¯å”¯ä¸€çš„ã€‚\næ ·ä¾‹è¾“å…¥ 16 23-10 99 311-5 87 4102-1 0 5102-3 100 611-9 89 73-2 61 æ ·ä¾‹è¾“å‡º 111 176 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d%\u0026#34;, \u0026amp;n); 7 8 for(int i=0; i\u0026lt;n; i++) 9 { 10 int x, y, z; 11 scanf(\u0026#34;%d-%d %d\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); 12 a[x] += z; 13 } 14 int mx = 0, id = 0; 15 for(int i=1; i\u0026lt;=1000; i++) 16 { 17 if(mx \u0026lt; a[i]) 18 { 19 mx = a[i]; 20 id = i; 21 } 22 } 23 printf(\u0026#34;%d %d\\n\u0026#34;, id, mx); 24 return 0; 25} ","permalink":"https://blog.lordash.de/posts/solution/patb-1047-%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B/","summary":"ç¼–ç¨‹å›¢ä½“èµ› (PATB-1047) é¢˜é¢ ç¼–ç¨‹å›¢ä½“èµ›çš„è§„åˆ™ä¸ºï¼šæ¯ä¸ªå‚èµ›é˜Ÿç”±è‹¥å¹²é˜Ÿå‘˜ç»„æˆï¼›æ‰€æœ‰é˜Ÿå‘˜ç‹¬ç«‹æ¯”èµ›ï¼›å‚èµ›é˜Ÿçš„æˆç»©ä¸ºæ‰€æœ‰é˜Ÿå‘˜çš„æˆç»©å’Œï¼›æˆç»©æœ€é«˜çš„é˜Ÿè·èƒœã€‚ ç°ç»™å®šæ‰€æœ‰","title":"PATB-1047 ç¼–ç¨‹å›¢ä½“èµ›"},{"content":"åˆ’æ‹³ (PATB-1046) é¢˜é¢ åˆ’æ‹³æ˜¯å¤è€ä¸­å›½é…’æ–‡åŒ–çš„ä¸€ä¸ªæœ‰è¶£çš„ç»„æˆéƒ¨åˆ†ã€‚é…’æ¡Œä¸Šä¸¤äººåˆ’æ‹³çš„æ–¹æ³•ä¸ºï¼šæ¯äººå£ä¸­å–Šå‡ºä¸€ä¸ªæ•°å­—ï¼ŒåŒæ—¶ç”¨æ‰‹æ¯”åˆ’å‡ºä¸€ä¸ªæ•°å­—ã€‚å¦‚æœè°æ¯”åˆ’å‡ºçš„æ•°å­—æ­£å¥½ç­‰äºä¸¤äººå–Šå‡ºçš„æ•°å­—ä¹‹å’Œï¼Œè°å°±èµ¢äº†ï¼Œè¾“å®¶ç½šä¸€æ¯é…’ã€‚ä¸¤äººåŒèµ¢æˆ–ä¸¤äººåŒè¾“åˆ™ç»§ç»­ä¸‹ä¸€è½®ï¼Œç›´åˆ°å”¯ä¸€çš„èµ¢å®¶å‡ºç°ã€‚\nä¸‹é¢ç»™å‡ºç”²ã€ä¹™ä¸¤äººçš„åˆ’æ‹³è®°å½•ï¼Œè¯·ä½ ç»Ÿè®¡ä»–ä»¬æœ€ååˆ†åˆ«å–äº†å¤šå°‘æ¯é…’ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œå…ˆç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€è½®åˆ’æ‹³çš„è®°å½•ï¼Œæ ¼å¼ä¸ºï¼š\n1ç”²å–Š ç”²åˆ’ ä¹™å–Š ä¹™åˆ’ å…¶ä¸­å–Šæ˜¯å–Šå‡ºçš„æ•°å­—ï¼Œåˆ’æ˜¯åˆ’å‡ºçš„æ•°å­—ï¼Œå‡ä¸ºä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•°ï¼ˆä¸¤åªæ‰‹ä¸€èµ·åˆ’ï¼‰ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­å…ˆåè¾“å‡ºç”²ã€ä¹™ä¸¤äººå–é…’çš„æ¯æ•°ï¼Œå…¶é—´ä»¥ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥ 15 28 10 9 12 35 10 5 10 43 8 5 12 512 18 1 13 64 16 12 15 æ ·ä¾‹è¾“å‡º 11 2 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; scanf(\u0026#34;%d%\u0026#34;, \u0026amp;n); 4 5 int sa = 0, sb = 0; 6 for(int i=0; i\u0026lt;n; i++) 7 { 8 int a, b, c, d; 9 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d); 10 if(b == d) continue; 11 if(b == a + c) sb++; 12 if(d == a + c) sa++; 13 } 14 printf(\u0026#34;%d %d\\n\u0026#34;, sa, sb); 15 return 0; 16} ","permalink":"https://blog.lordash.de/posts/solution/patb-1046-%E5%88%92%E6%8B%B3/","summary":"åˆ’æ‹³ (PATB-1046) é¢˜é¢ åˆ’æ‹³æ˜¯å¤è€ä¸­å›½é…’æ–‡åŒ–çš„ä¸€ä¸ªæœ‰è¶£çš„ç»„æˆéƒ¨åˆ†ã€‚é…’æ¡Œä¸Šä¸¤äººåˆ’æ‹³çš„æ–¹æ³•ä¸ºï¼šæ¯äººå£ä¸­å–Šå‡ºä¸€ä¸ªæ•°å­—ï¼ŒåŒæ—¶ç”¨æ‰‹æ¯”åˆ’å‡ºä¸€ä¸ªæ•°å­—ã€‚å¦‚æœè°æ¯”åˆ’å‡ºçš„æ•°å­—","title":"PATB-1046 åˆ’æ‹³"},{"content":"å¿«é€Ÿæ’åº (PATB-1045) é¢˜é¢ è‘—åçš„å¿«é€Ÿæ’åºç®—æ³•é‡Œæœ‰ä¸€ä¸ªç»å…¸çš„åˆ’åˆ†è¿‡ç¨‹ï¼šæˆ‘ä»¬é€šå¸¸é‡‡ç”¨æŸç§æ–¹æ³•å–ä¸€ä¸ªå…ƒç´ ä½œä¸ºä¸»å…ƒï¼Œé€šè¿‡äº¤æ¢ï¼ŒæŠŠæ¯”ä¸»å…ƒå°çš„å…ƒç´ æ”¾åˆ°å®ƒçš„å·¦è¾¹ï¼Œæ¯”ä¸»å…ƒå¤§çš„å…ƒç´ æ”¾åˆ°å®ƒçš„å³è¾¹ã€‚ ç»™å®šåˆ’åˆ†åçš„ N ä¸ªäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°çš„æ’åˆ—ï¼Œè¯·é—®æœ‰å¤šå°‘ä¸ªå…ƒç´ å¯èƒ½æ˜¯åˆ’åˆ†å‰é€‰å–çš„ä¸»å…ƒï¼Ÿ\nä¾‹å¦‚ç»™å®š $N = 5$, æ’åˆ—æ˜¯1ã€3ã€2ã€4ã€5ã€‚åˆ™ï¼š\n1 çš„å·¦è¾¹æ²¡æœ‰å…ƒç´ ï¼Œå³è¾¹çš„å…ƒç´ éƒ½æ¯”å®ƒå¤§ï¼Œæ‰€ä»¥å®ƒå¯èƒ½æ˜¯ä¸»å…ƒï¼› å°½ç®¡ 3 çš„å·¦è¾¹å…ƒç´ éƒ½æ¯”å®ƒå°ï¼Œä½†å…¶å³è¾¹çš„ 2 æ¯”å®ƒå°ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ˜¯ä¸»å…ƒï¼› å°½ç®¡ 2 çš„å³è¾¹å…ƒç´ éƒ½æ¯”å®ƒå¤§ï¼Œä½†å…¶å·¦è¾¹çš„ 3 æ¯”å®ƒå¤§ï¼Œæ‰€ä»¥å®ƒä¸èƒ½æ˜¯ä¸»å…ƒï¼› ç±»ä¼¼åŸå› ï¼Œ4 å’Œ 5 éƒ½å¯èƒ½æ˜¯ä¸»å…ƒã€‚ å› æ­¤ï¼Œæœ‰ 3 ä¸ªå…ƒç´ å¯èƒ½æ˜¯ä¸»å…ƒã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ 1 è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤105ï¼‰ï¼› ç¬¬ 2 è¡Œæ˜¯ç©ºæ ¼åˆ†éš”çš„ N ä¸ªä¸åŒçš„æ­£æ•´æ•°ï¼Œæ¯ä¸ªæ•°ä¸è¶…è¿‡ 10^9ã€‚\nè¾“å‡º åœ¨ç¬¬ 1 è¡Œä¸­è¾“å‡ºæœ‰å¯èƒ½æ˜¯ä¸»å…ƒçš„å…ƒç´ ä¸ªæ•°ï¼›åœ¨ç¬¬ 2 è¡Œä¸­æŒ‰é€’å¢é¡ºåºè¾“å‡ºè¿™äº›å…ƒç´ ï¼Œå…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 15 21 3 2 4 5 æ ·ä¾‹è¾“å‡º 13 21 4 5 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn], b[mxn]; 3int ans[mxn]; 4 5int main() 6{ 7 int n; scanf(\u0026#34;%d%\u0026#34;, \u0026amp;n); 8 9 for(int i=0; i\u0026lt;n; i++) 10 { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 12 b[i] = a[i]; 13 } 14 sort(b, b+n); 15 16 int mx = 0, num = 0; 17 for(int i=0; i\u0026lt;n; i++) 18 { 19 if(a[i]==b[i] \u0026amp;\u0026amp; b[i]\u0026gt;mx) 20 ans[num++] = a[i]; 21 mx = max(mx, a[i]); 22 } 23 printf(\u0026#34;%d\\n\u0026#34;, num); 24 for(int i=0; i\u0026lt;num; i++) 25 { 26 if(i) printf(\u0026#34; \u0026#34;); 27 printf(\u0026#34;%d\u0026#34;, ans[i]); 28 } 29 printf(\u0026#34;\\n\u0026#34;); 30 return 0; 31} ","permalink":"https://blog.lordash.de/posts/solution/patb-1045-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","summary":"å¿«é€Ÿæ’åº (PATB-1045) é¢˜é¢ è‘—åçš„å¿«é€Ÿæ’åºç®—æ³•é‡Œæœ‰ä¸€ä¸ªç»å…¸çš„åˆ’åˆ†è¿‡ç¨‹ï¼šæˆ‘ä»¬é€šå¸¸é‡‡ç”¨æŸç§æ–¹æ³•å–ä¸€ä¸ªå…ƒç´ ä½œä¸ºä¸»å…ƒï¼Œé€šè¿‡äº¤æ¢ï¼ŒæŠŠæ¯”ä¸»å…ƒå°çš„å…ƒç´ æ”¾åˆ°å®ƒçš„å·¦è¾¹ï¼Œæ¯”ä¸»","title":"PATB-1045 å¿«é€Ÿæ’åº"},{"content":"ç«æ˜Ÿæ•°å­— (PATB-1044) é¢˜é¢ ç«æ˜Ÿäººæ˜¯ä»¥ 13 è¿›åˆ¶è®¡æ•°çš„ï¼š\nåœ°çƒäººçš„ 0 è¢«ç«æ˜Ÿäººç§°ä¸º tretã€‚ åœ°çƒäººæ•°å­— 1 åˆ° 12 çš„ç«æ˜Ÿæ–‡åˆ†åˆ«ä¸ºï¼šjan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, decã€‚ ç«æ˜Ÿäººå°†è¿›ä½ä»¥åçš„ 12 ä¸ªé«˜ä½æ•°å­—åˆ†åˆ«ç§°ä¸ºï¼štam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jouã€‚ ä¾‹å¦‚åœ°çƒäººçš„æ•°å­— 29 ç¿»è¯‘æˆç«æ˜Ÿæ–‡å°±æ˜¯ hel marï¼›è€Œç«æ˜Ÿæ–‡ elo nov å¯¹åº”åœ°çƒæ•°å­— 115ã€‚ä¸ºäº†æ–¹ä¾¿äº¤æµï¼Œè¯·ä½ ç¼–å†™ç¨‹åºå®ç°åœ°çƒå’Œç«æ˜Ÿæ•°å­—ä¹‹é—´çš„äº’è¯‘ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆ\u0026lt;100ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ª [0, 169) åŒºé—´å†…çš„æ•°å­— â€”â€” æˆ–è€…æ˜¯åœ°çƒæ–‡ï¼Œæˆ–è€…æ˜¯ç«æ˜Ÿæ–‡ã€‚\nè¾“å‡º å¯¹åº”è¾“å…¥çš„æ¯ä¸€è¡Œï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºç¿»è¯‘åçš„å¦ä¸€ç§è¯­è¨€çš„æ•°å­—ã€‚\næ ·ä¾‹è¾“å…¥ 14 229 35 4elo nov 5tam æ ·ä¾‹è¾“å‡º 1hel mar 2may 3115 413 æç¤º æ— \næ€è·¯ ä»£ç  1char a[][5] = { 2 \u0026#34;tret\u0026#34;, \u0026#34;jan\u0026#34;, \u0026#34;feb\u0026#34;, \u0026#34;mar\u0026#34;, \u0026#34;apr\u0026#34;, \u0026#34;may\u0026#34;, \u0026#34;jun\u0026#34;, 3 \u0026#34;jly\u0026#34;, \u0026#34;aug\u0026#34;, \u0026#34;sep\u0026#34;, \u0026#34;oct\u0026#34;, \u0026#34;nov\u0026#34;, \u0026#34;dec\u0026#34; 4}; 5char b[][5] = { 6 \u0026#34; \u0026#34;, \u0026#34;tam\u0026#34;, \u0026#34;hel\u0026#34;, \u0026#34;maa\u0026#34;, \u0026#34;huh\u0026#34;, \u0026#34;tou\u0026#34;, \u0026#34;kes\u0026#34;, 7 \u0026#34;hei\u0026#34;, \u0026#34;elo\u0026#34;, \u0026#34;syy\u0026#34;, \u0026#34;lok\u0026#34;, \u0026#34;mer\u0026#34;, \u0026#34;jou\u0026#34; 8}; 9char s[100]; 10 11int main() 12{ 13 int n; scanf(\u0026#34;%d%*c\u0026#34;, \u0026amp;n); 14 while(n--) 15 { 16 fgets(s, 100, stdin); 17 if(isdigit(s[0])) 18 { 19 int t = 0; sscanf(s, \u0026#34;%d\u0026#34;, \u0026amp;t); 20 if(t/13) printf(\u0026#34;%s\u0026#34;, b[t/13]); 21 if(t/13 \u0026amp;\u0026amp; t%13) printf(\u0026#34; \u0026#34;); 22 if(t%13 || t==0) printf(\u0026#34;%s\u0026#34;, a[t%13]); 23 printf(\u0026#34;\\n\u0026#34;); continue; 24 } 25 26 char t1[10], t2[10]; 27 int ans = 0; 28 if(strlen(s) \u0026gt; 5) 29 sscanf(s, \u0026#34;%s %s\u0026#34;, t1, t2); 30 else{ 31 sscanf(s, \u0026#34;%s\u0026#34;, t1); strcpy(t2, t1); 32 } 33 34 for(int i=0; i\u0026lt;13; i++) 35 { 36 if(strcmp(a[i], t2) == 0) 37 ans += i; 38 if(strcmp(b[i], t1) == 0) 39 ans += i * 13; 40 } 41 printf(\u0026#34;%d\\n\u0026#34;, ans); 42 } 43 44 return 0; 45} ","permalink":"https://blog.lordash.de/posts/solution/patb-1044-%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97/","summary":"ç«æ˜Ÿæ•°å­— (PATB-1044) é¢˜é¢ ç«æ˜Ÿäººæ˜¯ä»¥ 13 è¿›åˆ¶è®¡æ•°çš„ï¼š åœ°çƒäººçš„ 0 è¢«ç«æ˜Ÿäººç§°ä¸º tretã€‚ åœ°çƒäººæ•°å­— 1 åˆ° 12 çš„ç«æ˜Ÿæ–‡åˆ†åˆ«ä¸ºï¼šjan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, decã€‚ ç«","title":"PATB-1044 ç«æ˜Ÿæ•°å­—"},{"content":"è¾“å‡ºPATest (PATB-1043) é¢˜é¢ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ 10^4 çš„ã€ä»…ç”±è‹±æ–‡å­—æ¯æ„æˆçš„å­—ç¬¦ä¸²ã€‚è¯·å°†å­—ç¬¦é‡æ–°è°ƒæ•´é¡ºåºï¼ŒæŒ‰ PATestPATest.... è¿™æ ·çš„é¡ºåºè¾“å‡ºï¼Œå¹¶å¿½ç•¥å…¶å®ƒå­—ç¬¦ã€‚å½“ç„¶ï¼Œå…­ç§å­—ç¬¦çš„ä¸ªæ•°ä¸ä¸€å®šæ˜¯ä¸€æ ·å¤šçš„ï¼Œè‹¥æŸç§å­—ç¬¦å·²ç»è¾“å‡ºå®Œï¼Œåˆ™ä½™ä¸‹çš„å­—ç¬¦ä»æŒ‰ PATest çš„é¡ºåºæ‰“å°ï¼Œç›´åˆ°æ‰€æœ‰å­—ç¬¦éƒ½è¢«è¾“å‡ºã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ 10^4 çš„ã€ä»…ç”±è‹±æ–‡å­—æ¯æ„æˆçš„éç©ºå­—ç¬¦ä¸²ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­æŒ‰é¢˜ç›®è¦æ±‚è¾“å‡ºæ’åºåçš„å­—ç¬¦ä¸²ã€‚é¢˜ç›®ä¿è¯è¾“å‡ºéç©ºã€‚\næ ·ä¾‹è¾“å…¥ 1redlesPayBestPATTopTeePHPereatitAPPT æ ·ä¾‹è¾“å‡º 1PATestPATestPTetPTePePee æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[]=\u0026#34;PATest\u0026#34;; 3int a[7]; 4 5int main() 6{ 7 scanf(\u0026#34;%s\u0026#34;, s); 8 int sl = strlen(s); 9 10 for(int i=0; i\u0026lt;sl; i++) 11 { 12 if(strchr(t, s[i]) != NULL) 13 a[strchr(t, s[i])-t]++; 14 } 15 16 int sum = 0; 17 for(int i=0; i\u0026lt;6; i++) 18 sum += a[i]; 19 20 while(sum) 21 { 22 for(int i=0; i\u0026lt;6; i++) 23 { 24 if(a[i]){ 25 printf(\u0026#34;%c\u0026#34;, t[i]); 26 a[i]--; sum--; 27 } 28 } 29 } 30 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1043-%E8%BE%93%E5%87%BApatest/","summary":"è¾“å‡ºPATest (PATB-1043) é¢˜é¢ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ 10^4 çš„ã€ä»…ç”±è‹±æ–‡å­—æ¯æ„æˆçš„å­—ç¬¦ä¸²ã€‚è¯·å°†å­—ç¬¦é‡æ–°è°ƒæ•´é¡ºåºï¼ŒæŒ‰ PATestPATest.... è¿™æ ·çš„é¡ºåºè¾“å‡ºï¼Œå¹¶å¿½ç•¥å…¶å®ƒå­—ç¬¦ã€‚å½“ç„¶ï¼Œå…­ç§","title":"PATB-1043 è¾“å‡ºPATest"},{"content":"å­—ç¬¦ç»Ÿè®¡ (PATB-1042) é¢˜é¢ è¯·ç¼–å†™ç¨‹åºï¼Œæ‰¾å‡ºä¸€æ®µç»™å®šæ–‡å­—ä¸­å‡ºç°æœ€é¢‘ç¹çš„é‚£ä¸ªè‹±æ–‡å­—æ¯ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ 1000 çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²ç”± ASCII ç è¡¨ä¸­ä»»æ„å¯è§å­—ç¬¦åŠç©ºæ ¼ç»„æˆï¼Œè‡³å°‘åŒ…å« 1 ä¸ªè‹±æ–‡å­—æ¯ï¼Œä»¥å›è½¦ç»“æŸï¼ˆå›è½¦ä¸ç®—åœ¨å†…ï¼‰ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºå‡ºç°é¢‘ç‡æœ€é«˜çš„é‚£ä¸ªè‹±æ–‡å­—æ¯åŠå…¶å‡ºç°æ¬¡æ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚å¦‚æœæœ‰å¹¶åˆ—ï¼Œåˆ™è¾“å‡ºæŒ‰å­—æ¯åºæœ€å°çš„é‚£ä¸ªå­—æ¯ã€‚ç»Ÿè®¡æ—¶ä¸åŒºåˆ†å¤§å°å†™ï¼Œè¾“å‡ºå°å†™å­—æ¯ã€‚\næ ·ä¾‹è¾“å…¥ 1This is a simple TEST. There ARE numbers and other symbols 1\u0026amp;2\u0026amp;3........... æ ·ä¾‹è¾“å‡º 1e 7 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn]; 3int t[26]; 4 5int main() 6{ 7 fgets(s, mxn, stdin); 8 int sl = strlen(s); 9 10 for(int i=0; i\u0026lt;sl; i++) 11 { 12 if(isalpha(s[i])) 13 { 14 if(isupper(s[i])) 15 s[i] = tolower(s[i]); 16 t[s[i]-\u0026#39;a\u0026#39;]++; 17 } 18 } 19 int mx = 0, id = 0; 20 for(int i=0; i\u0026lt;26; i++) 21 { 22 if(mx \u0026lt; t[i]) 23 { 24 mx = t[i]; 25 id = i; 26 } 27 } 28 printf(\u0026#34;%c %d\\n\u0026#34;, id+\u0026#39;a\u0026#39;, mx); 29 30 return 0; 31} ","permalink":"https://blog.lordash.de/posts/solution/patb-1042-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1/","summary":"å­—ç¬¦ç»Ÿè®¡ (PATB-1042) é¢˜é¢ è¯·ç¼–å†™ç¨‹åºï¼Œæ‰¾å‡ºä¸€æ®µç»™å®šæ–‡å­—ä¸­å‡ºç°æœ€é¢‘ç¹çš„é‚£ä¸ªè‹±æ–‡å­—æ¯ã€‚ è¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡ 1000 çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²ç”± ASCII ç è¡¨ä¸­ä»»æ„å¯è§","title":"PATB-1042 å­—ç¬¦ç»Ÿè®¡"},{"content":"è€ƒè¯•åº§ä½å· (PATB-1041) é¢˜é¢ æ¯ä¸ª PAT è€ƒç”Ÿåœ¨å‚åŠ è€ƒè¯•æ—¶éƒ½ä¼šè¢«åˆ†é…ä¸¤ä¸ªåº§ä½å·ï¼Œä¸€ä¸ªæ˜¯è¯•æœºåº§ä½ï¼Œä¸€ä¸ªæ˜¯è€ƒè¯•åº§ä½ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œè€ƒç”Ÿåœ¨å…¥åœºæ—¶å…ˆå¾—åˆ°è¯•æœºåº§ä½å·ç ï¼Œå…¥åº§è¿›å…¥è¯•æœºçŠ¶æ€åï¼Œç³»ç»Ÿä¼šæ˜¾ç¤ºè¯¥è€ƒç”Ÿçš„è€ƒè¯•åº§ä½å·ç ï¼Œè€ƒè¯•æ—¶è€ƒç”Ÿéœ€è¦æ¢åˆ°è€ƒè¯•åº§ä½å°±åº§ã€‚ä½†æœ‰äº›è€ƒç”Ÿè¿Ÿåˆ°äº†ï¼Œè¯•æœºå·²ç»ç»“æŸï¼Œä»–ä»¬åªèƒ½æ‹¿ç€é¢†åˆ°çš„è¯•æœºåº§ä½å·ç æ±‚åŠ©äºä½ ï¼Œä»åå°æŸ¥å‡ºä»–ä»¬çš„è€ƒè¯•åº§ä½å·ç ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤1000ï¼‰ï¼Œéšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªè€ƒç”Ÿçš„ä¿¡æ¯ï¼šå‡†è€ƒè¯å· è¯•æœºåº§ä½å· è€ƒè¯•åº§ä½å·ã€‚å…¶ä¸­å‡†è€ƒè¯å·ç”± 16 ä½æ•°å­—ç»„æˆï¼Œåº§ä½ä» 1 åˆ° N ç¼–å·ã€‚è¾“å…¥ä¿è¯æ¯ä¸ªäººçš„å‡†è€ƒè¯å·éƒ½ä¸åŒï¼Œå¹¶ä¸”ä»»ä½•æ—¶å€™éƒ½ä¸ä¼šæŠŠä¸¤ä¸ªäººåˆ†é…åˆ°åŒä¸€ä¸ªåº§ä½ä¸Šã€‚\nè€ƒç”Ÿä¿¡æ¯ä¹‹åï¼Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Mï¼ˆâ‰¤Nï¼‰ï¼Œéšåä¸€è¡Œä¸­ç»™å‡º M ä¸ªå¾…æŸ¥è¯¢çš„è¯•æœºåº§ä½å·ç ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹åº”æ¯ä¸ªéœ€è¦æŸ¥è¯¢çš„è¯•æœºåº§ä½å·ç ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºå¯¹åº”è€ƒç”Ÿçš„å‡†è€ƒè¯å·å’Œè€ƒè¯•åº§ä½å·ç ï¼Œä¸­é—´ç”¨ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥ 14 23310120150912233 2 4 33310120150912119 4 1 43310120150912126 1 3 53310120150912002 3 2 62 73 4 æ ·ä¾‹è¾“å‡º 13310120150912002 2 23310120150912119 1 æç¤º æ— \næ€è·¯ ä»£ç  1struct P{ 2 char s[20]; 3 int t; 4}; 5 6int main() 7{ 8 int n, m; 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 10 11 map\u0026lt;int, P\u0026gt; mmp; 12 for(int i=0; i\u0026lt;n; i++) 13 { 14 int x; P y; 15 scanf(\u0026#34;%s %d %d\u0026#34;, y.s, \u0026amp;x, \u0026amp;y.t); 16 mmp[x] = y; 17 } 18 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 19 for(int i=0; i\u0026lt;m; i++) 20 { 21 int x; scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 22 printf(\u0026#34;%s %d\\n\u0026#34;, mmp[x].s, mmp[x].t); 23 } 24 25 return 0; 26} ","permalink":"https://blog.lordash.de/posts/solution/patb-1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/","summary":"è€ƒè¯•åº§ä½å· (PATB-1041) é¢˜é¢ æ¯ä¸ª PAT è€ƒç”Ÿåœ¨å‚åŠ è€ƒè¯•æ—¶éƒ½ä¼šè¢«åˆ†é…ä¸¤ä¸ªåº§ä½å·ï¼Œä¸€ä¸ªæ˜¯è¯•æœºåº§ä½ï¼Œä¸€ä¸ªæ˜¯è€ƒè¯•åº§ä½ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œè€ƒç”Ÿåœ¨å…¥åœºæ—¶å…ˆå¾—åˆ°è¯•æœºåº§ä½å·ç ï¼Œå…¥åº§","title":"PATB-1041 è€ƒè¯•åº§ä½å·"},{"content":"æœ‰å‡ ä¸ªPAT (PATB-1040) é¢˜é¢ å­—ç¬¦ä¸² APPAPT ä¸­åŒ…å«äº†ä¸¤ä¸ªå•è¯ PATï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ª PAT æ˜¯ç¬¬ 2 ä½(P)ï¼Œç¬¬ 4 ä½(A)ï¼Œç¬¬ 6 ä½(T)ï¼›ç¬¬äºŒä¸ª PAT æ˜¯ç¬¬ 3 ä½(P)ï¼Œç¬¬ 4 ä½(A)ï¼Œç¬¬ 6 ä½(T)ã€‚\nç°ç»™å®šå­—ç¬¦ä¸²ï¼Œé—®ä¸€å…±å¯ä»¥å½¢æˆå¤šå°‘ä¸ª PATï¼Ÿ\nè¾“å…¥ è¾“å…¥åªæœ‰ä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé•¿åº¦ä¸è¶…è¿‡105ï¼ŒåªåŒ…å« Pã€Aã€T ä¸‰ç§å­—æ¯ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºç»™å®šå­—ç¬¦ä¸²ä¸­åŒ…å«å¤šå°‘ä¸ª PATã€‚ç”±äºç»“æœå¯èƒ½æ¯”è¾ƒå¤§ï¼Œåªè¾“å‡ºå¯¹ 1000000007 å–ä½™æ•°çš„ç»“æœã€‚\næ ·ä¾‹è¾“å…¥ 1APPAPT æ ·ä¾‹è¾“å‡º 12 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn]; 3 4int main() 5{ 6 scanf(\u0026#34;%s\u0026#34;, s); 7 int sl = strlen(s); 8 9 LL p=0, a=0, t=0, mod=1000000007; 10 for(int i=0; i\u0026lt;sl; i++) 11 { 12 if(s[i]==\u0026#39;P\u0026#39;) 13 p++; 14 else if(s[i]==\u0026#39;A\u0026#39;) 15 a += p; 16 else if(s[i]==\u0026#39;T\u0026#39;) 17 t += a; 18 } 19 printf(\u0026#34;%d\\n\u0026#34;, t%mod); 20 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1040-%E6%9C%89%E5%87%A0%E4%B8%AApat/","summary":"æœ‰å‡ ä¸ªPAT (PATB-1040) é¢˜é¢ å­—ç¬¦ä¸² APPAPT ä¸­åŒ…å«äº†ä¸¤ä¸ªå•è¯ PATï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ª PAT æ˜¯ç¬¬ 2 ä½(P)ï¼Œç¬¬ 4 ä½(A)ï¼Œç¬¬ 6 ä½(T)ï¼›ç¬¬äºŒä¸ª PAT æ˜¯ç¬¬ 3 ä½(P)ï¼Œç¬¬ 4 ä½(A","title":"PATB-1040 æœ‰å‡ ä¸ªPAT"},{"content":"åˆ°åº•ä¹°ä¸ä¹° (PATB-1039) é¢˜é¢ å°çº¢æƒ³ä¹°äº›ç å­åšä¸€ä¸²è‡ªå·±å–œæ¬¢çš„ç ä¸²ã€‚å–ç å­çš„æ‘Šä¸»æœ‰å¾ˆå¤šä¸²äº”é¢œå…­è‰²çš„ç ä¸²ï¼Œä½†æ˜¯ä¸è‚¯æŠŠä»»ä½•ä¸€ä¸²æ‹†æ•£äº†å–ã€‚äºæ˜¯å°çº¢è¦ä½ å¸®å¿™åˆ¤æ–­ä¸€ä¸‹ï¼ŒæŸä¸²ç å­é‡Œæ˜¯å¦åŒ…å«äº†å…¨éƒ¨è‡ªå·±æƒ³è¦çš„ç å­ï¼Ÿå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆå‘Šè¯‰å¥¹æœ‰å¤šå°‘å¤šä½™çš„ç å­ï¼›å¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆå‘Šè¯‰å¥¹ç¼ºäº†å¤šå°‘ç å­ã€‚\nä¸ºæ–¹ä¾¿èµ·è§ï¼Œæˆ‘ä»¬ç”¨[0-9]ã€[a-z]ã€[A-Z]èŒƒå›´å†…çš„å­—ç¬¦æ¥è¡¨ç¤ºé¢œè‰²ã€‚ä¾‹å¦‚åœ¨å›¾1ä¸­ï¼Œç¬¬3ä¸²æ˜¯å°çº¢æƒ³åšçš„ç ä¸²ï¼›é‚£ä¹ˆç¬¬1ä¸²å¯ä»¥ä¹°ï¼Œå› ä¸ºåŒ…å«äº†å…¨éƒ¨å¥¹æƒ³è¦çš„ç å­ï¼Œè¿˜å¤šäº†8é¢—ä¸éœ€è¦çš„ç å­ï¼›ç¬¬2ä¸²ä¸èƒ½ä¹°ï¼Œå› ä¸ºæ²¡æœ‰é»‘è‰²ç å­ï¼Œå¹¶ä¸”å°‘äº†ä¸€é¢—çº¢è‰²çš„ç å­ã€‚\nå›¾ 1\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹åˆ†åˆ«åœ¨ 2 è¡Œä¸­å…ˆåç»™å‡ºæ‘Šä¸»çš„ç ä¸²å’Œå°çº¢æƒ³åšçš„ç ä¸²ï¼Œä¸¤ä¸²éƒ½ä¸è¶…è¿‡ 1000 ä¸ªç å­ã€‚\nè¾“å‡º å¦‚æœå¯ä»¥ä¹°ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º Yes ä»¥åŠæœ‰å¤šå°‘å¤šä½™çš„ç å­ï¼›å¦‚æœä¸å¯ä»¥ä¹°ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡º No ä»¥åŠç¼ºäº†å¤šå°‘ç å­ã€‚å…¶é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥1 1ppRYYGrrYBR2258 2YrR8RrY æ ·ä¾‹è¾“å‡º1 1Yes 8 æ ·ä¾‹è¾“å…¥2 1ppRYYGrrYB225 2YrR8RrY æ ·ä¾‹è¾“å‡º2 1No 2 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[mxn]; 3int a[mxn], b[mxn]; 4 5int main() 6{ 7 scanf(\u0026#34;%s %s\u0026#34;, s, t); 8 int sl = strlen(s), tl = strlen(t); 9 10 for(int i=0; i\u0026lt;sl; i++) 11 a[s[i]]++; 12 for(int i=0; i\u0026lt;tl; i++) 13 b[t[i]]++; 14 15 int sa = 0, sb = 0; 16 for(int i=1; i\u0026lt;=256; i++) 17 { 18 sa += a[i]-b[i] \u0026gt; 0 ? a[i]-b[i] : 0; 19 sb += b[i]-a[i] \u0026gt; 0 ? b[i]-a[i] : 0; 20 } 21 if(sb) 22 printf(\u0026#34;No %d\\n\u0026#34;, sb); 23 else 24 printf(\u0026#34;Yes %d\\n\u0026#34;, sa); 25 26 return 0; 27} ","permalink":"https://blog.lordash.de/posts/solution/patb-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0/","summary":"åˆ°åº•ä¹°ä¸ä¹° (PATB-1039) é¢˜é¢ å°çº¢æƒ³ä¹°äº›ç å­åšä¸€ä¸²è‡ªå·±å–œæ¬¢çš„ç ä¸²ã€‚å–ç å­çš„æ‘Šä¸»æœ‰å¾ˆå¤šä¸²äº”é¢œå…­è‰²çš„ç ä¸²ï¼Œä½†æ˜¯ä¸è‚¯æŠŠä»»ä½•ä¸€ä¸²æ‹†æ•£äº†å–ã€‚äºæ˜¯å°çº¢è¦ä½ å¸®å¿™åˆ¤æ–­ä¸€ä¸‹","title":"PATB-1039 åˆ°åº•ä¹°ä¸ä¹°"},{"content":"ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿ (PATB-1038) é¢˜é¢ æœ¬é¢˜è¦æ±‚è¯»å…¥ N åå­¦ç”Ÿçš„æˆç»©ï¼Œå°†è·å¾—æŸä¸€ç»™å®šåˆ†æ•°çš„å­¦ç”Ÿäººæ•°è¾“å‡ºã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ 1 è¡Œç»™å‡ºä¸è¶…è¿‡ 10^5 çš„æ­£æ•´æ•° Nï¼Œå³å­¦ç”Ÿæ€»äººæ•°ã€‚éšåä¸€è¡Œç»™å‡º N åå­¦ç”Ÿçš„ç™¾åˆ†åˆ¶æ•´æ•°æˆç»©ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æœ€åä¸€è¡Œç»™å‡ºè¦æŸ¥è¯¢çš„åˆ†æ•°ä¸ªæ•° Kï¼ˆä¸è¶…è¿‡ N çš„æ­£æ•´æ•°ï¼‰ï¼Œéšåæ˜¯ K ä¸ªåˆ†æ•°ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­æŒ‰æŸ¥è¯¢é¡ºåºç»™å‡ºå¾—åˆ†ç­‰äºæŒ‡å®šåˆ†æ•°çš„å­¦ç”Ÿäººæ•°ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 110 260 75 90 55 75 99 82 90 75 50 33 75 90 88 æ ·ä¾‹è¾“å‡º 13 2 0 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn], b[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 for(int i=0; i\u0026lt;n; i++) 9 { 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 11 b[a[i]]++; 12 } 13 14 int k, t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;k); 15 for(int i=0; i\u0026lt;k; i++){ 16 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 17 if(i) printf(\u0026#34; \u0026#34;); 18 printf(\u0026#34;%d\u0026#34;, b[t]); 19 } 20 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F/","summary":"ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿ (PATB-1038) é¢˜é¢ æœ¬é¢˜è¦æ±‚è¯»å…¥ N åå­¦ç”Ÿçš„æˆç»©ï¼Œå°†è·å¾—æŸä¸€ç»™å®šåˆ†æ•°çš„å­¦ç”Ÿäººæ•°è¾“å‡ºã€‚ è¾“å…¥ è¾“å…¥åœ¨ç¬¬ 1 è¡Œç»™å‡ºä¸è¶…è¿‡ 10^5 çš„æ­£æ•´æ•° Nï¼Œå³å­¦ç”Ÿæ€»äººæ•°ã€‚éšå","title":"PATB-1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿ"},{"content":"åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’± (PATB-1037) é¢˜é¢ å¦‚æœä½ æ˜¯å“ˆåˆ©Â·æ³¢ç‰¹è¿·ï¼Œä½ ä¼šçŸ¥é“é­”æ³•ä¸–ç•Œæœ‰å®ƒè‡ªå·±çš„è´§å¸ç³»ç»Ÿ â€”â€” å°±å¦‚æµ·æ ¼å‘Šè¯‰å“ˆåˆ©çš„ï¼šâ€œåä¸ƒä¸ªé“¶è¥¿å¯(Sickle)å…‘ä¸€ä¸ªåŠ éš†(Galleon)ï¼ŒäºŒåä¹ä¸ªçº³ç‰¹(Knut)å…‘ä¸€ä¸ªè¥¿å¯ï¼Œå¾ˆå®¹æ˜“ã€‚â€ç°åœ¨ï¼Œç»™å®šå“ˆåˆ©åº”ä»˜çš„ä»·é’± P å’Œä»–å®ä»˜çš„é’± Aï¼Œä½ çš„ä»»åŠ¡æ˜¯å†™ä¸€ä¸ªç¨‹åºæ¥è®¡ç®—ä»–åº”è¯¥è¢«æ‰¾çš„é›¶é’±ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ 1 è¡Œä¸­åˆ†åˆ«ç»™å‡º P å’Œ Aï¼Œæ ¼å¼ä¸º Galleon.Sickle.Knutï¼Œå…¶é—´ç”¨ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚è¿™é‡Œ Galleon æ˜¯ [0, 107] åŒºé—´å†…çš„æ•´æ•°ï¼ŒSickle æ˜¯ [0, 17) åŒºé—´å†…çš„æ•´æ•°ï¼ŒKnut æ˜¯ [0, 29) åŒºé—´å†…çš„æ•´æ•°ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­ç”¨ä¸è¾“å…¥åŒæ ·çš„æ ¼å¼è¾“å‡ºå“ˆåˆ©åº”è¯¥è¢«æ‰¾çš„é›¶é’±ã€‚å¦‚æœä»–æ²¡å¸¦å¤Ÿé’±ï¼Œé‚£ä¹ˆè¾“å‡ºçš„åº”è¯¥æ˜¯è´Ÿæ•°ã€‚\næ ·ä¾‹è¾“å…¥1 110.16.27 14.1.28 æ ·ä¾‹è¾“å‡º1 13.2.1 æ ·ä¾‹è¾“å…¥2 114.1.28 10.16.27 æ ·ä¾‹è¾“å‡º2 1-3.2.1 æç¤º æ— \næ€è·¯ ä»£ç  1#define Sg(u) ((u) \u0026gt; eps ? 1 : ((u) \u0026lt; -eps ? -1 : 0)) 2#define Abs(u) (Sg(u) \u0026gt;= 0 ? (u) : -(u)) 3 4int main() 5{ 6 LL ag, as, ak, bg, bs, bk; 7 scanf(\u0026#34;%lld.%lld.%lld\u0026#34;, \u0026amp;ag, \u0026amp;as, \u0026amp;ak); 8 scanf(\u0026#34;%lld.%lld.%lld\u0026#34;, \u0026amp;bg, \u0026amp;bs, \u0026amp;bk); 9 10 LL a = ag * 493 + as * 29 + ak; 11 LL b = bg * 493 + bs * 29 + bk; 12 LL c = Abs(b - a); 13 14 if(Sg(b - a) \u0026lt; 0) printf(\u0026#34;-\u0026#34;); 15 printf(\u0026#34;%lld.%lld.%lld\\n\u0026#34;, c/493, c/29%17, c%29); 16 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/patb-1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1/","summary":"åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’± (PATB-1037) é¢˜é¢ å¦‚æœä½ æ˜¯å“ˆåˆ©Â·æ³¢ç‰¹è¿·ï¼Œä½ ä¼šçŸ¥é“é­”æ³•ä¸–ç•Œæœ‰å®ƒè‡ªå·±çš„è´§å¸ç³»ç»Ÿ â€”â€” å°±å¦‚æµ·æ ¼å‘Šè¯‰å“ˆåˆ©çš„ï¼šâ€œåä¸ƒä¸ªé“¶è¥¿å¯(Sickle)å…‘ä¸€ä¸ªåŠ ","title":"PATB-1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’±"},{"content":"è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹ (PATB-1036) é¢˜é¢ ç¾å›½æ€»ç»Ÿå¥¥å·´é©¬ä¸ä»…å‘¼åæ‰€æœ‰äººéƒ½å­¦ä¹ ç¼–ç¨‹ï¼Œç”šè‡³ä»¥èº«ä½œåˆ™ç¼–å†™ä»£ç ï¼Œæˆä¸ºç¾å›½å†å²ä¸Šé¦–ä½ç¼–å†™è®¡ç®—æœºä»£ç çš„æ€»ç»Ÿã€‚2014 å¹´åº•ï¼Œä¸ºåº†ç¥â€œè®¡ç®—æœºç§‘å­¦æ•™è‚²å‘¨â€æ­£å¼å¯åŠ¨ï¼Œå¥¥å·´é©¬ç¼–å†™äº†å¾ˆç®€å•çš„è®¡ç®—æœºä»£ç ï¼šåœ¨å±å¹•ä¸Šç”»ä¸€ä¸ªæ­£æ–¹å½¢ã€‚ç°åœ¨ä½ ä¹Ÿè·Ÿä»–ä¸€èµ·ç”»å§ï¼\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ­£æ–¹å½¢è¾¹é•¿ Nï¼ˆ3â‰¤Nâ‰¤20ï¼‰å’Œç»„æˆæ­£æ–¹å½¢è¾¹çš„æŸç§å­—ç¬¦ Cï¼Œé—´éš”ä¸€ä¸ªç©ºæ ¼ã€‚\nè¾“å‡º è¾“å‡ºç”±ç»™å®šå­—ç¬¦ C ç”»å‡ºçš„æ­£æ–¹å½¢ã€‚ä½†æ˜¯æ³¨æ„åˆ°è¡Œé—´è·æ¯”åˆ—é—´è·å¤§ï¼Œæ‰€ä»¥ä¸ºäº†è®©ç»“æœçœ‹ä¸Šå»æ›´åƒæ­£æ–¹å½¢ï¼Œæˆ‘ä»¬è¾“å‡ºçš„è¡Œæ•°å®é™…ä¸Šæ˜¯åˆ—æ•°çš„ 50%ï¼ˆå››èˆäº”å…¥å–æ•´ï¼‰ã€‚\næ ·ä¾‹è¾“å…¥ 110 a æ ·ä¾‹è¾“å‡º 1aaaaaaaaaa 2a a 3a a 4a a 5aaaaaaaaaa æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; char c; 4 scanf(\u0026#34;%d %c\u0026#34;, \u0026amp;n, \u0026amp;c); 5 int m = round(n*0.5); 6 7 for(int i=0; i\u0026lt;m; i++) 8 { 9 for(int j=0; j\u0026lt;n; j++) 10 { 11 if(i==0 || i==m-1) 12 printf(\u0026#34;%c\u0026#34;, c); 13 else if(j==0 || j==n-1) 14 printf(\u0026#34;%c\u0026#34;, c); 15 else 16 printf(\u0026#34; \u0026#34;); 17 } 18 printf(\u0026#34;\\n\u0026#34;); 19 } 20 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B/","summary":"è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹ (PATB-1036) é¢˜é¢ ç¾å›½æ€»ç»Ÿå¥¥å·´é©¬ä¸ä»…å‘¼åæ‰€æœ‰äººéƒ½å­¦ä¹ ç¼–ç¨‹ï¼Œç”šè‡³ä»¥èº«ä½œåˆ™ç¼–å†™ä»£ç ï¼Œæˆä¸ºç¾å›½å†å²ä¸Šé¦–ä½ç¼–å†™è®¡ç®—æœºä»£ç çš„æ€»ç»Ÿã€‚2014 å¹´åº•ï¼Œä¸º","title":"PATB-1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹"},{"content":"æ’å…¥ä¸å½’å¹¶ (PATB-1035) é¢˜é¢ æ ¹æ®ç»´åŸºç™¾ç§‘çš„å®šä¹‰ï¼š\næ’å…¥æ’åºæ˜¯è¿­ä»£ç®—æ³•ï¼Œé€ä¸€è·å¾—è¾“å…¥æ•°æ®ï¼Œé€æ­¥äº§ç”Ÿæœ‰åºçš„è¾“å‡ºåºåˆ—ã€‚æ¯æ­¥è¿­ä»£ä¸­ï¼Œç®—æ³•ä»è¾“å…¥åºåˆ—ä¸­å–å‡ºä¸€å…ƒç´ ï¼Œå°†ä¹‹æ’å…¥æœ‰åºåºåˆ—ä¸­æ­£ç¡®çš„ä½ç½®ã€‚å¦‚æ­¤è¿­ä»£ç›´åˆ°å…¨éƒ¨å…ƒç´ æœ‰åºã€‚\nå½’å¹¶æ’åºè¿›è¡Œå¦‚ä¸‹è¿­ä»£æ“ä½œï¼šé¦–å…ˆå°†åŸå§‹åºåˆ—çœ‹æˆ N ä¸ªåªåŒ…å« 1 ä¸ªå…ƒç´ çš„æœ‰åºå­åºåˆ—ï¼Œç„¶åæ¯æ¬¡è¿­ä»£å½’å¹¶ä¸¤ä¸ªç›¸é‚»çš„æœ‰åºå­åºåˆ—ï¼Œç›´åˆ°æœ€ååªå‰©ä¸‹ 1 ä¸ªæœ‰åºçš„åºåˆ—ã€‚\nç°ç»™å®šåŸå§‹åºåˆ—å’Œç”±æŸæ’åºç®—æ³•äº§ç”Ÿçš„ä¸­é—´åºåˆ—ï¼Œè¯·ä½ åˆ¤æ–­è¯¥ç®—æ³•ç©¶ç«Ÿæ˜¯å“ªç§æ’åºç®—æ³•ï¼Ÿ\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° N (â‰¤100)ï¼›éšåä¸€è¡Œç»™å‡ºåŸå§‹åºåˆ—çš„ N ä¸ªæ•´æ•°ï¼›æœ€åä¸€è¡Œç»™å‡ºç”±æŸæ’åºç®—æ³•äº§ç”Ÿçš„ä¸­é—´åºåˆ—ã€‚è¿™é‡Œå‡è®¾æ’åºçš„ç›®æ ‡åºåˆ—æ˜¯å‡åºã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º é¦–å…ˆåœ¨ç¬¬ 1 è¡Œä¸­è¾“å‡ºInsertion Sortè¡¨ç¤ºæ’å…¥æ’åºã€æˆ–Merge Sortè¡¨ç¤ºå½’å¹¶æ’åºï¼›ç„¶ååœ¨ç¬¬ 2 è¡Œä¸­è¾“å‡ºç”¨è¯¥æ’åºç®—æ³•å†è¿­ä»£ä¸€è½®çš„ç»“æœåºåˆ—ã€‚é¢˜ç›®ä¿è¯æ¯ç»„æµ‹è¯•çš„ç»“æœæ˜¯å”¯ä¸€çš„ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä¸”è¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥1 110 23 1 2 8 7 5 9 4 6 0 31 2 3 7 8 5 9 4 6 0 æ ·ä¾‹è¾“å‡º1 1Insertion Sort 21 2 3 5 7 8 9 4 6 0 æ ·ä¾‹è¾“å…¥2 110 23 1 2 8 7 5 9 4 0 6 31 3 2 8 5 7 4 9 0 6 æ ·ä¾‹è¾“å‡º2 1Merge Sort 21 2 3 8 4 5 7 9 0 6 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn], b[mxn]; 3 4int main() 5{ 6 int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 8 for(int i=0; i\u0026lt;n; i++) 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 for(int i=0; i\u0026lt;n; i++) 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); 12 13 int x = 1, flag = 1; 14 while(x\u0026lt;n \u0026amp; b[x-1]\u0026lt;=b[x]) x++; 15 for(int i=x; i\u0026lt;n; i++) 16 { 17 if(a[i] != b[i]){ 18 flag = 0; 19 break; 20 } 21 } 22 23 if(flag) 24 { 25 printf(\u0026#34;Insertion Sort\\n\u0026#34;); 26 sort(a, a+x+1); 27 for(int i=0; i\u0026lt;n; i++) 28 { 29 if(i) printf(\u0026#34; \u0026#34;); 30 printf(\u0026#34;%d\u0026#34;, a[i]); 31 } 32 return 0; 33 } 34 35 printf(\u0026#34;Merge Sort\\n\u0026#34;); 36 int k = 1; 37 while(1) 38 { 39 flag = 1; 40 for(int i=0; i\u0026lt;n; i++){ 41 if(a[i]!=b[i]){ 42 flag = 0; 43 break; 44 } 45 } 46 k *= 2; 47 for(int i=0; i\u0026lt;n/k; i++) 48 sort(a+i*k, a+i*k+k); 49 sort(a+n/k*k, a+n); 50 51 if(flag) break; 52 } 53 for(int i=0; i\u0026lt;n; i++) 54 { 55 if(i) printf(\u0026#34; \u0026#34;); 56 printf(\u0026#34;%d\u0026#34;, a[i]); 57 } 58 59 return 0; 60} ","permalink":"https://blog.lordash.de/posts/solution/patb-1035-%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6/","summary":"æ’å…¥ä¸å½’å¹¶ (PATB-1035) é¢˜é¢ æ ¹æ®ç»´åŸºç™¾ç§‘çš„å®šä¹‰ï¼š æ’å…¥æ’åºæ˜¯è¿­ä»£ç®—æ³•ï¼Œé€ä¸€è·å¾—è¾“å…¥æ•°æ®ï¼Œé€æ­¥äº§ç”Ÿæœ‰åºçš„è¾“å‡ºåºåˆ—ã€‚æ¯æ­¥è¿­ä»£ä¸­ï¼Œç®—æ³•ä»è¾“å…¥åºåˆ—ä¸­å–å‡ºä¸€å…ƒç´ ï¼Œå°†","title":"PATB-1035 æ’å…¥ä¸å½’å¹¶"},{"content":"æœ‰ç†æ•°å››åˆ™è¿ç®— (PATB-1034) é¢˜é¢ æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®— 2 ä¸ªæœ‰ç†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ a1/b1 a2/b2 çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å‹èŒƒå›´å†…çš„æ•´æ•°ï¼Œè´Ÿå·åªå¯èƒ½å‡ºç°åœ¨åˆ†å­å‰ï¼Œåˆ†æ¯ä¸ä¸º 0ã€‚\nè¾“å‡º åˆ†åˆ«åœ¨ 4 è¡Œä¸­æŒ‰ç…§ æœ‰ç†æ•°1 è¿ç®—ç¬¦ æœ‰ç†æ•°2 = ç»“æœ çš„æ ¼å¼é¡ºåºè¾“å‡º 2 ä¸ªæœ‰ç†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚æ³¨æ„è¾“å‡ºçš„æ¯ä¸ªæœ‰ç†æ•°å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€å½¢å¼ k a/bï¼Œå…¶ä¸­ k æ˜¯æ•´æ•°éƒ¨åˆ†ï¼Œa/b æ˜¯æœ€ç®€åˆ†æ•°éƒ¨åˆ†ï¼›è‹¥ä¸ºè´Ÿæ•°ï¼Œåˆ™é¡»åŠ æ‹¬å·ï¼›è‹¥é™¤æ³•åˆ†æ¯ä¸º 0ï¼Œåˆ™è¾“å‡º Infã€‚é¢˜ç›®ä¿è¯æ­£ç¡®çš„è¾“å‡ºä¸­æ²¡æœ‰è¶…è¿‡æ•´å‹èŒƒå›´çš„æ•´æ•°ã€‚\næ ·ä¾‹è¾“å…¥1 12/3 -4/2 æ ·ä¾‹è¾“å‡º1 12/3 + (-2) = (-1 1/3) 22/3 - (-2) = 2 2/3 32/3 * (-2) = (-1 1/3) 42/3 / (-2) = (-1/3) æ ·ä¾‹è¾“å…¥2 15/3 0/6 æ ·ä¾‹è¾“å‡º2 11 2/3 + 0 = 1 2/3 21 2/3 - 0 = 1 2/3 31 2/3 * 0 = 0 41 2/3 / 0 = Inf æç¤º æ— \næ€è·¯ ä»£ç  1typedef long long LL; 2typedef double DB; 3const DB eps = 1e-8; 4#define Sg(u) ((u) \u0026gt; eps ? 1 : ((u) \u0026lt; -eps ? -1 : 0)) 5#define Abs(u) (Sg(u) \u0026gt;= 0 ? (u) : -(u)) 6 7LL gcd(LL a, LL b) { 8 return b ? gcd(b, a%b) : a; 9} 10 11void print(LL x, LL y) 12{ 13 if(!x || !y){ 14 printf(\u0026#34;%s\u0026#34;, x ? \u0026#34;Inf\u0026#34; : \u0026#34;0\u0026#34;); 15 return; 16 } 17 int flag = Sg(Sg(x)*Sg(y)); 18 x = Abs(x) * flag; 19 y = Abs(y); 20 21 if(flag\u0026lt;0) printf(\u0026#34;(\u0026#34;); 22 if(x/y) 23 printf(\u0026#34;%lld\u0026#34;, x/y); 24 if(x%y) { 25 LL t = Abs(gcd(x, y)); 26 if(x/y){ 27 x = Abs(x%y); 28 printf(\u0026#34; \u0026#34;); 29 } 30 printf(\u0026#34;%lld/%lld\u0026#34;, x/t, y/t); 31 } 32 if(flag\u0026lt;0) printf(\u0026#34;)\u0026#34;); 33} 34 35int main() 36{ 37 LL x1, x2, y1, y2; 38 scanf(\u0026#34;%lld/%lld %lld/%lld\u0026#34;, \u0026amp;x1, \u0026amp;x2, \u0026amp;y1, \u0026amp;y2); 39 40 print(x1, x2); printf(\u0026#34; + \u0026#34;); print(y1, y2); printf(\u0026#34; = \u0026#34;); 41 print(x1*y2+x2*y1, x2*y2); printf(\u0026#34;\\n\u0026#34;); 42 43 print(x1, x2); printf(\u0026#34; - \u0026#34;); print(y1, y2); printf(\u0026#34; = \u0026#34;); 44 print(x1*y2-x2*y1, x2*y2); printf(\u0026#34;\\n\u0026#34;); 45 46 print(x1, x2); printf(\u0026#34; * \u0026#34;); print(y1, y2); printf(\u0026#34; = \u0026#34;); 47 print(x1*y1, x2*y2); printf(\u0026#34;\\n\u0026#34;); 48 49 print(x1, x2); printf(\u0026#34; / \u0026#34;); print(y1, y2); printf(\u0026#34; = \u0026#34;); 50 print(x1*y2, x2*y1); printf(\u0026#34;\\n\u0026#34;); 51 52 return 0; 53} ","permalink":"https://blog.lordash.de/posts/solution/patb-1034-%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","summary":"æœ‰ç†æ•°å››åˆ™è¿ç®— (PATB-1034) é¢˜é¢ æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®— 2 ä¸ªæœ‰ç†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚ è¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§ a1/b1 a2/b2 çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯","title":"PATB-1034 æœ‰ç†æ•°å››åˆ™è¿ç®—"},{"content":"æ—§é”®ç›˜æ‰“å­— (PATB-1033) é¢˜é¢ æ—§é”®ç›˜ä¸Šåäº†å‡ ä¸ªé”®ï¼Œäºæ˜¯åœ¨æ•²ä¸€æ®µæ–‡å­—çš„æ—¶å€™ï¼Œå¯¹åº”çš„å­—ç¬¦å°±ä¸ä¼šå‡ºç°ã€‚ç°åœ¨ç»™å‡ºåº”è¯¥è¾“å…¥çš„ä¸€æ®µæ–‡å­—ã€ä»¥åŠåæ‰çš„é‚£äº›é”®ï¼Œæ‰“å‡ºçš„ç»“æœæ–‡å­—ä¼šæ˜¯æ€æ ·ï¼Ÿ\nè¾“å…¥ è¾“å…¥åœ¨ 2 è¡Œä¸­åˆ†åˆ«ç»™å‡ºåæ‰çš„é‚£äº›é”®ã€ä»¥åŠåº”è¯¥è¾“å…¥çš„æ–‡å­—ã€‚å…¶ä¸­å¯¹åº”è‹±æ–‡å­—æ¯çš„åé”®ä»¥å¤§å†™ç»™å‡ºï¼›æ¯æ®µæ–‡å­—æ˜¯ä¸è¶…è¿‡ 10^5 ä¸ªå­—ç¬¦çš„ä¸²ã€‚å¯ç”¨çš„å­—ç¬¦åŒ…æ‹¬å­—æ¯ [a-z, A-Z]ã€æ•°å­— 0-9ã€ä»¥åŠä¸‹åˆ’çº¿ _ï¼ˆä»£è¡¨ç©ºæ ¼ï¼‰ã€,ã€.ã€-ã€+ï¼ˆä»£è¡¨ä¸Šæ¡£é”®ï¼‰ã€‚é¢˜ç›®ä¿è¯ç¬¬ 2 è¡Œè¾“å…¥çš„æ–‡å­—ä¸²éç©ºã€‚\næ³¨æ„ï¼šå¦‚æœä¸Šæ¡£é”®åæ‰äº†ï¼Œé‚£ä¹ˆå¤§å†™çš„è‹±æ–‡å­—æ¯æ— æ³•è¢«æ‰“å‡ºã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºèƒ½å¤Ÿè¢«æ‰“å‡ºçš„ç»“æœæ–‡å­—ã€‚å¦‚æœæ²¡æœ‰ä¸€ä¸ªå­—ç¬¦èƒ½è¢«æ‰“å‡ºï¼Œåˆ™è¾“å‡ºç©ºè¡Œã€‚\næ ·ä¾‹è¾“å…¥ 17+IE. 27_This_is_a_test. æ ·ä¾‹è¾“å‡º 1_hs_s_a_tst æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3char s[mxn]; 4 5int main() 6{ 7 fgets(s, mxn, stdin); 8 for(int i=0; s[i]; i++) 9 { 10 if(isalpha(s[i])){ 11 a[toupper(s[i])]++; 12 a[tolower(s[i])]++; 13 }else 14 a[s[i]]++; 15 } 16 17 fgets(s, mxn, stdin); 18 for(int i=0; s[i]; i++) 19 { 20 if(a[s[i]]) 21 continue; 22 if(isupper(s[i]) \u0026amp;\u0026amp; a[\u0026#39;+\u0026#39;]) 23 continue; 24 printf(\u0026#34;%c\u0026#34;, s[i]); 25 } 26 printf(\u0026#34;\\n\u0026#34;); 27 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/patb-1033-%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97/","summary":"æ—§é”®ç›˜æ‰“å­— (PATB-1033) é¢˜é¢ æ—§é”®ç›˜ä¸Šåäº†å‡ ä¸ªé”®ï¼Œäºæ˜¯åœ¨æ•²ä¸€æ®µæ–‡å­—çš„æ—¶å€™ï¼Œå¯¹åº”çš„å­—ç¬¦å°±ä¸ä¼šå‡ºç°ã€‚ç°åœ¨ç»™å‡ºåº”è¯¥è¾“å…¥çš„ä¸€æ®µæ–‡å­—ã€ä»¥åŠåæ‰çš„é‚£äº›é”®ï¼Œæ‰“å‡ºçš„ç»“æœæ–‡","title":"PATB-1033 æ—§é”®ç›˜æ‰“å­—"},{"content":"æŒ–æ˜æœºæŠ€æœ¯å“ªå®¶å¼º (PATB-1032) é¢˜é¢ ä¸ºäº†ç”¨äº‹å®è¯´æ˜æŒ–æ˜æœºæŠ€æœ¯åˆ°åº•å“ªå®¶å¼ºï¼ŒPAT ç»„ç»‡äº†ä¸€åœºæŒ–æ˜æœºæŠ€èƒ½å¤§èµ›ã€‚ç°è¯·ä½ æ ¹æ®æ¯”èµ›ç»“æœç»Ÿè®¡å‡ºæŠ€æœ¯æœ€å¼ºçš„é‚£ä¸ªå­¦æ ¡ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ 1 è¡Œç»™å‡ºä¸è¶…è¿‡ 10^5 çš„æ­£æ•´æ•° Nï¼Œå³å‚èµ›äººæ•°ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½å‚èµ›è€…çš„ä¿¡æ¯å’Œæˆç»©ï¼ŒåŒ…æ‹¬å…¶æ‰€ä»£è¡¨çš„å­¦æ ¡çš„ç¼–å·ï¼ˆä» 1 å¼€å§‹è¿ç»­ç¼–å·ï¼‰ã€åŠå…¶æ¯”èµ›æˆç»©ï¼ˆç™¾åˆ†åˆ¶ï¼‰ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ€»å¾—åˆ†æœ€é«˜çš„å­¦æ ¡çš„ç¼–å·ã€åŠå…¶æ€»åˆ†ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ²¡æœ‰å¹¶åˆ—ã€‚\næ ·ä¾‹è¾“å…¥ 16 23 65 32 80 41 100 52 70 63 40 73 0 æ ·ä¾‹è¾“å‡º 12 150 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4int main() 5{ 6 int n; 7 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 9 int num = 0, x, y; 10 for(int i = 0; i\u0026lt;n; i++) 11 { 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y); 13 a[x] += y; 14 num = max(num, x); 15 } 16 int mx = 0, id = 0; 17 for(int i=1; i\u0026lt;=num; i++) 18 { 19 if(a[i]\u0026gt;mx) { 20 mx = a[i]; 21 id = i; 22 } 23 } 24 printf(\u0026#34;%d %d\\n\u0026#34;, id, a[id]); 25 26 return 0; 27} ","permalink":"https://blog.lordash.de/posts/solution/patb-1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/","summary":"æŒ–æ˜æœºæŠ€æœ¯å“ªå®¶å¼º (PATB-1032) é¢˜é¢ ä¸ºäº†ç”¨äº‹å®è¯´æ˜æŒ–æ˜æœºæŠ€æœ¯åˆ°åº•å“ªå®¶å¼ºï¼ŒPAT ç»„ç»‡äº†ä¸€åœºæŒ–æ˜æœºæŠ€èƒ½å¤§èµ›ã€‚ç°è¯·ä½ æ ¹æ®æ¯”èµ›ç»“æœç»Ÿè®¡å‡ºæŠ€æœ¯æœ€å¼ºçš„é‚£ä¸ªå­¦æ ¡ã€‚ è¾“å…¥ è¾“","title":"PATB-1032 æŒ–æ˜æœºæŠ€æœ¯å“ªå®¶å¼º"},{"content":"æŸ¥éªŒèº«ä»½è¯ (PATB-1031) é¢˜é¢ ä¸€ä¸ªåˆæ³•çš„èº«ä»½è¯å·ç ç”±17ä½åœ°åŒºã€æ—¥æœŸç¼–å·å’Œé¡ºåºç¼–å·åŠ 1ä½æ ¡éªŒç ç»„æˆã€‚æ ¡éªŒç çš„è®¡ç®—è§„åˆ™å¦‚ä¸‹ï¼š\né¦–å…ˆå¯¹å‰17ä½æ•°å­—åŠ æƒæ±‚å’Œï¼Œæƒé‡åˆ†é…ä¸ºï¼š{7ï¼Œ9ï¼Œ10ï¼Œ5ï¼Œ8ï¼Œ4ï¼Œ2ï¼Œ1ï¼Œ6ï¼Œ3ï¼Œ7ï¼Œ9ï¼Œ10ï¼Œ5ï¼Œ8ï¼Œ4ï¼Œ2}ï¼›ç„¶åå°†è®¡ç®—çš„å’Œå¯¹11å–æ¨¡å¾—åˆ°å€¼Zï¼›æœ€åæŒ‰ç…§ä»¥ä¸‹å…³ç³»å¯¹åº”Zå€¼ä¸æ ¡éªŒç Mçš„å€¼ï¼š\n1Zï¼š0 1 2 3 4 5 6 7 8 9 10 2Mï¼š1 0 X 9 8 7 6 5 4 3 2 ç°åœ¨ç»™å®šä¸€äº›èº«ä»½è¯å·ç ï¼Œè¯·ä½ éªŒè¯æ ¡éªŒç çš„æœ‰æ•ˆæ€§ï¼Œå¹¶è¾“å‡ºæœ‰é—®é¢˜çš„å·ç ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤100ï¼‰æ˜¯è¾“å…¥çš„èº«ä»½è¯å·ç çš„ä¸ªæ•°ã€‚éšåNè¡Œï¼Œæ¯è¡Œç»™å‡º1ä¸ª18ä½èº«ä»½è¯å·ç ã€‚\nè¾“å‡º æŒ‰ç…§è¾“å…¥çš„é¡ºåºæ¯è¡Œè¾“å‡º1ä¸ªæœ‰é—®é¢˜çš„èº«ä»½è¯å·ç ã€‚è¿™é‡Œå¹¶ä¸æ£€éªŒå‰17ä½æ˜¯å¦åˆç†ï¼Œåªæ£€æŸ¥å‰17ä½æ˜¯å¦å…¨ä¸ºæ•°å­—ä¸”æœ€å1ä½æ ¡éªŒç è®¡ç®—å‡†ç¡®ã€‚å¦‚æœæ‰€æœ‰å·ç éƒ½æ­£å¸¸ï¼Œåˆ™è¾“å‡ºAll passedã€‚\næ ·ä¾‹è¾“å…¥ 14 2320124198808240056 312010X198901011234 4110108196711301866 537070419881216001X æ ·ä¾‹è¾“å‡º 112010X198901011234 2110108196711301866 337070419881216001X æ ·ä¾‹è¾“å…¥ 12 2320124198808240056 3110108196711301862 æ ·ä¾‹è¾“å‡º 1All passed æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int p[] = {7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2}; 3char m[] = \u0026#34;10X98765432\u0026#34;, s[mxn]; 4 5int main() 6{ 7 int n; 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 int ans = 0; 11 for(int cs = 0; cs\u0026lt;n; cs++) 12 { 13 scanf(\u0026#34;%s\u0026#34;, s); 14 15 int z = 0, err = 0; 16 for(int i=0; i\u0026lt;17; i++) 17 if(isdigit(s[i])) 18 z += (s[i]-\u0026#39;0\u0026#39;) * p[i]; 19 else{ 20 err = 1; break; 21 } 22 23 if(!err \u0026amp;\u0026amp; s[17] == m[z%11]) 24 ans++; 25 else 26 printf(\u0026#34;%s\\n\u0026#34;, s); 27 } 28 if(ans == n) 29 printf(\u0026#34;All passed\\n\u0026#34;); 30 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81/","summary":"æŸ¥éªŒèº«ä»½è¯ (PATB-1031) é¢˜é¢ ä¸€ä¸ªåˆæ³•çš„èº«ä»½è¯å·ç ç”±17ä½åœ°åŒºã€æ—¥æœŸç¼–å·å’Œé¡ºåºç¼–å·åŠ 1ä½æ ¡éªŒç ç»„æˆã€‚æ ¡éªŒç çš„è®¡ç®—è§„åˆ™å¦‚ä¸‹ï¼š é¦–å…ˆå¯¹å‰17ä½æ•°å­—åŠ æƒæ±‚å’Œï¼Œæƒé‡","title":"PATB-1031 æŸ¥éªŒèº«ä»½è¯"},{"content":"å®Œç¾æ•°åˆ— (PATB-1030) é¢˜é¢ ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°åˆ—ï¼Œå’Œæ­£æ•´æ•° pï¼Œè®¾è¿™ä¸ªæ•°åˆ—ä¸­çš„æœ€å¤§å€¼æ˜¯ Mï¼Œæœ€å°å€¼æ˜¯ mï¼Œå¦‚æœ Mâ‰¤mpï¼Œåˆ™ç§°è¿™ä¸ªæ•°åˆ—æ˜¯å®Œç¾æ•°åˆ—ã€‚\nç°åœ¨ç»™å®šå‚æ•° p å’Œä¸€äº›æ­£æ•´æ•°ï¼Œè¯·ä½ ä»ä¸­é€‰æ‹©å°½å¯èƒ½å¤šçš„æ•°æ„æˆä¸€ä¸ªå®Œç¾æ•°åˆ—\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸¤ä¸ªæ­£æ•´æ•° N å’Œ pï¼Œå…¶ä¸­ Nï¼ˆâ‰¤10^5ï¼‰æ˜¯è¾“å…¥çš„æ­£æ•´æ•°çš„ä¸ªæ•°ï¼Œpï¼ˆâ‰¤10^9ï¼‰æ˜¯ç»™å®šçš„å‚æ•°ã€‚ç¬¬äºŒè¡Œç»™å‡º N ä¸ªæ­£æ•´æ•°ï¼Œæ¯ä¸ªæ•°ä¸è¶…è¿‡ 10^9ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€å¤šå¯ä»¥é€‰æ‹©å¤šå°‘ä¸ªæ•°å¯ä»¥ç”¨å®ƒä»¬ç»„æˆä¸€ä¸ªå®Œç¾æ•°åˆ—ã€‚\næ ·ä¾‹è¾“å…¥ 110 8 22 3 20 4 5 1 6 7 8 9 æ ·ä¾‹è¾“å‡º 18 æç¤º æ— \næ€è·¯ ä»£ç  1typedef long long LL; 2const int mxn = 1e5 + 5; 3LL a[mxn]; 4 5int main() 6{ 7 int n, p; 8 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;p); 9 10 for(int i=0; i\u0026lt;n; i++) 11 scanf(\u0026#34;%lld\u0026#34;, \u0026amp;a[i]); 12 sort(a, a+n); 13 14 int ans = 1; 15 for(int i=0; i\u0026lt;n; i++) 16 { 17 int count = ans - 1; 18 for(int j=i+count; j\u0026lt;n; j++) 19 { 20 if(a[j] \u0026lt;= p*a[i]) 21 count++; 22 else 23 break; 24 } 25 ans = max(ans, count); 26 27 if(i+count \u0026gt; n) 28 break; 29 } 30 printf(\u0026#34;%d\\n\u0026#34;, ans); 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1030-%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97/","summary":"å®Œç¾æ•°åˆ— (PATB-1030) é¢˜é¢ ç»™å®šä¸€ä¸ªæ­£æ•´æ•°æ•°åˆ—ï¼Œå’Œæ­£æ•´æ•° pï¼Œè®¾è¿™ä¸ªæ•°åˆ—ä¸­çš„æœ€å¤§å€¼æ˜¯ Mï¼Œæœ€å°å€¼æ˜¯ mï¼Œå¦‚æœ Mâ‰¤mpï¼Œåˆ™ç§°è¿™ä¸ªæ•°åˆ—æ˜¯å®Œç¾æ•°åˆ—ã€‚ ç°åœ¨ç»™å®šå‚æ•° p å’Œä¸€","title":"PATB-1030 å®Œç¾æ•°åˆ—"},{"content":"æ—§é”®ç›˜ (PATB-1029) é¢˜é¢ æ—§é”®ç›˜ä¸Šåäº†å‡ ä¸ªé”®ï¼Œäºæ˜¯åœ¨æ•²ä¸€æ®µæ–‡å­—çš„æ—¶å€™ï¼Œå¯¹åº”çš„å­—ç¬¦å°±ä¸ä¼šå‡ºç°ã€‚ç°åœ¨ç»™å‡ºåº”è¯¥è¾“å…¥çš„ä¸€æ®µæ–‡å­—ã€ä»¥åŠå®é™…è¢«è¾“å…¥çš„æ–‡å­—ï¼Œè¯·ä½ åˆ—å‡ºè‚¯å®šåæ‰çš„é‚£äº›é”®ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ 2 è¡Œä¸­åˆ†åˆ«ç»™å‡ºåº”è¯¥è¾“å…¥çš„æ–‡å­—ã€ä»¥åŠå®é™…è¢«è¾“å…¥çš„æ–‡å­—ã€‚æ¯æ®µæ–‡å­—æ˜¯ä¸è¶…è¿‡ 80 ä¸ªå­—ç¬¦çš„ä¸²ï¼Œç”±å­—æ¯ A-Zï¼ˆåŒ…æ‹¬å¤§ã€å°å†™ï¼‰ã€æ•°å­— 0-9ã€ä»¥åŠä¸‹åˆ’çº¿ _ï¼ˆä»£è¡¨ç©ºæ ¼ï¼‰ç»„æˆã€‚é¢˜ç›®ä¿è¯ 2 ä¸ªå­—ç¬¦ä¸²å‡éç©ºã€‚\nè¾“å‡º æŒ‰ç…§å‘ç°é¡ºåºï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºåæ‰çš„é”®ã€‚å…¶ä¸­è‹±æ–‡å­—æ¯åªè¾“å‡ºå¤§å†™ï¼Œæ¯ä¸ªåé”®åªè¾“å‡ºä¸€æ¬¡ã€‚é¢˜ç›®ä¿è¯è‡³å°‘æœ‰ 1 ä¸ªåé”®ã€‚\næ ·ä¾‹è¾“å…¥ 17_This_is_a_test 2_hs_s_a_es æ ·ä¾‹è¾“å‡º 17TI æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char s[mxn], t[mxn]; 3int a[mxn]; 4 5int main() 6{ 7 scanf(\u0026#34;%s %s\u0026#34;, s, t); 8 int sl = strlen(s); 9 int tl = strlen(t); 10 11 for(int i=0; i\u0026lt;tl; i++) 12 { 13 if(isalpha(t[i])) 14 a[toupper(t[i])]++; 15 else 16 a[t[i]]++; 17 } 18 19 for(int i=0; i\u0026lt;sl; i++) 20 { 21 if(isalpha(s[i])) 22 s[i] = toupper(s[i]); 23 if(a[s[i]] == 0) 24 { 25 printf(\u0026#34;%c\u0026#34;, s[i]); 26 a[s[i]]++; 27 } 28 } 29 return 0; 30} ","permalink":"https://blog.lordash.de/posts/solution/patb-1029-%E6%97%A7%E9%94%AE%E7%9B%98/","summary":"æ—§é”®ç›˜ (PATB-1029) é¢˜é¢ æ—§é”®ç›˜ä¸Šåäº†å‡ ä¸ªé”®ï¼Œäºæ˜¯åœ¨æ•²ä¸€æ®µæ–‡å­—çš„æ—¶å€™ï¼Œå¯¹åº”çš„å­—ç¬¦å°±ä¸ä¼šå‡ºç°ã€‚ç°åœ¨ç»™å‡ºåº”è¯¥è¾“å…¥çš„ä¸€æ®µæ–‡å­—ã€ä»¥åŠå®é™…è¢«è¾“å…¥çš„æ–‡å­—ï¼Œè¯·ä½ åˆ—å‡ºè‚¯å®š","title":"PATB-1029 æ—§é”®ç›˜"},{"content":"äººå£æ™®æŸ¥ (PATB-1028) é¢˜é¢ æŸåŸé•‡è¿›è¡Œäººå£æ™®æŸ¥ï¼Œå¾—åˆ°äº†å…¨ä½“å±…æ°‘çš„ç”Ÿæ—¥ã€‚ç°è¯·ä½ å†™ä¸ªç¨‹åºï¼Œæ‰¾å‡ºé•‡ä¸Šæœ€å¹´é•¿å’Œæœ€å¹´è½»çš„äººã€‚\nè¿™é‡Œç¡®ä¿æ¯ä¸ªè¾“å…¥çš„æ—¥æœŸéƒ½æ˜¯åˆæ³•çš„ï¼Œä½†ä¸ä¸€å®šæ˜¯åˆç†çš„â€”â€”å‡è®¾å·²çŸ¥é•‡ä¸Šæ²¡æœ‰è¶…è¿‡ 200 å²çš„è€äººï¼Œè€Œä»Šå¤©æ˜¯ 2014 å¹´ 9 æœˆ 6 æ—¥ï¼Œæ‰€ä»¥è¶…è¿‡ 200 å²çš„ç”Ÿæ—¥å’Œæœªå‡ºç”Ÿçš„ç”Ÿæ—¥éƒ½æ˜¯ä¸åˆç†çš„ï¼Œåº”è¯¥è¢«è¿‡æ»¤æ‰ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼Œå–å€¼åœ¨(0,105]ï¼›éšå N è¡Œï¼Œæ¯è¡Œç»™å‡º 1 ä¸ªäººçš„å§“åï¼ˆç”±ä¸è¶…è¿‡ 5 ä¸ªè‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ï¼‰ã€ä»¥åŠæŒ‰ yyyy/mm/ddï¼ˆå³å¹´/æœˆ/æ—¥ï¼‰æ ¼å¼ç»™å‡ºçš„ç”Ÿæ—¥ã€‚é¢˜ç›®ä¿è¯æœ€å¹´é•¿å’Œæœ€å¹´è½»çš„äººæ²¡æœ‰å¹¶åˆ—ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­é¡ºåºè¾“å‡ºæœ‰æ•ˆç”Ÿæ—¥çš„ä¸ªæ•°ã€æœ€å¹´é•¿äººå’Œæœ€å¹´è½»äººçš„å§“åï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥ 15 2John 2001/05/12 3Tom 1814/09/06 4Ann 2121/01/30 5James 1814/09/05 6Steve 1967/11/20 æ ·ä¾‹è¾“å‡º 13 Tom John æç¤º æ— \næ€è·¯ ä»£ç  1struct P{ 2 char s[15], t[15]; 3}tmp, mx, mi; 4 5int main() 6{ 7 int n; 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 int num = 0; 11 for(int i=0; i\u0026lt;n; i++) 12 { 13 scanf(\u0026#34;%s %s\u0026#34;, tmp.s, tmp.t); 14 15 if(strcmp(tmp.t, \u0026#34;1814/09/06\u0026#34;) \u0026lt; 0) 16 continue; 17 if(strcmp(tmp.t, \u0026#34;2014/09/06\u0026#34;) \u0026gt; 0) 18 continue; 19 num++; 20 21 if(num==1) 22 { 23 strcpy(mi.s, tmp.s); strcpy(mi.t, tmp.t); 24 strcpy(mx.s, tmp.s); strcpy(mx.t, tmp.t); 25 continue; 26 } 27 28 if(strcmp(tmp.t, mi.t) \u0026lt; 0) { 29 strcpy(mi.s, tmp.s); strcpy(mi.t, tmp.t); 30 } 31 32 if(strcmp(tmp.t, mx.t) \u0026gt; 0) { 33 strcpy(mx.s, tmp.s); strcpy(mx.t, tmp.t); 34 } 35 } 36 if(num) 37 printf(\u0026#34;%d %s %s\\n\u0026#34;, num, mi.s, mx.s); 38 else 39 printf(\u0026#34;0\\n\u0026#34;); 40 41 return 0; 42} ","permalink":"https://blog.lordash.de/posts/solution/patb-1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/","summary":"äººå£æ™®æŸ¥ (PATB-1028) é¢˜é¢ æŸåŸé•‡è¿›è¡Œäººå£æ™®æŸ¥ï¼Œå¾—åˆ°äº†å…¨ä½“å±…æ°‘çš„ç”Ÿæ—¥ã€‚ç°è¯·ä½ å†™ä¸ªç¨‹åºï¼Œæ‰¾å‡ºé•‡ä¸Šæœ€å¹´é•¿å’Œæœ€å¹´è½»çš„äººã€‚ è¿™é‡Œç¡®ä¿æ¯ä¸ªè¾“å…¥çš„æ—¥æœŸéƒ½æ˜¯åˆæ³•çš„ï¼Œä½†ä¸ä¸€","title":"PATB-1028 äººå£æ™®æŸ¥"},{"content":"æ‰“å°æ²™æ¼ (PATB-1027) é¢˜é¢ æœ¬é¢˜è¦æ±‚ä½ å†™ä¸ªç¨‹åºæŠŠç»™å®šçš„ç¬¦å·æ‰“å°æˆæ²™æ¼çš„å½¢çŠ¶ã€‚ä¾‹å¦‚ç»™å®š17ä¸ªâ€œ*â€ï¼Œè¦æ±‚æŒ‰ä¸‹åˆ—æ ¼å¼æ‰“å°\n1***** 2 *** 3 * 4 *** 5***** æ‰€è°“â€œæ²™æ¼å½¢çŠ¶â€ï¼Œæ˜¯æŒ‡æ¯è¡Œè¾“å‡ºå¥‡æ•°ä¸ªç¬¦å·ï¼›å„è¡Œç¬¦å·ä¸­å¿ƒå¯¹é½ï¼›ç›¸é‚»ä¸¤è¡Œç¬¦å·æ•°å·®2ï¼›ç¬¦å·æ•°å…ˆä»å¤§åˆ°å°é¡ºåºé€’å‡åˆ°1ï¼Œå†ä»å°åˆ°å¤§é¡ºåºé€’å¢ï¼›é¦–å°¾ç¬¦å·æ•°ç›¸ç­‰ã€‚\nç»™å®šä»»æ„Nä¸ªç¬¦å·ï¼Œä¸ä¸€å®šèƒ½æ­£å¥½ç»„æˆä¸€ä¸ªæ²™æ¼ã€‚è¦æ±‚æ‰“å°å‡ºçš„æ²™æ¼èƒ½ç”¨æ‰å°½å¯èƒ½å¤šçš„ç¬¦å·ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œç»™å‡º1ä¸ªæ­£æ•´æ•°Nï¼ˆâ‰¤1000ï¼‰å’Œä¸€ä¸ªç¬¦å·ï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º é¦–å…ˆæ‰“å°å‡ºç”±ç»™å®šç¬¦å·ç»„æˆçš„æœ€å¤§çš„æ²™æ¼å½¢çŠ¶ï¼Œæœ€ååœ¨ä¸€è¡Œä¸­è¾“å‡ºå‰©ä¸‹æ²¡ç”¨æ‰çš„ç¬¦å·æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 119 * æ ·ä¾‹è¾“å‡º 1***** 2 *** 3 * 4 *** 5***** 62 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int n; char c; 4 scanf(\u0026#34;%d %c\u0026#34;, \u0026amp;n, \u0026amp;c); 5 6 int x, num=0; 7 for(x=1; ; x++) 8 { 9 if(n \u0026lt; 2*x*x-1) 10 { 11 x--; 12 num = 2*x*x-1; 13 break; 14 } 15 } 16 int flag = 1, m = 2*x-1; 17 int a = 0, b = m; 18 19 for(int i=1; i\u0026lt;=m; i++) 20 { 21 for(int j=0; j\u0026lt;a; j++) printf(\u0026#34; \u0026#34;); 22 for(int j=0; j\u0026lt;b; j++) printf(\u0026#34;%c\u0026#34;, c); 23 printf(\u0026#34;\\n\u0026#34;); 24 if(i==x) flag = 0; 25 26 if(flag) 27 a++, b-=2; 28 else 29 a--, b+=2; 30 } 31 printf(\u0026#34;%d\\n\u0026#34;, n-num); 32 33 return 0; 34} ","permalink":"https://blog.lordash.de/posts/solution/patb-1027-%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F/","summary":"æ‰“å°æ²™æ¼ (PATB-1027) é¢˜é¢ æœ¬é¢˜è¦æ±‚ä½ å†™ä¸ªç¨‹åºæŠŠç»™å®šçš„ç¬¦å·æ‰“å°æˆæ²™æ¼çš„å½¢çŠ¶ã€‚ä¾‹å¦‚ç»™å®š17ä¸ªâ€œ*â€ï¼Œè¦æ±‚æŒ‰ä¸‹åˆ—æ ¼å¼æ‰“å° 1***** 2 *** 3 * 4 *** 5***** æ‰€è°“â€œæ²™æ¼å½¢çŠ¶â€ï¼Œæ˜¯æŒ‡","title":"PATB-1027 æ‰“å°æ²™æ¼"},{"content":"ç¨‹åºè¿è¡Œæ—¶é—´ (PATB-1026) é¢˜é¢ è¦è·å¾—ä¸€ä¸ª C è¯­è¨€ç¨‹åºçš„è¿è¡Œæ—¶é—´ï¼Œå¸¸ç”¨çš„æ–¹æ³•æ˜¯è°ƒç”¨å¤´æ–‡ä»¶ time.hï¼Œå…¶ä¸­æä¾›äº† clock() å‡½æ•°ï¼Œå¯ä»¥æ•æ‰ä»ç¨‹åºå¼€å§‹è¿è¡Œåˆ° clock() è¢«è°ƒç”¨æ—¶æ‰€è€—è´¹çš„æ—¶é—´ã€‚è¿™ä¸ªæ—¶é—´å•ä½æ˜¯ clock tickï¼Œå³â€œæ—¶é’Ÿæ‰“ç‚¹â€ã€‚åŒæ—¶è¿˜æœ‰ä¸€ä¸ªå¸¸æ•° CLK_TCKï¼Œç»™å‡ºäº†æœºå™¨æ—¶é’Ÿæ¯ç§’æ‰€èµ°çš„æ—¶é’Ÿæ‰“ç‚¹æ•°ã€‚äºæ˜¯ä¸ºäº†è·å¾—ä¸€ä¸ªå‡½æ•° f çš„è¿è¡Œæ—¶é—´ï¼Œæˆ‘ä»¬åªè¦åœ¨è°ƒç”¨ f ä¹‹å‰å…ˆè°ƒç”¨ clock()ï¼Œè·å¾—ä¸€ä¸ªæ—¶é’Ÿæ‰“ç‚¹æ•° C1ï¼›åœ¨ f æ‰§è¡Œå®Œæˆåå†è°ƒç”¨ clock()ï¼Œè·å¾—å¦ä¸€ä¸ªæ—¶é’Ÿæ‰“ç‚¹æ•° C2ï¼›ä¸¤æ¬¡è·å¾—çš„æ—¶é’Ÿæ‰“ç‚¹æ•°ä¹‹å·® (C2-C1) å°±æ˜¯ f è¿è¡Œæ‰€æ¶ˆè€—çš„æ—¶é’Ÿæ‰“ç‚¹æ•°ï¼Œå†é™¤ä»¥å¸¸æ•° CLK_TCKï¼Œå°±å¾—åˆ°äº†ä»¥ç§’ä¸ºå•ä½çš„è¿è¡Œæ—¶é—´ã€‚\nè¿™é‡Œä¸å¦¨ç®€å•å‡è®¾å¸¸æ•° CLK_TCK ä¸º 100ã€‚ç°ç»™å®šè¢«æµ‹å‡½æ•°å‰åä¸¤æ¬¡è·å¾—çš„æ—¶é’Ÿæ‰“ç‚¹æ•°ï¼Œè¯·ä½ ç»™å‡ºè¢«æµ‹å‡½æ•°è¿è¡Œçš„æ—¶é—´ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­é¡ºåºç»™å‡º 2 ä¸ªæ•´æ•° C1 å’Œ C2ã€‚æ³¨æ„ä¸¤æ¬¡è·å¾—çš„æ—¶é’Ÿæ‰“ç‚¹æ•°è‚¯å®šä¸ç›¸åŒï¼Œå³ C1 \u0026lt; C2ï¼Œå¹¶ä¸”å–å€¼åœ¨ [0,10^7]ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºè¢«æµ‹å‡½æ•°è¿è¡Œçš„æ—¶é—´ã€‚è¿è¡Œæ—¶é—´å¿…é¡»æŒ‰ç…§ hh:mm:ssï¼ˆå³2ä½çš„ æ—¶:åˆ†:ç§’ï¼‰æ ¼å¼è¾“å‡ºï¼›ä¸è¶³ 1 ç§’çš„æ—¶é—´å››èˆäº”å…¥åˆ°ç§’ã€‚\næ ·ä¾‹è¾“å…¥ 1123 4577973 æ ·ä¾‹è¾“å‡º 112:42:59 æç¤º æ— \næ€è·¯ ä»£ç  1int main() 2{ 3 int c1, c2; 4 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;c1, \u0026amp;c2); 5 6 int t = (c2-c1) / 100; 7 int x = (c2-c1) % 100 \u0026gt;= 50 ? 1 : 0; 8 printf(\u0026#34;%02d:%02d:%02d\\n\u0026#34;, t/3600, t%3600/60, t%60+x); 9 10 return 0; 11} ","permalink":"https://blog.lordash.de/posts/solution/patb-1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/","summary":"ç¨‹åºè¿è¡Œæ—¶é—´ (PATB-1026) é¢˜é¢ è¦è·å¾—ä¸€ä¸ª C è¯­è¨€ç¨‹åºçš„è¿è¡Œæ—¶é—´ï¼Œå¸¸ç”¨çš„æ–¹æ³•æ˜¯è°ƒç”¨å¤´æ–‡ä»¶ time.hï¼Œå…¶ä¸­æä¾›äº† clock() å‡½æ•°ï¼Œå¯ä»¥æ•æ‰ä»ç¨‹åºå¼€å§‹è¿è¡Œåˆ° clock() è¢«è°ƒç”¨æ—¶æ‰€","title":"PATB-1026 ç¨‹åºè¿è¡Œæ—¶é—´"},{"content":"åè½¬é“¾è¡¨ (PATB-1025) é¢˜é¢ ç»™å®šä¸€ä¸ªå¸¸æ•° K ä»¥åŠä¸€ä¸ªå•é“¾è¡¨ Lï¼Œè¯·ç¼–å†™ç¨‹åºå°† L ä¸­æ¯ K ä¸ªç»“ç‚¹åè½¬ã€‚ä¾‹å¦‚ï¼šç»™å®š L ä¸º 1â†’2â†’3â†’4â†’5â†’6ï¼ŒK ä¸º 3ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º 3â†’2â†’1â†’6â†’5â†’4ï¼›å¦‚æœ K ä¸º 4ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º 4â†’3â†’2â†’1â†’5â†’6ï¼Œå³æœ€åä¸åˆ° K ä¸ªå…ƒç´ ä¸åè½¬ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ç¬¬ 1 è¡Œç»™å‡ºç¬¬ 1 ä¸ªç»“ç‚¹çš„åœ°å€ã€ç»“ç‚¹æ€»ä¸ªæ•°æ­£æ•´æ•° N (â‰¤10^5)ã€ä»¥åŠæ­£æ•´æ•° K (â‰¤N)ï¼Œå³è¦æ±‚åè½¬çš„å­é“¾ç»“ç‚¹çš„ä¸ªæ•°ã€‚ç»“ç‚¹çš„åœ°å€æ˜¯ 5 ä½éè´Ÿæ•´æ•°ï¼ŒNULL åœ°å€ç”¨ âˆ’1 è¡¨ç¤ºã€‚\næ¥ä¸‹æ¥æœ‰ N è¡Œï¼Œæ¯è¡Œæ ¼å¼ä¸ºï¼š\n1Address Data Next å…¶ä¸­ Address æ˜¯ç»“ç‚¹åœ°å€ï¼ŒData æ˜¯è¯¥ç»“ç‚¹ä¿å­˜çš„æ•´æ•°æ•°æ®ï¼ŒNext æ˜¯ä¸‹ä¸€ç»“ç‚¹çš„åœ°å€ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œé¡ºåºè¾“å‡ºåè½¬åçš„é“¾è¡¨ï¼Œå…¶ä¸Šæ¯ä¸ªç»“ç‚¹å ä¸€è¡Œï¼Œæ ¼å¼ä¸è¾“å…¥ç›¸åŒã€‚\næ ·ä¾‹è¾“å…¥ 100100 6 4 200000 4 99999 300100 1 12309 468237 6 -1 533218 3 00000 699999 5 68237 712309 2 33218 æ ·ä¾‹è¾“å‡º 100000 4 33218 233218 3 12309 312309 2 00100 400100 1 99999 599999 5 68237 668237 6 -1 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int val[mxn], nxt[mxn], ans[mxn]; 3 4int main() 5{ 6 int s, n, k, x; 7 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;s, \u0026amp;n, \u0026amp;k); 8 9 for (int i=0; i\u0026lt;n; i++) 10 { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;x); 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;val[x], \u0026amp;nxt[x]); 13 } 14 15 int num = 0; 16 for (int t=s; t!=-1; t=nxt[t]) { 17 ans[num++] = t; 18 } 19 20 for (int i=0; i\u0026lt;(num-num%k); i+=k) 21 reverse(begin(ans)+i, begin(ans)+i+k); 22 23 for (int i=0; i\u0026lt;num-1; i++) 24 printf(\u0026#34;%05d %d %05d\\n\u0026#34;, ans[i], val[ans[i]], ans[i+1]); 25 26 printf(\u0026#34;%05d %d -1\u0026#34;, ans[num-1], val[ans[num-1]]); 27 return 0; 28} ","permalink":"https://blog.lordash.de/posts/solution/patb-1025-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"åè½¬é“¾è¡¨ (PATB-1025) é¢˜é¢ ç»™å®šä¸€ä¸ªå¸¸æ•° K ä»¥åŠä¸€ä¸ªå•é“¾è¡¨ Lï¼Œè¯·ç¼–å†™ç¨‹åºå°† L ä¸­æ¯ K ä¸ªç»“ç‚¹åè½¬ã€‚ä¾‹å¦‚ï¼šç»™å®š L ä¸º 1â†’2â†’3â†’4â†’5â†’6ï¼ŒK ä¸º 3ï¼Œåˆ™è¾“å‡ºåº”è¯¥ä¸º 3â†’","title":"PATB-1025 åè½¬é“¾è¡¨"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æ™®æ™®é€šé€šå·¥ç§‘ç”·ï¼Œæœ¬ç§‘æ¯•ä¸šäºæ²³å—æŸåŒéï¼Œè½¯ä»¶å·¥ç¨‹ä¸“ä¸šã€‚ç›®å‰æ˜¯æŸå…¬å¸çš„Linuxåº”ç”¨å¼€å‘å·¥ç¨‹å¸ˆã€‚\næˆ–è®¸ï¼Œæˆ‘ä»¬æœ‰äº›å…±åŒè¯é¢˜ï¼š\nè¿åŠ¨ çƒ­çˆ±è·‘æ­¥ï¼ŒSBï¼š2KM7minã€5KM20minã€10KM43minã€‚å¾…éƒ‘å·4å¹´æ²¡æŠ½åˆ°éƒ‘å¼€ã€‚\nè·†æ‹³é“å“åŠ¿é»‘å¸¦ä¸€æ®µã€‚ä¸ä¼šç«æŠ€ï¼Œä¸ä¼šç‰¹æŠ€ï¼Œä¹Ÿæ²¡å‚åŠ è¿‡æ¯”èµ›ã€‚\néŸ³ä¹ çœŸÂ·äº”éŸ³ä¸å…¨ã€‚\nå–œæ¬¢ç”µéŸ³ï¼ŒAviciié¸½è¿·ã€‚\nè‡ªå­¦åŠéŸ³é˜¶å£ç´ä¸­â€¦â€¦\næ¸¸æˆ 3Dçœ©æ™•\nFPSï¼šäººé—´åœ°ç‹±ã€CSGOã€æˆ˜åœ°1\nMOBAï¼šè‹±é›„è”ç›Ÿ\nARPGï¼šä¸Šå¤å·è½´5ï¼šå¤©é™…ã€å¡å°”è¾¾ä¼ è¯´ï¼šæ—·é‡ä¹‹æ¯ã€é¬¼æ³£ç³»åˆ—\nå…¶å®ƒè”æœºï¼šé¥¥è’ã€Minecraftã€åŸç¥\nå¨è‰º ä¼šç…®æ³¡é¢å’ŒæŒ‚é¢ã€‚è¿˜ä¼šåšçº¢çƒ§æ’éª¨ã€å¯ä¹é¸¡ç¿…ã€éº»è¾£è™¾å°¾â€¦â€¦\nå…¶å®ƒ è’Ÿè’»æ¯•ä¸šæ—¶çš„çœŸÂ·ç®€å† ","permalink":"https://blog.lordash.de/f/personal/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æ™®æ™®é€šé€šå·¥ç§‘ç”·ï¼Œæœ¬ç§‘æ¯•ä¸šäºæ²³å—æŸåŒéï¼Œè½¯ä»¶å·¥ç¨‹ä¸“ä¸šã€‚ç›®å‰æ˜¯æŸå…¬å¸çš„Linuxåº”ç”¨å¼€å‘å·¥ç¨‹å¸ˆã€‚ æˆ–è®¸ï¼Œæˆ‘ä»¬æœ‰äº›å…±åŒè¯é¢˜ï¼š è¿åŠ¨","title":"ä¸ªäºº"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æœ€åˆæ˜¯åœ¨æ ¡æœŸé—´å‚åŠ ç®—æ³•ç«èµ›æ—¶ï¼Œä¸ºäº†è®°å½•å’Œåˆ†äº«è§£é¢˜è¿‡ç¨‹è€Œæ­å»ºçš„åšå®¢ã€‚ä½†æ˜¯ç°åœ¨æ¯•ä¸šæ²¦ä¸ºç¤¾ç•œäº†ï¼Œäºæ˜¯æ‰“ç®—åŠ å…¥ä¸€äº›éæŠ€æœ¯ç±»çš„éšç¬”å’Œç”Ÿæ´»æ„Ÿæ‚Ÿä¹‹ç±»çš„ã€‚\næœ¬åšå®¢ä½¿ç”¨Hexoåšå®¢å¼•æ“å’ŒNexTä¸»é¢˜æ­å»ºï¼Œå…·ä½“ç‰ˆæœ¬å¦‚ä¸‹ï¼š\n1os: win32 10.0.19044 2node: 16.14.2 3v8: 9.4.146.24-node.20 4hexo: 6.1.0 5hexo-cli: 4.3.0 6NexT version 8.11.1 åŸºæœ¬çš„æ­å»ºå’Œä¼˜åŒ–è¿‡ç¨‹å¯ä»¥å‚è€ƒã€é…ç½®ã€‘Windows10ä½¿ç”¨Hexoå’ŒPagesæœåŠ¡æ­å»ºä¸ªäººåšå®¢å’Œã€é…ç½®ã€‘Hexoä»¥åŠNexT8ä¸»é¢˜çš„é…ç½®è¿™ä¸¤ç¯‡æ–‡ç« ã€‚\nç›®å‰éƒ¨ç½²åœ¨Vercelå’ŒGithub Pagesä¸Šï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®ï¼š\nblog.lordash.de gh1656409967.github.io è®¿é—®å¡é¡¿ï¼Œæ¨èä½¿ç”¨ç§‘å­¦ä¸Šç½‘ ","permalink":"https://blog.lordash.de/f/about/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æœ€åˆæ˜¯åœ¨æ ¡æœŸé—´å‚åŠ ç®—æ³•ç«èµ›æ—¶ï¼Œä¸ºäº†è®°å½•å’Œåˆ†äº«è§£é¢˜è¿‡ç¨‹è€Œæ­å»ºçš„åšå®¢ã€‚ä½†æ˜¯ç°åœ¨æ¯•ä¸šæ²¦ä¸ºç¤¾ç•œäº†ï¼Œäºæ˜¯æ‰“ç®—åŠ å…¥ä¸€äº›éæŠ€æœ¯ç±»çš„éšç¬”","title":"å…³äº"},{"content":"ç§‘å­¦è®¡æ•°æ³• (PATB-1024) é¢˜é¢ ç§‘å­¦è®¡æ•°æ³•æ˜¯ç§‘å­¦å®¶ç”¨æ¥è¡¨ç¤ºå¾ˆå¤§æˆ–å¾ˆå°çš„æ•°å­—çš„ä¸€ç§æ–¹ä¾¿çš„æ–¹æ³•ï¼Œå…¶æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼[+-][1-9].[0-9]+E[+-][0-9]+ï¼Œå³æ•°å­—çš„æ•´æ•°éƒ¨åˆ†åªæœ‰ 1 ä½ï¼Œå°æ•°éƒ¨åˆ†è‡³å°‘æœ‰ 1 ä½ï¼Œè¯¥æ•°å­—åŠå…¶æŒ‡æ•°éƒ¨åˆ†çš„æ­£è´Ÿå·å³ä½¿å¯¹æ­£æ•°ä¹Ÿå¿…å®šæ˜ç¡®ç»™å‡ºã€‚\nç°ä»¥ç§‘å­¦è®¡æ•°æ³•çš„æ ¼å¼ç»™å‡ºå®æ•° Aï¼Œè¯·ç¼–å†™ç¨‹åºæŒ‰æ™®é€šæ•°å­—è¡¨ç¤ºæ³•è¾“å‡º Aï¼Œå¹¶ä¿è¯æ‰€æœ‰æœ‰æ•ˆä½éƒ½è¢«ä¿ç•™ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³ä¸€ä¸ªä»¥ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤ºçš„å®æ•° Aã€‚è¯¥æ•°å­—çš„å­˜å‚¨é•¿åº¦ä¸è¶…è¿‡ 9999 å­—èŠ‚ï¼Œä¸”å…¶æŒ‡æ•°çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 9999ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œä¸­æŒ‰æ™®é€šæ•°å­—è¡¨ç¤ºæ³•è¾“å‡º Aï¼Œå¹¶ä¿è¯æ‰€æœ‰æœ‰æ•ˆä½éƒ½è¢«ä¿ç•™ï¼ŒåŒ…æ‹¬æœ«å°¾çš„ 0ã€‚\næ ·ä¾‹è¾“å…¥1 1+1.23400E-03 æ ·ä¾‹è¾“å‡º1 10.00123400 æ ·ä¾‹è¾“å…¥2 1-1.2E+10 æ ·ä¾‹è¾“å‡º2 1-12000000000 æç¤º æ— \næ€è·¯ ä»£ç  1char s[mxn]; 2 3int main() 4{ 5 while(~ scanf(\u0026#34;%s\u0026#34;, s) ) 6 { 7 char* t = strchr(s, \u0026#39;E\u0026#39;); 8 int len = t - s - 3, l, r; 9 sscanf(t + 1, \u0026#34;%d\u0026#34;, \u0026amp;r); 10 *(t) = \u0026#39;\\0\u0026#39;; 11 t = strchr(s, \u0026#39;.\u0026#39;) + 1; 12 sscanf(s+1, \u0026#34;%d\u0026#34;, \u0026amp;l); 13 14 if (s[0] == \u0026#39;-\u0026#39;) 15 printf(\u0026#34;-\u0026#34;); 16 17 if (r \u0026gt; 0) 18 { 19 if (r \u0026gt; len) 20 { 21 printf(\u0026#34;%d%s\u0026#34;, l, t); 22 for (int i = 0; i \u0026lt; r - len; i++) 23 printf(\u0026#34;0\u0026#34;); 24 } 25 else 26 { 27 printf(\u0026#34;%d\u0026#34;, l); 28 int len2 = strlen(t); 29 for (int i = 0; i \u0026lt; len2; i++) 30 { 31 if (i == r) 32 printf(\u0026#34;.\u0026#34;); 33 printf(\u0026#34;%c\u0026#34;, t[i]); 34 } 35 } 36 } 37 else 38 { 39 printf(\u0026#34;0.\u0026#34;); 40 for (int i = 0; i + r + 1 \u0026lt; 0; i++) 41 printf(\u0026#34;0\u0026#34;); 42 printf(\u0026#34;%d%s\u0026#34;, l, t); 43 } 44 45 printf(\u0026#34;\\n\u0026#34;); 46 } 47 return 0; 48} ","permalink":"https://blog.lordash.de/posts/solution/patb-1024-%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95/","summary":"ç§‘å­¦è®¡æ•°æ³• (PATB-1024) é¢˜é¢ ç§‘å­¦è®¡æ•°æ³•æ˜¯ç§‘å­¦å®¶ç”¨æ¥è¡¨ç¤ºå¾ˆå¤§æˆ–å¾ˆå°çš„æ•°å­—çš„ä¸€ç§æ–¹ä¾¿çš„æ–¹æ³•ï¼Œå…¶æ»¡è¶³æ­£åˆ™è¡¨è¾¾å¼[+-][1-9].[0-9]+E[+-][0-","title":"PATB-1024 ç§‘å­¦è®¡æ•°æ³•"},{"content":"ç»„ä¸ªæœ€å°æ•° (PATB-1023) é¢˜é¢ ç»™å®šæ•°å­— 0-9 å„è‹¥å¹²ä¸ªã€‚ä½ å¯ä»¥ä»¥ä»»æ„é¡ºåºæ’åˆ—è¿™äº›æ•°å­—ï¼Œä½†å¿…é¡»å…¨éƒ¨ä½¿ç”¨ã€‚ç›®æ ‡æ˜¯ä½¿å¾—æœ€åå¾—åˆ°çš„æ•°å°½å¯èƒ½å°ï¼ˆæ³¨æ„ 0 ä¸èƒ½åšé¦–ä½ï¼‰ã€‚ä¾‹å¦‚ï¼šç»™å®šä¸¤ä¸ª 0ï¼Œä¸¤ä¸ª 1ï¼Œä¸‰ä¸ª 5ï¼Œä¸€ä¸ª 8ï¼Œæˆ‘ä»¬å¾—åˆ°çš„æœ€å°çš„æ•°å°±æ˜¯ 10015558ã€‚\nç°ç»™å®šæ•°å­—ï¼Œè¯·ç¼–å†™ç¨‹åºè¾“å‡ºèƒ½å¤Ÿç»„æˆçš„æœ€å°çš„æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º 10 ä¸ªéè´Ÿæ•´æ•°ï¼Œé¡ºåºè¡¨ç¤ºæˆ‘ä»¬æ‹¥æœ‰æ•°å­— 0ã€æ•°å­— 1ã€â€¦â€¦æ•°å­— 9 çš„ä¸ªæ•°ã€‚æ•´æ•°é—´ç”¨ä¸€ä¸ªç©ºæ ¼åˆ†éš”ã€‚10 ä¸ªæ•°å­—çš„æ€»ä¸ªæ•°ä¸è¶…è¿‡ 50ï¼Œä¸”è‡³å°‘æ‹¥æœ‰ 1 ä¸ªé 0 çš„æ•°å­—ã€‚\nè¾“å‡º 1åœ¨ä¸€è¡Œä¸­è¾“å‡ºèƒ½å¤Ÿç»„æˆçš„æœ€å°çš„æ•°ã€‚ æ ·ä¾‹è¾“å…¥ 12 2 0 0 0 3 0 0 1 0 æ ·ä¾‹è¾“å‡º 110015558 æç¤º æ— \næ€è·¯ ä»£ç  1int a[15]; 2 3int main() 4{ 5 for (int i = 0; i \u0026lt; 10; i++) 6 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 7 8 for (int i = 1; i \u0026lt; 10; i++) 9 { 10 if (a[i]) 11 { 12 printf(\u0026#34;%d\u0026#34;, i); 13 a[i]--; 14 break; 15 } 16 } 17 18 for (int i = 0; i \u0026lt; 10; i++) 19 { 20 while (a[i]) 21 { 22 printf(\u0026#34;%d\u0026#34;, i); 23 a[i]--; 24 } 25 } 26 27 printf(\u0026#34;\\n\u0026#34;); 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/patb-1023-%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0/","summary":"ç»„ä¸ªæœ€å°æ•° (PATB-1023) é¢˜é¢ ç»™å®šæ•°å­— 0-9 å„è‹¥å¹²ä¸ªã€‚ä½ å¯ä»¥ä»¥ä»»æ„é¡ºåºæ’åˆ—è¿™äº›æ•°å­—ï¼Œä½†å¿…é¡»å…¨éƒ¨ä½¿ç”¨ã€‚ç›®æ ‡æ˜¯ä½¿å¾—æœ€åå¾—åˆ°çš„æ•°å°½å¯èƒ½å°ï¼ˆæ³¨æ„ 0 ä¸èƒ½åšé¦–ä½ï¼‰ã€‚ä¾‹å¦‚ï¼š","title":"PATB-1023 ç»„ä¸ªæœ€å°æ•°"},{"content":"Dè¿›åˆ¶çš„A+B (PATB-1022) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªéè´Ÿ 10 è¿›åˆ¶æ•´æ•° A å’Œ B (â‰¤2^30âˆ’1)ï¼Œè¾“å‡º A+B çš„ D (1\u0026lt;Dâ‰¤10)è¿›åˆ¶æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º 3 ä¸ªæ•´æ•° Aã€B å’Œ Dã€‚\nè¾“å‡º è¾“å‡º A+B çš„ D è¿›åˆ¶æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 1123 456 8 æ ·ä¾‹è¾“å‡º 11103 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2char s[mxn]; 3 4int main() 5{ 6 LL a, b, d; 7 scanf(\u0026#34;%lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;d); 8 9 LL t = a + b; 10 11 for (n = 0; t; t/=d) 12 s[++n] = \u0026#34;0123456789\u0026#34;[t % d]; 13 14 if (!n) 15 printf(\u0026#34;0\u0026#34;); 16 17 for(; n; n--) 18 printf(\u0026#34;%c\u0026#34;, s[n]); 19 20 printf(\u0026#34;\\n\u0026#34;); 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1022-d%E8%BF%9B%E5%88%B6%E7%9A%84a+b/","summary":"Dè¿›åˆ¶çš„A+B (PATB-1022) é¢˜é¢ è¾“å…¥ä¸¤ä¸ªéè´Ÿ 10 è¿›åˆ¶æ•´æ•° A å’Œ B (â‰¤2^30âˆ’1)ï¼Œè¾“å‡º A+B çš„ D (1\u0026lt;Dâ‰¤10)è¿›åˆ¶æ•°ã€‚ è¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º 3 ä¸ªæ•´æ•°","title":"PATB-1022 Dè¿›åˆ¶çš„A+B"},{"content":"ä¸ªä½æ•°ç»Ÿè®¡ (PATB-1021) é¢˜é¢ ç»™å®šä¸€ä¸ª k ä½æ•´æ•° N=dkâˆ’1Ã—10^(kâˆ’1)+â‹¯+d1Ã—10^1+d0 (0â‰¤diâ‰¤9, i=0,â‹¯,kâˆ’1, dkâˆ’1\u0026gt;0)ï¼Œè¯·ç¼–å†™ç¨‹åºç»Ÿè®¡æ¯ç§ä¸åŒçš„ä¸ªä½æ•°å­—å‡ºç°çš„æ¬¡æ•°ã€‚ä¾‹å¦‚ï¼šç»™å®š N=100311ï¼Œåˆ™æœ‰ 2 ä¸ª 0ï¼Œ3 ä¸ª 1ï¼Œå’Œ 1 ä¸ª 3ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³ä¸€ä¸ªä¸è¶…è¿‡ 1000 ä½çš„æ­£æ•´æ•° Nã€‚\nè¾“å‡º å¯¹ N ä¸­æ¯ä¸€ç§ä¸åŒçš„ä¸ªä½æ•°å­—ï¼Œä»¥ D:M çš„æ ¼å¼åœ¨ä¸€è¡Œä¸­è¾“å‡ºè¯¥ä½æ•°å­— D åŠå…¶åœ¨ N ä¸­å‡ºç°çš„æ¬¡æ•° Mã€‚è¦æ±‚æŒ‰ D çš„å‡åºè¾“å‡ºã€‚\næ ·ä¾‹è¾“å…¥ 1100311 æ ·ä¾‹è¾“å‡º 10:2 21:3 33:1 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2int a[15]; 3 4int main() 5{ 6 char t[mxm]; 7 scanf(\u0026#34;%s\u0026#34;, t); 8 int len = strlen(t); 9 for (int i = 0; i \u0026lt; len; i++) 10 { 11 a[t[i] - \u0026#39;0\u0026#39;]++; 12 } 13 for (int i = 0; i \u0026lt;= 9; i++) 14 { 15 if (a[i]) 16 printf(\u0026#34;%d:%d\\n\u0026#34;, i, a[i]); 17 } 18 19 return 0; 20} ","permalink":"https://blog.lordash.de/posts/solution/patb-1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/","summary":"ä¸ªä½æ•°ç»Ÿè®¡ (PATB-1021) é¢˜é¢ ç»™å®šä¸€ä¸ª k ä½æ•´æ•° N=dkâˆ’1Ã—10^(kâˆ’1)+â‹¯+d1Ã—10^1+d0 (0â‰¤diâ‰¤9, i=0,â‹¯,kâˆ’1, dkâˆ’1\u0026gt;","title":"PATB-1021 ä¸ªä½æ•°ç»Ÿè®¡"},{"content":"æœˆé¥¼ (PATB-1020) é¢˜é¢ æœˆé¥¼æ˜¯ä¸­å›½äººåœ¨ä¸­ç§‹ä½³èŠ‚æ—¶åƒçš„ä¸€ç§ä¼ ç»Ÿé£Ÿå“ï¼Œä¸åŒåœ°åŒºæœ‰è®¸å¤šä¸åŒé£å‘³çš„æœˆé¥¼ã€‚ç°ç»™å®šæ‰€æœ‰ç§ç±»æœˆé¥¼çš„åº“å­˜é‡ã€æ€»å”®ä»·ã€ä»¥åŠå¸‚åœºçš„æœ€å¤§éœ€æ±‚é‡ï¼Œè¯·ä½ è®¡ç®—å¯ä»¥è·å¾—çš„æœ€å¤§æ”¶ç›Šæ˜¯å¤šå°‘ã€‚\næ³¨æ„ï¼šé”€å”®æ—¶å…è®¸å–å‡ºä¸€éƒ¨åˆ†åº“å­˜ã€‚æ ·ä¾‹ç»™å‡ºçš„æƒ…å½¢æ˜¯è¿™æ ·çš„ï¼šå‡å¦‚æˆ‘ä»¬æœ‰ 3 ç§æœˆé¥¼ï¼Œå…¶åº“å­˜é‡åˆ†åˆ«ä¸º 18ã€15ã€10 ä¸‡å¨ï¼Œæ€»å”®ä»·åˆ†åˆ«ä¸º 75ã€72ã€45 äº¿å…ƒã€‚å¦‚æœå¸‚åœºçš„æœ€å¤§éœ€æ±‚é‡åªæœ‰ 20 ä¸‡å¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€å¤§æ”¶ç›Šç­–ç•¥åº”è¯¥æ˜¯å–å‡ºå…¨éƒ¨ 15 ä¸‡å¨ç¬¬ 2 ç§æœˆé¥¼ã€ä»¥åŠ 5 ä¸‡å¨ç¬¬ 3 ç§æœˆé¥¼ï¼Œè·å¾— 72 + 45/2 = 94.5ï¼ˆäº¿å…ƒï¼‰ã€‚\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å…ˆç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° N è¡¨ç¤ºæœˆé¥¼çš„ç§ç±»æ•°ã€ä»¥åŠä¸è¶…è¿‡ 500ï¼ˆä»¥ä¸‡å¨ä¸ºå•ä½ï¼‰çš„æ­£æ•´æ•° D è¡¨ç¤ºå¸‚åœºæœ€å¤§éœ€æ±‚é‡ã€‚éšåä¸€è¡Œç»™å‡º N ä¸ªæ­£æ•°è¡¨ç¤ºæ¯ç§æœˆé¥¼çš„åº“å­˜é‡ï¼ˆä»¥ä¸‡å¨ä¸ºå•ä½ï¼‰ï¼›æœ€åä¸€è¡Œç»™å‡º N ä¸ªæ­£æ•°è¡¨ç¤ºæ¯ç§æœˆé¥¼çš„æ€»å”®ä»·ï¼ˆä»¥äº¿å…ƒä¸ºå•ä½ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹æ¯ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºæœ€å¤§æ”¶ç›Šï¼Œä»¥äº¿å…ƒä¸ºå•ä½å¹¶ç²¾ç¡®åˆ°å°æ•°ç‚¹å 2 ä½ã€‚\næ ·ä¾‹è¾“å…¥ 13 20 218 15 10 375 72 45 æ ·ä¾‹è¾“å‡º 194.50 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3struct P { 4 DB num, price; 5}a[mxn]; 6 7bool cmp(P x, P y) 8{ 9 return x.price / x.num \u0026gt; y.price / y.num; 10} 11 12int main() 13{ 14 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 15 for (int i = 0; i \u0026lt; n; i++) 16 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[i].num); 17 18 for (int i = 0; i \u0026lt; n; i++) 19 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[i].price); 20 21 sort(a, a + n, cmp); 22 23 DB ans = 0; 24 for (int i = 0; i \u0026lt; n; i++) 25 { 26 if (m \u0026gt; a[i].num) 27 { 28 ans += a[i].price; 29 m -= a[i].num; 30 } 31 else 32 { 33 ans += m * (a[i].price / a[i].num); 34 break; 35 } 36 } 37 printf(\u0026#34;%.2lf\\n\u0026#34;, ans); 38 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/solution/patb-1020-%E6%9C%88%E9%A5%BC/","summary":"æœˆé¥¼ (PATB-1020) é¢˜é¢ æœˆé¥¼æ˜¯ä¸­å›½äººåœ¨ä¸­ç§‹ä½³èŠ‚æ—¶åƒçš„ä¸€ç§ä¼ ç»Ÿé£Ÿå“ï¼Œä¸åŒåœ°åŒºæœ‰è®¸å¤šä¸åŒé£å‘³çš„æœˆé¥¼ã€‚ç°ç»™å®šæ‰€æœ‰ç§ç±»æœˆé¥¼çš„åº“å­˜é‡ã€æ€»å”®ä»·ã€ä»¥åŠå¸‚åœºçš„æœ€å¤§éœ€æ±‚é‡ï¼Œ","title":"PATB-1020 æœˆé¥¼"},{"content":"æ•°å­—é»‘æ´ (PATB-1019) é¢˜é¢ ç»™å®šä»»ä¸€ä¸ªå„ä½æ•°å­—ä¸å®Œå…¨ç›¸åŒçš„ 4 ä½æ­£æ•´æ•°ï¼Œå¦‚æœæˆ‘ä»¬å…ˆæŠŠ 4 ä¸ªæ•°å­—æŒ‰éé€’å¢æ’åºï¼Œå†æŒ‰éé€’å‡æ’åºï¼Œç„¶åç”¨ç¬¬ 1 ä¸ªæ•°å­—å‡ç¬¬ 2 ä¸ªæ•°å­—ï¼Œå°†å¾—åˆ°ä¸€ä¸ªæ–°çš„æ•°å­—ã€‚ä¸€ç›´é‡å¤è¿™æ ·åšï¼Œæˆ‘ä»¬å¾ˆå¿«ä¼šåœåœ¨æœ‰â€œæ•°å­—é»‘æ´â€ä¹‹ç§°çš„ 6174ï¼Œè¿™ä¸ªç¥å¥‡çš„æ•°å­—ä¹Ÿå« Kaprekar å¸¸æ•°ã€‚\nä¾‹å¦‚ï¼Œæˆ‘ä»¬ä»6767å¼€å§‹ï¼Œå°†å¾—åˆ°\n17766 - 6677 = 1089 29810 - 0189 = 9621 39621 - 1269 = 8352 48532 - 2358 = 6174 57641 - 1467 = 6174 6... ... ç°ç»™å®šä»»æ„ 4 ä½æ­£æ•´æ•°ï¼Œè¯·ç¼–å†™ç¨‹åºæ¼”ç¤ºåˆ°è¾¾é»‘æ´çš„è¿‡ç¨‹ã€‚\nè¾“å…¥ è¾“å…¥ç»™å‡ºä¸€ä¸ª (0,10^4) åŒºé—´å†…çš„æ­£æ•´æ•° Nã€‚\nè¾“å‡º å¦‚æœ N çš„ 4 ä½æ•°å­—å…¨ç›¸ç­‰ï¼Œåˆ™åœ¨ä¸€è¡Œå†…è¾“å‡º N - N = 0000ï¼›å¦åˆ™å°†è®¡ç®—çš„æ¯ä¸€æ­¥åœ¨ä¸€è¡Œå†…è¾“å‡ºï¼Œç›´åˆ° 6174 ä½œä¸ºå·®å‡ºç°ï¼Œè¾“å‡ºæ ¼å¼è§æ ·ä¾‹ã€‚æ³¨æ„æ¯ä¸ªæ•°å­—æŒ‰ 4 ä½æ•°æ ¼å¼è¾“å‡ºã€‚\næ ·ä¾‹è¾“å…¥1 16767 æ ·ä¾‹è¾“å‡º1 17766 - 6677 = 1089 29810 - 0189 = 9621 39621 - 1269 = 8352 48532 - 2358 = 6174 æ ·ä¾‹è¾“å…¥2 12222 æ ·ä¾‹è¾“å‡º2 12222 - 2222 = 0000 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3void strrev(char* s, char* t) 4{ 5 int len = strlen(s); 6 for (int i = 0; i \u0026lt; len; i++) 7 { 8 t[i] = s[len - i - 1]; 9 } 10 t[len] = \u0026#39;\\0\u0026#39;; 11} 12 13int main() 14{ 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 16 char t1[15], t2[15], t3[15]; 17 while (1) 18 { 19 sprintf(t2, \u0026#34;%04d\u0026#34;, n); 20 sort(t2, t2 + 4); 21 strrev(t2, t1); 22 sscanf(t1, \u0026#34;%d\u0026#34;, \u0026amp;n); 23 sscanf(t2, \u0026#34;%d\u0026#34;, \u0026amp;m); 24 n = n - m; 25 sprintf(t3, \u0026#34;%04d\u0026#34;, n); 26 printf(\u0026#34;%s - %s = %s\\n\u0026#34;, t1, t2, t3); 27 if (n == 0 || n == 6174) 28 break; 29 } 30 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E/","summary":"æ•°å­—é»‘æ´ (PATB-1019) é¢˜é¢ ç»™å®šä»»ä¸€ä¸ªå„ä½æ•°å­—ä¸å®Œå…¨ç›¸åŒçš„ 4 ä½æ­£æ•´æ•°ï¼Œå¦‚æœæˆ‘ä»¬å…ˆæŠŠ 4 ä¸ªæ•°å­—æŒ‰éé€’å¢æ’åºï¼Œå†æŒ‰éé€’å‡æ’åºï¼Œç„¶åç”¨ç¬¬ 1 ä¸ªæ•°å­—å‡ç¬¬ 2 ä¸ªæ•°å­—ï¼Œå°†å¾—","title":"PATB-1019 æ•°å­—é»‘æ´"},{"content":"é”¤å­å‰ªåˆ€å¸ƒ (PATB-1018) é¢˜é¢ å¤§å®¶åº”è¯¥éƒ½ä¼šç©â€œé”¤å­å‰ªåˆ€å¸ƒâ€çš„æ¸¸æˆï¼šä¸¤äººåŒæ—¶ç»™å‡ºæ‰‹åŠ¿ï¼Œèƒœè´Ÿè§„åˆ™å¦‚å›¾æ‰€ç¤ºï¼š\nç°ç»™å‡ºä¸¤äººçš„äº¤é”‹è®°å½•ï¼Œè¯·ç»Ÿè®¡åŒæ–¹çš„èƒœã€å¹³ã€è´Ÿæ¬¡æ•°ï¼Œå¹¶ä¸”ç»™å‡ºåŒæ–¹åˆ†åˆ«å‡ºä»€ä¹ˆæ‰‹åŠ¿çš„èƒœç®—æœ€å¤§ã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ 1 è¡Œç»™å‡ºæ­£æ•´æ•° Nï¼ˆâ‰¤10^5ï¼‰ï¼Œå³åŒæ–¹äº¤é”‹çš„æ¬¡æ•°ã€‚éšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€æ¬¡äº¤é”‹çš„ä¿¡æ¯ï¼Œå³ç”²ã€ä¹™åŒæ–¹åŒæ—¶ç»™å‡ºçš„çš„æ‰‹åŠ¿ã€‚C ä»£è¡¨â€œé”¤å­â€ã€J ä»£è¡¨â€œå‰ªåˆ€â€ã€B ä»£è¡¨â€œå¸ƒâ€ï¼Œç¬¬ 1 ä¸ªå­—æ¯ä»£è¡¨ç”²æ–¹ï¼Œç¬¬ 2 ä¸ªä»£è¡¨ä¹™æ–¹ï¼Œä¸­é—´æœ‰ 1 ä¸ªç©ºæ ¼ã€‚\nè¾“å‡º è¾“å‡ºç¬¬ 1ã€2 è¡Œåˆ†åˆ«ç»™å‡ºç”²ã€ä¹™çš„èƒœã€å¹³ã€è´Ÿæ¬¡æ•°ï¼Œæ•°å­—é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ã€‚ç¬¬ 3 è¡Œç»™å‡ºä¸¤ä¸ªå­—æ¯ï¼Œåˆ†åˆ«ä»£è¡¨ç”²ã€ä¹™è·èƒœæ¬¡æ•°æœ€å¤šçš„æ‰‹åŠ¿ï¼Œä¸­é—´æœ‰ 1 ä¸ªç©ºæ ¼ã€‚å¦‚æœè§£ä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºæŒ‰å­—æ¯åºæœ€å°çš„è§£ã€‚\næ ·ä¾‹è¾“å…¥ 110 2C J 3J B 4C B 5B B 6B C 7C C 8C B 9J B 10B C 11J J æ ·ä¾‹è¾“å‡º 15 3 2 22 3 5 3B B æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3char s[] = \u0026#34; BCJ\u0026#34;; 4int a[10], b[10]; 5 6int main() 7{ 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 10 char x, y; 11 for (int i = 0; i \u0026lt; n; i++) 12 { 13 scanf(\u0026#34; %c %c\u0026#34;, \u0026amp;x, \u0026amp;y); 14 if (x == y) 15 { 16 a[5]++, b[5]++; 17 continue; 18 } 19 if (x == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; y == \u0026#39;C\u0026#39;) 20 a[1]++, a[4]++, b[6]++; 21 else if (x == \u0026#39;B\u0026#39; \u0026amp;\u0026amp; y == \u0026#39;J\u0026#39;) 22 b[3]++, a[6]++, b[4]++; 23 else if (x == \u0026#39;C\u0026#39; \u0026amp;\u0026amp; y == \u0026#39;J\u0026#39;) 24 a[2]++, a[4]++, b[6]++; 25 else if (x == \u0026#39;C\u0026#39; \u0026amp;\u0026amp; y == \u0026#39;B\u0026#39;) 26 b[1]++, a[6]++, b[4]++; 27 else if (y == \u0026#39;B\u0026#39;) 28 a[3]++, a[4]++, b[6]++; 29 else 30 b[2]++, a[6]++, b[4]++; 31 } 32 33 printf(\u0026#34;%d %d %d\\n\u0026#34;, a[4], a[5], a[6]); 34 printf(\u0026#34;%d %d %d\\n\u0026#34;, b[4], b[5], b[6]); 35 int idx1 = 1, idx2 = 1; 36 for (int i = 1; i \u0026lt;= 3; i++) 37 { 38 if (a[idx1] \u0026lt; a[i]) 39 idx1 = i; 40 if (b[idx2] \u0026lt; b[i]) 41 idx2 = i; 42 } 43 printf(\u0026#34;%c %c\\n\u0026#34;, s[idx1], s[idx2]); 44 45 return 0; 46} ","permalink":"https://blog.lordash.de/posts/solution/patb-1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/","summary":"é”¤å­å‰ªåˆ€å¸ƒ (PATB-1018) é¢˜é¢ å¤§å®¶åº”è¯¥éƒ½ä¼šç©â€œé”¤å­å‰ªåˆ€å¸ƒâ€çš„æ¸¸æˆï¼šä¸¤äººåŒæ—¶ç»™å‡ºæ‰‹åŠ¿ï¼Œèƒœè´Ÿè§„åˆ™å¦‚å›¾æ‰€ç¤ºï¼š ç°ç»™å‡ºä¸¤äººçš„äº¤é”‹è®°å½•ï¼Œè¯·ç»Ÿè®¡åŒæ–¹çš„èƒœã€å¹³ã€è´Ÿæ¬¡æ•°ï¼Œå¹¶","title":"PATB-1018 é”¤å­å‰ªåˆ€å¸ƒ"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä½ è‹¥çœ‰æ¢¢å˜´è§’å¸¦ç€ç¬‘ï¼Œä½•å¤„ä¸æ˜¯é£æ™¯\n","permalink":"https://blog.lordash.de/f/gallery/scenery/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä½ è‹¥çœ‰æ¢¢å˜´è§’å¸¦ç€ç¬‘ï¼Œä½•å¤„ä¸æ˜¯é£æ™¯","title":"é£æ™¯"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä¸€æ˜Ÿé™¨è½ï¼Œé»¯æ·¡ä¸äº†æ˜Ÿç©ºç¿çƒ‚ï¼›ä¸€èŠ±å‡‹é›¶ï¼Œè’èŠœä¸äº†æ•´ä¸ªæ˜¥å¤©ã€‚\n-è¯ä¹¦-\n-é”»ç‚¼-\n-é£æ™¯-\n-æ›²è°±-\n-èœè°±-\n","permalink":"https://blog.lordash.de/f/gallery/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä¸€æ˜Ÿé™¨è½ï¼Œé»¯æ·¡ä¸äº†æ˜Ÿç©ºç¿çƒ‚ï¼›ä¸€èŠ±å‡‹é›¶ï¼Œè’èŠœä¸äº†æ•´ä¸ªæ˜¥å¤©ã€‚ -è¯ä¹¦- -é”»ç‚¼- -é£æ™¯- -æ›²è°±- -èœè°±-","title":"ç›¸å†Œ"},{"content":"Aé™¤ä»¥B (PATB-1017) é¢˜é¢ æœ¬é¢˜è¦æ±‚è®¡ç®— A/Bï¼Œå…¶ä¸­ A æ˜¯ä¸è¶…è¿‡ 1000 ä½çš„æ­£æ•´æ•°ï¼ŒB æ˜¯ 1 ä½æ­£æ•´æ•°ã€‚ä½ éœ€è¦è¾“å‡ºå•†æ•° Q å’Œä½™æ•° Rï¼Œä½¿å¾— A=BÃ—Q+R æˆç«‹ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º A å’Œ Bï¼Œä¸­é—´ä»¥ 1 ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­ä¾æ¬¡è¾“å‡º Q å’Œ Rï¼Œä¸­é—´ä»¥ 1 ç©ºæ ¼åˆ†éš”ã€‚\næ ·ä¾‹è¾“å…¥ 1123456789050987654321 7 æ ·ä¾‹è¾“å‡º 117636684150141093474 3 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2char a[mxn]; 3int b; 4 5int main() 6{ 7 scanf(\u0026#34;%s %d\u0026#34;, a, \u0026amp;b); 8 int len = strlen(a), t = 0; 9 for (int i = 0; i \u0026lt; len; i++) 10 { 11 t = t * 10 + a[i] - \u0026#39;0\u0026#39;; 12 if (i || t / b || len \u0026lt;= 1) 13 printf(\u0026#34;%d\u0026#34;, t / b); 14 t %= b; 15 } 16 17 printf(\u0026#34; %d\\n\u0026#34;, t); 18 return 0; 19} ","permalink":"https://blog.lordash.de/posts/solution/patb-1017-a%E9%99%A4%E4%BB%A5b/","summary":"Aé™¤ä»¥B (PATB-1017) é¢˜é¢ æœ¬é¢˜è¦æ±‚è®¡ç®— A/Bï¼Œå…¶ä¸­ A æ˜¯ä¸è¶…è¿‡ 1000 ä½çš„æ­£æ•´æ•°ï¼ŒB æ˜¯ 1 ä½æ­£æ•´æ•°ã€‚ä½ éœ€è¦è¾“å‡ºå•†æ•° Q å’Œä½™æ•° Rï¼Œä½¿å¾— A=BÃ—Q+R æˆç«‹ã€‚ è¾“å…¥ è¾“å…¥åœ¨ä¸€","title":"PATB-1017 Aé™¤ä»¥B"},{"content":"éƒ¨åˆ†A+B (PATB-1016) é¢˜é¢ æ­£æ•´æ•° A çš„â€œDAï¼ˆä¸º 1 ä½æ•´æ•°ï¼‰éƒ¨åˆ†â€å®šä¹‰ä¸ºç”± A ä¸­æ‰€æœ‰ DA ç»„æˆçš„æ–°æ•´æ•° PAã€‚ä¾‹å¦‚ï¼šç»™å®š A=3862767ï¼ŒDA=6ï¼Œåˆ™ A çš„â€œ6 éƒ¨åˆ†â€PA æ˜¯ 66ï¼Œå› ä¸º A ä¸­æœ‰ 2 ä¸ª 6ã€‚\nç°ç»™å®š Aã€DAã€Bã€DBï¼Œè¯·ç¼–å†™ç¨‹åºè®¡ç®— PA+PBã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡ç»™å‡º Aã€DAã€Bã€DBï¼Œä¸­é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œå…¶ä¸­ 0\u0026lt;A,B\u0026lt;10^10ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡º PA+PB çš„å€¼ã€‚\næ ·ä¾‹è¾“å…¥1 13862767 6 13530293 3 æ ·ä¾‹è¾“å‡º1 1399 æ ·ä¾‹è¾“å…¥2 13862767 1 13530293 8 æ ·ä¾‹è¾“å‡º2 10 æç¤º æ— \næ€è·¯ ä»£ç  1int a, b, da, db; 2 3int main() 4{ 5 scanf(\u0026#34;%d %d %d %d\u0026#34;, \u0026amp;a, \u0026amp;da, \u0026amp;b, \u0026amp;db); 6 int ta = 0, tb = 0; 7 while (a) 8 { 9 if (a % 10 == da) 10 ta = ta * 10 + da; 11 a /= 10; 12 } 13 while (b) 14 { 15 if (b % 10 == db) 16 tb = tb * 10 + db; 17 b /= 10; 18 } 19 20 printf(\u0026#34;%d\\n\u0026#34;, ta + tb); 21 return 0; 22} ","permalink":"https://blog.lordash.de/posts/solution/patb-1016-%E9%83%A8%E5%88%86a+b/","summary":"éƒ¨åˆ†A+B (PATB-1016) é¢˜é¢ æ­£æ•´æ•° A çš„â€œDAï¼ˆä¸º 1 ä½æ•´æ•°ï¼‰éƒ¨åˆ†â€å®šä¹‰ä¸ºç”± A ä¸­æ‰€æœ‰ DA ç»„æˆçš„æ–°æ•´æ•° PAã€‚ä¾‹å¦‚ï¼šç»™å®š A=3862767ï¼ŒDA=6ï¼Œåˆ™ A çš„â€œ6 éƒ¨","title":"PATB-1016 éƒ¨åˆ†A+B"},{"content":"å¾·æ‰è®º (PATB-1015) é¢˜é¢ å®‹ä»£å²å­¦å®¶å¸é©¬å…‰åœ¨ã€Šèµ„æ²»é€šé‰´ã€‹ä¸­æœ‰ä¸€æ®µè‘—åçš„â€œå¾·æ‰è®ºâ€ï¼šâ€œæ˜¯æ•…æ‰å¾·å…¨å°½è°“ä¹‹åœ£äººï¼Œæ‰å¾·å…¼äº¡è°“ä¹‹æ„šäººï¼Œå¾·èƒœæ‰è°“ä¹‹å›å­ï¼Œæ‰èƒœå¾·è°“ä¹‹å°äººã€‚å‡¡å–äººä¹‹æœ¯ï¼Œè‹Ÿä¸å¾—åœ£äººï¼Œå›å­è€Œä¸ä¹‹ï¼Œä¸å…¶å¾—å°äººï¼Œä¸è‹¥å¾—æ„šäººã€‚â€\nç°ç»™å‡ºä¸€æ‰¹è€ƒç”Ÿçš„å¾·æ‰åˆ†æ•°ï¼Œè¯·æ ¹æ®å¸é©¬å…‰çš„ç†è®ºç»™å‡ºå½•å–æ’åã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º 3 ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«ä¸ºï¼šNï¼ˆâ‰¤10^5ï¼‰ï¼Œå³è€ƒç”Ÿæ€»æ•°ï¼›Lï¼ˆâ‰¥60ï¼‰ï¼Œä¸ºå½•å–æœ€ä½åˆ†æ•°çº¿ï¼Œå³å¾·åˆ†å’Œæ‰åˆ†å‡ä¸ä½äº L çš„è€ƒç”Ÿæ‰æœ‰èµ„æ ¼è¢«è€ƒè™‘å½•å–ï¼›Hï¼ˆ\u0026lt;100ï¼‰ï¼Œä¸ºä¼˜å…ˆå½•å–çº¿â€”â€”å¾·åˆ†å’Œæ‰åˆ†å‡ä¸ä½äºæ­¤çº¿çš„è¢«å®šä¹‰ä¸ºâ€œæ‰å¾·å…¨å°½â€ï¼Œæ­¤ç±»è€ƒç”ŸæŒ‰å¾·æ‰æ€»åˆ†ä»é«˜åˆ°ä½æ’åºï¼›æ‰åˆ†ä¸åˆ°ä½†å¾·åˆ†åˆ°çº¿çš„ä¸€ç±»è€ƒç”Ÿå±äºâ€œå¾·èƒœæ‰â€ï¼Œä¹ŸæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬ä¸€ç±»è€ƒç”Ÿä¹‹åï¼›å¾·æ‰åˆ†å‡ä½äº Hï¼Œä½†æ˜¯å¾·åˆ†ä¸ä½äºæ‰åˆ†çš„è€ƒç”Ÿå±äºâ€œæ‰å¾·å…¼äº¡â€ä½†å°šæœ‰â€œå¾·èƒœæ‰â€è€…ï¼ŒæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬äºŒç±»è€ƒç”Ÿä¹‹åï¼›å…¶ä»–è¾¾åˆ°æœ€ä½çº¿ L çš„è€ƒç”Ÿä¹ŸæŒ‰æ€»åˆ†æ’åºï¼Œä½†æ’åœ¨ç¬¬ä¸‰ç±»è€ƒç”Ÿä¹‹åã€‚\néšå N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä½è€ƒç”Ÿçš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ï¼šå‡†è€ƒè¯å· å¾·åˆ† æ‰åˆ†ï¼Œå…¶ä¸­å‡†è€ƒè¯å·ä¸º 8 ä½æ•´æ•°ï¼Œå¾·æ‰åˆ†ä¸ºåŒºé—´ [0, 100] å†…çš„æ•´æ•°ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º è¾“å‡ºç¬¬ä¸€è¡Œé¦–å…ˆç»™å‡ºè¾¾åˆ°æœ€ä½åˆ†æ•°çº¿çš„è€ƒç”Ÿäººæ•° Mï¼Œéšå M è¡Œï¼Œæ¯è¡ŒæŒ‰ç…§è¾“å…¥æ ¼å¼è¾“å‡ºä¸€ä½è€ƒç”Ÿçš„ä¿¡æ¯ï¼Œè€ƒç”ŸæŒ‰è¾“å…¥ä¸­è¯´æ˜çš„è§„åˆ™ä»é«˜åˆ°ä½æ’åºã€‚å½“æŸç±»è€ƒç”Ÿä¸­æœ‰å¤šäººæ€»åˆ†ç›¸åŒæ—¶ï¼ŒæŒ‰å…¶å¾·åˆ†é™åºæ’åˆ—ï¼›è‹¥å¾·åˆ†ä¹Ÿå¹¶åˆ—ï¼Œåˆ™æŒ‰å‡†è€ƒè¯å·çš„å‡åºè¾“å‡ºã€‚\næ ·ä¾‹è¾“å…¥ 114 60 80 210000001 64 90 310000002 90 60 410000011 85 80 510000003 85 80 610000004 80 85 710000005 82 77 810000006 83 76 910000007 90 78 1010000008 75 79 1110000009 59 90 1210000010 88 45 1310000012 80 100 1410000013 90 99 1510000014 66 60 æ ·ä¾‹è¾“å‡º 112 210000013 90 99 310000012 80 100 410000003 85 80 510000011 85 80 610000004 80 85 710000007 90 78 810000006 83 76 910000005 82 77 1010000002 90 60 1110000014 66 60 1210000008 75 79 1310000001 64 90 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int n, m; 3 4struct P { 5 int num, d, c; 6 int lv; 7} a[mxn]; 8 9bool cmp(P x, P y) 10{ 11 if (x.lv != y.lv) 12 return x.lv \u0026lt; y.lv; 13 if (x.d + x.c != y.d + y.c) 14 return x.d + x.c \u0026gt; y.d + y.c; 15 if (x.d != y.d) 16 return x.d \u0026gt; y.d; 17 return x.num \u0026lt; y.num; 18} 19 20int l, h; 21 22int main() 23{ 24 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;n, \u0026amp;l, \u0026amp;h); 25 memset(a, 0, sizeof a); 26 27 int num = n; 28 for (int i = 0; i \u0026lt; n; i++) 29 { 30 scanf(\u0026#34;%d %d %d\u0026#34;, \u0026amp;a[i].num, \u0026amp;a[i].d, \u0026amp;a[i].c); 31 if (a[i].d \u0026gt;= h \u0026amp;\u0026amp; a[i].c \u0026gt;= h) 32 a[i].lv = 1; 33 else if (a[i].d \u0026gt;= h \u0026amp;\u0026amp; a[i].c \u0026gt;= l) 34 a[i].lv = 2; 35 else if (a[i].d \u0026gt;= a[i].c \u0026amp;\u0026amp; a[i].d \u0026gt;= l \u0026amp;\u0026amp; a[i].c \u0026gt;= l) 36 a[i].lv = 3; 37 else if (a[i].d \u0026gt;= l \u0026amp;\u0026amp; a[i].c \u0026gt;= l) 38 a[i].lv = 4; 39 else 40 { 41 a[i].lv = 5; 42 num--; 43 } 44 } 45 sort(a, a + n, cmp); 46 47 printf(\u0026#34;%d\\n\u0026#34;, num); 48 for (int i = 0; i \u0026lt; num; i++) 49 printf(\u0026#34;%d %d %d\\n\u0026#34;, a[i].num, a[i].d, a[i].c); 50 51 return 0; 52} ","permalink":"https://blog.lordash.de/posts/solution/patb-1015-%E5%BE%B7%E6%89%8D%E8%AE%BA/","summary":"å¾·æ‰è®º (PATB-1015) é¢˜é¢ å®‹ä»£å²å­¦å®¶å¸é©¬å…‰åœ¨ã€Šèµ„æ²»é€šé‰´ã€‹ä¸­æœ‰ä¸€æ®µè‘—åçš„â€œå¾·æ‰è®ºâ€ï¼šâ€œæ˜¯æ•…æ‰å¾·å…¨å°½è°“ä¹‹åœ£äººï¼Œæ‰å¾·å…¼äº¡è°“ä¹‹æ„šäººï¼Œå¾·èƒœæ‰è°“ä¹‹å›å­ï¼Œæ‰èƒœå¾·è°“ä¹‹å°äºº","title":"PATB-1015 å¾·æ‰è®º"},{"content":"ç¦å°”æ‘©æ–¯çš„çº¦ä¼š (PATB-1014) é¢˜é¢ å¤§ä¾¦æ¢ç¦å°”æ‘©æ–¯æ¥åˆ°ä¸€å¼ å¥‡æ€ªçš„å­—æ¡ï¼šæˆ‘ä»¬çº¦ä¼šå§ï¼ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s\u0026amp;hgsfdk d\u0026amp;Hyscvnmã€‚å¤§ä¾¦æ¢å¾ˆå¿«å°±æ˜ç™½äº†ï¼Œå­—æ¡ä¸Šå¥‡æ€ªçš„ä¹±ç å®é™…ä¸Šå°±æ˜¯çº¦ä¼šçš„æ—¶é—´æ˜ŸæœŸå›› 14:04ï¼Œå› ä¸ºå‰é¢ä¸¤å­—ç¬¦ä¸²ä¸­ç¬¬ 1 å¯¹ç›¸åŒçš„å¤§å†™è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å†™æœ‰åŒºåˆ†ï¼‰æ˜¯ç¬¬ 4 ä¸ªå­—æ¯ Dï¼Œä»£è¡¨æ˜ŸæœŸå››ï¼›ç¬¬ 2 å¯¹ç›¸åŒçš„å­—ç¬¦æ˜¯ E ï¼Œé‚£æ˜¯ç¬¬ 5 ä¸ªè‹±æ–‡å­—æ¯ï¼Œä»£è¡¨ä¸€å¤©é‡Œçš„ç¬¬ 14 ä¸ªé’Ÿå¤´ï¼ˆäºæ˜¯ä¸€å¤©çš„ 0 ç‚¹åˆ° 23 ç‚¹ç”±æ•°å­— 0 åˆ° 9ã€ä»¥åŠå¤§å†™å­—æ¯ A åˆ° N è¡¨ç¤ºï¼‰ï¼›åé¢ä¸¤å­—ç¬¦ä¸²ç¬¬ 1 å¯¹ç›¸åŒçš„è‹±æ–‡å­—æ¯ s å‡ºç°åœ¨ç¬¬ 4 ä¸ªä½ç½®ï¼ˆä» 0 å¼€å§‹è®¡æ•°ï¼‰ä¸Šï¼Œä»£è¡¨ç¬¬ 4 åˆ†é’Ÿã€‚ç°ç»™å®šä¸¤å¯¹å­—ç¬¦ä¸²ï¼Œè¯·å¸®åŠ©ç¦å°”æ‘©æ–¯è§£ç å¾—åˆ°çº¦ä¼šçš„æ—¶é—´ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ 4 è¡Œä¸­åˆ†åˆ«ç»™å‡º 4 ä¸ªéç©ºã€ä¸åŒ…å«ç©ºæ ¼ã€ä¸”é•¿åº¦ä¸è¶…è¿‡ 60 çš„å­—ç¬¦ä¸²ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºçº¦ä¼šçš„æ—¶é—´ï¼Œæ ¼å¼ä¸º DAY HH:MMï¼Œå…¶ä¸­ DAY æ˜¯æŸæ˜ŸæœŸçš„ 3 å­—ç¬¦ç¼©å†™ï¼Œå³ MON è¡¨ç¤ºæ˜ŸæœŸä¸€ï¼ŒTUE è¡¨ç¤ºæ˜ŸæœŸäºŒï¼ŒWED è¡¨ç¤ºæ˜ŸæœŸä¸‰ï¼ŒTHU è¡¨ç¤ºæ˜ŸæœŸå››ï¼ŒFRI è¡¨ç¤ºæ˜ŸæœŸäº”ï¼ŒSAT è¡¨ç¤ºæ˜ŸæœŸå…­ï¼ŒSUN è¡¨ç¤ºæ˜ŸæœŸæ—¥ã€‚é¢˜ç›®è¾“å…¥ä¿è¯æ¯ä¸ªæµ‹è¯•å­˜åœ¨å”¯ä¸€è§£ã€‚\næ ·ä¾‹è¾“å…¥ 13485djDkxh4hhGE 22984akDfkkkkggEdsb 3s\u0026amp;hgsfdk 4d\u0026amp;Hyscvnm æ ·ä¾‹è¾“å‡º 1THU 14:04 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3char day[][5] = { \u0026#34;MON\u0026#34;,\u0026#34;TUE\u0026#34;,\u0026#34;WED\u0026#34;,\u0026#34;THU\u0026#34;,\u0026#34;FRI\u0026#34;,\u0026#34;SAT\u0026#34;,\u0026#34;SUN\u0026#34; }; 4char HH[] = \u0026#34;0123456789ABCDEFGHIJKLMN\u0026#34;; 5char s1[105], s2[105], s3[105], s4[105]; 6 7int main() 8{ 9 scanf(\u0026#34;%s %s %s %s\u0026#34;, s1, s2, s3, s4); 10 11 int len = min(strlen(s1), strlen(s2)), flag = 1; 12 for (int i = 0; i \u0026lt; len; i++) 13 { 14 if (s1[i] == s2[i]) 15 { 16 if (\u0026#39;A\u0026#39; \u0026lt;= s1[i] \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;G\u0026#39; \u0026amp;\u0026amp; flag) 17 { 18 printf(\u0026#34;%s \u0026#34;, day[s1[i] - \u0026#39;A\u0026#39;]); 19 flag = 0; 20 } 21 else if ((isdigit(s1[i]) || (\u0026#39;A\u0026#39; \u0026lt;= s1[i] \u0026amp;\u0026amp; s1[i] \u0026lt;= \u0026#39;N\u0026#39;)) \u0026amp;\u0026amp; !flag) 22 { 23 printf(\u0026#34;%02d:\u0026#34;, strchr(HH, s1[i]) - HH); 24 break; 25 } 26 } 27 } 28 29 len = min(strlen(s3), strlen(s4)); 30 for (int i = 0; i \u0026lt; len; i++) 31 { 32 if (isalpha(s3[i]) \u0026amp;\u0026amp; s3[i] == s4[i]) 33 { 34 printf(\u0026#34;%02d\\n\u0026#34;, i); 35 break; 36 } 37 } 38 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/solution/patb-1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A/","summary":"ç¦å°”æ‘©æ–¯çš„çº¦ä¼š (PATB-1014) é¢˜é¢ å¤§ä¾¦æ¢ç¦å°”æ‘©æ–¯æ¥åˆ°ä¸€å¼ å¥‡æ€ªçš„å­—æ¡ï¼šæˆ‘ä»¬çº¦ä¼šå§ï¼ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s\u0026amp;hgsfdk d\u0026amp;Hyscvnmã€‚å¤§ä¾¦æ¢å¾ˆå¿«å°±æ˜ç™½äº†ï¼Œå­—æ¡ä¸Šå¥‡æ€ªçš„ä¹±ç å®é™…","title":"PATB-1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼š"},{"content":"æ•°ç´ æ•° (PATB-1013) é¢˜é¢ ä»¤ Pi è¡¨ç¤ºç¬¬ i ä¸ªç´ æ•°ã€‚ç°ä»»ç»™ä¸¤ä¸ªæ­£æ•´æ•° Mâ‰¤Nâ‰¤10^4ï¼Œè¯·è¾“å‡º PM åˆ° PN çš„æ‰€æœ‰ç´ æ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º M å’Œ Nï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º è¾“å‡ºä» PM åˆ° PN çš„æ‰€æœ‰ç´ æ•°ï¼Œæ¯ 10 ä¸ªæ•°å­—å  1 è¡Œï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 15 27 æ ·ä¾‹è¾“å‡º 111 13 17 19 23 29 31 37 41 43 247 53 59 61 67 71 73 79 83 89 397 101 103 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e6 + 5; 2bool isP[mxn]; 3int prime[mxn]; 4 5int euler(int n) 6{ 7 memset(isP, 1, sizeof isP); 8 isP[0] = isP[1] = 0; 9 10 int cnt = 0; 11 for (int i = 2; i \u0026lt;= n; i++) 12 { 13 if (isP[i]) prime[++cnt] = i; 14 for (int j = 1; j \u0026lt;= cnt; j++) 15 { 16 if (i * prime[j] \u0026gt; n) break; 17 isP[i * prime[j]] = 0; 18 if (i % prime[j] == 0) break; 19 } 20 } 21 return cnt; 22} 23 24int n, m; 25 26int main() 27{ 28 int cnt = euler(N); 29 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 30 31 int nf = 0, lc = 0; 32 for (int i = n; i \u0026lt;= m; i++) 33 { 34 if (nf) 35 printf(\u0026#34; \u0026#34;); 36 else 37 nf = 1; 38 39 printf(\u0026#34;%d\u0026#34;, prime[i]); 40 lc++; 41 42 if (lc % 10 == 0) 43 { 44 nf = 0; 45 printf(\u0026#34;\\n\u0026#34;); 46 } 47 } 48 49 return 0; 50} ","permalink":"https://blog.lordash.de/posts/solution/patb-1013-%E6%95%B0%E7%B4%A0%E6%95%B0/","summary":"æ•°ç´ æ•° (PATB-1013) é¢˜é¢ ä»¤ Pi è¡¨ç¤ºç¬¬ i ä¸ªç´ æ•°ã€‚ç°ä»»ç»™ä¸¤ä¸ªæ­£æ•´æ•° Mâ‰¤Nâ‰¤10^4ï¼Œè¯·è¾“å‡º PM åˆ° PN çš„æ‰€æœ‰ç´ æ•°ã€‚ è¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º M å’Œ Nï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡º è¾“","title":"PATB-1013 æ•°ç´ æ•°"},{"content":"æ•°å­—åˆ†ç±» (PATB-1012) é¢˜é¢ ç»™å®šä¸€ç³»åˆ—æ­£æ•´æ•°ï¼Œè¯·æŒ‰è¦æ±‚å¯¹æ•°å­—è¿›è¡Œåˆ†ç±»ï¼Œå¹¶è¾“å‡ºä»¥ä¸‹ 5 ä¸ªæ•°å­—ï¼š\nA1 = èƒ½è¢« 5 æ•´é™¤çš„æ•°å­—ä¸­æ‰€æœ‰å¶æ•°çš„å’Œï¼› A2 = å°†è¢« 5 é™¤åä½™ 1 çš„æ•°å­—æŒ‰ç»™å‡ºé¡ºåºè¿›è¡Œäº¤é”™æ±‚å’Œï¼Œå³è®¡ç®— n1âˆ’n2+n3âˆ’n4â‹¯ï¼› A3 = è¢« 5 é™¤åä½™ 2 çš„æ•°å­—çš„ä¸ªæ•°ï¼› A4 = è¢« 5 é™¤åä½™ 3 çš„æ•°å­—çš„å¹³å‡æ•°ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹å 1 ä½ï¼› A5 = è¢« 5 é™¤åä½™ 4 çš„æ•°å­—ä¸­æœ€å¤§æ•°å­—ã€‚ è¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹å…ˆç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° Nï¼Œéšåç»™å‡º N ä¸ªä¸è¶…è¿‡ 1000 çš„å¾…åˆ†ç±»çš„æ­£æ•´æ•°ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹ç»™å®šçš„ N ä¸ªæ­£æ•´æ•°ï¼ŒæŒ‰é¢˜ç›®è¦æ±‚è®¡ç®— A1~A5 å¹¶åœ¨ä¸€è¡Œä¸­é¡ºåºè¾“å‡ºã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†è¡Œæœ«ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚\nè‹¥å…¶ä¸­æŸä¸€ç±»æ•°å­—ä¸å­˜åœ¨ï¼Œåˆ™åœ¨ç›¸åº”ä½ç½®è¾“å‡º Nã€‚\næ ·ä¾‹è¾“å…¥1 113 1 2 3 4 5 6 7 8 9 10 20 16 18 æ ·ä¾‹è¾“å‡º1 130 11 2 9.7 9 æ ·ä¾‹è¾“å…¥2 18 1 2 4 5 6 7 9 16 æ ·ä¾‹è¾“å‡º2 1N 11 2 N 9 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3int main() 4{ 5 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 7 int a1 = 0, a2 = 0, a3 = 0, a5 = 0; 8 int c1 = 0, c2 = 0, c4 = 0, c5 = 0; 9 DB a4 = 0; 10 11 for (int i = 0; i \u0026lt; n; i++) 12 { 13 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 14 switch (m % 5) 15 { 16 case 0: 17 if (m % 2 == 0) 18 { 19 c1++; 20 a1 += m; 21 } 22 break; 23 case 1: 24 c2++; 25 a2 = a2 + m * ((c2 \u0026amp; 1) ? 1 : -1); 26 break; 27 case 2: 28 a3++; 29 break; 30 case 3: 31 c4++, a4 += m; 32 break; 33 case 4: 34 c5++; 35 a5 = max(a5, m); 36 } 37 } 38 if (c1) 39 printf(\u0026#34;%d\u0026#34;, a1); 40 else 41 printf(\u0026#34;N\u0026#34;); 42 43 if (c2) 44 printf(\u0026#34; %d\u0026#34;, a2); 45 else 46 printf(\u0026#34; N\u0026#34;); 47 48 if (a3) 49 printf(\u0026#34; %d\u0026#34;, a3); 50 else 51 printf(\u0026#34; N\u0026#34;); 52 53 if (c4) 54 printf(\u0026#34; %.1lf\u0026#34;, a4 / c4); 55 else 56 printf(\u0026#34; N\u0026#34;); 57 58 if (c5) 59 printf(\u0026#34; %d\u0026#34;, a5); 60 else 61 printf(\u0026#34; N\u0026#34;); 62 63 return 0; 64} ","permalink":"https://blog.lordash.de/posts/solution/patb-1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/","summary":"æ•°å­—åˆ†ç±» (PATB-1012) é¢˜é¢ ç»™å®šä¸€ç³»åˆ—æ­£æ•´æ•°ï¼Œè¯·æŒ‰è¦æ±‚å¯¹æ•°å­—è¿›è¡Œåˆ†ç±»ï¼Œå¹¶è¾“å‡ºä»¥ä¸‹ 5 ä¸ªæ•°å­—ï¼š A1 = èƒ½è¢« 5 æ•´é™¤çš„æ•°å­—ä¸­æ‰€æœ‰å¶æ•°çš„å’Œï¼› A2 = å°†è¢« 5 é™¤åä½™ 1 çš„æ•°å­—æŒ‰ç»™","title":"PATB-1012 æ•°å­—åˆ†ç±»"},{"content":"A+B å’Œ C (PATB-1011) é¢˜é¢ ç»™å®šåŒºé—´ [âˆ’2^31,2^31] å†…çš„ 3 ä¸ªæ•´æ•° Aã€B å’Œ Cï¼Œè¯·åˆ¤æ–­ A+B æ˜¯å¦å¤§äº Cã€‚\nè¾“å…¥ è¾“å…¥ç¬¬ 1 è¡Œç»™å‡ºæ­£æ•´æ•° T (â‰¤10)ï¼Œæ˜¯æµ‹è¯•ç”¨ä¾‹çš„ä¸ªæ•°ã€‚éšåç»™å‡º T ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ç»„å ä¸€è¡Œï¼Œé¡ºåºç»™å‡º Aã€B å’Œ Cã€‚æ•´æ•°é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º å¯¹æ¯ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡º Case #X: true å¦‚æœ A+B\u0026gt;Cï¼Œå¦åˆ™è¾“å‡º Case #X: falseï¼Œå…¶ä¸­ X æ˜¯æµ‹è¯•ç”¨ä¾‹çš„ç¼–å·ï¼ˆä» 1 å¼€å§‹ï¼‰ã€‚\næ ·ä¾‹è¾“å…¥ 14 21 2 3 32 3 4 42147483647 0 2147483646 50 -2147483648 -2147483647 æ ·ä¾‹è¾“å‡º 1Case #1: false 2Case #2: true 3Case #3: true 4Case #4: false æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3int main() 4{ 5 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 for (int i = 1; i \u0026lt;= n; i++) 7 { 8 LL a, b, c; 9 scanf(\u0026#34;%lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c); 10 printf(\u0026#34;Case #%d: \u0026#34;, i); 11 if (a + b \u0026gt; c) 12 printf(\u0026#34;true\\n\u0026#34;); 13 else 14 printf(\u0026#34;false\\n\u0026#34;); 15 } 16 return 0; 17} ","permalink":"https://blog.lordash.de/posts/solution/patb-1011-a+b-%E5%92%8C-c/","summary":"A+B å’Œ C (PATB-1011) é¢˜é¢ ç»™å®šåŒºé—´ [âˆ’2^31,2^31] å†…çš„ 3 ä¸ªæ•´æ•° Aã€B å’Œ Cï¼Œè¯·åˆ¤æ–­ A+B æ˜¯å¦å¤§äº Cã€‚ è¾“å…¥ è¾“å…¥ç¬¬ 1 è¡Œç»™å‡ºæ­£æ•´æ•° T (â‰¤10)ï¼Œæ˜¯æµ‹è¯•ç”¨ä¾‹çš„ä¸ª","title":"PATB-1011 A+B å’Œ C"},{"content":"ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼ (PATB-1010) é¢˜é¢ è®¾è®¡å‡½æ•°æ±‚ä¸€å…ƒå¤šé¡¹å¼çš„å¯¼æ•°ã€‚ï¼ˆæ³¨ï¼šx^nï¼ˆnä¸ºæ•´æ•°ï¼‰çš„ä¸€é˜¶å¯¼æ•°ä¸ºnx^nâˆ’1ã€‚ï¼‰\nè¾“å…¥ ä»¥æŒ‡æ•°é€’é™æ–¹å¼è¾“å…¥å¤šé¡¹å¼éé›¶é¡¹ç³»æ•°å’ŒæŒ‡æ•°ï¼ˆç»å¯¹å€¼å‡ä¸ºä¸è¶…è¿‡ 1000 çš„æ•´æ•°ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º ä»¥ä¸è¾“å…¥ç›¸åŒçš„æ ¼å¼è¾“å‡ºå¯¼æ•°å¤šé¡¹å¼éé›¶é¡¹çš„ç³»æ•°å’ŒæŒ‡æ•°ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†ç»“å°¾ä¸èƒ½æœ‰å¤šä½™ç©ºæ ¼ã€‚æ³¨æ„â€œé›¶å¤šé¡¹å¼â€çš„æŒ‡æ•°å’Œç³»æ•°éƒ½æ˜¯ 0ï¼Œä½†æ˜¯è¡¨ç¤ºä¸º 0 0ã€‚\næ ·ä¾‹è¾“å…¥ 13 4 -5 2 6 1 -2 0 æ ·ä¾‹è¾“å‡º 112 3 -10 1 6 0 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3int main() 4{ 5 int nf = 0; 6 while (~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m) \u0026amp;\u0026amp; m) 7 { 8 if (nf) 9 printf(\u0026#34; \u0026#34;); 10 else 11 nf = 1; 12 printf(\u0026#34;%d %d\u0026#34;, n * m, m - 1); 13 } 14 if (!nf) 15 printf(\u0026#34;0 0\u0026#34;); 16 17 printf(\u0026#34;\\n\u0026#34;); 18 return 0; 19} ","permalink":"https://blog.lordash.de/posts/solution/patb-1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/","summary":"ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼ (PATB-1010) é¢˜é¢ è®¾è®¡å‡½æ•°æ±‚ä¸€å…ƒå¤šé¡¹å¼çš„å¯¼æ•°ã€‚ï¼ˆæ³¨ï¼šx^nï¼ˆnä¸ºæ•´æ•°ï¼‰çš„ä¸€é˜¶å¯¼æ•°ä¸ºnx^nâˆ’1ã€‚ï¼‰ è¾“å…¥ ä»¥æŒ‡æ•°é€’é™æ–¹å¼è¾“å…¥å¤šé¡¹å¼éé›¶é¡¹ç³»æ•°å’Œ","title":"PATB-1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼"},{"content":"è¯´åè¯ (PATB-1009) é¢˜é¢ ç»™å®šä¸€å¥è‹±è¯­ï¼Œè¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œå°†å¥ä¸­æ‰€æœ‰å•è¯çš„é¡ºåºé¢ å€’è¾“å‡ºã€‚\nè¾“å…¥ æµ‹è¯•è¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œå†…ç»™å‡ºæ€»é•¿åº¦ä¸è¶…è¿‡ 80 çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²ç”±è‹¥å¹²å•è¯å’Œè‹¥å¹²ç©ºæ ¼ç»„æˆï¼Œå…¶ä¸­å•è¯æ˜¯ç”±è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å†™æœ‰åŒºåˆ†ï¼‰ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå•è¯ä¹‹é—´ç”¨ 1 ä¸ªç©ºæ ¼åˆ†å¼€ï¼Œè¾“å…¥ä¿è¯å¥å­æœ«å°¾æ²¡æœ‰å¤šä½™çš„ç©ºæ ¼ã€‚\nè¾“å‡º æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼Œè¾“å‡ºå€’åºåçš„å¥å­ã€‚\næ ·ä¾‹è¾“å…¥ 1Hello World Here I Come æ ·ä¾‹è¾“å‡º 1Come I Here World Hello æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3char s[105][105]; 4 5int main() 6{ 7 for (n = 0; ~scanf(\u0026#34;%s\u0026#34;, s[n]); n++); 8 for (int i=n-1; i \u0026gt;= 0; i--) 9 { 10 if (i != n - 1) 11 printf(\u0026#34; \u0026#34;); 12 printf(\u0026#34;%s\u0026#34;, s[i]); 13 } 14 15 printf(\u0026#34;\\n\u0026#34;); 16 return 0; 17} ","permalink":"https://blog.lordash.de/posts/solution/patb-1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/","summary":"è¯´åè¯ (PATB-1009) é¢˜é¢ ç»™å®šä¸€å¥è‹±è¯­ï¼Œè¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œå°†å¥ä¸­æ‰€æœ‰å•è¯çš„é¡ºåºé¢ å€’è¾“å‡ºã€‚ è¾“å…¥ æµ‹è¯•è¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œå†…ç»™å‡ºæ€»é•¿åº¦ä¸è¶…è¿‡ 80 çš„å­—ç¬¦ä¸²ã€‚å­—","title":"PATB-1009 è¯´åè¯"},{"content":"æ•°ç»„å…ƒç´ å¾ªç¯å³ç§»é—®é¢˜ (PATB-1008) é¢˜é¢ ä¸€ä¸ªæ•°ç»„Aä¸­å­˜æœ‰Nï¼ˆ\u0026gt;0ï¼‰ä¸ªæ•´æ•°ï¼Œåœ¨ä¸å…è®¸ä½¿ç”¨å¦å¤–æ•°ç»„çš„å‰æä¸‹ï¼Œå°†æ¯ä¸ªæ•´æ•°å¾ªç¯å‘å³ç§»Mï¼ˆâ‰¥0ï¼‰ä¸ªä½ç½®ï¼Œå³å°†Aä¸­çš„æ•°æ®ç”±ï¼ˆA0A1â‹¯ANâˆ’1ï¼‰å˜æ¢ä¸ºï¼ˆANâˆ’Mâ‹¯ANâˆ’1A0A1â‹¯ANâˆ’Mâˆ’1ï¼‰ï¼ˆæœ€åMä¸ªæ•°å¾ªç¯ç§»è‡³æœ€å‰é¢çš„Mä¸ªä½ç½®ï¼‰ã€‚å¦‚æœéœ€è¦è€ƒè™‘ç¨‹åºç§»åŠ¨æ•°æ®çš„æ¬¡æ•°å°½é‡å°‘ï¼Œè¦å¦‚ä½•è®¾è®¡ç§»åŠ¨çš„æ–¹æ³•ï¼Ÿ\nè¾“å…¥ æ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œç¬¬1è¡Œè¾“å…¥Nï¼ˆ1â‰¤Nâ‰¤100ï¼‰å’ŒMï¼ˆâ‰¥0ï¼‰ï¼›ç¬¬2è¡Œè¾“å…¥Nä¸ªæ•´æ•°ï¼Œä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºå¾ªç¯å³ç§»Mä½ä»¥åçš„æ•´æ•°åºåˆ—ï¼Œä¹‹é—´ç”¨ç©ºæ ¼åˆ†éš”ï¼Œåºåˆ—ç»“å°¾ä¸èƒ½æœ‰å¤šä½™ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 16 2 21 2 3 4 5 6 æ ·ä¾‹è¾“å‡º 15 6 1 2 3 4 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int a[mxn]; 3 4int main() 5{ 6 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); 7 for (int i = 0; i \u0026lt; n; i++) 8 { 9 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 10 } 11 12 int nf = 0, t = n - (m % n); 13 for (int i = t; i \u0026lt; n; i++) 14 { 15 if (nf) 16 printf(\u0026#34; \u0026#34;); 17 else 18 nf = 1; 19 printf(\u0026#34;%d\u0026#34;, a[i]); 20 } 21 for (int i = 0; i \u0026lt; t; i++) 22 { 23 if (nf) 24 printf(\u0026#34; \u0026#34;); 25 else 26 nf = 1; 27 printf(\u0026#34;%d\u0026#34;, a[i]); 28 } 29 30 printf(\u0026#34;\\n\u0026#34;); 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/patb-1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/","summary":"æ•°ç»„å…ƒç´ å¾ªç¯å³ç§»é—®é¢˜ (PATB-1008) é¢˜é¢ ä¸€ä¸ªæ•°ç»„Aä¸­å­˜æœ‰Nï¼ˆ\u0026gt;0ï¼‰ä¸ªæ•´æ•°ï¼Œåœ¨ä¸å…è®¸ä½¿ç”¨å¦å¤–æ•°ç»„çš„å‰æä¸‹ï¼Œå°†æ¯ä¸ªæ•´æ•°å¾ªç¯å‘å³ç§»Mï¼ˆâ‰¥0ï¼‰ä¸ªä½ç½®ï¼Œå³å°†A","title":"PATB-1008 æ•°ç»„å…ƒç´ å¾ªç¯å³ç§»é—®é¢˜"},{"content":"ç´ æ•°å¯¹çŒœæƒ³ (PATB-1007) é¢˜é¢ è®©æˆ‘ä»¬å®šä¹‰dnä¸ºï¼šdn=pn+1âˆ’pnï¼Œå…¶ä¸­piæ˜¯ç¬¬iä¸ªç´ æ•°ã€‚æ˜¾ç„¶æœ‰d1=1ï¼Œä¸”å¯¹äºn\u0026gt;1æœ‰dnæ˜¯å¶æ•°ã€‚â€œç´ æ•°å¯¹çŒœæƒ³â€è®¤ä¸ºâ€œå­˜åœ¨æ— ç©·å¤šå¯¹ç›¸é‚»ä¸”å·®ä¸º2çš„ç´ æ•°â€ã€‚\nç°ç»™å®šä»»æ„æ­£æ•´æ•°N(\u0026lt;10^5)ï¼Œè¯·è®¡ç®—ä¸è¶…è¿‡Nçš„æ»¡è¶³çŒœæƒ³çš„ç´ æ•°å¯¹çš„ä¸ªæ•°ã€‚\nè¾“å…¥ è¾“å…¥åœ¨ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nã€‚\nè¾“å‡º åœ¨ä¸€è¡Œä¸­è¾“å‡ºä¸è¶…è¿‡Nçš„æ»¡è¶³çŒœæƒ³çš„ç´ æ•°å¯¹çš„ä¸ªæ•°ã€‚\næ ·ä¾‹è¾“å…¥ 120 æ ·ä¾‹è¾“å‡º 14 æç¤º æ— \næ€è·¯ ä»£ç  1const int mxn = 1e5 + 5; 2int n, m; 3 4bool isP[mxn]; 5int prime[mxn]; 6 7int euler(int n) 8{ 9 memset(isP, 1, sizeof isP); 10 isP[0] = isP[1] = 0; 11 12 int cnt = 0; 13 for (int i = 2; i \u0026lt;= n; i++) 14 { 15 if (isP[i]) prime[++cnt] = i; 16 for (int j = 1; j \u0026lt;= cnt; j++) 17 { 18 if (i * prime[j] \u0026gt; n) break; 19 isP[i * prime[j]] = 0; 20 if (i % prime[j] == 0) break; 21 } 22 } 23 return cnt; 24} 25 26int a[mxn]; 27 28int main() 29{ 30 int cnt = euler(N); 31 memset(a, 0, sizeof a); 32 for (int i = 3; i \u0026lt;= N; i++) 33 { 34 if (isP[i] \u0026amp;\u0026amp; isP[i - 2]) 35 a[i] = a[i - 1] + 1; 36 else 37 a[i] = a[i - 1]; 38 } 39 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 40 printf(\u0026#34;%d\\n\u0026#34;, a[n]); 41 return 0; 42} ","permalink":"https://blog.lordash.de/posts/solution/patb-1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/","summary":"ç´ æ•°å¯¹çŒœæƒ³ (PATB-1007) é¢˜é¢ è®©æˆ‘ä»¬å®šä¹‰dnä¸ºï¼šdn=pn+1âˆ’pnï¼Œå…¶ä¸­piæ˜¯ç¬¬iä¸ªç´ æ•°ã€‚æ˜¾ç„¶æœ‰d1=1ï¼Œä¸”å¯¹äºn\u0026gt;1æœ‰dnæ˜¯å¶æ•°ã€‚â€œç´ æ•°å¯¹çŒœæƒ³â€","title":"PATB-1007 ç´ æ•°å¯¹çŒœæƒ³"},{"content":"æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•° (PATB-1006) é¢˜é¢ è®©æˆ‘ä»¬ç”¨å­—æ¯ B æ¥è¡¨ç¤ºâ€œç™¾â€ã€å­—æ¯ S è¡¨ç¤ºâ€œåâ€ï¼Œç”¨ 12...n æ¥è¡¨ç¤ºä¸ä¸ºé›¶çš„ä¸ªä½æ•°å­— nï¼ˆ\u0026lt;10ï¼‰ï¼Œæ¢ä¸ªæ ¼å¼æ¥è¾“å‡ºä»»ä¸€ä¸ªä¸è¶…è¿‡ 3 ä½çš„æ­£æ•´æ•°ã€‚ä¾‹å¦‚ 234 åº”è¯¥è¢«è¾“å‡ºä¸º BBSSS1234ï¼Œå› ä¸ºå®ƒæœ‰ 2 ä¸ªâ€œç™¾â€ã€3 ä¸ªâ€œåâ€ã€ä»¥åŠä¸ªä½çš„ 4ã€‚\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œç»™å‡ºæ­£æ•´æ•° nï¼ˆ\u0026lt;1000ï¼‰ã€‚\nè¾“å‡º æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼Œç”¨è§„å®šçš„æ ¼å¼è¾“å‡º nã€‚\næ ·ä¾‹è¾“å…¥1 1234 æ ·ä¾‹è¾“å‡º1 1BBSSS1234 æ ·ä¾‹è¾“å…¥2 123 æ ·ä¾‹è¾“å‡º2 1SS123 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3int main() 4{ 5 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 6 int b = n / 100; 7 for (int i = 0; i \u0026lt; b; i++) 8 printf(\u0026#34;B\u0026#34;); 9 int s = n / 10 % 10; 10 for (int i = 0; i \u0026lt; s; i++) 11 printf(\u0026#34;S\u0026#34;); 12 int x = n % 10; 13 for (int i = 1; i \u0026lt;= x; i++) 14 printf(\u0026#34;%d\u0026#34;, i); 15 16 printf(\u0026#34;\\n\u0026#34;); 17 return 0; 18} ","permalink":"https://blog.lordash.de/posts/solution/patb-1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/","summary":"æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•° (PATB-1006) é¢˜é¢ è®©æˆ‘ä»¬ç”¨å­—æ¯ B æ¥è¡¨ç¤ºâ€œç™¾â€ã€å­—æ¯ S è¡¨ç¤ºâ€œåâ€ï¼Œç”¨ 12...n æ¥è¡¨ç¤ºä¸ä¸ºé›¶çš„ä¸ªä½æ•°å­— nï¼ˆ\u0026lt;10ï¼‰ï¼Œæ¢ä¸ªæ ¼å¼æ¥è¾“å‡ºä»»ä¸€ä¸ªä¸è¶…è¿‡","title":"PATB-1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•°"},{"content":"ç»§ç»­(3n+1)çŒœæƒ³ (PATB-1005) é¢˜é¢ å¡æ‹‰å…¹(Callatz)çŒœæƒ³å·²ç»åœ¨1001ä¸­ç»™å‡ºäº†æè¿°ã€‚åœ¨è¿™ä¸ªé¢˜ç›®é‡Œï¼Œæƒ…å†µç¨å¾®æœ‰äº›å¤æ‚ã€‚\nå½“æˆ‘ä»¬éªŒè¯å¡æ‹‰å…¹çŒœæƒ³çš„æ—¶å€™ï¼Œä¸ºäº†é¿å…é‡å¤è®¡ç®—ï¼Œå¯ä»¥è®°å½•ä¸‹é€’æ¨è¿‡ç¨‹ä¸­é‡åˆ°çš„æ¯ä¸€ä¸ªæ•°ã€‚ä¾‹å¦‚å¯¹ n=3 è¿›è¡ŒéªŒè¯çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®— 3ã€5ã€8ã€4ã€2ã€1ï¼Œåˆ™å½“æˆ‘ä»¬å¯¹ n=5ã€8ã€4ã€2 è¿›è¡ŒéªŒè¯çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç›´æ¥åˆ¤å®šå¡æ‹‰å…¹çŒœæƒ³çš„çœŸä¼ªï¼Œè€Œä¸éœ€è¦é‡å¤è®¡ç®—ï¼Œå› ä¸ºè¿™ 4 ä¸ªæ•°å·²ç»åœ¨éªŒè¯3çš„æ—¶å€™é‡åˆ°è¿‡äº†ï¼Œæˆ‘ä»¬ç§° 5ã€8ã€4ã€2 æ˜¯è¢« 3â€œè¦†ç›–â€çš„æ•°ã€‚æˆ‘ä»¬ç§°ä¸€ä¸ªæ•°åˆ—ä¸­çš„æŸä¸ªæ•° n ä¸ºâ€œå…³é”®æ•°â€ï¼Œå¦‚æœ n ä¸èƒ½è¢«æ•°åˆ—ä¸­çš„å…¶ä»–æ•°å­—æ‰€è¦†ç›–ã€‚\nç°åœ¨ç»™å®šä¸€ç³»åˆ—å¾…éªŒè¯çš„æ•°å­—ï¼Œæˆ‘ä»¬åªéœ€è¦éªŒè¯å…¶ä¸­çš„å‡ ä¸ªå…³é”®æ•°ï¼Œå°±å¯ä»¥ä¸å¿…å†é‡å¤éªŒè¯ä½™ä¸‹çš„æ•°å­—ã€‚ä½ çš„ä»»åŠ¡å°±æ˜¯æ‰¾å‡ºè¿™äº›å…³é”®æ•°å­—ï¼Œå¹¶æŒ‰ä»å¤§åˆ°å°çš„é¡ºåºè¾“å‡ºå®ƒä»¬ã€‚\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œç¬¬ 1 è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° K (\u0026lt;100)ï¼Œç¬¬ 2 è¡Œç»™å‡º K ä¸ªäº’ä¸ç›¸åŒçš„å¾…éªŒè¯çš„æ­£æ•´æ•° n (1\u0026lt;nâ‰¤100)çš„å€¼ï¼Œæ•°å­—é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚\nè¾“å‡º æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼ŒæŒ‰ä»å¤§åˆ°å°çš„é¡ºåºè¾“å‡ºå…³é”®æ•°å­—ã€‚æ•°å­—é—´ç”¨ 1 ä¸ªç©ºæ ¼éš”å¼€ï¼Œä½†ä¸€è¡Œä¸­æœ€åä¸€ä¸ªæ•°å­—åæ²¡æœ‰ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 16 23 5 6 7 8 11 æ ·ä¾‹è¾“å‡º 17 6 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3int vis[105]; 4 5int main() 6{ 7 memset(vis, 0, sizeof vis); 8 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 9 for (int i = 0; i \u0026lt; n; i++) 10 { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 12 vis[m] = 1; 13 } 14 15 for (int i = 100; i \u0026gt;= 1; i--) 16 { 17 if (!vis[i]) 18 continue; 19 20 for (int t = i; t != 1;) 21 { 22 if (t \u0026amp; 1) 23 t = (3 * t + 1) / 2; 24 else 25 t = t / 2; 26 27 if (t \u0026lt;= 100) 28 vis[t] = 0; 29 } 30 } 31 int nf = 0; 32 for (int i = 100; i \u0026gt;= 1; i--) 33 { 34 if (vis[i]) 35 { 36 if (nf) 37 printf(\u0026#34; \u0026#34;); 38 else 39 nf = 1; 40 printf(\u0026#34;%d\u0026#34;, i); 41 } 42 } 43 44 printf(\u0026#34;\\n\u0026#34;); 45 return 0; 46} ","permalink":"https://blog.lordash.de/posts/solution/patb-1005-%E7%BB%A7%E7%BB%AD3n+1%E7%8C%9C%E6%83%B3/","summary":"ç»§ç»­(3n+1)çŒœæƒ³ (PATB-1005) é¢˜é¢ å¡æ‹‰å…¹(Callatz)çŒœæƒ³å·²ç»åœ¨1001ä¸­ç»™å‡ºäº†æè¿°ã€‚åœ¨è¿™ä¸ªé¢˜ç›®é‡Œï¼Œæƒ…å†µç¨å¾®æœ‰äº›å¤æ‚ã€‚ å½“æˆ‘ä»¬éªŒè¯å¡æ‹‰å…¹çŒœæƒ³çš„æ—¶å€™","title":"PATB-1005 ç»§ç»­(3n+1)çŒœæƒ³"},{"content":"æˆç»©æ’å (PATB-1004) é¢˜é¢ è¯»å…¥ nï¼ˆ\u0026gt;0ï¼‰åå­¦ç”Ÿçš„å§“åã€å­¦å·ã€æˆç»©ï¼Œåˆ†åˆ«è¾“å‡ºæˆç»©æœ€é«˜å’Œæˆç»©æœ€ä½å­¦ç”Ÿçš„å§“åå’Œå­¦å·ã€‚\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ ¼å¼ä¸º\n1ç¬¬ 1 è¡Œï¼šæ­£æ•´æ•° n 2ç¬¬ 2 è¡Œï¼šç¬¬ 1 ä¸ªå­¦ç”Ÿçš„å§“å å­¦å· æˆç»© 3ç¬¬ 3 è¡Œï¼šç¬¬ 2 ä¸ªå­¦ç”Ÿçš„å§“å å­¦å· æˆç»© 4 ... ... ... 5ç¬¬ n+1 è¡Œï¼šç¬¬ n ä¸ªå­¦ç”Ÿçš„å§“å å­¦å· æˆç»© å…¶ä¸­å§“åå’Œå­¦å·å‡ä¸ºä¸è¶…è¿‡ 10 ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œæˆç»©ä¸º 0 åˆ° 100 ä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼Œè¿™é‡Œä¿è¯åœ¨ä¸€ç»„æµ‹è¯•ç”¨ä¾‹ä¸­æ²¡æœ‰ä¸¤ä¸ªå­¦ç”Ÿçš„æˆç»©æ˜¯ç›¸åŒçš„ã€‚\nè¾“å‡º å¯¹æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹è¾“å‡º 2 è¡Œï¼Œç¬¬ 1 è¡Œæ˜¯æˆç»©æœ€é«˜å­¦ç”Ÿçš„å§“åå’Œå­¦å·ï¼Œç¬¬ 2 è¡Œæ˜¯æˆç»©æœ€ä½å­¦ç”Ÿçš„å§“åå’Œå­¦å·ï¼Œå­—ç¬¦ä¸²é—´æœ‰ 1 ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 13 2Joe Math990112 89 3Mike CS991301 100 4Mary EE990830 95 æ ·ä¾‹è¾“å‡º 1Mike CS991301 2Joe Math990112 æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3struct P { 4 char a[15]; 5 char b[15]; 6 int c; 7}; 8 9int main(void) 10{ 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 12 P t; 13 scanf(\u0026#34;%s %s %d\u0026#34;, t.a, t.b, \u0026amp;t.c); 14 P mx = t, mi = t; 15 n--; 16 17 while (n--) 18 { 19 scanf(\u0026#34;%s %s %d\u0026#34;, t.a, t.b, \u0026amp;t.c); 20 if (t.c \u0026gt; mx.c) 21 mx = t; 22 if (t.c \u0026lt; mi.c) 23 mi = t; 24 } 25 printf(\u0026#34;%s %s\\n\u0026#34;, mx.a, mx.b); 26 printf(\u0026#34;%s %s\\n\u0026#34;, mi.a, mi.b); 27} ","permalink":"https://blog.lordash.de/posts/solution/patb-1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/","summary":"æˆç»©æ’å (PATB-1004) é¢˜é¢ è¯»å…¥ nï¼ˆ\u0026gt;0ï¼‰åå­¦ç”Ÿçš„å§“åã€å­¦å·ã€æˆç»©ï¼Œåˆ†åˆ«è¾“å‡ºæˆç»©æœ€é«˜å’Œæˆç»©æœ€ä½å­¦ç”Ÿçš„å§“åå’Œå­¦å·ã€‚ è¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ ¼","title":"PATB-1004 æˆç»©æ’å"},{"content":"æˆ‘è¦é€šè¿‡ï¼ (PATB-1003) é¢˜é¢ â€œç­”æ¡ˆæ­£ç¡®â€æ˜¯è‡ªåŠ¨åˆ¤é¢˜ç³»ç»Ÿç»™å‡ºçš„æœ€ä»¤äººæ¬¢å–œçš„å›å¤ã€‚æœ¬é¢˜å±äº PAT çš„â€œç­”æ¡ˆæ­£ç¡®â€å¤§æ´¾é€ â€”â€” åªè¦è¯»å…¥çš„å­—ç¬¦ä¸²æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼Œç³»ç»Ÿå°±è¾“å‡ºâ€œç­”æ¡ˆæ­£ç¡®â€ï¼Œå¦åˆ™è¾“å‡ºâ€œç­”æ¡ˆé”™è¯¯â€ã€‚\nå¾—åˆ°â€œç­”æ¡ˆæ­£ç¡®â€çš„æ¡ä»¶æ˜¯ï¼š\nå­—ç¬¦ä¸²ä¸­å¿…é¡»ä»…æœ‰ Pã€ Aã€ Tè¿™ä¸‰ç§å­—ç¬¦ï¼Œä¸å¯ä»¥åŒ…å«å…¶å®ƒå­—ç¬¦ï¼› ä»»æ„å½¢å¦‚ xPATx çš„å­—ç¬¦ä¸²éƒ½å¯ä»¥è·å¾—â€œç­”æ¡ˆæ­£ç¡®â€ï¼Œå…¶ä¸­ x æˆ–è€…æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œæˆ–è€…æ˜¯ä»…ç”±å­—æ¯ A ç»„æˆçš„å­—ç¬¦ä¸²ï¼› å¦‚æœ aPbTc æ˜¯æ­£ç¡®çš„ï¼Œé‚£ä¹ˆ aPbATca ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼Œå…¶ä¸­ aã€ bã€ c å‡æˆ–è€…æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œæˆ–è€…æ˜¯ä»…ç”±å­—æ¯ A ç»„æˆçš„å­—ç¬¦ä¸²ã€‚ ç°åœ¨å°±è¯·ä½ ä¸º PAT å†™ä¸€ä¸ªè‡ªåŠ¨è£åˆ¤ç¨‹åºï¼Œåˆ¤å®šå“ªäº›å­—ç¬¦ä¸²æ˜¯å¯ä»¥è·å¾—â€œç­”æ¡ˆæ­£ç¡®â€çš„ã€‚\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚ç¬¬ 1 è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° n (\u0026lt;10)ï¼Œæ˜¯éœ€è¦æ£€æµ‹çš„å­—ç¬¦ä¸²ä¸ªæ•°ã€‚æ¥ä¸‹æ¥æ¯ä¸ªå­—ç¬¦ä¸²å ä¸€è¡Œï¼Œå­—ç¬¦ä¸²é•¿åº¦ä¸è¶…è¿‡ 100ï¼Œä¸”ä¸åŒ…å«ç©ºæ ¼ã€‚\nè¾“å‡º æ¯ä¸ªå­—ç¬¦ä¸²çš„æ£€æµ‹ç»“æœå ä¸€è¡Œï¼Œå¦‚æœè¯¥å­—ç¬¦ä¸²å¯ä»¥è·å¾—â€œç­”æ¡ˆæ­£ç¡®â€ï¼Œåˆ™è¾“å‡º YESï¼Œå¦åˆ™è¾“å‡º NOã€‚\næ ·ä¾‹è¾“å…¥ 18 2PAT 3PAAT 4AAPATAA 5AAPAATAAAA 6xPATx 7PT 8Whatever 9APAAATAA æ ·ä¾‹è¾“å‡º 1YES 2YES 3YES 4YES 5NO 6NO 7NO 8NO æç¤º æ— \næ€è·¯ ä»£ç  1int n, m; 2 3char s[105]; 4 5int main(void) 6{ 7 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 8 while (n--) 9 { 10 int err = 0, p = 0, t = 0; 11 int la = 0, ma = 0, ra = 0; 12 13 scanf(\u0026#34;%s\u0026#34;, s); 14 int len = strlen(s); 15 16 for (int i = 0; i \u0026lt; len; i++) 17 { 18 if (s[i] == \u0026#39;P\u0026#39;) 19 { 20 p++; 21 } 22 else if (s[i] == \u0026#39;A\u0026#39;) 23 { 24 if (!p) 25 la++; 26 else if (!t) 27 ma++; 28 else if (t) 29 ra++; 30 } 31 else if (s[i] == \u0026#39;T\u0026#39;) 32 { 33 if (p \u0026amp;\u0026amp; ma) 34 t++; 35 else 36 err = 1; 37 } 38 else 39 { 40 err = 1; 41 } 42 } 43 44 if (p != 1 || ma == 0 || t != 1 || la * ma != ra) 45 { 46 err = 1; 47 } 48 49 if (err) 50 printf(\u0026#34;NO\\n\u0026#34;); 51 else 52 printf(\u0026#34;YES\\n\u0026#34;); 53 } 54} ","permalink":"https://blog.lordash.de/posts/solution/patb-1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87/","summary":"æˆ‘è¦é€šè¿‡ï¼ (PATB-1003) é¢˜é¢ â€œç­”æ¡ˆæ­£ç¡®â€æ˜¯è‡ªåŠ¨åˆ¤é¢˜ç³»ç»Ÿç»™å‡ºçš„æœ€ä»¤äººæ¬¢å–œçš„å›å¤ã€‚æœ¬é¢˜å±äº PAT çš„â€œç­”æ¡ˆæ­£ç¡®â€å¤§æ´¾é€ â€”â€” åªè¦è¯»å…¥çš„å­—ç¬¦ä¸²æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼Œç³»ç»Ÿå°±è¾“å‡º","title":"PATB-1003 æˆ‘è¦é€šè¿‡ï¼"},{"content":"å†™å‡ºè¿™ä¸ªæ•° (PATB-1002) é¢˜é¢ è¯»å…¥ä¸€ä¸ªæ­£æ•´æ•° nï¼Œè®¡ç®—å…¶å„ä½æ•°å­—ä¹‹å’Œï¼Œç”¨æ±‰è¯­æ‹¼éŸ³å†™å‡ºå’Œçš„æ¯ä¸€ä½æ•°å­—ã€‚\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³ç»™å‡ºè‡ªç„¶æ•° n çš„å€¼ã€‚è¿™é‡Œä¿è¯ n å°äº 10^100ã€‚\nè¾“å‡º åœ¨ä¸€è¡Œå†…è¾“å‡º n çš„å„ä½æ•°å­—ä¹‹å’Œçš„æ¯ä¸€ä½ï¼Œæ‹¼éŸ³æ•°å­—é—´æœ‰ 1 ç©ºæ ¼ï¼Œä½†ä¸€è¡Œä¸­æœ€åä¸€ä¸ªæ‹¼éŸ³æ•°å­—åæ²¡æœ‰ç©ºæ ¼ã€‚\næ ·ä¾‹è¾“å…¥ 11234567890987654321123456789 æ ·ä¾‹è¾“å‡º 1yi san wu æç¤º æ— \næ€è·¯ ä»£ç  1int T; 2int n, m; 3 4char s[][5] = { 5 \u0026#34;ling\u0026#34;, \u0026#34;yi\u0026#34;, \u0026#34;er\u0026#34;, \u0026#34;san\u0026#34;, \u0026#34;si\u0026#34;, 6 \u0026#34;wu\u0026#34;, \u0026#34;liu\u0026#34;, \u0026#34;qi\u0026#34;, \u0026#34;ba\u0026#34;, \u0026#34;jiu\u0026#34; 7}; 8 9char c; 10 11int main() 12{ 13 n = 0; 14 while (~scanf(\u0026#34;%c\u0026#34;, \u0026amp;c) \u0026amp;\u0026amp; c != \u0026#39;\\n\u0026#39;) 15 { 16 n += c - \u0026#39;0\u0026#39;; 17 } 18 char t[5] = \u0026#34;\u0026#34;; 19 sprintf(t, \u0026#34;%d\u0026#34;, n); 20 int len = strlen(t); 21 for (int i = 0; i \u0026lt; len; i++) 22 { 23 if (i) 24 printf(\u0026#34; \u0026#34;); 25 printf(\u0026#34;%s\u0026#34;, s[t[i] - \u0026#39;0\u0026#39;]); 26 } 27} ","permalink":"https://blog.lordash.de/posts/solution/patb-1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/","summary":"å†™å‡ºè¿™ä¸ªæ•° (PATB-1002) é¢˜é¢ è¯»å…¥ä¸€ä¸ªæ­£æ•´æ•° nï¼Œè®¡ç®—å…¶å„ä½æ•°å­—ä¹‹å’Œï¼Œç”¨æ±‰è¯­æ‹¼éŸ³å†™å‡ºå’Œçš„æ¯ä¸€ä½æ•°å­—ã€‚ è¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³ç»™å‡ºè‡ªç„¶æ•° n çš„å€¼ã€‚è¿™","title":"PATB-1002 å†™å‡ºè¿™ä¸ªæ•°"},{"content":"å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³ (PATB-1001) é¢˜é¢ å¡æ‹‰å…¹(Callatz)çŒœæƒ³ï¼š\nå¯¹ä»»ä½•ä¸€ä¸ªæ­£æ•´æ•° nï¼Œå¦‚æœå®ƒæ˜¯å¶æ•°ï¼Œé‚£ä¹ˆæŠŠå®ƒç æ‰ä¸€åŠï¼›å¦‚æœå®ƒæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæŠŠ (3n+1) ç æ‰ä¸€åŠã€‚è¿™æ ·ä¸€ç›´åå¤ç ä¸‹å»ï¼Œæœ€åä¸€å®šåœ¨æŸä¸€æ­¥å¾—åˆ° n=1ã€‚å¡æ‹‰å…¹åœ¨ 1950 å¹´çš„ä¸–ç•Œæ•°å­¦å®¶å¤§ä¼šä¸Šå…¬å¸ƒäº†è¿™ä¸ªçŒœæƒ³ï¼Œä¼ è¯´å½“æ—¶è€¶é²å¤§å­¦å¸ˆç”Ÿé½åŠ¨å‘˜ï¼Œæ‹¼å‘½æƒ³è¯æ˜è¿™ä¸ªè²Œä¼¼å¾ˆå‚»å¾ˆå¤©çœŸçš„å‘½é¢˜ï¼Œç»“æœé—¹å¾—å­¦ç”Ÿä»¬æ— å¿ƒå­¦ä¸šï¼Œä¸€å¿ƒåªè¯ (3n+1)ï¼Œä»¥è‡³äºæœ‰äººè¯´è¿™æ˜¯ä¸€ä¸ªé˜´è°‹ï¼Œå¡æ‹‰å…¹æ˜¯åœ¨è“„æ„å»¶ç¼“ç¾å›½æ•°å­¦ç•Œæ•™å­¦ä¸ç§‘ç ”çš„è¿›å±•â€¦â€¦\næˆ‘ä»¬ä»Šå¤©çš„é¢˜ç›®ä¸æ˜¯è¯æ˜å¡æ‹‰å…¹çŒœæƒ³ï¼Œè€Œæ˜¯å¯¹ç»™å®šçš„ä»»ä¸€ä¸è¶…è¿‡ 1000 çš„æ­£æ•´æ•° nï¼Œç®€å•åœ°æ•°ä¸€ä¸‹ï¼Œéœ€è¦å¤šå°‘æ­¥ï¼ˆç å‡ ä¸‹ï¼‰æ‰èƒ½å¾—åˆ° n=1ï¼Ÿ\nè¾“å…¥ æ¯ä¸ªæµ‹è¯•è¾“å…¥åŒ…å« 1 ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³ç»™å‡ºæ­£æ•´æ•° n çš„å€¼ã€‚\nè¾“å‡º è¾“å‡ºä» n è®¡ç®—åˆ° 1 éœ€è¦çš„æ­¥æ•°ã€‚\næ ·ä¾‹è¾“å…¥ 13 æ ·ä¾‹è¾“å‡º 15 æç¤º æ— \næ€è·¯ ä»£ç  1int T; 2int n, m; 3 4int main() 5{ 6 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 7 m = 0; 8 9 while (n != 1) 10 { 11 if (n \u0026amp; 1) 12 n = (3 * n + 1) / 2; 13 else 14 n /= 2; 15 m++; 16 } 17 printf(\u0026#34;%d\\n\u0026#34;, m); 18 return 0; 19} ","permalink":"https://blog.lordash.de/posts/solution/patb-1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%843n+1%E7%8C%9C%E6%83%B3/","summary":"å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³ (PATB-1001) é¢˜é¢ å¡æ‹‰å…¹(Callatz)çŒœæƒ³ï¼š å¯¹ä»»ä½•ä¸€ä¸ªæ­£æ•´æ•° nï¼Œå¦‚æœå®ƒæ˜¯å¶æ•°ï¼Œé‚£ä¹ˆæŠŠå®ƒç æ‰ä¸€åŠï¼›å¦‚æœå®ƒæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆæŠŠ (3n+1)","title":"PATB-1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³"},{"content":"ä¸€ã€å‡†å¤‡ åŸºæœ¬ä¿¡æ¯\næ“ä½œç³»ç»Ÿ: Windows10 jdkç‰ˆæœ¬: 1.8 Hadoopç‰ˆæœ¬: 2.9.2 ä¸‹è½½å¹¶è§£å‹\nApache Hadoop: å®˜ç½‘ æˆ–è€… æ¸…åæº\nwinutils: github/cdarlint\näºŒã€é…ç½® ç¯å¢ƒå˜é‡ æ–°å»ºç³»ç»Ÿå˜é‡ HADOOP_HOME è‡³æ‰€åœ¨ç›®å½•ï¼Œå¦‚ D:\\environment\\hadoop-2.9.2\nåœ¨ path ä¸­æ·»åŠ  %HADOOP_HOME%\\bin åŠ %HADOOP_HOME%\\sbin å¹¶ä»¥ ; (è‹±æ–‡åˆ†å·)ä¸å…¶ä»–é¡¹éš”å¼€ã€‚\nHadoopé…ç½®æ–‡ä»¶ å‡åœ¨ %HADOOP_HOME%\\etc\\hadoop\\ ä¸‹é¢:\nä¿®æ”¹ hadoop-env.cmd ï¼ŒæŸ¥æ‰¾ set JAVA_HOME ï¼Œå°†åé¢å†…å®¹æ”¹ä¸ºJDKç›®å½•ã€‚\n1@rem The java implementation to use. Required. 2@rem set JAVA_HOME=%JAVA_HOME% 3set JAVA_HOME=D:\\environment\\Java\\jdk1.8.0_201 ä¿®æ”¹ core-site.xml\n1\u0026lt;configuration\u0026gt; 2 \u0026lt;property\u0026gt; 3 \u0026lt;name\u0026gt;fs.defaultFS\u0026lt;/name\u0026gt; 4 \u0026lt;value\u0026gt;hdfs://localhost:9000\u0026lt;/value\u0026gt; 5 \u0026lt;/property\u0026gt; 6\u0026lt;/configuration\u0026gt; ä¿®æ”¹ hdfs-site.xml\n1\u0026lt;configuration\u0026gt; 2 \u0026lt;property\u0026gt; 3 \u0026lt;name\u0026gt;dfs.replication\u0026lt;/name\u0026gt; 4 \u0026lt;value\u0026gt;1\u0026lt;/value\u0026gt; 5 \u0026lt;/property\u0026gt; 6 \u0026lt;property\u0026gt; 7 \u0026lt;name\u0026gt;dfs.namenode.name.dir\u0026lt;/name\u0026gt; 8 \u0026lt;value\u0026gt;/D:/environment/hadoop-2.9.2/data/namenode\u0026lt;/value\u0026gt; 9 \u0026lt;/property\u0026gt; 10 \u0026lt;property\u0026gt; 11 \u0026lt;name\u0026gt;dfs.datanode.data.dir\u0026lt;/name\u0026gt; 12 \u0026lt;value\u0026gt;/D:/environment/hadoop-2.9.2/data/datanode\u0026lt;/value\u0026gt; 13 \u0026lt;/property\u0026gt; 14\u0026lt;/configuration\u0026gt; ä¿®æ”¹ yarn-site.xml\n1\u0026lt;configuration\u0026gt; 2 \u0026lt;property\u0026gt; 3 \u0026lt;name\u0026gt;yarn.nodemanager.aux-services\u0026lt;/name\u0026gt; 4 \u0026lt;value\u0026gt;mapreduce_shuffle\u0026lt;/value\u0026gt; 5 \u0026lt;/property\u0026gt; 6\u0026lt;/configuration\u0026gt; winutils æŠŠä¹‹å‰ä¸‹è½½çš„ winutils è§£å‹ï¼Œæ‰¾åˆ°å¯¹åº”ç‰ˆæœ¬ï¼Œå°†å†…å®¹è¦†ç›–åˆ° hadoop-2.9.2\\bin ä¸­ã€‚\næ ¼å¼åŒ–namenode ä»¥ç®¡ç†å‘˜æƒé™å¯åŠ¨å‘½ä»¤è¡Œï¼Œè¿è¡Œ hdfs namenode -format ï¼Œè¿™é¡¹å‘½ä»¤åªç”¨åœ¨ç¬¬ä¸€æ¬¡å¯åŠ¨å‰æ‰§è¡Œã€‚å¦‚æœç»“æœä¸­çœ‹åˆ°æœ‰ successfully ï¼Œè¯´æ˜ä»¥ä¸Šé…ç½®æˆåŠŸã€‚\nä¸‰ã€æµ‹è¯• ä»¥ç®¡ç†å‘˜æƒé™å¯åŠ¨å‘½ä»¤è¡Œï¼Œå¦‚æœä¹‹å‰æ²¡æœ‰åœ¨ path ä¸­é…ç½® sbin ï¼Œé‚£ä¹ˆ cd è‡³ %HADOOP_HOME%\\sbin ä¸­ï¼Œè¿è¡Œ start-all å¯åŠ¨ï¼Œå‡ºç°ä»¥ä¸‹å››ä¸ªçª—å£ï¼š\nå³å¯¹åº”è¿è¡Œ jps æ˜¾ç¤ºä»¥ä¸‹äº”ä¸ªè¿›ç¨‹åç§°ï¼š\nè®¿é—® http://localhost:8088 æŸ¥çœ‹é›†ç¾¤çŠ¶æ€ï¼š\nè®¿é—® http://localhost:50070 æŸ¥çœ‹HadoopçŠ¶æ€ï¼š\nå‘½ä»¤è¡Œè¿è¡Œ stop-all å…³é—­ã€‚\n","permalink":"https://blog.lordash.de/posts/configure/4f05172528ab13b7/","summary":"ä¸€ã€å‡†å¤‡ åŸºæœ¬ä¿¡æ¯ æ“ä½œç³»ç»Ÿ: Windows10 jdkç‰ˆæœ¬: 1.8 Hadoopç‰ˆæœ¬: 2.9.2 ä¸‹è½½å¹¶è§£å‹ Apache Hadoop: å®˜ç½‘ æˆ–è€… æ¸…åæº winutils: github/cdarlint äºŒã€é…ç½® ç¯å¢ƒå˜é‡ æ–°å»ºç³»ç»Ÿå˜é‡ HADOOP_HOME è‡³æ‰€åœ¨ç›®å½•ï¼Œå¦‚ D:\\environment\\hadoop-2.9.2","title":"Win10é…ç½®Hadoop2.9.2å•æœºç‰ˆ"},{"content":"ä¸€ã€å‡†å¤‡ ä¸‹è½½å¹¶å®‰è£…ä»¥ä¸‹ä¸¤é¡¹:\nGpg4win\nThunderbird\näºŒã€é…ç½®Gpg4win ä¸€è·¯nextå®‰è£…ã€‚\næ–°å»ºå¯†é’¥å¯¹ï¼ŒæŒ‰æç¤ºè¿›è¡Œã€‚\nå¯ä»¥ç‚¹å‡» å¯¼å‡º... å¯¼å‡º .ascæ–‡ä»¶ã€‚\nä¸‰ã€é…ç½®Thunderbird ä¸€è·¯nextå®‰è£…ã€‚\nå¼€å¯é‚®ç®±çš„IMAPæœåŠ¡ã€‚ä»¥QQé‚®ç®±ä¸ºä¾‹ï¼Œå¯åŠ¨QQé‚®ç®±ç½‘é¡µç‰ˆï¼Œæ‰“å¼€ è®¾ç½® \u0026gt; è´¦æˆ· ä¸‹æ‹‰æ‰¾åˆ°è¯¥é¡¹ï¼Œå¹¶é€‰æ‹©å¼€å¯IMAP/SMTPæœåŠ¡ã€‚\nä¿å­˜æç¤ºä¸­çš„æˆæƒç \nåœ¨Thunderbirdä¸­é…ç½®é‚®ç®±ï¼Œå¯†ç ä¸€æ ä¸­å¡«å†™æˆæƒç å³å¯ã€‚\nç‚¹å¼€ æ˜¾ç¤ºèœå• æ‰¾åˆ° é™„åŠ ç»„ä»¶ ï¼Œæœç´¢å¹¶å®‰è£… Enigmail æ’ä»¶ã€‚\né‡å¯åº”ç”¨åï¼Œåœ¨Thunderbirdèœå•æ ä¸­æ‰¾åˆ° Enigmail \u0026gt; å¯†é’¥ç®¡ç† ï¼Œç‚¹å‡» æ–‡ä»¶ \u0026gt; ä»æ–‡ä»¶å¯¼å…¥å¯†é’¥ å¯ä»¥å¯¼å…¥æŸä¸ªé‚®ç®±åœ°å€çš„å…¬é’¥æ–‡ä»¶ï¼Œæˆ–è€…åœ¨æœç´¢æ¡†ä¸­é€šè¿‡è¾“å…¥é‚®ç®±åœ°å€æˆ–å¯†é’¥IDåœ¨å…¬é’¥æœåŠ¡å™¨ä¸Šæœç´¢å¯¹åº”çš„å…¬é’¥ï¼Œä¹Ÿå¯ä»¥æ˜¯é‚®ä»¶ç­‰æ–¹å¼ä¼ é€’çš„Gpg4winå¯¼å‡ºçš„ .asc æ–‡ä»¶ã€‚\nå››ã€å‘é€\u0026amp;æ¥æ”¶é‚®ä»¶ å‘é€é‚®ä»¶\nå‡è®¾æˆ‘ä»¬éœ€è¦å‘XXX@XXX.XXXè¿™ä¸ªç”µå­é‚®ä»¶åœ°å€å‘é€GPGåŠ å¯†é‚®ä»¶ï¼Œé¦–å…ˆåº”è¯¥å¯¼å…¥XXX@XXX.XXXå¯¹åº”çš„å…¬é’¥æ–‡ä»¶ï¼ˆè¯¥æ–‡ä»¶å°†ç”¨äºåŠ å¯†é‚®ä»¶ï¼‰ï¼Œæˆ–è€…é€šè¿‡é‚®ä»¶åœ°å€XXX@XXX.XXXæˆ–å¯¹æ–¹çš„å¯†é’¥IDåœ¨å…¬é’¥æœåŠ¡å™¨ä¸Šæœç´¢å…¶å…¬é’¥ï¼Œæœç´¢åˆ°çš„å…¬é’¥éœ€è¦è¿›è¡ŒæŒ‡çº¹éªŒè¯ä»¥ç¡®ä¿è¯¥å…¬é’¥ä¸æ˜¯ä¼ªé€ çš„ã€‚\nåœ¨æ–°å»ºé‚®ä»¶ç•Œé¢é€‰ä¸­ åŠ å¯† å’Œ ç­¾åé‚®ä»¶ æŒ‰é’®å³å¯ã€‚\næ¥æ”¶é‚®ä»¶\næ‰“å¼€æ¥æ”¶åˆ°çš„åŠ å¯†é‚®ä»¶ï¼Œä¼šæç¤ºéªŒè¯å¯†ç ï¼ŒéªŒè¯å®Œå³å¯æŸ¥çœ‹å†…å®¹ã€‚\né™„ã€ç–‘éš¾è§£å†³ é—®: Thunderbirdæ·»åŠ æ–°é‚®ç®±æ—¶æç¤º æ¥å—æœåŠ¡å™¨å·²å­˜åœ¨ å¦‚ä½•è§£å†³ï¼Ÿ ç­”: å½»åº•é€€å‡ºThunderbird ( åŒ…æ‹¬å…³é—­åå°è¿›ç¨‹ )ï¼Œå†é‡æ–°æ‰“å¼€å³å¯ã€‚ ","permalink":"https://blog.lordash.de/posts/essays/%E4%BD%BF%E7%94%A8gpg4win%E5%8A%A0%E5%AF%86%E9%82%AE%E4%BB%B6/","summary":"ä¸€ã€å‡†å¤‡ ä¸‹è½½å¹¶å®‰è£…ä»¥ä¸‹ä¸¤é¡¹: Gpg4win Thunderbird äºŒã€é…ç½®Gpg4win ä¸€è·¯nextå®‰è£…ã€‚ æ–°å»ºå¯†é’¥å¯¹ï¼ŒæŒ‰æç¤ºè¿›è¡Œã€‚ å¯ä»¥ç‚¹å‡» å¯¼å‡º... å¯¼å‡º .ascæ–‡ä»¶ã€‚ ä¸‰ã€é…ç½®","title":"ä½¿ç”¨Gpg4winåŠ å¯†é‚®ä»¶"},{"content":"ä¸€ã€æºæ’’å¯†ç ç®€ä»‹ åœ¨å¯†ç å­¦ä¸­ï¼Œæºæ’’å¯†ç ï¼ˆè‹±è¯­ï¼šCaesar cipherï¼‰ï¼Œæˆ–ç§°æºæ’’åŠ å¯†ã€æºæ’’å˜æ¢ã€å˜æ¢åŠ å¯†ï¼Œæ˜¯ä¸€ç§æœ€ç®€å•ä¸”æœ€å¹¿ä¸ºäººçŸ¥çš„åŠ å¯†æŠ€æœ¯ã€‚å®ƒæ˜¯ä¸€ç§æ›¿æ¢åŠ å¯†çš„æŠ€æœ¯ï¼Œæ˜æ–‡ä¸­çš„æ‰€æœ‰å­—æ¯éƒ½åœ¨å­—æ¯è¡¨ä¸Šå‘åï¼ˆæˆ–å‘å‰ï¼‰æŒ‰ç…§ä¸€ä¸ªå›ºå®šæ•°ç›®è¿›è¡Œåç§»åè¢«æ›¿æ¢æˆå¯†æ–‡ã€‚ä¾‹å¦‚ï¼Œå½“åç§»é‡æ˜¯3çš„æ—¶å€™ï¼Œæ‰€æœ‰çš„å­—æ¯Aå°†è¢«æ›¿æ¢æˆDï¼ŒBå˜æˆEï¼Œä»¥æ­¤ç±»æ¨ã€‚è¿™ä¸ªåŠ å¯†æ–¹æ³•æ˜¯ä»¥ç½—é©¬å…±å’Œæ—¶æœŸæºæ’’çš„åå­—å‘½åçš„ï¼Œå½“å¹´æºæ’’æ›¾ç”¨æ­¤æ–¹æ³•ä¸å…¶å°†å†›ä»¬è¿›è¡Œè”ç³»ã€‚\næ ¹æ®åç§»é‡çš„ä¸åŒï¼Œè¿˜å­˜åœ¨è‹¥å¹²ç‰¹å®šçš„æºæ’’å¯†ç åç§°ï¼š\nåç§»é‡ä¸º10ï¼šAvocat(Aâ†’K) åç§»é‡ä¸º13ï¼šROT13 åç§»é‡ä¸º-5ï¼šCassis (K 6) åç§»é‡ä¸º-6ï¼šCassette (K 7) äºŒã€C++ç®€å•å®ç° 1#include \u0026lt;bits/stdc++.h\u0026gt; 2using namespace std; 3 4const int SIZ = 100000; 5char src[SIZ], enc[SIZ]; 6 7void caesar(char src[], char enc[], int key) 8{ 9 key %= 26; 10 for (int i=0; src[i]; i++) 11 { 12 if ((src[i]\u0026lt;\u0026#39;A\u0026#39;) || (src[i]\u0026gt;\u0026#39;Z\u0026#39; \u0026amp;\u0026amp; src[i]\u0026lt;\u0026#39;a\u0026#39;) || src[i]\u0026gt;\u0026#39;z\u0026#39;) { 13 enc[i] = src[i]; continue; 14 } 15 16 if (src[i] \u0026gt;= \u0026#39;a\u0026#39;) 17 enc[i] = (src[i] - \u0026#39;a\u0026#39; + key + 26) % 26 + \u0026#39;a\u0026#39;; 18 else 19 enc[i] = (src[i] - \u0026#39;A\u0026#39; + key + 26) % 26 + \u0026#39;A\u0026#39;; 20 } 21} 22 23int main() 24{ 25 system(\u0026#34;chcp 65001\u0026#34;); 26 while (1) 27 { 28 printf(\u0026#34;-- å‡¯æ’’å¯†ç  åŠ /è§£å¯† -- \\n\u0026#34;); 29 printf(\u0026#34;1. åŠ å¯† \\n2. è§£å¯† \\n3. é€€å‡º \\n\u0026#34;); 30 31 int select, key; scanf(\u0026#34;%d\u0026#34;, \u0026amp;select); 32 if (select == 3) break; 33 34 printf(\u0026#34;è¯·è¾“å…¥åŸæ–‡: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, src); 35 printf(\u0026#34;è¯·è¾“å…¥å¯†é’¥: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); 36 37 if (select == 2) key = -key; 38 memset(enc, 0, sizeof(enc)); 39 40 caesar(src, enc, key); printf(\u0026#34;å¯†æ–‡: %s\\n\u0026#34;, enc); 41 system(\u0026#34;pause\u0026#34;); system(\u0026#34;cls\u0026#34;); 42 } 43 return 0; 44} 45 46/* 47abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 48*/ ","permalink":"https://blog.lordash.de/posts/essays/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/","summary":"ä¸€ã€æºæ’’å¯†ç ç®€ä»‹ åœ¨å¯†ç å­¦ä¸­ï¼Œæºæ’’å¯†ç ï¼ˆè‹±è¯­ï¼šCaesar cipherï¼‰ï¼Œæˆ–ç§°æºæ’’åŠ å¯†ã€æºæ’’å˜æ¢ã€å˜æ¢åŠ å¯†ï¼Œæ˜¯ä¸€ç§æœ€ç®€å•ä¸”æœ€å¹¿ä¸ºäººçŸ¥çš„åŠ å¯†æŠ€æœ¯","title":"å‡¯æ’’å¯†ç çš„ç®€å•å®ç°"},{"content":"ä¸€ã€æ€ä¹ˆåƒéƒ½ä¸èƒ–çš„åŸå›  åŸºå› è¡¨è¾¾ï¼Œèº«ä½“å€¾å‘äºå°†å¤šä½™çš„è¥å…»ä»£è°¢è€Œä¸æ˜¯å‚¨å­˜\né¥®é£Ÿä¹ æƒ¯ï¼Œå®¢è§‚ä¸Šåƒå¾—å°‘\nèº«ä½“ä¸éœ€è¦\näºŒã€å¢é‡ä¸ºä»€ä¹ˆè¦å¢è‚Œ å¢è‚Œï¼šè‚Œè‚‰å¢é•¿å¯æ§ï¼Œé”»ç‚¼å“ªå¢å“ª\nå¢è„‚ï¼šè„‚è‚ªå¢é•¿ä¸å¯æ§ï¼Œå¢é•¿çš„ä½ç½®ç”±åŸºå› å†³å®š\nä¸‰ã€æ€ä¹ˆç»ƒå®¹æ˜“æ˜¾å£® å¢è‚Œçš„åŸºæœ¬åŸç†å°±æ˜¯é€šè¿‡åŠ›é‡è®­ç»ƒï¼Œä¸æ–­åˆºæ¿€è‚Œè‚‰ï¼Œè®©è‚Œçº¤ç»´æ’•è£‚ï¼Œè®©è‚Œç³–åŸæ¶ˆè€—ï¼Œç„¶åè¡¥å……è¶³å¤Ÿçš„è¥å…»ï¼Œè®©è‚Œè‚‰è¿›è¡Œè¶…é‡æ¢å¤ï¼ŒåŒæ—¶è´Ÿè·æ¸è¿›ã€‚å…³äºå¢è‚Œæœ‰ä»¥ä¸‹è¦ç‚¹ï¼š\nä¼˜å…ˆç»ƒèƒ¸ã€èƒŒã€è‡€è…¿ç­‰å¤§è‚Œç¾¤ã€‚\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nä¸€æ–¹é¢ï¼Œå¤§è‚Œç¾¤çš„è‚Œè‚‰é‡å æ¯”å¤§ï¼Œå¢è‚Œå¯¹ä½“å‹å˜åŒ–çš„æ•ˆæœæ›´åŠ æ˜æ˜¾ï¼ˆè‚©éƒ¨ã€æ‰‹è‡‚ã€è…°è…¹ã€å°è…¿åˆ™ä¸ºå°è‚Œç¾¤ï¼Œä½†æ˜¯ç”±äºä¸‰è§’è‚Œåœ¨èº«ä½“ä¸¤ä¾§ï¼Œç»ƒå¤§äº†ï¼Œä»æ­£é¢çœ‹äººä¼šé©¬ä¸Šå˜å®½ï¼Œæ‰€ä»¥è‚©éƒ¨ä¹Ÿå¯ä»¥å’Œå¤§è‚Œç¾¤åœ¨å‰æœŸå®‰æ’ä¼˜å…ˆçš„è®­ç»ƒï¼‰ã€‚å¦ä¸€æ–¹é¢ï¼Œå¤§è‚Œç¾¤çš„è®­ç»ƒä¼šå¸¦åŠ¨å°è‚Œç¾¤ï¼Œå¤§éƒ¨åˆ†ç»ƒèƒ¸èƒŒçš„åŠ¨ä½œï¼Œæ‰‹è‡‚éƒ½æ˜¯æœ‰ä¸€èµ·å‚ä¸å‘åŠ›çš„ã€‚å¾ˆå¤šç»ƒè‡€è…¿çš„åŠ¨ä½œï¼Œç”±äºå¯¹æ ¸å¿ƒç¨³å®šçš„è¦æ±‚éå¸¸é«˜ï¼Œè…°è…¹æ ¸å¿ƒè‚Œç¾¤éƒ½æ˜¯ä¼šè¢«ä¸€èµ·ç»ƒåˆ°çš„ã€‚\n{% endfold %}\nä½¿ç”¨å¤§é‡é‡è®­ç»ƒã€‚\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nä½•è°“â€œå¤§â€ï¼Œä¸€èˆ¬æ¥è¯´ä¸€å£æ°”èƒ½åš5~10ä¸ªçš„åŠ¨ä½œçš„é‡é‡å°±è¶³å¤Ÿäº†ã€‚è‚Œè‚‰åˆ†ä¸ºä¸¤ç§ï¼Œçº¢è‚Œçº¤ç»´ï¼ˆåŠ›é‡å°ã€è€åŠ›å¼ºã€ä½“ç§¯å°ã€ä½“ç§¯å¢é•¿æ½œåŠ›å°ï¼‰ï¼Œç™½è‚Œçº¤ç»´ï¼ˆåŠ›é‡å¤§ã€è€åŠ›å·®ã€ä½“ç§¯å¤§ã€ä½“ç§¯å¢é•¿æ½œåŠ›å¤§ï¼‰ã€‚æ‰€ä»¥å¿«é€Ÿå¢é‡ï¼Œéœ€è¦å¢é•¿ç™½è‚Œçº¤ç»´ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨å¤§é‡é‡å»åˆºæ¿€ã€‚\n{% endfold %}\nä»¥å¤åˆåŠ¨ä½œä¸ºä¸»ã€‚\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nå¤åˆåŠ¨ä½œå¯ä»¥åŒæ—¶æ»¡è¶³ä»¥ä¸Šä¸¤ä¸ªæ¡ä»¶ï¼Œå¤§è‚Œç¾¤å¸¦åŠ¨å°è‚Œç¾¤å’Œä½¿ç”¨å¤§é‡é‡è®­ç»ƒã€‚è´Ÿé‡è®­ç»ƒå¯ä»¥åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼Œå¤åˆåŠ¨ä½œå’Œå­¤ç«‹åŠ¨ä½œã€‚\nå¤åˆåŠ¨ä½œï¼Œå°±æ˜¯åŒæ—¶è¦ç”¨åˆ°å¤šå—è‚Œè‚‰ï¼Œå¤šä¸ªå…³èŠ‚ä¸€èµ·è¿åŠ¨çš„åŠ¨ä½œã€‚ä¾‹å¦‚ï¼Œå§æ¨ã€æ¨ä¸¾ã€ä¿¯å§æ’‘ï¼Œå¯ä»¥åŒæ—¶ç»ƒåˆ°èƒ¸éƒ¨ã€è‚©éƒ¨å‰æŸå’Œæ‰‹è‡‚çš„è‚±ä¸‰å¤´è‚Œï¼›å¼•ä½“å‘ä¸Šã€åˆ’èˆ¹ï¼Œå¯ä»¥åŒæ—¶ç»ƒåˆ°èƒŒéƒ¨å’Œæ‰‹è‡‚çš„è‚±äºŒå¤´è‚Œï¼›æ·±è¹²å¯ä»¥åŒæ—¶ç»ƒåˆ°å¤§è…¿çš„å‰ä¾§ã€åä¾§å’Œè‡€éƒ¨ï¼Œå¯¹è…°è…¹æ ¸å¿ƒä¹Ÿæœ‰åˆºæ¿€ï¼›ç¡¬æ‹‰å°±æ›´å‰å®³äº†ï¼Œé™¤äº†æ•´ä¸ªè‡€éƒ¨è…¿éƒ¨ã€è…°è…¹æ ¸å¿ƒã€èƒŒéƒ¨ï¼Œç”šè‡³å‰è‡‚éƒ½æœ‰ä¸€å®šåˆºæ¿€ã€‚\nå­¤ç«‹åŠ¨ä½œï¼Œä¾‹å¦‚å¼¯ä¸¾ï¼Œåªèƒ½é’ˆå¯¹å•ä¸€æ–¹é¢çš„è‚Œè‚‰ï¼Œä½†æ˜¯ä¹Ÿç‰¹åˆ«é‡è¦ï¼Œæœ‰äº›å¤åˆåŠ¨ä½œè¦†ç›–ä¸åˆ°çš„åœ°æ–¹ï¼Œæˆ–è€…éœ€è¦ç‰¹åˆ«åŠ å¼ºçš„åœ°æ–¹ï¼Œå°±å¯ä»¥ä½¿ç”¨å­¤ç«‹åŠ¨ä½œè¿›è¡Œè¡¥å……ã€‚\n{% endfold %}\nä¼˜å…ˆé€‰æ‹©è‡ªç”±é‡é‡ï¼Œå³æ é“ƒå“‘é“ƒç­‰ã€‚\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nè‡ªç”±é‡é‡çš„æ•ˆæœä¼šæ¯”å›ºå®šå™¨æ¢°è¦æ›´å¥½ã€‚ä¸€æ–¹é¢ï¼Œæ˜¯è‚Œè‚‰çš„å—åŠ›èŒƒå›´ã€‚å›ºå®šå™¨æ¢°çš„åŠ¨ä½œè½¨è¿¹å¤ªè¿‡å•ä¸€ï¼Œåªèƒ½å¤Ÿåˆºæ¿€åˆ°æŸå—è‚Œè‚‰çš„æŸä¸ªå±€éƒ¨ã€‚å¦ä¸€æ–¹é¢ï¼Œæ˜¯å®‰å…¨æ€§ã€‚é•¿æœŸåªä½¿ç”¨å›ºå®šå™¨æ¢°ï¼Œä¼šå¼€å§‹ä¾èµ–å›ºå®šå™¨æ¢°çš„ç¨³å®šæ€§ï¼Œè‡ªå·±åè€Œæ²¡æœ‰åŠæ³•å­¦ä¼šæ§åˆ¶è‚Œè‚‰çš„ç¨³å®šæ€§ã€‚\nåˆç†çš„æ–¹æ³•åº”è¯¥æ˜¯ç”±æœ€è½»çš„è‡ªç”±é‡é‡å¼€å§‹ç»ƒã€‚åˆšå¼€å§‹ä½¿ç”¨æ é“ƒå“‘é“ƒï¼Œä¼šæ„Ÿè§‰åŠ¨ä½œä¸ç¨³ï¼Œè¿™æ˜¯æ­£å¸¸çš„ï¼Œä½†ç”±äºé‡é‡å°æ‰€ä»¥ä¸å¿…æ‹…å¿ƒå—ä¼¤ã€‚å¤šç»ƒå‡ æ¬¡ååŠ¨ä½œæ§åˆ¶å¾ˆç¨³äº†ï¼Œå†é€æ­¥å¾ªåºæ¸è¿›åœ°å¢åŠ é‡é‡ã€‚\n{% endfold %}\nå››ã€è®­ç»ƒè®¡åˆ’ è®­ç»ƒå‰éœ€è¦çƒ­èº«ï¼Œå¯ä»¥æ…¢è·‘5~10åˆ†é’Ÿï¼Œå†å¯¹å…¨èº«åšä¸€äº›ç®€å•çš„çŸ­æ—¶é—´æ‹‰ä¼¸ã€‚\nåŒåˆ†åŒ–åŒå¾ªç¯è®­ç»ƒï¼ˆåˆå­¦è€…å»ºè®®ï¼‰\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nä¹Ÿå°±æ˜¯æŠŠå…¨èº«åˆ’åˆ†ä¸ºä¸Šä¸‹ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæ¯æ¬¡åªç»ƒå…¶ä¸­ä¸€ä¸ªéƒ¨åˆ†ï¼Œç„¶åä¸€å‘¨å››ç»ƒã€‚ä¾‹å¦‚è¯´ï¼Œå‘¨ä¸€ã€å››ç»ƒä¸ŠåŠèº«ï¼ˆèƒ¸ã€èƒŒã€è‚©ã€æ‰‹è‡‚ï¼‰ï¼Œå‘¨äºŒã€äº”ç»ƒä¸‹åŠèº«ï¼ˆè…¿ã€è‡€ã€å°è…¿ã€æ ¸å¿ƒï¼‰ã€‚è¿™æ ·æ¯ä¸ªéƒ¨ä½æ¯å‘¨å°±èƒ½è®­ç»ƒåˆ°ä¸¤æ¬¡ï¼Œè®­ç»ƒå®¹é‡å’Œè®­ç»ƒé¢‘ç‡éƒ½æœ‰ä¿éšœã€‚\n{% endfold %}\nèº¯å¹² + å››è‚¢ï¼ˆå¿«é€Ÿæ˜¾å£®ï¼‰\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nèº¯å¹²ä¸»è¦å°±æ˜¯èƒ¸éƒ¨å’ŒèƒŒéƒ¨ä¸¤æ–¹é¢ï¼Œèƒ¸èƒŒç»ƒå¤§äº†ï¼Œäººå°±ä¸ä¼šæ˜¾å¾—å•è–„ã€‚å››è‚¢ä¸»è¦æ˜¯å¤§è…¿ã€è‚©éƒ¨å’Œæ‰‹è‡‚ï¼Œè¿™äº›éƒ¨åˆ†å¤å¤©ç‰¹åˆ«å®¹æ˜“å¤–éœ²ï¼Œç»ƒå£®äº†æ¯”è¾ƒå®¹æ˜“çªå‡ºè‚Œè‚‰æ„Ÿã€‚ä¸€å‘¨å››ç»ƒçš„è¯ï¼Œå‘¨ä¸€ã€å››è¿›è¡Œèº¯å¹²è®­ç»ƒï¼ˆèƒ¸å¤§è‚Œã€èƒŒéƒ¨è‚Œç¾¤ï¼‰ï¼Œå‘¨äºŒã€äº”è¿›è¡Œå››è‚¢è®­ç»ƒï¼ˆè‡€è…¿è‚Œç¾¤ã€ä¸‰è§’è‚Œä¸­åã€è‚±äºŒå¤´è‚Œï¼‰ã€‚\n{% endfold %}\næ¥ä¸‹æ¥ç»™å‡ºã€èº¯å¹² + å››è‚¢ã€‘çš„è®­ç»ƒæ–¹æ¡ˆ\nèº¯å¹² - åŸºç¡€ èƒ¸éƒ¨è®­ç»ƒï¼Œå“‘é“ƒå§æ¨\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nè‡ªç”±é‡é‡ï¼Œå…ˆæŠŠè‚©èƒ›éª¨æ”¶ç´§ï¼Œä»°èººåœ¨å§æ¨æ¤…ä¸Šï¼Œè‚©éƒ¨å†å¾€ä¸­é—´æ”¶ä¸€æ”¶ï¼ŒåŒæ‰‹å‚ç›´åœ¨èº«ä½“ä¸Šæ–¹ï¼Œç„¶åç¼“æ…¢æœ‰æ§åˆ¶åœ°æŠŠå“‘é“ƒå¾€ä¸‹æ”¾ï¼Œæ”¾åˆ°æœ€ä½ç‚¹å†ç”¨åŠ›å¾€ä¸Šæ¨ï¼Œæ³¨æ„å°è‡‚å…¨ç¨‹æ˜¯å‚ç›´åœ°é¢çš„ï¼Œå¯ä»¥æƒ³æƒ³æŠŠä¸¤è¾¹çš„æ‰‹è‚˜å¾€ä¸­é—´å¤¹ï¼Œè¿™æ ·èƒ¸è‚ŒæŒ¤å‹çš„æ„Ÿè§‰ä¼šå¼ºçƒˆå¾ˆå¤šã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š8æ¬¡ é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šæœ€åä¸€ç»„åŠ›ç«­\n{% endfold %}\nèƒŒéƒ¨è®­ç»ƒï¼Œå¼•ä½“å‘ä¸Š\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåŒæ‰‹æ¯”è‚©éƒ¨ç•¥å®½æ¡ç€åŠæ†ï¼Œèº«ä½“æŒºç›´ï¼Œå…ˆæŠŠè‚©èƒ›éª¨å¾€ä¸‹å‹ï¼Œç„¶åæŠŠæ•´ä¸ªèº«ä½“ç”¨åŠ›æ‹‰ä¸Šå»ï¼Œç„¶åå†ç¼“æ…¢æœ‰æ§åˆ¶åœ°å¾€ä¸‹æ”¾ã€‚æ³¨æ„ä¸‰ä¸ªé—®é¢˜ï¼Œâ‘ æ‹‰èµ·æ¥çš„è¿‡ç¨‹ä¸­ä¸è¦è€¸è‚©ï¼Œâ‘¡èº«ä½“ä¸è¦å¾€åä»°å¤ªå¤šï¼Œâ‘¢åŠ¨ä½œè¦å°½é‡åšå®Œå…¨ç¨‹ã€‚\nç»„æ•°ï¼šè‡ªå®š æ¬¡æ•°ï¼šå…±30ä¸ª é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šå®Œæˆç›®æ ‡æ•°é‡å³å¯\n{% endfold %}\nèƒ¸éƒ¨è®­ç»ƒï¼Œä¸Šæ–œå§æ¨\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nä¸Šæ–œå§æ¨ï¼Œä½¿ç”¨æ é“ƒå“‘é“ƒæˆ–è€…å²å¯†æ–¯æœºï¼ŒåŒæ ·å…ˆæ”¶ç´§è‚©èƒ›éª¨ï¼Œä»°èººåœ¨å§æ¨æ¤…ä¸Šï¼ŒåŒæ‰‹å‚ç›´æ”¾åœ¨èº«ä½“ä¸Šæ–¹ï¼Œç„¶åç¼“æ…¢æœ‰æ§åˆ¶åœ°æŠŠå“‘é“ƒå¾€ä¸‹æ”¾ï¼Œæ”¾åˆ°æœ€ä½ç‚¹å†ç”¨åŠ›å¾€ä¸Šæ¨ï¼ŒåŒæ ·æ³¨æ„å°è‡‚å…¨ç¨‹æ˜¯å‚ç›´åœ°é¢çš„ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š8æ¬¡ é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šæœ€åä¸€ç»„åŠ›ç«­\n{% endfold %}\nèƒŒéƒ¨è®­ç»ƒï¼Œåå§¿åˆ’èˆ¹\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nååœ¨å‡³å­ä¸Šï¼ŒåŒè„šè¸©ç¨³ï¼ŒæŒºç›´è…°èƒŒï¼Œæ ¸å¿ƒæ”¶ç´§ï¼Œç”¨åŠ›æŠŠæŠŠæ‰‹æ‹‰èµ·æ¥ï¼Œç„¶åç¼“æ…¢æœ‰æ§åˆ¶çš„å¾€ä¸‹æ”¾ï¼Œèº«ä½“å¯èƒ½ä¼šæœ‰å°å¹…åº¦çš„æ‘†åŠ¨ï¼Œä½†æ˜¯è¦ä¿æŒèº«ä½“æŒºç›´ï¼Œæ‘†åŠ¨çš„å¹…åº¦ä¹Ÿä¸è¦å¤ªå¤§ï¼Œè¦ç‰¹åˆ«æ³¨æ„ï¼Œå¾€åæ‹‰çš„æ—¶å€™ï¼ŒèƒŒéƒ¨è¦ä½¿åŠ²åœ°å¾€ä¸­é—´å¤¹ï¼Œè¿™æ ·èƒŒéƒ¨æ‰èƒ½ç»ƒå‡ºæ„Ÿè§‰æ¥ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š12æ¬¡ é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šæœ€åä¸€ç»„åŠ›ç«­\n{% endfold %}\nèº¯å¹² - é™„åŠ  èƒ¸éƒ¨è®­ç»ƒï¼Œç»³ç´¢å¤¹èƒ¸\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nèƒ¸éƒ¨å­¤ç«‹åŠ¨ä½œï¼Œå¤¹èƒ¸ï¼Œé¾™é—¨æ¶æˆ–è€…å¤¹èƒ¸å™¨æ¢°ç­‰ï¼Œå¯ä»¥å¸®åŠ©æ–°æ‰‹å°½å¿«æ‰¾åˆ°èƒ¸éƒ¨è‚Œè‚‰æŒ¤å‹å‘åŠ›çš„æ„Ÿè§‰ï¼Œè€Œä¸”ä¹Ÿä¸ä¼šå¢åŠ æ‰‹è‡‚çš„ç–²åŠ³ï¼Œæ³¨æ„è‚©èƒ›éª¨ä¿æŒæ”¶ç´§çŠ¶æ€ã€‚æƒ³ç€æŠŠæ‰‹è‚˜ä»ä¸¤è¾¹å¾€ä¸­é—´å¤¹ï¼Œèƒ¸è‚Œå°±æœ‰æ„Ÿè§‰äº†ã€‚\nç»„æ•°ï¼š3ç»„ æ¬¡æ•°ï¼š15~20æ¬¡ é—´æ­‡ï¼š45~60ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\nèƒŒéƒ¨è®­ç»ƒï¼Œå•è‡‚å“‘é“ƒåˆ’èˆ¹\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nç®—ä¸ä¸Šå­¤ç«‹åŠ¨ä½œï¼Œä½†æ˜¯å¯ä»¥å°½å¯èƒ½çš„è®©èƒŒéƒ¨è‚Œè‚‰å¾€åæ”¶ç¼©ï¼ŒåŒæ ·æœ‰åˆ©äºæ–°æ‰‹æ‰¾å‘åŠ›æ„Ÿè§‰çš„è®­ç»ƒï¼Œè¦æ³¨æ„èº«ä½“çš„ç¨³å®šï¼Œä¸è¦å·¦å³æ‘‡æ™ƒï¼Œå……åˆ†æ„Ÿå—è‚©éƒ¨å’ŒèƒŒéƒ¨å¾€åç§»åŠ¨çš„æ„Ÿè§‰ã€‚\nç»„æ•°ï¼š3ç»„ æ¬¡æ•°ï¼š12~15æ¬¡ é—´æ­‡ï¼š45~60ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\nèº¯å¹² - æ”¾æ¾ {% fold æŸ¥çœ‹è¯¦ç»† %}\næ‹‰ä¼¸èƒ¸è‚Œ æ‹‰ä¼¸èƒŒé˜”è‚Œ æ‹‰ä¼¸ä¸­èƒŒéƒ¨ æ”¾æ¾å¤§åœ†è‚Œ æ”¾æ¾èƒ¸å°è‚Œ è¡¥å……ç³–åŸï¼ˆé¦™è•‰ã€å¢è‚Œç²‰ï¼‰ {% endfold %}\nå››è‚¢ - åŸºç¡€ è…¿éƒ¨è®­ç»ƒï¼Œé«˜è„šæ¯æ·±è¹²\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåŒæ‰‹æ’‘ç€å“‘é“ƒï¼Œç´§è´´èƒ¸å‰ï¼ŒæŒºèƒ¸æ”¶èƒŒï¼ŒåŒè„šç«™è·æ¯”è‚©å®½ç•¥å®½ï¼Œç„¶åè‡€éƒ¨å¾€åæ¨ï¼Œè†ç›–å¾€ä¸¤è¾¹æ‰“å¼€ï¼Œé€‚å½“åœ°å¾€è„šå°–çš„æ–¹å‘æ»‘åŠ¨ï¼Œé¡ºåŠ¿è¹²ä¸‹ï¼Œç„¶åå¤§è…¿å’Œè‡€éƒ¨å‘åŠ›ï¼Œç”¨åŠ›ç«™èµ·æ¥ã€‚æ³¨æ„ï¼Œé‡å¿ƒä¿æŒåœ¨è¶³å¼“å¤„ï¼Œè…°èƒŒè¦æŒºç›´æˆä¸€æ¡ç›´çº¿ï¼Œè†ç›–çš„æœå‘è¦å’Œè„šå°–çš„æ–¹å‘ä¸€è‡´ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š8æ¬¡ é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šæœ€åä¸€ç»„åŠ›ç«­\n{% endfold %}\nè…¿éƒ¨è®­ç»ƒï¼Œç½—é©¬å°¼äºšç¡¬æ‹‰\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåŠç¨‹çš„ç¡¬æ‹‰ï¼ŒåŒæ‰‹æ¡ç€æ é“ƒæˆ–è€…å“‘é“ƒï¼ŒæŒºç›´è…°èƒŒï¼Œæ ¸å¿ƒæ”¶ç´§ç„¶åå¾€å‰ç¼“æ…¢æœ‰æ§åˆ¶åœ°ä¿¯èº«ä¸‹å»ï¼Œå†ç”¨åŠ›æŠŠæ é“ƒæ‹‰èµ·æ¥ï¼Œæ‹‰èµ·æ¥åœ°è¿‡ç¨‹ä¸æ˜¯è…°éƒ¨å‘åŠ›ï¼Œè…°è…¹æ ¸å¿ƒå…¨ç¨‹æ”¶ç´§ï¼ŒæŠŠé«‹éƒ¨å¾€å‰é¡¶ï¼Œç”¨è‡€éƒ¨å‘åŠ›ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š12æ¬¡ é—´æ­‡ï¼š1~2åˆ†é’Ÿ ç»ƒæ³•ï¼šæœ€åä¸€ç»„åŠ›ç«­\n{% endfold %}\nè‚©éƒ¨è®­ç»ƒï¼Œä¾§å¹³ä¸¾\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåŒæ‰‹æ¡ç€å“‘é“ƒåœ¨èº«ä½“çš„ä¸¤ä¾§ï¼Œèº«ä½“ç«™ç›´ï¼ŒæŠŠå“‘é“ƒå¾€ä¸¤è¾¹æŠ¬èµ·æ¥ï¼ŒæŠ¬åˆ°è‚©éƒ¨æ°´å¹³çš„é«˜åº¦ï¼Œå°±å¯ä»¥ç¼“æ…¢æœ‰æ§åˆ¶åœ°å¾€ä¸‹æ”¾äº†ã€‚è¦æ³¨æ„èº«ä½“è¦ç¨³ä½ï¼Œä¸è¦å‰åæ™ƒåŠ¨ï¼Œä¸è¦è€¸è‚©ï¼Œæ‰‹è‡‚çš„è§’åº¦ä¹Ÿä¸è¦æœ‰å˜åŒ–ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š15~20æ¬¡ é—´æ­‡ï¼š30~45ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\nè‚©éƒ¨è®­ç»ƒï¼Œé¢æ‹‰\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nç»ƒè‚©éƒ¨åæŸï¼ŒæŠŠæ‰‹ä¸Šçš„ç»³ç´¢ä»¥ä¸€ä¸ªå¾€åæ‹‰å¾€å¤–æ—‹çš„æ–¹å¼æ‹‰è¿‘è‡ªå·±çš„è„¸éƒ¨ï¼Œæ³¨æ„æ‰‹è‚˜ä¸è¦ä½äºè‚©ï¼ŒåŒæ‰‹ä¸è¦ä½äºæ‰‹è‚˜ã€‚\nç»„æ•°ï¼š4ç»„ æ¬¡æ•°ï¼š12~15æ¬¡ é—´æ­‡ï¼š45~60ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\næ‰‹è‡‚è®­ç»ƒï¼Œæ é“ƒå¼¯ä¸¾\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nèº«ä½“ä¸è¦æ™ƒåŠ¨ï¼ŒåŠ¨ä½œè¦åšå¤Ÿå…¨ç¨‹\nç»„æ•°ï¼š3ç»„ æ¬¡æ•°ï¼š12æ¬¡ é—´æ­‡ï¼š45~60ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\næ‰‹è‡‚è®­ç»ƒï¼Œé”¤å¼å¼¯ä¸¾\n{% fold æŸ¥çœ‹è¯¦ç»† %}\næ‹¿èµ·ä¸¤ä¸ªå“‘é“ƒï¼Œè™å£æœå‰ï¼Œå·¦å³äº¤æ›¿åšé”¤å¼å¼¯ä¸¾ï¼Œèº«ä½“ä¸è¦ä¹±æ™ƒã€‚\nç»„æ•°ï¼š3ç»„ æ¬¡æ•°ï¼š12æ¬¡ é—´æ­‡ï¼š45~60ç§’ ç»ƒæ³•ï¼šæ¯ç»„åŠ›ç«­\n{% endfold %}\nå››è‚¢ - æ”¾æ¾ {% fold æŸ¥çœ‹è¯¦ç»† %}\næ‹‰ä¼¸å¤§è…¿å‰ä¾§\næ‹‰ä¼¸å¤§è…¿åä¾§\nè›™è¶´ï¼ˆå¤§è…¿å†…ä¾§ï¼‰\næ‹‰ä¼¸è‚©éƒ¨\næ‹‰ä¼¸è‚±äºŒå¤´è‚Œ\næ”¾æ¾é«‚èƒ«æŸ\næ”¾æ¾è‚¡å››å¤´è‚Œ\n{% endfold %}\näº”ã€é¥®é£Ÿ è‚Œè‚‰ä¸æ˜¯åœ¨è®­ç»ƒæ—¶å¢é•¿çš„ï¼Œè€Œæ˜¯åœ¨æ¢å¤ä¸­ã€‚æ²¡åƒå¤Ÿï¼Œå°±æ²¡æœ‰åŸæ–™æ”¯æŒè‚Œçº¤ç»´çš„è¶…é‡æ¢å¤ã€‚ä¸‰åˆ†ç»ƒï¼Œä¸ƒåˆ†åƒã€‚\nè›‹ç™½è´¨ï¼Œæ¯å¤©æ¯å…¬æ–¤ä½“é‡1.8å…‹\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nè®­ç»ƒå¼ºåº¦è¶³å¤Ÿçš„å¢è‚Œè®­ç»ƒè€…ï¼Œæ¯å¤©æ¯å…¬æ–¤ä½“é‡éœ€è¦æ‘„å…¥1.5~2å…‹è›‹ç™½è´¨ã€‚ä»¥æ¯å¤©æ¯å…¬æ–¤ä½“é‡1.8å…‹ä¸ºä¾‹ï¼Œä½“é‡55kgï¼Œåˆ™éœ€è¦æ‘„å…¥55 Ã— 1.8 = 99g è›‹ç™½è´¨ã€‚è‚‰ã€è›‹ã€å¥¶å’Œè±†ç±»éƒ½æœ‰ä¸°å¯Œçš„è›‹ç™½è´¨ï¼Œä½†æ˜¯æ³¨æ„å¢è‚Œæ›´éœ€è¦åŠ¨ç‰©è›‹ç™½ã€‚\n{% endfold %}\nç¢³æ°´åŒ–åˆç‰©ï¼Œæ¯å¤©æ¯å…¬æ–¤ä½“é‡6å…‹\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåŒæ—¶ï¼Œè‚Œè‚‰å¢é•¿è¿˜éœ€è¦è¡¥å……ç¢³æ°´åŒ–åˆç‰©ï¼Œç”¨ä»¥æ”¯æŒè›‹ç™½è´¨çš„æ‘„å…¥ã€‚æ¯å¤©æ¯å…¬æ–¤éœ€è¦æ‘„å…¥4~8å…‹ç¢³æ°´åŒ–åˆç‰©ï¼Œä»¥6å…‹ç¢³æ°´åŒ–åˆç‰©ä¸ºä¾‹ï¼Œä½“é‡55kgéœ€è¦æ‘„å…¥55 Ã— 6 = 330g ç¢³æ°´åŒ–åˆç‰©ã€‚å¯¹äºä½“å‹ç˜¦çš„äººæ¥è¯´ï¼Œå¾ˆéš¾åƒå¤Ÿè¿™ä¸ªé‡ï¼Œå› æ­¤æ¥è¯´å¢è‚Œç²‰æ•ˆæœé€šå¸¸å¥½äºè›‹ç™½ç²‰ã€‚\n{% endfold %}\nä¸é¥±å’Œè„‚è‚ªé…¸ï¼Œåšæœç±»ç­‰éšæ„\n{% fold æŸ¥çœ‹è¯¦ç»† %}\nåšæœç±»ã€ç‰›æ²¹æœã€ä¸‰æ–‡é±¼éƒ½ä¸é”™ï¼Œè™½ç„¶ä¸æ˜¯å¢è‚Œçš„é‡ç‚¹ï¼Œä½†æ˜¯é€‚å½“æ‘„å…¥æœ‰ç›Šèº«ä½“å¥åº·ã€‚\n{% endfold %}\né¥®é£Ÿè®¡ç®—\nä½¿ç”¨è–„è·è¥å…»å¸ˆç­‰APPä»¥åŠé£Ÿç‰©ç§¤ï¼Œè®¡ç®—æ¯æ—¥æ‘„å…¥é‡æ˜¯å¦è¾¾æ ‡ã€‚\nåŠ é¤\nå¯ä»¥å®‰æ’ä¸€å¤©6é¤ã€‚å‰æœŸå›°éš¾çš„è¯å¯ä»¥å¾ªåºæ¸è¿›ã€‚\nç®€å•ç²—æš´\næ¯å‘¨ä¸€ç§°ä½“é‡ï¼Œå¦‚æœæœ‰ä¸Šå‡ï¼Œè¯´æ˜åƒå¤Ÿäº†ï¼Œåä¹‹æ²¡æœ‰ï¼Œéœ€è¦åŠ é‡ã€‚\nå…­ã€ä¼‘æ¯ ä¸è¦è®­ç»ƒè¿‡åº¦ï¼Œéœ€è¦æ³¨æ„è¶…é‡æ¢å¤åŸç†ï¼Œä¼‘æ¯å¾ˆé‡è¦ã€‚ è¿ç»­è®­ç»ƒä¸¤åˆ°ä¸‰å¤©ï¼Œéœ€è¦å½»åº•ä¼‘æ¯ä¸€å¤©ã€‚ åŒä¸€å—è‚Œè‚‰ï¼Œä¸è¦å®‰æ’è¿ç»­ä¸¤å¤©è®­ç»ƒã€‚ æ¯2~3ä¸ªæœˆå®‰æ’ä¸€å‘¨æ¢å¤å‘¨ï¼Œè®­ç»ƒå‡åŠæˆ–è€…å®Œå…¨ä¸ç»ƒã€‚ æ‹’ç»ç†¬å¤œï¼Œè®©çš®è´¨é†‡é™ä¸‹å»ã€‚ é™„ã€å®¶åº­è®¡åˆ’ ä½¿ç”¨å¼¹åŠ›å¸¦ã€‚\nå‘¨ä¸€å››ï¼Œèº¯å¹²è®­ç»ƒï¼š\nå¼¹åŠ›å¸¦ä¿¯å§æ’‘ åå§¿ä¸Šæ–œæ¨èƒ¸ å¼¹åŠ›å¸¦å¤¹èƒ¸ å¼¹åŠ›å¸¦ä¿¯èº«åˆ’èˆ¹ å¼¹åŠ›å¸¦åå§¿åˆ’èˆ¹ å¼¹åŠ›å¸¦ç›´è‡‚ä¸‹å‹ å‘¨äºŒäº”ï¼Œå››è‚¢è®­ç»ƒï¼š\nå¼¹åŠ›å¸¦æ·±è¹² å¼¹åŠ›å¸¦ç¡¬æ‹‰ å¼¹åŠ›å¸¦ä¾§å¹³ä¸¾ å¼¹åŠ›å¸¦é¢æ‹‰ å¼¹åŠ›å¸¦å¼¯ä¸¾ å¼¹åŠ›å¸¦é”¤å¼å¼¯ä¸¾ æ­¤å¤–å¯ä»¥å…³æ³¨æœ¬æ–‡å†…å®¹ä¸»è¦æ¥æºï¼ŒBç«™upåŠwxå…¬ä¼—å·â€œå“å”å¢é‡â€ã€‚\n","permalink":"https://blog.lordash.de/posts/share/ed4db4b5d278abf7/","summary":"ä¸€ã€æ€ä¹ˆåƒéƒ½ä¸èƒ–çš„åŸå›  åŸºå› è¡¨è¾¾ï¼Œèº«ä½“å€¾å‘äºå°†å¤šä½™çš„è¥å…»ä»£è°¢è€Œä¸æ˜¯å‚¨å­˜ é¥®é£Ÿä¹ æƒ¯ï¼Œå®¢è§‚ä¸Šåƒå¾—å°‘ èº«ä½“ä¸éœ€è¦ äºŒã€å¢é‡ä¸ºä»€ä¹ˆè¦å¢è‚Œ å¢è‚Œï¼šè‚Œè‚‰å¢é•¿å¯æ§ï¼Œ","title":"å¢é‡æ–¹æ³•æ¨è"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ Snipaste ä¸€ä¸ªç®€å•ä½†åŠŸèƒ½å¼ºå¤§çš„å‰ªè´´å·¥å…·ï¼Œè¿˜åŒ…å«è´´å›¾åŠŸèƒ½ã€‚ æ”¯æŒå¹³å°ï¼š Ditto windowså‰ªè´´æ¿çš„æ‰©å±•ï¼Œå¯ä»¥ä¿å­˜æ”¾ç½®åœ¨å‰ªè´´æ¿ä¸Šçš„ä»»ä½•ç±»å‹çš„ä¿¡æ¯ã€‚ æ”¯æŒå¹³å°ï¼š Everything Windowsä¸Šä¸€æ¬¾æœç´¢å¼•æ“ï¼Œå®ƒèƒ½å¤ŸåŸºäºæ–‡ä»¶åå¿«é€Ÿå®šæ–‡ä»¶å’Œæ–‡ä»¶å¤¹ä½ç½®ã€‚ æ”¯æŒå¹³å°ï¼š ","permalink":"https://blog.lordash.de/f/share/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ Snipaste ä¸€ä¸ªç®€å•ä½†åŠŸèƒ½å¼ºå¤§çš„å‰ªè´´å·¥å…·ï¼Œè¿˜åŒ…å«è´´å›¾åŠŸèƒ½ã€‚ æ”¯æŒå¹³å°ï¼š Ditto windowså‰ªè´´æ¿çš„æ‰©å±•ï¼Œå¯ä»¥ä¿å­˜æ”¾ç½®åœ¨å‰ªè´´æ¿ä¸Šçš„ä»»ä½•ç±»å‹","title":"å¥½ç‰©åˆ†äº«"},{"content":"é‚£äº›ä¹¦å†™çƒ­çˆ±çš„äºº jaihk66215çº§æ ¡å‹ ACM ä¿¡ä»°.15çº§æ ¡å‹ ACM ä¸Šå¤§ SSimpLe_Y15çº§æ ¡å‹ ACM liweihang17çº§æ ¡å‹ ACM é¹…å‚ ironz17çº§æ ¡å‹ è¥¿ç”µ irvix17çº§æ ¡å‹ ACM iamstarlee17çº§æ ¡å‹ ACM haut_bao17çº§æ ¡å‹ ACM Long_hen19çº§æ ¡å‹ ACM cosine19çº§æ ¡å‹ ACM æ‹“æ‹”é˜¿ç§€ æŠ–éŸ³å…¨æ ˆï¼Œé¢è¯•ç¬”è®° æŸ³å©¼ã®blog15çº§æ ¡å‹ PAT é˜¿ä¹ ç‰›å®¢ è®¤è¯†ä¸€ä¸‹å§ ç”³è¯·æ”¶å½•\n","permalink":"https://blog.lordash.de/f/links/","summary":"é‚£äº›ä¹¦å†™çƒ­çˆ±çš„äºº jaihk66215çº§æ ¡å‹ ACM ä¿¡ä»°.15çº§æ ¡å‹ ACM ä¸Šå¤§ SSimpLe_Y15çº§æ ¡å‹ ACM liweihang17çº§æ ¡å‹ ACM é¹…å‚ ironz","title":"å‹æƒ…é“¾æ¥"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ åœ¨çº¿è®¡ç®— ç¡®å®š ç¾/å¾·å†›Milï¼šæœªè®¾ç½®\nè‹å†›Milï¼šæœªè®¾ç½®\nè‹±å†›Milï¼šæœªè®¾ç½®\nå¯†ä½ç®€ä»‹ æ¯«å¼§åº¦(milliradianï¼Œç®€ç§°mrad)ï¼Œä¹Ÿç§°å¯†ä½(mil)ï¼Œæ˜¯ä¸€ç§åœ¨å‡ ä½•å­¦å’Œåº”ç”¨ç‰©ç†å­¦ä¸Šç”¨æ¥æµ‹é‡å¹³é¢è§’çš„SIå¯¼å‡ºå•ä½ï¼Œç›¸å½“äº1å¼§åº¦çš„åƒåˆ†ä¹‹ä¸€ï¼Œç»å¸¸è¢«ç”¨äºæ ¡æ­£ç«å™¨ç„å…·ã€‚ä¸€ä¸ª360åº¦åœ†å‘¨æ‰€å¯¹åº”çš„å¼§åº¦ä¸º2Ï€ï¼Œä¹Ÿå°±æ˜¯2000Ï€ï¼ˆ6283.185ï¼‰ä¸ªå¯†ä½ã€‚\nä¸ºè®¡ç®—æ–¹ä¾¿ï¼ŒåŸåçº¦é›†å›¢å›½å®¶å’Œä¸­å›½é€šå¸¸é‡‡ç”¨6000å¯†ä½åˆ¶ï¼Œç¾å›½ç­‰è¥¿æ–¹å›½å®¶é‡‡ç”¨6400å¯†ä½åˆ¶ã€‚ä½†éšç€è®¡ç®—æœºçš„æ™®åŠï¼Œç°åœ¨æ™®éä¸å†ä½¿ç”¨è€å¼æ ‡å‡†é‡Œä¿®çº¦è¿‡çš„å¯†ä½ï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨æ•°å­¦ä¸Šç²¾ç¡®çš„æ¯«å¼§åº¦ã€‚\næ•°å­¦åŸç† è§’åº¦è¶³å¤Ÿå°çš„æ—¶å€™ï¼Œæœ‰ï¼š$$ \\sin \\theta \\approx \\theta $$\nè¿™ä½¿å¾—ä¸‰è§’å­¦è®¡ç®—å¯ä»¥ç”¨ç®€å•çš„ç®—æœ¯æ¥è¿‘ä¼¼ã€‚1å¯†ä½æ¥è¿‘äº1ä¸ªæ¯«å¼§åº¦ã€‚å› æ­¤$$ \\tanâ¡(1 mil) \\approx \\tanâ¡(1 mrad) \\approx 0.001 $$\nä¾‹å¦‚ï¼Œå·²çŸ¥è¿œå¤„é«˜åº¦çº¦ä¸º1ç±³ï¼Œé«˜åº¦è§’çº¦ä¸º1ä¸ªå¯†ä½ï¼Œåˆ™å…¶è·ç¦»çº¦ä¸º1000ç±³ã€‚è¿™å°±æ˜¯å¯¹è·ç¦»çš„å¿«é€Ÿä¼°ç®—ã€‚è¿™ä¹Ÿå¯ä»¥ç”¨äºç”±è¿œå¤„ç‰©ä½“çš„æ°´å¹³è§‚å¯Ÿè§’åº¦æ¥ä¼°ç®—è·ç¦»ã€‚å†ä¾‹å¦‚ï¼Œè¿œå¤„çš„T-34çš„ä¾§é¢æµ‹å¾—ä¸º8.5ä¸ªå¯†ä½ï¼Œå·²çŸ¥å…¶ä¾§é¢çº¦6ç±³é•¿ï¼Œåˆ™è·ç¦»ä¸º $$ \\frac{6m}{ \\tan(8.5mil)} \\approx \\frac{6m}{0.0085} \\approx 705.882m $$ çº¦ç­‰äº 700 mã€‚\næ¸¸æˆ æ¸¸æˆé‡Œï¼Œä¸­è·¯HQé™„è¿‘çš„ä¸‰é—¨æ¦´å¼¹ç‚®ï¼Œä½¿ç”¨çš„æ˜¯é«˜å°„ç•Œå°„å‡»ï¼Œå³å°„è§’å¤§äº45Â°ï¼Œæ­¤æ—¶å°„ç¨‹å’Œå°„è§’è´Ÿç›¸å…³ï¼š\n1Mil=æœ€å¤§å°„è§’-(ç›®æ ‡è·ç¦»-æœ€å°å°„ç¨‹)/(æœ€å¤§å°„ç¨‹-æœ€å°å°„ç¨‹)*(æœ€å¤§å°„è§’-æœ€å°å°„è§’) ç»“åˆæ¸¸æˆç»™å‡ºçš„æ•°æ®ï¼š\n1ç¾/å¾· è‹ è‹± 21600M | 622 MIL 1600M | 800 MIL 1600M | 267 MIL 31500M | 646 MIL 1500M | 821 MIL 1500M | 284 MIL 41400M | 670 MIL 1400M | 843 MIL 1400M | 302 MIL 5... ... ... 6200M | 954 MIL 200M | 1099 MIL 200M | 516 MIL 7100M | 978 MIL 100M | 1120 MIL 100M | 533 MIL è®¡ç®—å¾—çŸ¥\n1ç¾/å¾·å†› Mil=978-(è·ç¦»-100)/(1600-100)*(978-622) 2è‹å†› Mil=1120-(è·ç¦»-100)/(1600-100)*(1120-800) 3è‹±å†› Mil=533-(è·ç¦»-100)/(1600-100)*(533-267) ","permalink":"https://blog.lordash.de/f/games/hell-let-loose-mil/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ åœ¨çº¿è®¡ç®— ç¡®å®š ç¾/å¾·å†›Milï¼šæœªè®¾ç½® è‹å†›Milï¼šæœªè®¾ç½® è‹±å†›Milï¼šæœªè®¾ç½® å¯†ä½ç®€ä»‹ æ¯«å¼§åº¦(milliradianï¼Œç®€ç§°mra","title":"äººé—´åœ°ç‹±-å¯†ä½è®¡ç®—"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æœªå®Œå¾…ç»­\næ‰å°çŒ«\näººé—´åœ°ç‹±-å¯†ä½\n","permalink":"https://blog.lordash.de/f/games/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ æœªå®Œå¾…ç»­ æ‰å°çŒ« äººé—´åœ°ç‹±-å¯†ä½","title":"æ¸¸æˆ"},{"content":" å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä½œè€…ï¼šganlvtech\ncanvaså¤§å°570x501ï¼Œè¯·ä½¿ç”¨PCç«¯æµè§ˆå™¨è®¿é—®ã€‚æ²¡åŠ è½½å°±åˆ·æ–°ä¸€ä¸‹~\n","permalink":"https://blog.lordash.de/f/games/catch-the-cat/","summary":"å…³äº ä¸ªäºº ç›¸å†Œ åˆ†äº« æ¸¸æˆ ä½œè€…ï¼šganlvtech canvaså¤§å°570x501ï¼Œè¯·ä½¿ç”¨PCç«¯æµè§ˆå™¨è®¿é—®ã€‚æ²¡åŠ è½½å°±åˆ·æ–°ä¸€ä¸‹~","title":"æ‰å°çŒ«"},{"content":"ä¸€ã€åˆ›å»ºæ–‡ç«  å‘½ä»¤ï¼š\n1hexo new [layout] \u0026lt;title\u0026gt; å‚æ•°è¯´æ˜ï¼š\nlayoutå¯ä»¥ä¸ºä»¥ä¸‹ä¸‰ç§ï¼š å‚æ•°å åŠŸèƒ½ æ–‡ç« è·¯å¾„ post æ–°å»ºåšæ–‡ source/_posts page æ–°å»ºé¡µé¢ï¼ˆå¦‚404ï¼Œåˆ†ç±»ï¼‰ source draft è‰ç¨¿ source/_drafts è‰ç¨¿å¯é€šè¿‡ä¸€ä¸‹å‘½ä»¤å‘å¸ƒï¼š\n1hexo publish [layout] \u0026lt;title\u0026gt; æ³¨æ„ï¼Œtitle å¹¶ä¸æ˜¯åšæ–‡çš„æ ‡é¢˜ï¼Œè€Œæ˜¯åšæ–‡markdownæ–‡ä»¶çš„åå­—ï¼Œä¹Ÿå°±æ˜¯åšæ–‡é“¾æ¥çš„åç¼€ï¼ˆä¾‹å¦‚ https://gh1656409967.github.io/éšç¬”/ã€éšç¬”ã€‘hexoæ–‡ç« æ“ä½œ/ ä¸­çš„ ã€éšç¬”ã€‘hexoæ–‡ç« æ“ä½œ ï¼‰\näºŒã€æ–‡ç« æ¨¡ç‰ˆ åˆ›å»ºæ¨¡ç‰ˆ\nåœ¨æ–°å»ºæ–‡ç« æ—¶ï¼Œhexo ä¼šæ ¹æ® scaffolds æ–‡ä»¶å¤¹å†…ç›¸å¯¹åº”çš„æ–‡ä»¶æ¥å»ºç«‹æ–‡ä»¶ï¼Œä¾‹å¦‚ï¼š\n1hexo new blog \u0026#34;foo\u0026#34; åœ¨æ‰§è¡Œè¿™è¡ŒæŒ‡ä»¤æ—¶ï¼Œhexo ä¼šå°è¯•åœ¨ scaffolds æ–‡ä»¶å¤¹ä¸­å¯»æ‰¾ blog.mdï¼Œå¹¶æ ¹æ®å…¶å†…å®¹å»ºç«‹æ–‡ç« ã€‚\nä¿®æ”¹å‚æ•°\nä»¥ä¸‹æ˜¯å¯ä»¥åœ¨æ¨¡ç‰ˆä¸­ä½¿ç”¨çš„å˜é‡ï¼š\nå˜é‡ æè¿° layout å¸ƒå±€ title æ ‡é¢˜ date æ–‡ä»¶å»ºç«‹æ—¥æœŸ ä¸‰ã€Front-matter å°±æ˜¯åšæ–‡æœ€ä¸Šæ–¹ä»¥ --- åˆ†éš”çš„é‚£éƒ¨åˆ†ã€‚\né»˜è®¤å¯ä»¥ä½¿ç”¨çš„Front-matterï¼š\nå‚æ•° æè¿° é»˜è®¤å€¼ layout å¸ƒå±€ title æ ‡é¢˜ date å»ºç«‹æ—¥æœŸ æ–‡ä»¶å»ºç«‹æ—¥æœŸ updated æ›´æ–°æ—¥æœŸ æ–‡ä»¶æ›´æ–°æ—¥æœŸ comments å¼€å¯æ–‡ç« çš„è¯„è®ºåŠŸèƒ½ true tags æ ‡ç­¾ï¼ˆä¸é€‚ç”¨äºåˆ†é¡µï¼‰ categories åˆ†ç±»ï¼ˆä¸é€‚ç”¨äºåˆ†é¡µï¼‰ permalink è¦†ç›–æ–‡ç« ç½‘å€ ","permalink":"https://blog.lordash.de/posts/essays/hexo%E6%96%87%E7%AB%A0%E6%93%8D%E4%BD%9C/","summary":"ä¸€ã€åˆ›å»ºæ–‡ç«  å‘½ä»¤ï¼š 1hexo new [layout] \u0026lt;title\u0026gt; å‚æ•°è¯´æ˜ï¼š layoutå¯ä»¥ä¸ºä»¥ä¸‹ä¸‰ç§ï¼š å‚æ•°å åŠŸèƒ½ æ–‡ç« è·¯å¾„ post æ–°å»ºåšæ–‡ source/_posts page æ–°å»ºé¡µé¢ï¼ˆå¦‚404ï¼Œåˆ†ç±»ï¼‰ source draft è‰ç¨¿ source/_drafts è‰ç¨¿å¯é€š","title":"Hexoæ–‡ç« æ“ä½œ"},{"content":"ä¸€ã€å‡†å¤‡ äºMySQLå®˜ç½‘æ ¹æ®éœ€è¦ä¸‹è½½ï¼Œå‚è€ƒé“¾æ¥ï¼š\nmysql-8.0.18-winx64.zip mysql-connector-java-8.0.18.zip äºŒã€MySQL é…ç½® é…ç½®ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼Œæˆ–è€…ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œcmdï¼Œè¿›å…¥è§£å‹ç›®å½•ä¸‹çš„binç›®å½•ä¸­è¿è¡Œå‘½ä»¤ï¼Œä¾‹å¦‚ D:\\Program Files (x86)\\mysql-8.0.18-winx64\\bin\u0026gt;\nç”Ÿæˆdataç›®å½•\n1\u0026gt; mysqld --initialize-insecure --user=mysql å®‰è£…MySQL\n1\u0026gt; mysqld -install æµ‹è¯• å¯åŠ¨MySQLæœåŠ¡\n1\u0026gt; net start mysql ç™»å½•MySQLï¼ˆå¯†ç ä¸ºç©ºï¼Œç›´æ¥å›è½¦å³å¯ï¼‰\n1\u0026gt; mysql -u root -p å¦‚æœå¯†ç ä¸ä¸ºç©ºï¼Œå…ˆå…³é—­æœåŠ¡\n1\u0026gt; net stop mysql æ‰§è¡Œä»¥ä¸‹å‘½ä»¤åï¼Œå†é‡å¯æœåŠ¡ï¼Œç„¶åé‡æ–°ç™»å½•\n1\u0026gt; mysqld -nt --skip-grant-tables ï¼ˆä¾ç„¶æ— æ•ˆçš„ï¼Œè¯·åˆ é™¤ç›®å½•ä¸‹dataæ–‡ä»¶å¤¹ï¼Œå¹¶é‡æ–°é…ç½®ï¼‰\nä¿®æ”¹å¯†ç \n1mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new password\u0026#39;; ä¸‰ã€JDBC é…ç½® å°† mysql-connector-java-8.0.18.zip è§£å‹ï¼Œæ‰¾åˆ° mysql-connector-java-8.0.18.jarï¼Œç½®äºjava jreçš„lib/ext/ç›®å½•ä¸‹ã€‚ä»¥æœ¬æœºä¸ºå‚è€ƒï¼Œç›®å½•æ˜¯ï¼š C:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\\\næµ‹è¯• å†™ä¸€ä¸ªç®€å•æµ‹è¯• test.javaå¦‚ä¸‹ï¼Œç¼–è¯‘è¿è¡ŒæŸ¥çœ‹ç»“æœå³å¯ã€‚\n1import java.sql.*; 2public class test { 3 public static void main(String[] args) { 4 try { 5 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); 6 String url = \u0026#34;jdbc:mysql://localhost?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=UTC\u0026#34;; 7 Connection con = DriverManager.getConnection(url, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); 8 if (con != null) { 9 System.out.println(\u0026#34;success...\u0026#34;); 10 con.close(); 11 } 12 else { 13 System.out.println(\u0026#34;failure!!!\u0026#34;); 14 } 15 } 16 catch (ClassNotFoundException e) { 17 e.printStackTrace(); 18 } 19 catch (SQLException e) { 20 e.printStackTrace(); 21 } 22 } 23} é™„ï¼š\nmysql-connector-java 5ä¸­ä½¿ç”¨com.mysql.jdbc.Driverï¼Œè€Œmysql-connector-java 6ä¸­åˆ™ä½¿ç”¨com.mysql.cj.jdbc.Driver è¿æ¥å­—ç¬¦ä¸²ååŠ ?useUnicode=true\u0026amp;characterEncoding=UTF-8è§£å†³ä¸­æ–‡ä¹±ç é—®é¢˜ è¿æ¥å­—ç¬¦ä¸²ååŠ ?serverTimezone=UTCè§£å†³æ—¶åŒºé—®é¢˜ ","permalink":"https://blog.lordash.de/posts/configure/0da28f65294b5e79/","summary":"ä¸€ã€å‡†å¤‡ äºMySQLå®˜ç½‘æ ¹æ®éœ€è¦ä¸‹è½½ï¼Œå‚è€ƒé“¾æ¥ï¼š mysql-8.0.18-winx64.zip mysql-connector-java-8.0.18.zip äºŒã€MySQL é…ç½® é…ç½®ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼Œæˆ–è€…ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œcmdï¼Œè¿›å…¥è§£å‹ç›®å½•ä¸‹çš„binç›®","title":"Win10é…ç½®MySQLå’ŒJDBC"},{"content":"Monthly Expense (POJ - 3273) é¢˜é¢ Farmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 â‰¤ moneyi â‰¤ 10,000) that he will need to spend each day over the next N (1 â‰¤ N â‰¤ 100,000) days.\nFJ wants to create a budget for a sequential set of exactly M (1 â‰¤ M â‰¤ N) fiscal periods called \u0026ldquo;fajomonths\u0026rdquo;. Each of these fajomonths contains a set of 1 or more consecutive days. Every day is contained in exactly one fajomonth.\nFJ\u0026rsquo;s goal is to arrange the fajomonths so as to minimize the expenses of the fajomonth with the highest spending and thus determine his monthly spending limit.\nè¾“å…¥ Line 1: Two space-separated integers: N and M Lines 2.. N+1: Line i+1 contains the number of dollars Farmer John spends on the ith day\nè¾“å‡º Line 1: The smallest possible monthly limit Farmer John can afford to live with.\næ ·ä¾‹è¾“å…¥ 17 5 2100 3400 4300 5100 6500 7101 8400 æ ·ä¾‹è¾“å‡º 1500 æç¤º If Farmer John schedules the months so that the first two days are a month, the third and fourth are a month, and the last three are their own months, he spends at most $500 in any month. Any other method of scheduling gives a larger minimum monthly limit.\næ€è·¯ ä»£ç  1using namespace std; 2const int N = 2e5+10; 3 4int a[N] = {0}; 5int n, m; 6 7int main(void) { 8 while(~scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)) { 9 int sum = 0, mx = 0; 10 for(int i=0; i\u0026lt;n; i++) { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 12 sum += a[i]; 13 mx = max(mx, a[i]); 14 } 15 int l=mx, r=sum, mid=0; 16 while(l\u0026lt;=r) { 17 mid = l+(r-l)/2; 18 int ans = 1, k = 0; 19 for(int i=0; i\u0026lt;n; i++) { 20 k += a[i]; 21 if(k\u0026gt;mid) { 22 k = a[i]; 23 ans ++; 24 } 25 } 26 if(ans\u0026gt;m) 27 l = mid+1; 28 else 29 r = mid-1; 30 } 31 printf(\u0026#34;%d\\n\u0026#34;, mid); 32 } 33 return 0; 34} ","permalink":"https://blog.lordash.de/posts/solution/poj-3273-monthly-expense/","summary":"Monthly Expense (POJ - 3273) é¢˜é¢ Farmer John is an astounding accounting wizard and has realized he might run out of money to run the farm. He has already calculated and recorded the exact amount of money (1 â‰¤ moneyi â‰¤ 10,000) that he will need to spend each day over the next N (1 â‰¤ N â‰¤ 100,000) days. FJ wants to create a budget for a sequential","title":"POJ-3273 Monthly Expense"},{"content":"Pie (POJ - 3122) é¢˜é¢ My birthday is coming up and traditionally I\u0026rsquo;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.\nMy friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.\nWhat is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.\nè¾“å…¥ One line with a positive integer: the number of test cases. Then for each test case:\nOne line with two integers N and F with 1 â‰¤ N, F â‰¤ 10 000: the number of pies and the number of friends. One line with N integers ri with 1 â‰¤ ri â‰¤ 10 000: the radii of the pies. è¾“å‡º For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^âˆ’3.\næ ·ä¾‹è¾“å…¥ 13 23 3 34 3 3 41 24 55 610 5 71 4 2 3 4 5 6 5 4 2 æ ·ä¾‹è¾“å‡º 125.1327 23.1416 350.2655 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2const double pi = acos(-1.0); 3const double eps = 1e-6; 4const int N = 2e5 + 5; 5 6double a[N] = {0}; 7int T, n, f; 8 9int main(void) { 10 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 11 while(T--) { 12 scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;f); 13 double mx=0; 14 for(int i=0; i\u0026lt;n; i++) { 15 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[i]); 16 a[i] = a[i]*a[i]*pi; 17 mx = max(mx, a[i]); 18 } 19 double l=0, r=mx, mid=0; 20 while(r-l \u0026gt; eps) { 21 mid = l+(r-l)/2; 22 int num = 0; 23 for(int i=0; i\u0026lt;n; i++) { 24 num += (int)(a[i]/mid); 25 } 26 if(num \u0026gt;= f+1) 27 l = mid; 28 else 29 r = mid; 30 } 31 printf(\u0026#34;%.4lf\\n\u0026#34;, mid); 32 } 33 return 0; 34} ","permalink":"https://blog.lordash.de/posts/solution/poj-3122-pie/","summary":"Pie (POJ - 3122) é¢˜é¢ My birthday is coming up and traditionally I\u0026rsquo;m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This","title":"POJ-3122 Pie"},{"content":"Seek the Name, Seek the Fame (POJ-2752) é¢˜é¢ The little cat is so famous, that many couples tramp over hill and dale to Byteland, and asked the little cat to give names to their newly-born babies. They seek the name, and at the same time seek the fame. In order to escape from such boring job, the innovative little cat works out an easy but fantastic algorithm:\nStep1. Connect the father\u0026rsquo;s name and the mother\u0026rsquo;s name, to a new string S. Step2. Find a proper prefix-suffix string of S (which is not only the prefix, but also the suffix of S).\nExample: Father=\u0026lsquo;ala\u0026rsquo;, Mother=\u0026lsquo;la\u0026rsquo;, we have S = \u0026lsquo;ala\u0026rsquo;+\u0026lsquo;la\u0026rsquo; = \u0026lsquo;alala\u0026rsquo;. Potential prefix-suffix strings of S are {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;ala\u0026rsquo;, \u0026lsquo;alala\u0026rsquo;}. Given the string S, could you help the little cat to write a program to calculate the length of possible prefix-suffix strings of S? (He might thank you by giving your baby a name:)\nè¾“å…¥ The input contains a number of test cases. Each test case occupies a single line that contains the string S described above.\nRestrictions: Only lowercase letters may appear in the input. 1 \u0026lt;= Length of S \u0026lt;= 400000.\nè¾“å‡º For each test case, output a single line with integer numbers in increasing order, denoting the possible length of the new baby\u0026rsquo;s name.\næ ·ä¾‹è¾“å…¥ 1ababcababababcabab 2aaaaa æ ·ä¾‹è¾“å‡º 12 4 9 18 21 2 3 4 5 æç¤º æ— \næ€è·¯ æ±‚æ‰€æœ‰å…¬å…±å‰ç¼€åç¼€é•¿åº¦\nä»£ç  1char s[mxn], t[mxn]; 2int nxt[mxn], a[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 // ans++; 29 // j = nxt[j]; 30 return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 // return ans; 36 return -1; 37} 38 39int main() 40{ 41 while(scanf(\u0026#34;%s\u0026#34;, s) == 1) 42 { 43 int n = strlen(s), j=0; 44 getnxt(s, n); 45 46 for(int i=n; i\u0026gt;0; i=nxt[i]){ 47 a[j++] = i; 48 } 49 for(int i=j-1; i\u0026gt;=0; i--){ 50 printf(\u0026#34;%d \u0026#34;, a[i]); 51 } 52 printf(\u0026#34;\\n\u0026#34;); 53 } 54 return 0; 55} ","permalink":"https://blog.lordash.de/posts/solution/poj-2752-seek-the-name-seek-the-fame/","summary":"Seek the Name, Seek the Fame (POJ-2752) é¢˜é¢ The little cat is so famous, that many couples tramp over hill and dale to Byteland, and asked the little cat to give names to their newly-born babies. They seek the name, and at the same time seek the fame. In order to escape from such boring job, the innovative little cat works out an easy but fantastic algorithm: Step1. Connect","title":"ã€é¢˜è§£ã€‘POJ-2752 Seek the Name, Seek the Fame"},{"content":"Balance (POJ - 1837) é¢˜é¢ Gigel has a strange \u0026ldquo;balance\u0026rdquo; and he wants to poise it. Actually, the device is different from any other ordinary balance. It orders two arms of negligible weight and each arm\u0026rsquo;s length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 \u0026lt;= G \u0026lt;= 20) knowing that these weights have distinct values in the range 1..25. Gigel may droop any weight of any hook but he is forced to use all the weights. Finally, Gigel managed to balance the device using the experience he gained at the National Olympiad in Informatics. Now he would like to know in how many ways the device can be balanced.\nKnowing the repartition of the hooks and the set of the weights write a program that calculates the number of possibilities to balance the device. It is guaranteed that will exist at least one solution for each test case at the evaluation.\nè¾“å…¥ The input has the following structure: â€¢ the first line contains the number C (2 \u0026lt;= C \u0026lt;= 20) and the number G (2 \u0026lt;= G \u0026lt;= 20); â€¢ the next line contains C integer numbers (these numbers are also distinct and sorted in ascending order) in the range -15..15 representing the repartition of the hooks; each number represents the position relative to the center of the balance on the X axis (when no weights are attached the device is balanced and lined up to the X axis; the absolute value of the distances represents the distance between the hook and the balance center and the sign of the numbers determines the arm of the balance to which the hook is attached: \u0026lsquo;-\u0026rsquo; for the left arm and \u0026lsquo;+\u0026rsquo; for the right arm); â€¢ on the next line there are G natural, distinct and sorted in ascending order numbers in the range 1..25 representing the weights\u0026rsquo; values.\nè¾“å‡º The output contains the number M representing the number of possibilities to poise the balance.\næ ·ä¾‹è¾“å…¥ 12 4 2-2 3 33 4 5 8 æ ·ä¾‹è¾“å‡º 12 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int N = 2e4 + 5; 4 5int dp[25][N]= {{0}}; 6int c[25], g[25]; 7int n, m; 8 9int main(void) { 10 while (scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m) == 2) { 11 for(int i=1; i\u0026lt;=n; i++) 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;c[i]); 13 for(int i=1; i\u0026lt;=m; i++) 14 scanf(\u0026#34;%d\u0026#34;, \u0026amp;g[i]); 15 dp[0][7500] = 1; 16 17 for(int i=1; i\u0026lt;=m; i++) { 18 for(int j=0; j\u0026lt;=15000; j++) 19 if(dp[i-1][j]) 20 for(int k=1; k\u0026lt;=n; k++) 21 dp[i][j+c[k]*g[i]] += dp[i-1][j]; 22 } 23 printf(\u0026#34;%d\\n\u0026#34;, dp[m][7500]); 24 } 25 26 return 0; 27} ","permalink":"https://blog.lordash.de/posts/solution/poj-1837-balance/","summary":"Balance (POJ - 1837) é¢˜é¢ Gigel has a strange \u0026ldquo;balance\u0026rdquo; and he wants to poise it. Actually, the device is different from any other ordinary balance. It orders two arms of negligible weight and each arm\u0026rsquo;s length is 15. Some hooks are attached to these arms and Gigel wants to hang up some weights from his collection of G weights (1 \u0026lt;= G \u0026lt;= 20) knowing that these weights","title":"POJ-1837 Balance"},{"content":"To the Max (POJ - 1050) é¢˜é¢ Given a two-dimensional array of positive and negative integers, a sub-rectangle is any contiguous sub-array of size 1*1 or greater located within the whole array. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the sub-rectangle with the largest sum is referred to as the maximal sub-rectangle. As an example, the maximal sub-rectangle of the array:\n0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 is in the lower left corner:\n9 2 -4 1 -1 8 and has a sum of 15.\nè¾“å…¥ The input consists of an N * N array of integers. The input begins with a single positive integer N on a line by itself, indicating the size of the square two-dimensional array. This is followed by N^2 integers separated by whitespace (spaces and newlines). These are the N^2 integers of the array, presented in row-major order. That is, all numbers in the first row, left to right, then all numbers in the second row, left to right, etc. N may be as large as 100. The numbers in the array will be in the range [-127,127].\nè¾“å‡º Output the sum of the maximal sub-rectangle.\næ ·ä¾‹è¾“å…¥ 14 20 -2 -7 0 9 2 -6 2 3-4 1 -4 1 -1 4 58 0 -2 æ ·ä¾‹è¾“å‡º 115 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2 + 5; 5 6int a[N][N] = {{0}}; 7int f[N][N][N] = {{{0}}}; 8int n; 9 10int main(void) { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 12 for (int i=0; i\u0026lt;n; i++) { 13 for (int j=0; j\u0026lt;n; j++) 14 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); 15 } 16 int mx = -inf; 17 for(int i=0; i\u0026lt;n; i++) { 18 for(int j=0; j\u0026lt;n; j++) { 19 int sum = 0; 20 for(int k=j; k\u0026lt;n; k++) { 21 sum += a[i][k]; 22 f[i][j][k] = max(f[i-1][j][k]+sum, sum); 23 mx = max(mx, f[i][j][k]); 24 } 25 } 26 } 27 printf(\u0026#34;%d\\n\u0026#34;, mx); 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/poj-1050-to-the-max/","summary":"To the Max (POJ - 1050) é¢˜é¢ Given a two-dimensional array of positive and negative integers, a sub-rectangle is any contiguous sub-array of size 1*1 or greater located within the whole array. The sum of a rectangle is the sum of all the elements in that rectangle. In this problem the sub-rectangle with the largest sum is referred to as the maximal sub-rectangle. As an example, the maximal sub-rectangle","title":"POJ-1050 To the Max"},{"content":"Monkey and Banana (HDU - 1069) é¢˜é¢ A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a tower and climb up to get its favorite food.\nThe researchers have n types of blocks, and an unlimited supply of blocks of each type. Each type-i block was a rectangular solid with linear dimensions (xi, yi, zi). A block could be reoriented so that any two of its three dimensions determined the dimensions of the base and the other dimension was the height.\nThey want to make sure that the tallest tower possible by stacking blocks can reach the roof. The problem is that, in building a tower, one block could only be placed on top of another block as long as the two base dimensions of the upper block were both strictly smaller than the corresponding base dimensions of the lower block because there has to be some space for the monkey to step on. This meant, for example, that blocks oriented to have equal-sized bases couldn\u0026rsquo;t be stacked.\nYour job is to write a program that determines the height of the tallest tower the monkey can build with a given set of blocks.\nè¾“å…¥ The input file will contain one or more test cases. The first line of each test case contains an integer n, representing the number of different blocks in the following data set. The maximum value for n is 30. Each of the next n lines contains three integers representing the values xi, yi and zi. Input is terminated by a value of zero (0) for n.\nè¾“å‡º For each test case, print one line containing the case number (they are numbered sequentially starting from 1) and the height of the tallest possible tower in the format \u0026ldquo;Case case: maximum height = height\u0026rdquo;.\næ ·ä¾‹è¾“å…¥ 11 210 20 30 32 46 8 10 55 5 5 67 71 1 1 82 2 2 93 3 3 104 4 4 115 5 5 126 6 6 137 7 7 145 1531 41 59 1626 53 58 1797 93 23 1884 62 64 1933 83 27 200 æ ·ä¾‹è¾“å‡º 1Case 1: maximum height = 40 2Case 2: maximum height = 21 3Case 3: maximum height = 28 4Case 4: maximum height = 342 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int N = 2e2 + 5; 4 5struct sc { 6 int l, w, h; 7} a[N]; 8 9int f[N] = {0}; 10int n, num = 1; 11 12bool cmp(sc x, sc y) { 13 if (x.l != y.l) 14 return x.l \u0026lt; y.l; 15 return x.w \u0026lt; y.w; 16} 17 18int main(void) { 19 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n) \u0026amp;\u0026amp; n) { 20 int l, w, h, t = 0; 21 for(int i=0; i\u0026lt;n; i++) { 22 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;w, \u0026amp;h); 23 a[t].l=l, a[t].w=w, a[t++].h=h; 24 a[t].l=l, a[t].w=h, a[t++].h=w; 25 a[t].l=w, a[t].w=l, a[t++].h=h; 26 a[t].l=w, a[t].w=h, a[t++].h=l; 27 a[t].l=h, a[t].w=l, a[t++].h=w; 28 a[t].l=h, a[t].w=w, a[t++].h=l; 29 } 30 sort(a, a+t, cmp); 31 32 int ans=0; 33 for(int i=0; i\u0026lt;t; i++) { 34 int mx=0; 35 for(int j=0; j\u0026lt;i; j++) { 36 if(a[j].l\u0026lt;a[i].l \u0026amp;\u0026amp; a[j].w\u0026lt;a[i].w) 37 mx = max(mx, f[j]); 38 } 39 f[i] = a[i].h+mx; 40 ans = max(ans, f[i]); 41 } 42 printf(\u0026#34;Case %d: maximum height = %d\\n\u0026#34;, num++, ans); 43 } 44 45 return 0; 46} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1069-monkey-and-banana/","summary":"Monkey and Banana (HDU - 1069) é¢˜é¢ A group of researchers are designing an experiment to test the IQ of a monkey. They will hang a banana at the roof of a building, and at the mean time, provide the monkey with some blocks. If the monkey is clever enough, it shall be able to reach the banana by placing one block on the top another to build a","title":"HDU-1069 Monkey and Banana"},{"content":"Ignatius and the Princess IV (HDU - 1029) é¢˜é¢ \u0026ldquo;OK, you are not too bad, em\u0026hellip; But you can never pass the next test.\u0026rdquo; feng5166 says.\n\u0026ldquo;I will tell you an odd number N, and then N integers. There will be a special integer among them, you have to tell me which integer is the special one after I tell you all the integers.\u0026rdquo; feng5166 says.\n\u0026ldquo;But what is the characteristic of the special integer?\u0026rdquo; Ignatius asks.\n\u0026ldquo;The integer will appear at least (N+1)/2 times. If you can\u0026rsquo;t find the right integer, I will kill the Princess, and you will be my dinner, too. Hahahaha\u0026hellip;..\u0026rdquo; feng5166 says.\nCan you find the special integer for Ignatius?\nè¾“å…¥ The input contains several test cases. Each test case contains two lines. The first line consists of an odd integer N(1\u0026lt;=N\u0026lt;=999999) which indicate the number of the integers feng5166 will tell our hero. The second line contains the N integers. The input is terminated by the end of file.\nè¾“å‡º For each test case, you have to output only one line which contains the special number you have found.\næ ·ä¾‹è¾“å…¥ 15 21 3 2 3 3 311 41 1 1 1 1 5 5 5 5 5 5 57 61 1 1 1 1 1 1 æ ·ä¾‹è¾“å‡º 13 25 31 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int N = 1e6 + 5; 4 5int a[N]; 6int n; 7 8int main(void) { 9 while(~scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)) { 10 int num=0, ans=-1; 11 for(int i=0; i\u0026lt;n; i++) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 13 if(num==0) { 14 num++; 15 ans = a[i]; 16 } else { 17 if(ans!=a[i]) 18 num--; 19 else 20 num++; 21 } 22 } 23 printf(\u0026#34;%d\\n\u0026#34;, ans); 24 } 25 26 return 0; 27} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1029-ignatius-and-the-princess-iv/","summary":"Ignatius and the Princess IV (HDU - 1029) é¢˜é¢ \u0026ldquo;OK, you are not too bad, em\u0026hellip; But you can never pass the next test.\u0026rdquo; feng5166 says. \u0026ldquo;I will tell you an odd number N, and then N integers. There will be a special integer among them, you have to tell me which integer is the special one after I tell you all the integers.\u0026rdquo; feng5166 says. \u0026ldquo;But what is","title":"HDU-1029 Ignatius and the Princess IV"},{"content":"Blowing Fuses (ZOJ - 1195) é¢˜é¢ Maybe you are familiar with the following situation. You have plugged in a lot of electrical devices, such as toasters, refrigerators, microwave ovens, computers, stereos, etc, and have them all running. But at the moment when you turn on the TV, the fuse blows, since the power drawn from all the machines is greater than the capacity of the fuse. Of course this is a great safety feature, avoiding that houses burn down too often due to fires ignited by overheating wires. But it is also annoying to walk down to the basement (or some other inconvenient place) to replace to fuse or switch it back on.\nWhat one would like to have is a program that checks before turning on an electrical device whether the combined power drawn by all running devices exceeds the fuses capacity (and it blows), or whether it is safe to turn it on.\nè¾“å…¥ The input consists of several test cases. Each test case describes a set of electrical devices and gives a sequence of turn on/off operations for these devices.\nThe first line of each test case contains three integers n, m and c, where n is the number of devices (n \u0026lt;= 20), m the number of operations performed on these devices and c is the capacity of the fuse (in Amperes). The following n lines contain one positive integer ci each, the consumption (in Amperes) of the i-th device.\nThis is followed by m lines also containing one integer each, between 1 and n inclusive. They describe a sequence of turn on/turn off operations performed on the devices. For every number, the state of that particular devices is toggled, i.e. if it is currently running, it is turned off, and if it is currently turned off, it will by switched on. At the beginning all devices are turned off.\nThe input will be terminated by a test case starting with n = m = c = 0. This test case should not be processed.\nè¾“å‡º For each test case, first output the number of the test case. Then output whether the fuse was blown during the operation sequence. The fuse will be blown if the sum of the power consumptions ci of turned on devices at some point exceeds the capacity of the fuse c.\nIf the fuse is not blown, output the maximal power consumption by turned on devices that occurred during the sequence.\nOutput a blank line after each test case.\næ ·ä¾‹è¾“å…¥ 12 2 10 25 37 41 52 63 6 10 72 85 97 102 111 122 133 141 153 160 0 0 æ ·ä¾‹è¾“å‡º 1Sequence 1 2Fuse was blown. 3 4Sequence 2 5Fuse was not blown. 6Maximal power consumption was 9 amperes. æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3 4int a[30][2]; 5int n, m, c, num = 1; 6 7int main(void) { 8 while (~scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;c) \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m \u0026amp;\u0026amp; c) { 9 memset(a, 0, sizeof(a)); 10 for (int i=1; i\u0026lt;=n; i++) { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][0]); 12 } 13 int mx = 0, sum = 0, t; 14 for (int i=1; i\u0026lt;=m; i++) { 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); 16 if(a[t][1]==0) { 17 a[t][1] = 1; 18 sum += a[t][0]; 19 } else { 20 a[t][1] = 0; 21 sum -= a[t][0]; 22 } 23 mx = max(sum, mx); 24 } 25 printf(\u0026#34;Sequence %d\\n\u0026#34;, num++); 26 if(mx\u0026gt;c) { 27 printf(\u0026#34;Fuse was blown.\\n\u0026#34;); 28 } else { 29 printf(\u0026#34;Fuse was not blown.\\n\u0026#34;); 30 printf(\u0026#34;Maximal power consumption was %d amperes.\\n\u0026#34;, mx); 31 } 32 printf(\u0026#34;\\n\u0026#34;); 33 } 34 35 return 0; 36} ","permalink":"https://blog.lordash.de/posts/solution/zoj-1195-blowing-fuses/","summary":"Blowing Fuses (ZOJ - 1195) é¢˜é¢ Maybe you are familiar with the following situation. You have plugged in a lot of electrical devices, such as toasters, refrigerators, microwave ovens, computers, stereos, etc, and have them all running. But at the moment when you turn on the TV, the fuse blows, since the power drawn from all the machines is greater than the capacity of the fuse. Of course this","title":"ZOJ-1195 Blowing Fuses"},{"content":"Function Run Fun (ZOJ - 1168) é¢˜é¢ We all love recursion! Don\u0026rsquo;t we?\nConsider a three-parameter recursive function w(a, b, c):\nif a \u0026lt;= 0 or b \u0026lt;= 0 or c \u0026lt;= 0, then w(a, b, c) returns: 1\nif a \u0026gt; 20 or b \u0026gt; 20 or c \u0026gt; 20, then w(a, b, c) returns: w(20, 20, 20)\nif a \u0026lt; b and b \u0026lt; c, then w(a, b, c) returns: w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)\notherwise it returns: w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)\nThis is an easy function to implement. The problem is, if implemented directly, for moderate values of a, b and c (for example, a = 15, b = 15, c = 15), the program takes hours to run because of the massive recursion.\nè¾“å…¥ The input for your program will be a series of integer triples, one per line, until the end-of-file flag of -1 -1 -1. Using the above technique, you are to calculate w(a, b, c) efficiently and print the result.\nè¾“å‡º Print the value for w(a,b,c) for each triple.\næ ·ä¾‹è¾“å…¥ 11 1 1 22 2 2 310 4 6 450 50 50 5-1 7 18 6-1 -1 -1 æ ·ä¾‹è¾“å‡º 1w(1, 1, 1) = 2 2w(2, 2, 2) = 4 3w(10, 4, 6) = 523 4w(50, 50, 50) = 1048576 5w(-1, 7, 18) = 1 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3 4int ans[21][21][21]; 5int a, b, c; 6 7int w(int a, int b, int c) { 8 if (a\u0026lt;=0 || b\u0026lt;=0 || c\u0026lt;=0) 9 return 1; 10 11 if (a\u0026gt;20 || b\u0026gt;20 || c\u0026gt;20) 12 return ans[20][20][20]; 13 14 if (ans[a][b][c]\u0026gt;0) 15 return ans[a][b][c]; 16 17 if (a\u0026lt;b \u0026amp;\u0026amp; b\u0026lt;c) 18 return w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c); 19 20 return w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1); 21} 22 23int main(void) { 24 for (int i=0; i\u0026lt;21; i++) 25 for (int j=0; j\u0026lt;21; j++) 26 for (int k=0; k\u0026lt;21; k++) 27 ans[i][j][k] = w(i, j, k); 28 29 while (scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c)==3) { 30 if (a==-1 \u0026amp;\u0026amp; b==-1 \u0026amp;\u0026amp; c==-1) 31 break; 32 printf(\u0026#34;w(%d, %d, %d) = %d\\n\u0026#34;, a, b, c, w(a, b, c)); 33 } 34 return 0; 35} ","permalink":"https://blog.lordash.de/posts/solution/zoj-1168-function-run-fun/","summary":"Function Run Fun (ZOJ - 1168) é¢˜é¢ We all love recursion! Don\u0026rsquo;t we? Consider a three-parameter recursive function w(a, b, c): if a \u0026lt;= 0 or b \u0026lt;= 0 or c \u0026lt;= 0, then w(a, b, c) returns: 1 if a \u0026gt; 20 or b \u0026gt; 20 or c \u0026gt; 20, then w(a, b, c) returns: w(20, 20, 20) if a \u0026lt; b and b \u0026lt; c, then w(a,","title":"ZOJ-1168 Function Run Fun"},{"content":"Software CRC (ZOJ - 1164) é¢˜é¢ You work for a company which uses lots of personal computers. Your boss, Dr Penny Pincher, has wanted to link the computers together for some time but has been unwilling to spend any money on the Ethernet boards you have recommended. You, unwittingly, have pointed out that each of the PCs has come from the vendor with an asynchronous serial port at no extra cost. Dr Pincher, of course, recognizes her opportunity and assigns you the task of writing the software necessary to allow communication between PCs.\nYou\u0026rsquo;ve read a bit about communications and know that every transmission is subject to error and that the typical solution to this problem is to append some error checking information to the end of each message. This information allows the receiving program to detect when a transmission error has occurred (in most cases). So, off you go to the library, borrow the biggest book on communications you can find and spend your weekend (unpaid overtime) reading about error checking.\nFinally you decide that CRC (cyclic redundancy check) is the best error checking for your situation and write a note to Dr Pincher detailing the proposed error checking mechanism noted below.\nThe message to be transmitted is viewed as a long positive binary number. The first byte of the message is treated as the most significant byte of the binary number. The second byte is the next most significant, etc. This binary number will be called \u0026ldquo;m\u0026rdquo; (for message). Instead of transmitting \u0026ldquo;m\u0026rdquo; you will transmit a message, \u0026ldquo;m2\u0026rdquo;, consisting of \u0026ldquo;m\u0026rdquo; followed by a two-byte CRC value.\nThe CRC value is chosen so that \u0026ldquo;m2\u0026rdquo; when divided by a certain 16-bit value \u0026ldquo;g\u0026rdquo; leaves a remainder of 0. This makes it easy for the receiving program to determine whether the message has been corrupted by transmission errors. It simply divides any message received by \u0026ldquo;g\u0026rdquo;. If the remainder of the division is zero, it is assumed that no error has occurred.\nYou notice that most of the suggested values of \u0026ldquo;g\u0026rdquo; in the book are odd, but don\u0026rsquo;t see any other similarities, so you select the value 34943 for \u0026ldquo;g\u0026rdquo; (the generator value).\nè¾“å…¥ You are to devise an algorithm for calculating the CRC value corresponding to any message that might be sent. To test this algorithm you will write a program which reads lines (each line being all characters up to, but not including the end of line character) as input, and for each line calculates the CRC value for the message contained in the line, and writes the numeric value of the CRC bytes (in hexadecimal notation) on an output line. Each input line will contain no more than 1024 ASCII characters. The input is terminated by a line that contains a # in column 1.\nè¾“å‡º CRC in hex format, one on each line. Note that each CRC printed should be in the range 0 to 34942 (decimal).\næ ·ä¾‹è¾“å…¥ 1this is a test 2 3A 4# æ ·ä¾‹è¾“å‡º 177 FD 200 00 30C 86 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3 4union { 5 unsigned int L; 6 struct { 7 unsigned char b1, b2, b3, b4; 8 } crc; 9} data; 10 11int main(void) { 12 unsigned char c, flag; 13 int num, g=34943; 14 while(1) { 15 num = data.L = 0; 16 while(scanf(\u0026#34;%c\u0026#34;, \u0026amp;c) \u0026amp;\u0026amp; c!=\u0026#39;\\n\u0026#39;) { 17 num++; 18 flag = c; 19 data.L = ((data.L\u0026lt;\u0026lt;8) + c)%g; 20 } 21 data.L = (data.L\u0026lt;\u0026lt;16)%g; 22 if (data.L) 23 data.L = g-data.L; 24 if (num==1 \u0026amp;\u0026amp; flag==\u0026#39;#\u0026#39;) 25 break; 26 printf(\u0026#34;%02X %02X\\n\u0026#34;, (int)data.crc.b2, (int)data.crc.b1); 27 } 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/zoj-1164-software-crc/","summary":"Software CRC (ZOJ - 1164) é¢˜é¢ You work for a company which uses lots of personal computers. Your boss, Dr Penny Pincher, has wanted to link the computers together for some time but has been unwilling to spend any money on the Ethernet boards you have recommended. You, unwittingly, have pointed out that each of the PCs has come from the vendor with an asynchronous serial port at no","title":"ZOJ-1164 Software CRC"},{"content":"Block Breaker (HDU - 6699) é¢˜é¢ Given a rectangle frame of size n Ã— m. Initially, the frame is strewn with n Ã— m square blocks of size 1 Ã— 1. Due to the friction with the frame and each other, the blocks are stable and will not drop.\nHowever, the blocks can be knocked down. When a block is knocked down, other remaining blocks may also drop since the friction provided by other remaining blocks may not sustain them anymore. Formally, a block will drop if it is knocked or not stable, which means that at least one of the left block and the right block has been dropped and at least one of the front block and the back block has been dropped. Especially, the frame can be regarded as a huge stable block, which means that if one block\u0026rsquo;s left is the frame, only when its right block has been dropped and at least one of the front block and the back block has been dropped can it drop. The rest situations are similar.\nNow you, the block breaker, want to knock down the blocks. Formally, you will do it q times. In each time, you may choose a position (xi, yi) If there remains a block at the chosen position, you will knock it down; otherwise, nothing will happen. Moreover, after knocking down the block, you will wait until no unstable blocks are going to drop and then do the next operation.\nFor example, please look at the following illustration, the frame is of size 2 Ã— 2 and the block (1, 1) and (1, 2) have been dropped. If we are going to knock the block (2, 1) , not only itself but also the block (2 , 1) will drop in this knocking operation.\nYou want to know how many blocks will drop in total in each knocking operation. Specifically, if nothing happens in one operation, the answer should be regarded as 0.\nè¾“å…¥ The first line contains one positive integer T ( 1 â‰¤ T â‰¤ 10 ) , denoting the number of test cases.\nFor each test case:\nThe first line contains three positive integers n, m and q ( 1 â‰¤ n , m â‰¤ 2000, 1 â‰¤ q â‰¤ 100000 ) , denoting the sizes in two dimensions of the frame and the number of knocking operations.\nEach of the following q lines contains two positive integers xi and yi ( 1 â‰¤ xi â‰¤ n , 1 â‰¤ yi â‰¤ m ), describing a knocking operation.\nè¾“å‡º For each test case, output q lines, each of which contains a non-negative integer, denoting the number of dropped blocks in the corresponding knocking operation.\næ ·ä¾‹è¾“å…¥ 12 22 2 3 31 1 41 2 52 2 64 4 6 71 1 81 2 92 1 102 2 114 4 123 3 æ ·ä¾‹è¾“å‡º 11 21 32 41 51 62 70 81 911 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int mod = 1e9 + 7; 4const int N = 2e3 + 5; 5 6bool vis[N][N]; 7 8int T, n, m, q; 9int x, y; 10 11struct P { 12 int x, y; 13}; 14 15int dx[] = {1, -1, 0, 0}; 16int dy[] = {0, 0, 1, -1}; 17 18bool ok(int x, int y) { 19 if ((x + 1 \u0026gt; n || !vis[x + 1][y]) \u0026amp;\u0026amp; (x - 1 \u0026lt;= 0 || !vis[x - 1][y])) 20 return 1; 21 if ((y + 1 \u0026gt; m || !vis[x][y + 1]) \u0026amp;\u0026amp; (y - 1 \u0026lt;= 0 || !vis[x][y - 1])) 22 return 1; 23 return 0; 24} 25 26int solve(int x, int y) { 27 if (vis[x][y]) 28 return 0; 29 30 int sum = 1; 31 vis[x][y] = 1; 32 33 P sp; 34 sp.x = x; 35 sp.y = y; 36 37 queue\u0026lt;P\u0026gt; q; 38 q.push(sp); 39 40 while (!q.empty()) { 41 P tp = q.front(); 42 q.pop(); 43 44 P np = tp; 45 for (int i = 0; i \u0026lt; 4; i++) { 46 int xi = np.x = tp.x + dx[i]; 47 int yi = np.y = tp.y + dy[i]; 48 49 if (xi \u0026lt;= 0 || xi \u0026gt; n || yi \u0026lt;= 0 || yi \u0026gt; m) 50 continue; 51 52 if (!vis[xi][yi] \u0026amp;\u0026amp; !ok(xi, yi)) { 53 sum++; 54 q.push(np); 55 vis[xi][yi] = 1; 56 } 57 } 58 } 59 60 return sum; 61} 62 63int main(void) { 64 65 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 66 while (T--) { 67 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;q); 68 memset(vis, 0, sizeof(vis)); 69 for (int i = 0; i \u0026lt; q; i++) { 70 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;x, \u0026amp;y); 71 printf(\u0026#34;%d\\n\u0026#34;, solve(x, y)); 72 } 73 } 74 75 return 0; 76} ","permalink":"https://blog.lordash.de/posts/solution/hdu-6699-block-breaker/","summary":"Block Breaker (HDU - 6699) é¢˜é¢ Given a rectangle frame of size n Ã— m. Initially, the frame is strewn with n Ã— m square blocks of size 1 Ã— 1. Due to the friction with the frame and each other, the blocks are stable and will not drop. However, the blocks can be knocked down. When a block is knocked down, other remaining blocks may also drop since","title":"HDU-6699 Block Breaker"},{"content":"Oulipo (HDU - 1686) é¢˜é¢ The French author Georges Perec (1936â€“1982) once wrote a book, La disparition, without the letter \u0026rsquo;e\u0026rsquo;. He was a member of the Oulipo group. A quote from the book:\nTout avait Pair normal, mais tout sâ€™affirmait faux. Tout avait Fair normal, dâ€™abord, puis surgissait lâ€™inhumain, lâ€™affolant. Il aurait voulu savoir oÃ¹ sâ€™articulait lâ€™association qui lâ€™unissait au roman : stir son tapis, assaillant Ã  tout instant son imagination, lâ€™intuition dâ€™un tabou, la vision dâ€™un mal obscur, dâ€™un quoi vacant, dâ€™un non-dit : la vision, lâ€™avision dâ€™un oubli commandant tout, oÃ¹ sâ€™abolissait la raison : tout avait lâ€™air normal maisâ€¦\nPerec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given â€œwordâ€ as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive \u0026lsquo;T\u0026rsquo;s is not unusual. And they never use spaces.\nSo we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {\u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, â€¦, \u0026lsquo;Z\u0026rsquo;} and two finite strings over that alphabet, a word W and a text T, count the number of occurrences of W in T. All the consecutive characters of W must exactly match consecutive characters of T. Occurrences may overlap.\nè¾“å…¥ The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:\nOne line with the word W, a string over {\u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, â€¦, \u0026lsquo;Z\u0026rsquo;}, with 1 â‰¤ |W| â‰¤ 10,000 (here |W| denotes the length of the string W). One line with the text T, a string over {\u0026lsquo;A\u0026rsquo;, \u0026lsquo;B\u0026rsquo;, \u0026lsquo;C\u0026rsquo;, â€¦, \u0026lsquo;Z\u0026rsquo;}, with |W| â‰¤ |T| â‰¤ 1,000,000.\nè¾“å‡º For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word W in the text T.\næ ·ä¾‹è¾“å…¥ 13 2BAPC 3BAPC 4AZA 5AZAZAZA 6VERDI 7AVERDXIVYERDIAN æ ·ä¾‹è¾“å‡º 11 23 30 æç¤º æ— \næ€è·¯ KMPæ¨¡æ¿é¢˜\nä»£ç  1char s[mxn], t[mxn]; 2int nxt[mxn]; 3 4void getnxt(char* t, int m) 5{ 6 int i = 0, j = -1; nxt[0] = -1; 7 while (i \u0026lt; m) 8 { 9 if (j == -1 || t[i] == t[j]) { 10 i++, j++; 11 // if (t[i] == t[j]) 12 // nxt[i] = nxt[j]; // nextæ•°ç»„ä¼˜åŒ– 13 // else 14 nxt[i] = j; 15 } else 16 j = nxt[j]; 17 } 18} 19 20int KMP(char* s, char* t, int n, int m) 21{ 22 int i = 0, j = 0, ans = 0; 23 while (i \u0026lt; n) 24 { 25 if (j == -1 || s[i] == t[j]) { 26 i++, j++; 27 if (j \u0026gt;= m) { // åŒ¹é… 28 ans++; 29 j = nxt[j]; 30 // return i-j; 31 } 32 } else 33 j = nxt[j]; 34 } 35 return ans; 36 // return -1; 37} 38 39int main() 40{ 41 int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 42 while(T--) 43 { 44 scanf(\u0026#34;%s%s\u0026#34;, t, s); 45 int tl = strlen(t), sl = strlen(s); 46 getnxt(t, tl); 47 printf(\u0026#34;%d\\n\u0026#34;, KMP(s, t, sl, tl)); 48 } 49 return 0; 50} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1686-oulipo/","summary":"Oulipo (HDU - 1686) é¢˜é¢ The French author Georges Perec (1936â€“1982) once wrote a book, La disparition, without the letter \u0026rsquo;e\u0026rsquo;. He was a member of the Oulipo group. A quote from the book: Tout avait Pair normal, mais tout sâ€™affirmait faux. Tout avait Fair normal, dâ€™a","title":"HDU-1686 Oulipo"},{"content":"Hawk-and-Chicken (HDU - 3639) é¢˜é¢ Kids in kindergarten enjoy playing a game called Hawk-and-Chicken. But there always exists a big problem: every kid in this game want to play the role of Hawk. So the teacher came up with an idea: Vote. Every child have some nice handkerchiefs, and if he/she think someone is suitable for the role of Hawk, he/she gives a handkerchief to this kid, which means this kid who is given the handkerchief win the support. Note the support can be transmitted. Kids who get the most supports win in the vote and able to play the role of Hawk.(A note:if A can win support from B(A != B) A can win only one support from B in any case the number of the supports transmitted from B to A are many. And A can\u0026rsquo;t win the support from himself in any case. If two or more kids own the same number of support from others, we treat all of them as winner. Here\u0026rsquo;s a sample: 3 kids A, B and C, A gives a handkerchief to B, B gives a handkerchief to C, so C wins 2 supports and he is choosen to be the Hawk.\nè¾“å…¥ There are several test cases. First is a integer T(T \u0026lt;= 50), means the number of test cases. Each test case start with two integer n, m in a line (2 \u0026lt;= n \u0026lt;= 5000, 0 \u0026lt;m \u0026lt;= 30000). n means there are n children(numbered from 0 to n - 1). Each of the following m lines contains two integers A and B(A != B) denoting that the child numbered A give a handkerchief to B.\nè¾“å‡º For each test case, the output should first contain one line with \u0026ldquo;Case x:\u0026rdquo;, here x means the case number start from 1. Followed by one number which is the total supports the winner(s) get. Then follow a line contain all the Hawks\u0026rsquo; number. The numbers must be listed in increasing order and separated by single spaces.\næ ·ä¾‹è¾“å…¥ 12 24 3 33 2 42 0 52 1 6 73 3 81 0 92 1 100 2 æ ·ä¾‹è¾“å‡º 1Case 1: 2 20 1 3Case 2: 2 40 1 2 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 5e3+5; 5const int M = 3e4+5; 6 7struct E { 8 int to, next; 9} e[M]; 10int H[N], tot, R[N]; 11 12int S[N], top; 13int dfn[N], low[N], bel[N], idx, scc; 14 15int T, n, m; 16int u, v; 17 18int od[N], num[N], sum[N]; 19bool vis[N]; 20 21void add(int *H, int from, int to) { 22 e[tot] = {to, H[from]}; 23 H[from] = tot++; 24} 25 26void dfs(int u) { 27 dfn[u] = low[u] = ++idx; 28 S[++top]=u; 29 30 for(int i=H[u]; ~i; i=e[i].next) { 31 int v = e[i].to; 32 if(!dfn[v]) { 33 dfs(v); 34 low[u] = min(low[u], low[v]); 35 } else if(!bel[v]) 36 low[u] = min(low[u], dfn[v]); 37 } 38 if(low[u]==dfn[u]) { 39 scc++; 40 int t; 41 do { 42 t=S[top--]; 43 bel[t]=scc; 44 } while(t!=u); 45 } 46} 47 48void tarjan() { 49 memset(dfn, 0, sizeof(dfn)); 50 memset(bel, 0, sizeof(bel)); 51 idx = scc = top = 0; 52 for(int i=1; i\u0026lt;=n; i++) { 53 if(!dfn[i]) 54 dfs(i); 55 } 56} 57 58int stat(int u) { 59 vis[u] = 1; 60 int t = num[u]; 61 for(int i=R[u]; ~i; i=e[i].next) { 62 int v = e[i].to; 63 if(!vis[v]) { 64 t += stat(v); 65 } 66 } 67 return t; 68} 69 70int solve() { 71 memset(od, 0, sizeof(od)); 72 memset(num, 0, sizeof(num)); 73 memset(sum, 0, sizeof(sum)); 74 75 for(int i=1; i\u0026lt;=n; i++) { 76 num[bel[i]]++; 77 } 78 79 for(int u=1; u\u0026lt;=n; u++) { 80 for(int i=H[u]; ~i; i=e[i].next) { 81 int v = e[i].to; 82 if(bel[u]!=bel[v]) { 83 add(R, bel[v], bel[u]); 84 od[bel[u]]++; 85 } 86 } 87 } 88 int ans=0; 89 for(int i=1; i\u0026lt;=scc; i++) { 90 if(!od[i]) { 91 memset(vis, 0, sizeof(vis)); 92 sum[i] = stat(i)-1; 93 ans = max(ans, sum[i]); 94 } 95 } 96 return ans; 97} 98 99int main(void) { 100 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 101 for(int cs=1; cs\u0026lt;=T; cs++) { 102 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 103 memset(H, -1, sizeof(H)); 104 memset(R, -1, sizeof(R)); 105 tot = 0; 106 for(int i=0; i\u0026lt;m; i++) { 107 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); 108 add(H, u+1, v+1); 109 } 110 tarjan(); 111 int ans = solve(), flag = 0; 112 printf(\u0026#34;Case %d: %d\\n\u0026#34;, cs, ans); 113 for(int i=1; i\u0026lt;=n; i++) { 114 if(sum[bel[i]]==ans) { 115 if(flag) 116 printf(\u0026#34; \u0026#34;); 117 else 118 flag = 1; 119 printf(\u0026#34;%d\u0026#34;, i-1); 120 } 121 } 122 printf(\u0026#34;\\n\u0026#34;); 123 } 124 return 0; 125} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3639-hawk-and-chicken/","summary":"Hawk-and-Chicken (HDU - 3639) é¢˜é¢ Kids in kindergarten enjoy playing a game called Hawk-and-Chicken. But there always exists a big problem: every kid in this game want to play the role of Hawk. So the teacher came up with an idea: Vote. Every child have some nice handkerchiefs, and if he/she think someone is suitable for the role of Hawk, he/she gives a handkerchief to this kid, which means","title":"HDU-3639 Hawk-and-Chicken"},{"content":"Summer Holiday (HDU - 1827) é¢˜é¢ To see a World in a Grain of Sand And a Heaven in a Wild Flower, Hold Infinity in the palm of your hand And Eternity in an hour. â€”â€” William Blake\nå¬è¯´lcyå¸®å¤§å®¶é¢„å®šäº†æ–°é©¬æ³°7æ—¥æ¸¸ï¼ŒWiskeyçœŸæ˜¯é«˜å…´çš„å¤œä¸èƒ½å¯å•Šï¼Œä»–æƒ³ç€å¾—å¿«ç‚¹æŠŠè¿™æ¶ˆæ¯å‘Šè¯‰å¤§å®¶ï¼Œè™½ç„¶ä»–æ‰‹ä¸Šæœ‰æ‰€æœ‰äººçš„è”ç³»æ–¹å¼ï¼Œä½†æ˜¯ä¸€ä¸ªä¸€ä¸ªè”ç³»è¿‡å»å®åœ¨å¤ªè€—æ—¶é—´å’Œç”µè¯è´¹äº†ã€‚ä»–çŸ¥é“å…¶ä»–äººä¹Ÿæœ‰ä¸€äº›åˆ«äººçš„è”ç³»æ–¹å¼ï¼Œè¿™æ ·ä»–å¯ä»¥é€šçŸ¥å…¶ä»–äººï¼Œå†è®©å…¶ä»–äººå¸®å¿™é€šçŸ¥ä¸€ä¸‹åˆ«äººã€‚ä½ èƒ½å¸®Wiskeyè®¡ç®—å‡ºè‡³å°‘è¦é€šçŸ¥å¤šå°‘äººï¼Œè‡³å°‘å¾—èŠ±å¤šå°‘ç”µè¯è´¹å°±èƒ½è®©æ‰€æœ‰äººéƒ½è¢«é€šçŸ¥åˆ°å—ï¼Ÿ\nè¾“å…¥ å¤šç»„æµ‹è¯•æ•°ç»„ï¼Œä»¥EOFç»“æŸã€‚ ç¬¬ä¸€è¡Œä¸¤ä¸ªæ•´æ•°Nå’ŒMï¼ˆ1\u0026lt;=N\u0026lt;=1000, 1\u0026lt;=M\u0026lt;=2000ï¼‰ï¼Œè¡¨ç¤ºäººæ•°å’Œè”ç³»å¯¹æ•°ã€‚ æ¥ä¸‹ä¸€è¡Œæœ‰Nä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºWiskeyè”ç³»ç¬¬iä¸ªäººçš„ç”µè¯è´¹ç”¨ã€‚ æ¥ç€æœ‰Mè¡Œï¼Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ•´æ•°Xï¼ŒYï¼Œè¡¨ç¤ºXèƒ½è”ç³»åˆ°Yï¼Œä½†æ˜¯ä¸è¡¨ç¤ºYä¹Ÿèƒ½è”ç³»Xã€‚\nè¾“å‡º è¾“å‡ºæœ€å°è”ç³»äººæ•°å’Œæœ€å°èŠ±è´¹ã€‚ æ¯ä¸ªCASEè¾“å‡ºç­”æ¡ˆä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 112 16 22 2 2 2 2 2 2 2 2 2 2 2 31 3 43 2 52 1 63 4 72 4 83 5 95 4 104 6 116 4 127 4 137 12 147 8 158 7 168 9 1710 9 1811 10 æ ·ä¾‹è¾“å‡º 13 6 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 2e4+5; 5const int M = 5e4+5; 6 7struct E { 8 int to, next; 9} e[M]; 10 11int H[N], tot; 12 13int S[N], top; 14int dfn[N], low[N], bel[N], idx, scc; 15 16int n, m, cost[N]; 17int u, v; 18 19int sc[N], id[N]; 20 21void add(int from, int to) { 22 e[tot] = {to, H[from]}; 23 H[from] = tot++; 24} 25 26void dfs(int u) { 27 dfn[u] = low[u] = ++idx; 28 S[++top]=u; 29 30 for(int i=H[u]; ~i; i=e[i].next) { 31 int v = e[i].to; 32 if(!dfn[v]) { 33 dfs(v); 34 low[u] = min(low[u], low[v]); 35 } else if(!bel[v]) 36 low[u] = min(low[u], dfn[v]); 37 } 38 if(low[u]==dfn[u]) { 39 scc++; 40 int t; 41 do { 42 t=S[top--]; 43 bel[t]=scc; 44 } while(t!=u); 45 } 46} 47 48void tarjan() { 49 memset(dfn, 0, sizeof(dfn)); 50 memset(bel, 0, sizeof(bel)); 51 idx = scc = top = 0; 52 for(int i=1; i\u0026lt;=n; i++) { 53 if(!dfn[i]) 54 dfs(i); 55 } 56} 57 58void solve(int \u0026amp;num, int \u0026amp;sum) { 59 memset(sc, inf, sizeof(sc)); 60 memset(id, 0, sizeof(id)); 61 62 for(int i=1; i\u0026lt;=n; i++) 63 sc[bel[i]] = min(sc[bel[i]], cost[i]); 64 65 for(int u=1; u\u0026lt;=n; u++) { 66 for(int i=H[u]; ~i; i=e[i].next) { 67 int v = e[i].to; 68 if(bel[u]!=bel[v]) { 69 id[bel[v]]++; 70 } 71 } 72 } 73 74 int a=0, b=0; 75 for(int i=1; i\u0026lt;=scc; i++) { 76 if(!id[i]) 77 num++, sum+=sc[i]; 78 } 79} 80 81int main(void) { 82 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)==2) { 83 memset(H, -1, sizeof(H)); 84 tot = 0; 85 for(int i=1; i\u0026lt;=n; i++) 86 scanf(\u0026#34;%d\u0026#34;, \u0026amp;cost[i]); 87 for(int i=0; i\u0026lt;m; i++) { 88 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); 89 add(u, v); 90 } 91 tarjan(); 92 int num=0, sum=0; 93 solve(num, sum); 94 printf(\u0026#34;%d %d\\n\u0026#34;, num, sum); 95 } 96 return 0; 97} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1827-summer-holiday/","summary":"Summer Holiday (HDU - 1827) é¢˜é¢ To see a World in a Grain of Sand And a Heaven in a Wild Flower, Hold Infinity in the palm of your hand And Eternity in an hour. â€”â€” William Blake å¬è¯´lcyå¸®å¤§å®¶é¢„å®šäº†æ–°é©¬æ³°7æ—¥æ¸¸ï¼ŒWiskeyçœŸæ˜¯é«˜å…´çš„å¤œ","title":"HDU-1827 Summer Holiday"},{"content":"Proving Equivalences (HDU - 2767) é¢˜é¢ Consider the following exercise, found in a generic linear algebra textbook.\nLet A be an n Ã— n matrix. Prove that the following statements are equivalent:\n\\1. A is invertible. \\2. Ax = b has exactly one solution for every n Ã— 1 matrix b. \\3. Ax = b is consistent for every n Ã— 1 matrix b. \\4. Ax = 0 has only the trivial solution x = 0.\nThe typical way to solve such an exercise is to show a series of implications. For instance, one can proceed by showing that (a) implies (b), that (b) implies (c), that (c) implies (d), and finally that (d) implies (a). These four implications show that the four statements are equivalent.\nAnother way would be to show that (a) is equivalent to (b) (by proving that (a) implies (b) and that (b) implies (a)), that (b) is equivalent to (c), and that (c) is equivalent to (d). However, this way requires proving six implications, which is clearly a lot more work than just proving four implications!\nI have been given some similar tasks, and have already started proving some implications. Now I wonder, how many more implications do I have to prove? Can you help me determine this?\nè¾“å…¥ On the first line one positive number: the number of testcases, at most 100. After that per testcase:\n* One line containing two integers n (1 â‰¤ n â‰¤ 20000) and m (0 â‰¤ m â‰¤ 50000): the number of statements and the number of implications that have already been proved. * m lines with two integers s1 and s2 (1 â‰¤ s1, s2 â‰¤ n and s1 â‰  s2) each, indicating that it has been proved that statement s1 implies statement s2.\nè¾“å‡º Per testcase:\n* One line with the minimum number of additional implications that need to be proved in order to prove that all statements are equivalent.\næ ·ä¾‹è¾“å…¥ 12 24 0 33 2 41 2 51 3 æ ·ä¾‹è¾“å‡º 14 22 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int N = 1e4+5; 4const int M = 1e5+5; 5 6struct E { 7 int to, next; 8} e[M]; 9 10int H[N], tot; 11 12int S[N], top; 13int dfn[N], low[N], bel[N], idx, scc; 14 15int T, n, m; 16int u, v; 17 18int id[N], od[N]; 19 20void add(int from, int to) { 21 e[tot] = {to, H[from]}; 22 H[from] = tot++; 23} 24 25void dfs(int u) { 26 dfn[u] = low[u] = ++idx; 27 S[++top]=u; 28 29 for(int i=H[u]; ~i; i=e[i].next) { 30 int v = e[i].to; 31 if(!dfn[v]) { 32 dfs(v); 33 low[u] = min(low[u], low[v]); 34 } else if(!bel[v]) 35 low[u] = min(low[u], dfn[v]); 36 } 37 if(low[u]==dfn[u]) { 38 scc++; 39 int t; 40 do { 41 t=S[top--]; 42 bel[t]=scc; 43 } while(t!=u); 44 } 45} 46 47void tarjan() { 48 memset(dfn, 0, sizeof(dfn)); 49 memset(bel, 0, sizeof(bel)); 50 idx = scc = top = 0; 51 for(int i=1; i\u0026lt;=n; i++) { 52 if(!dfn[i]) 53 dfs(i); 54 } 55} 56 57int solve() { 58 if(scc==1) 59 return 0; 60 61 memset(id, 0, sizeof(id)); 62 memset(od, 0, sizeof(od)); 63 64 for(int u=1; u\u0026lt;=n; u++) { 65 for(int i=H[u]; ~i; i=e[i].next) { 66 int v = e[i].to; 67 if(bel[u]!=bel[v]) { 68 od[bel[u]]++; 69 id[bel[v]]++; 70 } 71 } 72 } 73 74 int a=0, b=0; 75 for(int i=1; i\u0026lt;=scc; i++) { 76 a+=!id[i]; 77 b+=!od[i]; 78 } 79 return max(a, b); 80} 81 82int main(void) { 83 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 84 while(T--) { 85 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 86 memset(H, -1, sizeof(H)); 87 tot = 0; 88 for(int i=0; i\u0026lt;m; i++) { 89 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); 90 add(u, v); 91 } 92 tarjan(); 93 printf(\u0026#34;%d\\n\u0026#34;, solve()); 94 } 95 return 0; 96} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2767-proving-equivalences/","summary":"Proving Equivalences (HDU - 2767) é¢˜é¢ Consider the following exercise, found in a generic linear algebra textbook. Let A be an n Ã— n matrix. Prove that the following statements are equivalent: \\1. A is invertible. \\2. Ax = b has exactly one solution for every n Ã— 1 matrix b. \\3. Ax = b is consistent for every n Ã— 1 matrix b. \\4. Ax = 0 has","title":"HDU-2767 Proving Equivalences"},{"content":"Jungle Roads (POJ - 1251) é¢˜é¢ The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all the roads in use now and the cost in aacms per month to maintain them. Of course there needs to be some way to get between all the villages on maintained roads, even if the route is not as short as before. The Chief Elder would like to tell the Council of Elders what would be the smallest amount they could spend in aacms per month to maintain roads that would connect all the villages. The villages are labeled A through I in the maps above. The map on the right shows the roads that could be maintained most cheaply, for 216 aacms per month. Your task is to write a program that will solve such problems.\nè¾“å…¥ The input consists of one to 100 data sets, followed by a final line containing only 0. Each data set starts with a line containing only a number n, which is the number of villages, 1 \u0026lt; n \u0026lt; 27, and the villages are labeled with the first n letters of the alphabet, capitalized. Each data set is completed with n-1 lines that start with village labels in alphabetical order. There is no line for the last village. Each line for a village starts with the village label followed by a number, k, of roads from this village to villages with labels later in the alphabet. If k is greater than 0, the line continues with data for each of the k roads. The data for each road is the village label for the other end of the road followed by the monthly maintenance cost in aacms for the road. Maintenance costs will be positive integers less than 100. All data fields in the row are separated by single blanks. The road network will always allow travel between all the villages. The network will never have more than 75 roads. No village will have more than 15 roads going to other villages (before or after in the alphabet). In the sample input below, the first data set goes with the map above.\nè¾“å‡º The output is one integer per line for each data set: the minimum cost in aacms per month to maintain a road system that connect all the villages. Caution: A brute force solution that examines every possible set of roads will not finish within the one minute time limit.\næ ·ä¾‹è¾“å…¥ 19 2A 2 B 12 I 25 3B 3 C 10 H 40 I 8 4C 2 D 18 G 55 5D 1 E 44 6E 2 F 60 G 38 7F 0 8G 1 H 35 9H 1 I 35 103 11A 2 B 10 C 40 12B 1 C 20 130 æ ·ä¾‹è¾“å‡º 1216 230 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6int n; 7 8int f[N] = {0}; 9void init(int n) { 10 for(int i=0; i\u0026lt;n; i++) 11 f[i] = i; 12} 13 14int Find(int x) { 15 return f[x]==x ? x : f[x]=Find(f[x]); 16} 17 18bool same(int x, int y) { 19 return Find(x)==Find(y); 20} 21 22void join(int x, int y) { 23 x=Find(x), y=Find(y); 24 f[x] = y; 25} 26 27struct edge { 28 int u, v, w; 29} e[N]; 30 31bool cmp(edge a, edge b) { 32 return a.w \u0026lt; b.w; 33} 34 35int kruskal(int m) { 36 int ans=0; 37 for(int i=0; i\u0026lt;m; i++) { 38 if(!same(e[i].u, e[i].v)) { 39 join(e[i].u, e[i].v); 40 ans += e[i].w; 41 } 42 } 43 return ans; 44} 45 46int main(void) { 47 while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)==1 \u0026amp;\u0026amp; n) { 48 int k, w, num=0; 49 char f, t; 50 for(int i=0; i\u0026lt;n-1; i++) { 51 scanf(\u0026#34; %c%d\u0026#34;, \u0026amp;f, \u0026amp;k); 52 for(int j=0; j\u0026lt;k; j++) { 53 scanf(\u0026#34; %c%d\u0026#34;, \u0026amp;t, \u0026amp;w); 54 e[num] = {f-\u0026#39;A\u0026#39;, t-\u0026#39;A\u0026#39;, w}; 55 num++; 56 } 57 } 58 sort(e, e+num, cmp); 59 init(n); 60 printf(\u0026#34;%d\\n\u0026#34;, kruskal(num)); 61 } 62 return 0; 63} ","permalink":"https://blog.lordash.de/posts/solution/poj-1251-jungle-roads/","summary":"Jungle Roads (POJ - 1251) é¢˜é¢ The Head Elder of the tropical island of Lagrishan has a problem. A burst of foreign aid money was spent on extra roads between villages some years ago. But the jungle overtakes roads relentlessly, so the large road network is too expensive to maintain. The Council of Elders must choose to stop maintaining some roads. The map above on the left shows all","title":"POJ-1251 Jungle Roads"},{"content":"è¿·å®«åŸå ¡ (HDU - 1269) é¢˜é¢ ä¸ºäº†è®­ç»ƒå°å¸Œçš„æ–¹å‘æ„Ÿï¼ŒGardonå»ºç«‹äº†ä¸€åº§å¤§åŸå ¡ï¼Œé‡Œé¢æœ‰Nä¸ªæˆ¿é—´(N\u0026lt;=10000)å’ŒMæ¡é€šé“(M\u0026lt;=100000)ï¼Œæ¯ä¸ªé€šé“éƒ½æ˜¯å•å‘çš„ï¼Œå°±æ˜¯è¯´è‹¥ç§°æŸé€šé“è¿é€šäº†Aæˆ¿é—´å’ŒBæˆ¿é—´ï¼Œåªè¯´æ˜å¯ä»¥é€šè¿‡è¿™ä¸ªé€šé“ç”±Aæˆ¿é—´åˆ°è¾¾Bæˆ¿é—´ï¼Œä½†å¹¶ä¸è¯´æ˜é€šè¿‡å®ƒå¯ä»¥ç”±Bæˆ¿é—´åˆ°è¾¾Aæˆ¿é—´ã€‚Gardonéœ€è¦è¯·ä½ å†™ä¸ªç¨‹åºç¡®è®¤ä¸€ä¸‹æ˜¯å¦ä»»æ„ä¸¤ä¸ªæˆ¿é—´éƒ½æ˜¯ç›¸äº’è¿é€šçš„ï¼Œå³ï¼šå¯¹äºä»»æ„çš„iå’Œjï¼Œè‡³å°‘å­˜åœ¨ä¸€æ¡è·¯å¾„å¯ä»¥ä»æˆ¿é—´iåˆ°æˆ¿é—´jï¼Œä¹Ÿå­˜åœ¨ä¸€æ¡è·¯å¾„å¯ä»¥ä»æˆ¿é—´jåˆ°æˆ¿é—´iã€‚\nè¾“å…¥ è¾“å…¥åŒ…å«å¤šç»„æ•°æ®ï¼Œè¾“å…¥çš„ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•°ï¼šNå’ŒMï¼Œæ¥ä¸‹æ¥çš„Mè¡Œæ¯è¡Œæœ‰ä¸¤ä¸ªæ•°aå’Œbï¼Œè¡¨ç¤ºäº†ä¸€æ¡é€šé“å¯ä»¥ä»Aæˆ¿é—´æ¥åˆ°Bæˆ¿é—´ã€‚æ–‡ä»¶æœ€åä»¥ä¸¤ä¸ª0ç»“æŸã€‚\nè¾“å‡º å¯¹äºè¾“å…¥çš„æ¯ç»„æ•°æ®ï¼Œå¦‚æœä»»æ„ä¸¤ä¸ªæˆ¿é—´éƒ½æ˜¯ç›¸äº’è¿æ¥çš„ï¼Œè¾“å‡º\u0026quot;Yes\u0026quot;ï¼Œå¦åˆ™è¾“å‡º\u0026quot;No\u0026quot;ã€‚\næ ·ä¾‹è¾“å…¥ 13 3 21 2 32 3 43 1 53 3 61 2 72 3 83 2 90 0 æ ·ä¾‹è¾“å‡º 1Yes 2No æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int N = 1e4+5; 4const int M = 1e5+5; 5 6struct E { 7 int to, next; 8} e[M]; 9 10int H[N], tot; 11 12int S[N], top; 13int dfn[N], low[N], bel[N], idx, scc; 14 15int n, m; 16int u, v; 17 18void add(int from, int to) { 19 e[tot] = {to, H[from]}; 20 H[from] = tot++; 21} 22 23void dfs(int u) { 24 dfn[u] = low[u] = ++idx; 25 S[++top]=u; 26 27 for(int i=H[u]; ~i; i=e[i].next) { 28 int v = e[i].to; 29 if(!dfn[v]) { 30 dfs(v); 31 low[u] = min(low[u], low[v]); 32 } else if(!bel[v]) 33 low[u] = min(low[u], dfn[v]); 34 } 35 if(low[u]==dfn[u]) { 36 scc++; 37 int t; 38 do { 39 t=S[top--]; 40 bel[t]=scc; 41 } while(t!=u); 42 } 43} 44 45void tarjan() { 46 memset(dfn, 0, sizeof(dfn)); 47 memset(bel, 0, sizeof(bel)); 48 idx = scc = top = 0; 49 for(int i=1; i\u0026lt;=n; i++) { 50 if(!dfn[i]) 51 dfs(i); 52 } 53} 54 55int main(void) { 56 while(scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;m)==2 \u0026amp;\u0026amp; (n || m)) { 57 memset(H, -1, sizeof(H)); 58 tot = 0; 59 for(int i=0; i\u0026lt;m; i++) { 60 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); 61 add(u, v); 62 } 63 tarjan(); 64 if(scc==1) 65 printf(\u0026#34;Yes\\n\u0026#34;); 66 else 67 printf(\u0026#34;No\\n\u0026#34;); 68 } 69 return 0; 70} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1269-%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1/","summary":"è¿·å®«åŸå ¡ (HDU - 1269) é¢˜é¢ ä¸ºäº†è®­ç»ƒå°å¸Œçš„æ–¹å‘æ„Ÿï¼ŒGardonå»ºç«‹äº†ä¸€åº§å¤§åŸå ¡ï¼Œé‡Œé¢æœ‰Nä¸ªæˆ¿é—´(N\u0026lt;=10000)å’ŒMæ¡é€šé“(M\u0026lt;=100","title":"HDU-1269 è¿·å®«åŸå ¡"},{"content":"FatMouseâ€™s Speed (HDU - 1160) é¢˜é¢ FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing.\nè¾“å…¥ Input contains data for a bunch of mice, one mouse per line, terminated by end of file.\nThe data for a particular mouse will consist of a pair of integers: the first representing its size in grams and the second representing its speed in centimeters per second. Both integers are between 1 and 10000. The data in each test case will contain information for at most 1000 mice.\nTwo mice may have the same weight, the same speed, or even the same weight and speed.\nè¾“å‡º Your program should output a sequence of lines of data; the first line should contain a number n; the remaining n lines should each contain a single positive integer (each one representing a mouse). If these n integers are m[1], m[2],\u0026hellip;, m[n] then it must be the case that\nW[m[1]] \u0026lt; W[m[2]] \u0026lt; \u0026hellip; \u0026lt; W[m[n]]\nand\nS[m[1]] \u0026gt; S[m[2]] \u0026gt; \u0026hellip; \u0026gt; S[m[n]]\nIn order for the answer to be correct, n should be as large as possible. All inequalities are strict: weights must be strictly increasing, and speeds must be strictly decreasing. There may be many correct outputs for a given input, your program only needs to find one.\næ ·ä¾‹è¾“å…¥ 16008 1300 26000 2100 3500 2000 41000 4000 51100 3000 66000 2000 78000 1400 86000 1200 92000 1900 æ ·ä¾‹è¾“å‡º 14 24 35 49 57 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6struct P { 7 int w, s, id; 8}; 9 10P a[N]; 11int dp[N]; 12 13bool cmp(P a, P b) { 14 if(a.w==b.w) 15 return a.s \u0026gt; b.s; 16 return a.w \u0026lt; b.w; 17} 18 19int main(void) { 20 int n = 0; 21 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a[n].w, \u0026amp;a[n].s)==2) { 22 a[n].id = n+1; 23 n++; 24 } 25 sort(a, a+n, cmp); 26 int mx = 0; 27 28 for(int i=0; i\u0026lt;n; i++) { 29 dp[i] = 1; 30 for(int j=0; j\u0026lt;i; j++) { 31 if(a[j].w\u0026lt;a[i].w \u0026amp;\u0026amp; a[j].s\u0026gt;a[i].s) { 32 dp[i] = max(dp[i], dp[j]+1); 33 mx = max(mx, dp[i]); 34 } 35 } 36 } 37 printf(\u0026#34;%d\\n\u0026#34;, mx); 38 stack\u0026lt;int\u0026gt; st; 39 for(int i=n-1; i\u0026gt;=0; i--) { 40 if(dp[i]==mx) { 41 st.push(a[i].id); 42 mx--; 43 } 44 } 45 while(st.size()) { 46 printf(\u0026#34;%d\\n\u0026#34;, st.top()); 47 st.pop(); 48 } 49 return 0; 50} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1160-fatmouses-speed/","summary":"FatMouseâ€™s Speed (HDU - 1160) é¢˜é¢ FatMouse believes that the fatter a mouse is, the faster it runs. To disprove this, you want to take the data on a collection of mice and put as large a subset of this data as possible into a sequence so that the weights are increasing, but the speeds are decreasing. è¾“å…¥ Input","title":"HDU-1160 FatMouse's Speed"},{"content":"Advanced Fruits (POJ - 2264) é¢˜é¢ The company \u0026ldquo;21st Century Fruits\u0026rdquo; has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn\u0026rsquo;t work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them.\nA big topic of discussion inside the company is \u0026ldquo;How should the new creations be called?\u0026rdquo; A mixture between an apple and a pear could be called an apple-pear, of course, but this doesn\u0026rsquo;t sound very interesting. The boss finally decides to use the shortest string that contains both names of the original fruits as sub-strings as the new name. For instance, \u0026ldquo;applear\u0026rdquo; contains \u0026ldquo;apple\u0026rdquo; and \u0026ldquo;pear\u0026rdquo; (APPLEar and apPlEAR), and there is no shorter string that has the same property. A combination of a cranberry and a boysenberry would therefore be called a \u0026ldquo;boysecranberry\u0026rdquo; or a \u0026ldquo;craboysenberry\u0026rdquo;, for example.\nYour job is to write a program that computes such a shortest name for a combination of two given fruits. Your algorithm should be efficient, otherwise it is unlikely that it will execute in the alloted time for long fruit names.\nè¾“å…¥ Each line of the input contains two strings that represent the names of the fruits that should be combined. All names have a maximum length of 100 and only consist of alphabetic characters. Input is terminated by end of file.\nè¾“å‡º For each test case, output the shortest name of the resulting fruit on one line. If more than one shortest name is possible, any one is acceptable.\næ ·ä¾‹è¾“å…¥ 1apple peach 2ananas banana 3pear peach æ ·ä¾‹è¾“å‡º 1appleach 2bananas 3pearch æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6string s, t; 7int dp[N][N]; 8 9void print(int i, int j) { 10 stack\u0026lt;char\u0026gt;st; 11 while(i||j) { 12 if(i==0) { 13 st.push(t[j-1]), j--; 14 continue; 15 } 16 if(j==0) { 17 st.push(s[i-1]), i--; 18 continue; 19 } 20 if(s[i-1]==t[j-1]) { 21 st.push(s[i-1]); 22 i--, j--; 23 } else { 24 if(dp[i-1][j]\u0026gt;dp[i][j-1]) 25 st.push(s[i-1]), i--; 26 else 27 st.push(t[j-1]), j--; 28 } 29 } 30 while(st.size()) { 31 cout\u0026lt;\u0026lt;st.top(); 32 st.pop(); 33 } 34 cout\u0026lt;\u0026lt;endl; 35} 36 37int main(void) { 38 while(cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t) { 39 int n = s.size(); 40 int m = t.size(); 41 memset(dp, 0, sizeof(dp)); 42 for(int i=1; i\u0026lt;=n; i++) { 43 for(int j=1; j\u0026lt;=m; j++) { 44 if(s[i-1]==t[j-1]) 45 dp[i][j] = dp[i-1][j-1]+1; 46 else 47 dp[i][j] = max(dp[i-1][j], dp[i][j-1]); 48 } 49 } 50 print(n, m); 51 } 52 return 0; 53} ","permalink":"https://blog.lordash.de/posts/solution/poj-2264-advanced-fruits/","summary":"Advanced Fruits (POJ - 2264) é¢˜é¢ The company \u0026ldquo;21st Century Fruits\u0026rdquo; has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn\u0026rsquo;t work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them. A big topic of discussion inside the company is \u0026ldquo;How should the new","title":"POJ-2264 Advanced Fruits"},{"content":"Compromise (POJ - 2250) é¢˜é¢ In a few months the European Currency Union will become a reality. However, to join the club, the Maastricht criteria must be fulfilled, and this is not a trivial task for the countries (maybe except for Luxembourg). To enforce that Germany will fulfill the criteria, our government has so many wonderful options (raise taxes, sell stocks, revalue the gold reserves,\u0026hellip;) that it is really hard to choose what to do.\nTherefore the German government requires a program for the following task: Two politicians each enter their proposal of what to do. The computer then outputs the longest common subsequence of words that occurs in both proposals. As you can see, this is a totally fair compromise (after all, a common sequence of words is something what both people have in mind).\nYour country needs this program, so your job is to write it for us.\nè¾“å…¥ The input will contain several test cases. Each test case consists of two texts. Each text is given as a sequence of lower-case words, separated by whitespace, but with no punctuation. Words will be less than 30 characters long. Both texts will contain less than 100 words and will be terminated by a line containing a single \u0026lsquo;#\u0026rsquo;. Input is terminated by end of file.\nè¾“å‡º For each test case, print the longest common subsequence of words occuring in the two texts. If there is more than one such sequence, any one is acceptable. Separate the words by one blank. After the last word, output a newline character.\næ ·ä¾‹è¾“å…¥ 1die einkommen der landwirte 2sind fuer die abgeordneten ein buch mit sieben siegeln 3um dem abzuhelfen 4muessen dringend alle subventionsgesetze verbessert werden 5# 6die steuern auf vermoegen und einkommen 7sollten nach meinung der abgeordneten 8nachdruecklich erhoben werden 9dazu muessen die kontrollbefugnisse der finanzbehoerden 10dringend verbessert werden 11# æ ·ä¾‹è¾“å‡º 1die einkommen der abgeordneten muessen dringend verbessert werden æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6string a[N], b[N], s; 7int dp[N][N]; 8 9void print(int i, int j) { 10 stack\u0026lt;string\u0026gt;st; 11 while(i\u0026amp;\u0026amp;j) { 12 if(a[i-1]==b[j-1]) { 13 st.push(a[i-1]); 14 i--, j--; 15 } else { 16 if(dp[i-1][j]\u0026gt;dp[i][j-1]) 17 i--; 18 else 19 j--; 20 } 21 } 22 while(st.size()) { 23 cout\u0026lt;\u0026lt;st.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; 24 st.pop(); 25 } 26 cout\u0026lt;\u0026lt;endl; 27} 28 29int main(void) { 30 while(cin\u0026gt;\u0026gt;s) { 31 int n = 0, m = 0; 32 while(s!=\u0026#34;#\u0026#34;) { 33 a[n++] = s; 34 cin\u0026gt;\u0026gt;s; 35 } 36 cin\u0026gt;\u0026gt;s; 37 while(s!=\u0026#34;#\u0026#34;) { 38 b[m++] = s; 39 cin\u0026gt;\u0026gt;s; 40 } 41 memset(dp, 0, sizeof(dp)); 42 for(int i=1; i\u0026lt;=n; i++) { 43 for(int j=1; j\u0026lt;=m; j++) { 44 if(a[i-1]==b[j-1]) 45 dp[i][j] = dp[i-1][j-1]+1; 46 else 47 dp[i][j] = max(dp[i-1][j], dp[i][j-1]); 48 } 49 } 50 print(n, m); 51 } 52 return 0; 53} ","permalink":"https://blog.lordash.de/posts/solution/poj-2250-compromise/","summary":"Compromise (POJ - 2250) é¢˜é¢ In a few months the European Currency Union will become a reality. However, to join the club, the Maastricht criteria must be fulfilled, and this is not a trivial task for the countries (maybe except for Luxembourg). To enforce that Germany will fulfill the criteria, our government has so many wonderful options (raise taxes, sell stocks, revalue the gold reserves,\u0026hellip;) that it is really","title":"POJ-2250 Compromise"},{"content":"Common Subsequence (POJ-1458ã€HDU - 1159) é¢˜é¢ A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = \u0026lt; x1, x2, \u0026hellip;, xm \u0026gt; another sequence Z = \u0026lt; z1, z2, \u0026hellip;, zk \u0026gt; is a subsequence of X if there exists a strictly increasing sequence \u0026lt; i1, i2, \u0026hellip;, ik \u0026gt; of indices of X such that for all j = 1,2,\u0026hellip;,k, x ij = zj. For example, Z = \u0026lt; a, b, f, c \u0026gt; is a subsequence of X = \u0026lt; a, b, c, f, b, c \u0026gt; with index sequence \u0026lt; 1, 2, 4, 6 \u0026gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y.\nè¾“å…¥ The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct.\nè¾“å‡º For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line.\næ ·ä¾‹è¾“å…¥ 1abcfbc abfcab 2programming contest 3abcd mnp æ ·ä¾‹è¾“å‡º 14 22 30 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6char a[N], b[N]; 7int dp[N][N]; 8 9int main(void) { 10 while(scanf(\u0026#34;%s%s\u0026#34;, a, b)==2) { 11 int la = strlen(a); 12 int lb = strlen(b); 13 for(int i=1; i\u0026lt;=la; i++) { 14 for(int j=1; j\u0026lt;=lb; j++) { 15 if(a[i-1]==b[j-1]) 16 dp[i][j] = dp[i-1][j-1]+1; 17 else 18 dp[i][j] = max(dp[i-1][j], dp[i][j-1]); 19 } 20 } 21 printf(\u0026#34;%d\\n\u0026#34;, dp[la][lb]); 22 } 23 return 0; 24} ","permalink":"https://blog.lordash.de/posts/solution/poj-1458-common-subsequence/","summary":"Common Subsequence (POJ-1458ã€HDU - 1159) é¢˜é¢ A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = \u0026lt; x1, x2, \u0026hellip;, xm \u0026gt; another sequence Z = \u0026lt; z1, z2, \u0026hellip;, zk \u0026gt; is a subsequence of X if there exists a strictly increasing sequence \u0026lt;","title":"POJ-1458 Common Subsequence"},{"content":"Longest Ordered Subsequence (POJ - 2533) é¢˜é¢ A numeric sequence of ai is ordered if a1 \u0026lt; a2 \u0026lt; \u0026hellip; \u0026lt; aN. Let the subsequence of the given numeric sequence ( a1, a2, \u0026hellip;, aN) be any sequence ( ai1, ai2, \u0026hellip;, aiK), where 1 \u0026lt;= i1 \u0026lt; i2 \u0026lt; \u0026hellip; \u0026lt; iK \u0026lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8).\nYour program, when given the numeric sequence, must find the length of its longest ordered subsequence.\nè¾“å…¥ The first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 \u0026lt;= N \u0026lt;= 1000\nè¾“å‡º Output file must contain a single integer - the length of the longest ordered subsequence of the given sequence.\næ ·ä¾‹è¾“å…¥ 17 21 7 3 5 9 4 8 æ ·ä¾‹è¾“å‡º 14 æç¤º æ— \næ€è·¯ n^2ä¹Ÿèƒ½è¿‡\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int a[N]; 7int n; 8 9int dp[N], ans[N]; 10 11int main(void) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 13 for(int i=0; i\u0026lt;n; i++) 14 scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); 15 16 ans[0] = a[0]; 17 int len = 0; 18 for(int i=1; i\u0026lt;n; i++) { 19 if(a[i]\u0026gt;ans[len]) { 20 ans[++len] = a[i]; 21 } else { 22 int pos = lower_bound(ans, ans+len, a[i])-dp; 23 dp[pos] = a[i]; 24 } 25 } 26 printf(\u0026#34;%d\\n\u0026#34;, len+1); 27 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/poj-2533-longest-ordered-subsequence/","summary":"Longest Ordered Subsequence (POJ - 2533) é¢˜é¢ A numeric sequence of ai is ordered if a1 \u0026lt; a2 \u0026lt; \u0026hellip; \u0026lt; aN. Let the subsequence of the given numeric sequence ( a1, a2, \u0026hellip;, aN) be any sequence ( ai1, ai2, \u0026hellip;, aiK), where 1 \u0026lt;= i1 \u0026lt; i2 \u0026lt; \u0026hellip; \u0026lt; iK \u0026lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e.","title":"POJ-2533 Longest Ordered Subsequence"},{"content":"Alignment (POJ - 1836) é¢˜é¢ In the army, a platoon is composed by n soldiers. During the morning inspection, the soldiers are aligned in a straight line in front of the captain. The captain is not satisfied with the way his soldiers are aligned; it is true that the soldiers are aligned in order by their code number: 1 , 2 , 3 , . . . , n , but they are not aligned by their height. The captain asks some soldiers to get out of the line, as the soldiers that remain in the line, without changing their places, but getting closer, to form a new line, where each soldier can see by looking lengthwise the line at least one of the line\u0026rsquo;s extremity (left or right). A soldier see an extremity if there isn\u0026rsquo;t any soldiers with a higher or equal height than his height between him and that extremity.\nWrite a program that, knowing the height of each soldier, determines the minimum number of soldiers which have to get out of line.\nè¾“å…¥ On the first line of the input is written the number of the soldiers n. On the second line is written a series of n floating numbers with at most 5 digits precision and separated by a space character. The k-th number from this line represents the height of the soldier who has the code k (1 \u0026lt;= k \u0026lt;= n).\nThere are some restrictions: â€¢ 2 \u0026lt;= n \u0026lt;= 1000 â€¢ the height are floating numbers from the interval [0.5, 2.5]\nè¾“å‡º The only line of output will contain the number of the soldiers who have to get out of the line.\næ ·ä¾‹è¾“å…¥ 18 21.86 1.86 1.30621 2 1.4 1 1.97 2.2 æ ·ä¾‹è¾“å‡º 14 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6double a[N]; 7int n; 8 9int dp1[N], dp2[N]; 10 11int main(void) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 13 for(int i=0; i\u0026lt;n; i++) 14 scanf(\u0026#34;%lf\u0026#34;, \u0026amp;a[i]); 15 16 for(int i=0; i\u0026lt;n; i++) { 17 dp1[i] = 1; 18 for(int j=0; j\u0026lt;i; j++) { 19 if(a[j]\u0026lt;a[i]) 20 dp1[i] = max(dp1[i], dp1[j]+1); 21 } 22 } 23 for(int i=n-1; i\u0026gt;=0; i--) { 24 dp2[i] = 1; 25 for(int j=n-1; j\u0026gt;i; j--) { 26 if(a[j]\u0026lt;a[i]) 27 dp2[i] = max(dp2[i], dp2[j]+1); 28 } 29 } 30 int mx = 0; 31 for(int i=0; i\u0026lt;n; i++) { 32 for(int j=i+1; j\u0026lt;n; j++) 33 mx = max(mx, dp1[i]+dp2[j]); 34 } 35 printf(\u0026#34;%d\\n\u0026#34;, n-mx); 36 37 return 0; 38} ","permalink":"https://blog.lordash.de/posts/solution/poj-1836-alignment/","summary":"Alignment (POJ - 1836) é¢˜é¢ In the army, a platoon is composed by n soldiers. During the morning inspection, the soldiers are aligned in a straight line in front of the captain. The captain is not satisfied with the way his soldiers are aligned; it is true that the soldiers are aligned in order by their code number: 1 , 2 , 3 , . . . , n","title":"POJ-1836 Alignment"},{"content":"Bone Collector II (HDU - 2639) é¢˜é¢ The title of this problem is familiar,isn\u0026rsquo;t it?yeah,if you had took part in the \u0026ldquo;Rookie Cup\u0026rdquo; competition,you must have seem this title.If you haven\u0026rsquo;t seen it before,it doesn\u0026rsquo;t matter,I will give you a link:\nHere is the link: http://acm.hdu.edu.cn/showproblem.php?pid=2602\nToday we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get the same value of bones are the same.That means,it will be a strictly decreasing sequence from the 1st maximum , 2nd maximum .. to the K-th maximum.\nIf the total number of different values is less than K,just ouput 0.\nè¾“å…¥ The first line contain a integer T , the number of cases. Followed by T cases , each case three lines , the first line contain two integer N , V, K(N \u0026lt;= 100 , V \u0026lt;= 1000 , K \u0026lt;= 30)representing the number of bones and the volume of his bag and the K we need. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.\nè¾“å‡º One integer per line representing the K-th maximum of the total value (this number will be less than 2^31).\næ ·ä¾‹è¾“å…¥ 13 25 10 2 31 2 3 4 5 45 4 3 2 1 55 10 12 61 2 3 4 5 75 4 3 2 1 85 10 16 91 2 3 4 5 105 4 3 2 1 æ ·ä¾‹è¾“å‡º 112 22 30 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int w[N], c[N]; 7int T, n, v, m; 8 9int dp[N][N], a[N], b[N]; 10 11int main(void) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 13 while(T--) { 14 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;v, \u0026amp;m); 15 for(int i=0; i\u0026lt;n; i++) 16 scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); 17 for(int i=0; i\u0026lt;n; i++) 18 scanf(\u0026#34;%d\u0026#34;, \u0026amp;c[i]); 19 20 memset(dp, 0, sizeof(dp)); 21 22 for(int i=0; i\u0026lt;n; i++) { 23 for(int j=v; j\u0026gt;=c[i]; j--) { 24 for(int k=1; k\u0026lt;=m; k++) { 25 a[k] = dp[j][k]; 26 b[k] = dp[j-c[i]][k]+w[i]; 27 } 28 a[m+1] = b[m+1] = -1; 29 int di=1, ai=1, bi=1; 30 while(di\u0026lt;=m \u0026amp;\u0026amp; (ai\u0026lt;=m || bi\u0026lt;=m)) { 31 if(a[ai]\u0026gt;b[bi]) 32 dp[j][di] = a[ai++]; 33 else 34 dp[j][di] = b[bi++]; 35 if(dp[j][di]!=dp[j][di-1]) 36 di++; 37 } 38 } 39 } 40 printf(\u0026#34;%d\\n\u0026#34;, dp[v][m]); 41 } 42 return 0; 43} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2639-bone-collector-ii/","summary":"Bone Collector II (HDU - 2639) é¢˜é¢ The title of this problem is familiar,isn\u0026rsquo;t it?yeah,if you had took part in the \u0026ldquo;Rookie Cup\u0026rdquo; competition,you must have seem this title.If you haven\u0026rsquo;t seen it before,it doesn\u0026rsquo;t matter,I will give you a link: Here is the link: http://acm.hdu.edu.cn/showproblem.php?pid=2602 Today we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get","title":"HDU-2639 Bone Collector II"},{"content":"Bone Collector (HDU - 2602) é¢˜é¢ Many years ago , in Teddyâ€™s hometown there was a man who was called â€œBone Collectorâ€. This man like to collect varies of bones , such as dogâ€™s , cowâ€™s , also he went to the grave â€¦ The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each boneâ€™s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?\nè¾“å…¥ The first line contain a integer T , the number of cases. Followed by T cases , each case three lines , the first line contain two integer N , V, (N \u0026lt;= 1000 , V \u0026lt;= 1000 )representing the number of bones and the volume of his bag. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.\nè¾“å‡º One integer per line representing the maximum of the total value (this number will be less than 2^31).\næ ·ä¾‹è¾“å…¥ 11 25 10 31 2 3 4 5 45 4 3 2 1 æ ·ä¾‹è¾“å‡º 114 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int T, n, m; 7int c[N], w[N]; 8int dp[N]; 9 10int main(void) { 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 12 while(T--) { 13 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 14 for(int i=0; i\u0026lt;n; i++) { 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); 16 } 17 for(int i=0; i\u0026lt;n; i++) { 18 scanf(\u0026#34;%d\u0026#34;, \u0026amp;c[i]); 19 } 20 memset(dp, 0, sizeof(dp)); 21 for(int i=0; i\u0026lt;n; i++) { 22 for(int j=m; j\u0026gt;=c[i]; j--) { 23 dp[j] = max(dp[j], dp[j-c[i]]+w[i]); 24 } 25 } 26 printf(\u0026#34;%d\\n\u0026#34;, dp[m]); 27 } 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2602-bone-collector/","summary":"Bone Collector (HDU - 2602) é¢˜é¢ Many years ago , in Teddyâ€™s hometown there was a man who was called â€œBone Collectorâ€. This man like to collect varies of bones , such as dogâ€™s , cowâ€™s , also he went to","title":"HDU-2602 Bone Collector"},{"content":"Robberies (HDU - 2955) é¢˜é¢ The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university.\nFor a few months now, Roy has been assessing the security of various banks and the amount of cash they hold. He wants to make a calculated risk, and grab as much money as possible.\nHis mother, Ola, has decided upon a tolerable probability of getting caught. She feels that he is safe enough if the banks he robs together give a probability less than this.\nè¾“å…¥ The first line of input gives T, the number of cases. For each scenario, the first line of input gives a floating point number P, the probability Roy needs to be below, and an integer N, the number of banks he has plans for. Then follow N lines, where line j gives an integer Mj and a floating point number Pj . Bank j contains Mj millions, and the probability of getting caught from robbing it is Pj .\nè¾“å‡º For each test case, output a line with the maximum number of millions he can expect to get while the probability of getting caught is less than the limit set.\nNotes and Constraints 0 \u0026lt; T \u0026lt;= 100 0.0 \u0026lt;= P \u0026lt;= 1.0 0 \u0026lt; N \u0026lt;= 100 0 \u0026lt; Mj \u0026lt;= 100 0.0 \u0026lt;= Pj \u0026lt;= 1.0 A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds.\næ ·ä¾‹è¾“å…¥ 13 20.04 3 31 0.02 42 0.03 53 0.05 60.06 3 72 0.03 82 0.03 93 0.05 100.10 3 111 0.03 122 0.02 133 0.05 æ ·ä¾‹è¾“å‡º 12 24 36 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6double m, w[N]; 7int T, n, c[N]; 8 9double dp[N*N]; 10 11int main(void) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 13 while(T--) { 14 scanf(\u0026#34;%lf%d\u0026#34;, \u0026amp;m, \u0026amp;n); 15 int sum=0; 16 for(int i=0; i\u0026lt;n; i++) { 17 scanf(\u0026#34;%d%lf\u0026#34;, \u0026amp;c[i], \u0026amp;w[i]); 18 sum += c[i]; 19 } 20 memset(dp, 0, sizeof(dp)); 21 dp[0] = 1; 22 for(int i=0; i\u0026lt;n; i++) { 23 for(int j=sum; j\u0026gt;=c[i]; j--) { 24 dp[j] = max(dp[j], dp[j-c[i]]*(1.0-w[i])); 25 } 26 } 27 int ans; 28 for(ans=sum; dp[ans]\u0026lt;=1-m; ans--); 29 printf(\u0026#34;%d\\n\u0026#34;, ans); 30 } 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2955-robberies/","summary":"Robberies (HDU - 2955) é¢˜é¢ The aspiring Roy the Robber has seen a lot of American movies, and knows that the bad guys usually gets caught in the end, often because they become too greedy. He has decided to work in the lucrative business of bank robbery only for a short while, before retiring to a comfortable job at a university. For a few months now, Roy has been","title":"HDU-2955 Robberies"},{"content":"æ‚¼å¿µ512æ±¶å·å¤§åœ°éœ‡é‡éš¾åŒèƒâ€”â€”çæƒœç°åœ¨ï¼Œæ„Ÿæ©ç”Ÿæ´» (HDU - 2191) é¢˜é¢ æ€¥ï¼ç¾åŒºçš„é£Ÿç‰©ä¾ç„¶çŸ­ç¼ºï¼ ä¸ºäº†æŒ½æ•‘ç¾åŒºåŒèƒçš„ç”Ÿå‘½ï¼Œå¿ƒç³»ç¾åŒºåŒèƒçš„ä½ å‡†å¤‡è‡ªå·±é‡‡è´­ä¸€äº›ç²®é£Ÿæ”¯æ´ç¾åŒºï¼Œç°åœ¨å‡è®¾ä½ ä¸€å…±æœ‰èµ„é‡‘nå…ƒï¼Œè€Œå¸‚åœºæœ‰mç§å¤§ç±³ï¼Œæ¯ç§å¤§ç±³éƒ½æ˜¯è¢‹è£…äº§å“ï¼Œå…¶ä»·æ ¼ä¸ç­‰ï¼Œå¹¶ä¸”åªèƒ½æ•´è¢‹è´­ä¹°ã€‚ è¯·é—®ï¼šä½ ç”¨æœ‰é™çš„èµ„é‡‘æœ€å¤šèƒ½é‡‡è´­å¤šå°‘å…¬æ–¤ç²®é£Ÿå‘¢ï¼Ÿ\nè¾“å…¥ è¾“å…¥æ•°æ®é¦–å…ˆåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°Cï¼Œè¡¨ç¤ºæœ‰Cç»„æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ç»„æµ‹è¯•ç”¨ä¾‹çš„ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ•´æ•°nå’Œm(1\u0026lt;=n\u0026lt;=100, 1\u0026lt;=m\u0026lt;=100),åˆ†åˆ«è¡¨ç¤ºç»è´¹çš„é‡‘é¢å’Œå¤§ç±³çš„ç§ç±»ï¼Œç„¶åæ˜¯mè¡Œæ•°æ®ï¼Œæ¯è¡ŒåŒ…å«3ä¸ªæ•°pï¼Œhå’Œc(1\u0026lt;=p\u0026lt;=20,1\u0026lt;=h\u0026lt;=200,1\u0026lt;=c\u0026lt;=20)ï¼Œåˆ†åˆ«è¡¨ç¤ºæ¯è¢‹çš„ä»·æ ¼ã€æ¯è¢‹çš„é‡é‡ä»¥åŠå¯¹åº”ç§ç±»å¤§ç±³çš„è¢‹æ•°ã€‚\nè¾“å‡º å¯¹äºæ¯ç»„æµ‹è¯•æ•°æ®ï¼Œè¯·è¾“å‡ºèƒ½å¤Ÿè´­ä¹°å¤§ç±³çš„æœ€å¤šé‡é‡ï¼Œä½ å¯ä»¥å‡è®¾ç»è´¹ä¹°ä¸å…‰æ‰€æœ‰çš„å¤§ç±³ï¼Œå¹¶ä¸”ç»è´¹ä½ å¯ä»¥ä¸ç”¨å®Œã€‚æ¯ä¸ªå®ä¾‹çš„è¾“å‡ºå ä¸€è¡Œã€‚\næ ·ä¾‹è¾“å…¥ 11 28 2 32 100 4 44 100 2 æ ·ä¾‹è¾“å‡º 1400 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6int w, c, num; 7int T, n, m; 8 9int dp[N], q[N], k[N]; 10 11int main(void) { 12 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 13 while(T--) { 14 memset(dp, 0, sizeof(dp)); 15 memset(q, 0, sizeof(q)); 16 memset(k, 0, sizeof(k)); 17 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n); 18 19 for(int i=0; i\u0026lt;n; i++) { 20 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;c, \u0026amp;w, \u0026amp;num); 21 22 for(int b=0; b\u0026lt;c; b++) { 23 int head=0, tail=-1; 24 for(int j=0; j*c+b\u0026lt;=m; j++) { 25 int tmp = dp[j*c+b]-j*w; 26 while(head\u0026lt;=tail \u0026amp;\u0026amp; q[tail]\u0026lt;=tmp) 27 tail--; 28 k[++tail] = j; 29 q[tail] = tmp; 30 dp[j*c+b] = q[head]+j*w; 31 if(k[head]==j-num) 32 head++; 33 } 34 } 35 } 36 printf(\u0026#34;%d\\n\u0026#34;, dp[m]); 37 } 38 39 return 0; 40} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2191-%E6%82%BC%E5%BF%B5512/","summary":"æ‚¼å¿µ512æ±¶å·å¤§åœ°éœ‡é‡éš¾åŒèƒâ€”â€”çæƒœç°åœ¨ï¼Œæ„Ÿæ©ç”Ÿæ´» (HDU - 2191) é¢˜é¢ æ€¥ï¼ç¾åŒºçš„é£Ÿç‰©ä¾ç„¶çŸ­ç¼ºï¼ ä¸ºäº†æŒ½æ•‘ç¾åŒºåŒèƒçš„ç”Ÿå‘½ï¼Œå¿ƒç³»ç¾åŒºåŒèƒçš„ä½ å‡†å¤‡è‡ªå·±é‡‡è´­ä¸€äº›","title":"HDU-2191 æ‚¼å¿µ512"},{"content":"Big Event in HDU (HDU - 1171) é¢˜é¢ Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don\u0026rsquo;t know that Computer College had ever been split into Computer College and Software College in 2002. The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0\u0026lt;N\u0026lt;1000) kinds of facilities (different value, different kinds).\nè¾“å…¥ Input contains multiple test cases. Each test case starts with a number N (0 \u0026lt; N \u0026lt;= 50 \u0026ndash; the total number of different facilities). The next N lines contain an integer V (0\u0026lt;V\u0026lt;=50 \u0026ndash;value of facility) and an integer M (0\u0026lt;M\u0026lt;=100 \u0026ndash;corresponding number of the facilities) each. You can assume that all V are different. A test case starting with a negative integer terminates input and this test case is not to be processed.\nè¾“å‡º For each case, print one line containing two integers A and B which denote the value of Computer College and Software College will get respectively. A and B should be as equal as possible. At the same time, you should guarantee that A is not less than B.\næ ·ä¾‹è¾“å…¥ 12 210 1 320 1 43 510 1 620 2 730 1 8-1 æ ·ä¾‹è¾“å‡º 120 10 240 40 æç¤º æ— \næ€è·¯ 01èƒŒåŒ…\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int w[5000+5]; 7int n; 8 9int dp[250000+5]; 10 11int main(void) { 12 while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)==1 \u0026amp;\u0026amp; n\u0026gt;0) { 13 memset(dp, 0, sizeof(dp)); 14 int sum=0, tot=0, val, num; 15 for(int i=0; i\u0026lt;n; i++) { 16 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;val, \u0026amp;num); 17 while(num--){ 18 w[tot++] = val; 19 sum += val; 20 } 21 } 22 23 for(int i=0; i\u0026lt;tot; i++) { 24 for(int j=sum/2; j\u0026gt;=w[i]; j--) { 25 dp[j] = max(dp[j], dp[j-w[i]]+w[i]); 26 } 27 } 28 printf(\u0026#34;%d %d\\n\u0026#34;, sum-dp[sum/2], dp[sum/2]); 29 } 30 31 return 0; 32} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1171-big-event-in-hdu/","summary":"Big Event in HDU (HDU - 1171) é¢˜é¢ Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don\u0026rsquo;t know that Computer College had ever been split into Computer College and Software College in 2002. The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are","title":"HDU-1171 Big Event in HDU"},{"content":"é¥­å¡ (HDU - 2546) é¢˜é¢ ç”µå­ç§‘å¤§æœ¬éƒ¨é£Ÿå ‚çš„é¥­å¡æœ‰ä¸€ç§å¾ˆè¯¡å¼‚çš„è®¾è®¡ï¼Œå³åœ¨è´­ä¹°ä¹‹å‰åˆ¤æ–­ä½™é¢ã€‚å¦‚æœè´­ä¹°ä¸€ä¸ªå•†å“ä¹‹å‰ï¼Œå¡ä¸Šçš„å‰©ä½™é‡‘é¢å¤§äºæˆ–ç­‰äº5å…ƒï¼Œå°±ä¸€å®šå¯ä»¥è´­ä¹°æˆåŠŸï¼ˆå³ä½¿è´­ä¹°åå¡ä¸Šä½™é¢ä¸ºè´Ÿï¼‰ï¼Œå¦åˆ™æ— æ³•è´­ä¹°ï¼ˆå³ä½¿é‡‘é¢è¶³å¤Ÿï¼‰ã€‚æ‰€ä»¥å¤§å®¶éƒ½å¸Œæœ›å°½é‡ä½¿å¡ä¸Šçš„ä½™é¢æœ€å°‘ã€‚ æŸå¤©ï¼Œé£Ÿå ‚ä¸­æœ‰nç§èœå‡ºå”®ï¼Œæ¯ç§èœå¯è´­ä¹°ä¸€æ¬¡ã€‚å·²çŸ¥æ¯ç§èœçš„ä»·æ ¼ä»¥åŠå¡ä¸Šçš„ä½™é¢ï¼Œé—®æœ€å°‘å¯ä½¿å¡ä¸Šçš„ä½™é¢ä¸ºå¤šå°‘ã€‚\nè¾“å…¥ å¤šç»„æ•°æ®ã€‚å¯¹äºæ¯ç»„æ•°æ®ï¼š ç¬¬ä¸€è¡Œä¸ºæ­£æ•´æ•°nï¼Œè¡¨ç¤ºèœçš„æ•°é‡ã€‚n\u0026lt;=1000ã€‚ ç¬¬äºŒè¡ŒåŒ…æ‹¬nä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºæ¯ç§èœçš„ä»·æ ¼ã€‚ä»·æ ¼ä¸è¶…è¿‡50ã€‚ ç¬¬ä¸‰è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ­£æ•´æ•°mï¼Œè¡¨ç¤ºå¡ä¸Šçš„ä½™é¢ã€‚m\u0026lt;=1000ã€‚\nn=0è¡¨ç¤ºæ•°æ®ç»“æŸã€‚\nè¾“å‡º å¯¹äºæ¯ç»„è¾“å…¥,è¾“å‡ºä¸€è¡Œ,åŒ…å«ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå¡ä¸Šå¯èƒ½çš„æœ€å°ä½™é¢ã€‚\næ ·ä¾‹è¾“å…¥ 11 250 35 410 51 2 3 2 1 1 2 3 2 1 650 70 æ ·ä¾‹è¾“å‡º 1-45 232 æç¤º æ— \næ€è·¯ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int w[N]; 7int n, m; 8 9int dp[N]; 10 11int main(void) { 12 while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)==1 \u0026amp;\u0026amp; n) { 13 memset(dp, 0, sizeof(dp)); 14 for(int i=0; i\u0026lt;n; i++) { 15 scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); 16 } 17 sort(w, w+n); 18 scanf(\u0026#34;%d\u0026#34;, \u0026amp;m); 19 20 if(m\u0026lt;5){ 21 printf(\u0026#34;%d\\n\u0026#34;, m); 22 continue; 23 } 24 25 for(int i=0; i\u0026lt;n-1; i++) { 26 for(int j=m-5; j\u0026gt;=w[i]; j--) { 27 dp[j] = max(dp[j], dp[j-w[i]]+w[i]); 28 } 29 } 30 printf(\u0026#34;%d\\n\u0026#34;, m-dp[m-5]-w[n-1]); 31 } 32 33 return 0; 34} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2546-%E9%A5%AD%E5%8D%A1/","summary":"é¥­å¡ (HDU - 2546) é¢˜é¢ ç”µå­ç§‘å¤§æœ¬éƒ¨é£Ÿå ‚çš„é¥­å¡æœ‰ä¸€ç§å¾ˆè¯¡å¼‚çš„è®¾è®¡ï¼Œå³åœ¨è´­ä¹°ä¹‹å‰åˆ¤æ–­ä½™é¢ã€‚å¦‚æœè´­ä¹°ä¸€ä¸ªå•†å“ä¹‹å‰ï¼Œå¡ä¸Šçš„å‰©ä½™é‡‘é¢å¤§äºæˆ–ç­‰äº5å…ƒï¼Œå°±ä¸€å®šå¯ä»¥","title":"HDU-2546 é¥­å¡"},{"content":"Eight II ï¼ˆHDU - 3567) é¢˜é¢ Eight-puzzle, which is also called \u0026ldquo;Nine grids\u0026rdquo;, comes from an old game.\nIn this game, you are given a 3 by 3 board and 8 tiles. The tiles are numbered from 1 to 8 and each covers a grid. As you see, there is a blank grid which can be represented as an \u0026lsquo;X\u0026rsquo;. Tiles in grids having a common edge with the blank grid can be moved into that blank grid. This operation leads to an exchange of \u0026lsquo;X\u0026rsquo; with one tile.\nWe use the symbol \u0026lsquo;r\u0026rsquo; to represent exchanging \u0026lsquo;X\u0026rsquo; with the tile on its right side, and \u0026rsquo;l\u0026rsquo; for the left side, \u0026lsquo;u\u0026rsquo; for the one above it, \u0026rsquo;d\u0026rsquo; for the one below it.\nA state of the board can be represented by a string S using the rule showed below.\nThe problem is to operate an operation list of \u0026lsquo;r\u0026rsquo;, \u0026lsquo;u\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026rsquo;d\u0026rsquo; to turn the state of the board from state A to state B. You are required to find the result which meets the following constrains: \\1. It is of minimum length among all possible solutions. \\2. It is the lexicographically smallest one of all solutions of minimum length.\nè¾“å…¥ The first line is T (T \u0026lt;= 200), which means the number of test cases of this problem.\nThe input of each test case consists of two lines with state A occupying the first line and state B on the second line. It is guaranteed that there is an available solution from state A to B.\nè¾“å‡º For each test case two lines are expected.\nThe first line is in the format of \u0026ldquo;Case x: d\u0026rdquo;, in which x is the case number counted from one, d is the minimum length of operation list you need to turn A to B. S is the operation list meeting the constraints and it should be showed on the second line.\næ ·ä¾‹è¾“å…¥ 12 212X453786 312345678X 4564178X23 57568X4123 æ ·ä¾‹è¾“å‡º 1Case 1: 2 2dd 3Case 2: 8 4urrulldr æç¤º æ— \næ€è·¯ æ€è€ƒä¸€ä¸‹ï¼Œ\u0026lsquo;Xâ€™åœ¨9ä¸ªä¸åŒä½ç½®çš„ç›®æ ‡çŠ¶æ€å¯ä»¥åæ¨æ‰€æœ‰æƒ…å†µã€‚è¿™æ—¶æˆ‘ä»¬åªéœ€è¦ç®€å•æ˜ å°„ä¸€ä¸‹ï¼š\n564178X23â†’123456X78\n7568X4123â†’5126X3478\nå¤§è‡´æ€è·¯å°±å¾ˆæ˜ç¡®äº†ã€‚ç»§ç»­æ€è€ƒå­—å…¸åºçš„é—®é¢˜ï¼Œç”±äºæ¨å¯¼é¡ºåºå’Œé¢˜ç›®è¦æ±‚ä¸€è‡´ï¼Œåˆ™ä¸éœ€è¦å’ŒEight(HDU - 1043)ä¸€èˆ¬å°†æ–¹å‘é¢ å€’ï¼Œåªç”¨æŒ‰å­—å…¸åº(dlru)æ’å°±è¡Œ æ³¨æ„å‚è€ƒä»£ç ä¸­æœ€åçš„è·¯å¾„æ˜¯ç”±preæ•°ç»„é“¾æ¥çš„ï¼Œç›´æ¥å€’æ¨å›å»æ°å¥½å’Œæˆ‘ä»¬éœ€è¦çš„ç›¸åï¼Œæ‰€ä»¥å­˜å…¥ä¸²ä¸­å†é€†åºè¾“å‡ºã€‚è€Œåˆå§‹çŠ¶æ€çš„æ–¹å‘è¢«éšæ„çš„å­˜äº†ä¸€ä¸ª1(visæ•°ç»„)ï¼Œæ‰€ä»¥åœ¨æ•°é‡ä¸Šå’Œæœ€åè¾“å‡ºä¸­éƒ½è¦-1 ç”¨äº†åº·æ‹“å±•å¼€ï¼Œæ„Ÿè§‰å†ç”¨ä¸Šé€†å±•å¼€å¤ªè€—æ—¶äº†ï¼Œæ²¡æƒ³åˆ°å¥½çš„æ–¹æ³•ï¼Œå°±åœ¨ç»“æ„ä½“é‡Œé¢ä¸¢äº†ä¸€ä¸ªæ•°ç»„ã€‚å°½ç®¡æœ¬é¢˜æ—¶é—´å’Œç©ºé—´é™åˆ¶èŒƒå›´éƒ½æŒºå¤§ã€‚ä»¥åè¿˜å¾—å¥½å¥½æ·±å…¥ä¸€ä¸‹å…«æ•°ç å…«å¢ƒç•Œ\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 4e5+5; 5 6int vis[9][N], pre[9][N]; 7int T, n = 9; 8int fac[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}; 9 10int dx[] = { 1, 0, 0, -1}; 11int dy[] = { 0, -1, 1, 0}; 12char dir[] = \u0026#34;dlru\u0026#34;; 13 14int s[][9] = { 15 {9, 1, 2, 3, 4, 5, 6, 7, 8}, 16 {1, 9, 2, 3, 4, 5, 6, 7, 8}, 17 {1, 2, 9, 3, 4, 5, 6, 7, 8}, 18 {1, 2, 3, 9, 4, 5, 6, 7, 8}, 19 {1, 2, 3, 4, 9, 5, 6, 7, 8}, 20 {1, 2, 3, 4, 5, 9, 6, 7, 8}, 21 {1, 2, 3, 4, 5, 6, 9, 7, 8}, 22 {1, 2, 3, 4, 5, 6, 7, 9, 8}, 23 {1, 2, 3, 4, 5, 6, 7, 8, 9} 24}; 25 26struct P { 27 int a[10]; 28 int h, x; 29}; 30 31int cantor(int *s) { 32 int sum = 0; 33 for(int i=0; i\u0026lt;n; i++) { 34 int num = 0; 35 for(int j=i+1; j\u0026lt;n; j++) { 36 if(s[j]\u0026lt;s[i]) 37 num++; 38 } 39 sum += num*fac[n-i-1]; 40 } 41 return sum; 42} 43 44void decantor(int sum, int *t) { 45 int vis[10] = {0}; 46 for(int i=0; i\u0026lt;n; i++) { 47 int tmp = sum/fac[n-i-1]; 48 for(int j=0; j\u0026lt;=tmp; j++) { 49 if(vis[j]) 50 tmp++; 51 } 52 t[i] = tmp+1; 53 vis[tmp] = 1; 54 sum %= fac[n-i-1]; 55 } 56} 57 58void bfs(int k) { 59 P sp; 60 for(int i=0; i\u0026lt;n; i++) { 61 sp.a[i] = s[k][i]; 62 } 63 sp.h = cantor(sp.a); 64 sp.x = k; 65 66 queue\u0026lt;P\u0026gt; q; 67 q.push(sp); 68 vis[k][sp.h] = 1; 69 70 while(!q.empty()) { 71 P tp = q.front(); 72 q.pop(); 73 74 P np; 75 for(int i=0; i\u0026lt;4; i++) { 76 int x = tp.x/3+dx[i]; 77 int y = tp.x%3+dy[i]; 78 if(x\u0026lt;0 || x\u0026gt;=3 || y\u0026lt;0 || y\u0026gt;=3) { 79 continue; 80 } 81 np = tp; 82 np.x = x*3+y; 83 84 swap(np.a[np.x], np.a[tp.x]); 85 np.h = cantor(np.a); 86 87 if(vis[k][np.h]==-1) { 88 q.push(np); 89 vis[k][np.h] = i; 90 pre[k][np.h] = tp.h; 91 }; 92 } 93 } 94} 95 96int main(void) { 97 memset(vis, -1, sizeof(vis)); 98 memset(pre, -1, sizeof(pre)); 99 for(int i=0; i\u0026lt;n; i++) 100 bfs(i); 101 102 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 103 for(int cs=1; cs\u0026lt;=T; cs++) { 104 char str[10]; 105 int k, num[10], t[10]; 106 107 scanf(\u0026#34;%s\u0026#34;, str); 108 for(int i=0, j=1; i\u0026lt;n; i++) { 109 if(str[i]==\u0026#39;X\u0026#39;) 110 k = i; 111 else 112 num[str[i]-\u0026#39;0\u0026#39;] = j++; 113 } 114 115 scanf(\u0026#34;%s\u0026#34;, str); 116 for(int i=0; i\u0026lt;n; i++) { 117 if(str[i]==\u0026#39;X\u0026#39;) 118 t[i] = 9; 119 else 120 t[i] = num[str[i]-\u0026#39;0\u0026#39;]; 121 } 122 int h = cantor(t); 123 124 string path = \u0026#34;\u0026#34;; 125 while(h!=-1) { 126 path += dir[vis[k][h]]; 127 h = pre[k][h]; 128 } 129 printf(\u0026#34;Case %d: %d\\n\u0026#34;, cs, path.length()-1); 130 131 for(int i=path.length()-2; i\u0026gt;=0; i--) 132 printf(\u0026#34;%c\u0026#34;, path[i]); 133 printf(\u0026#34;\\n\u0026#34;); 134 } 135 136 return 0; 137} ","permalink":"https://blog.lordash.de/posts/solution/hdu-3567-eight-ii/","summary":"Eight II ï¼ˆHDU - 3567) é¢˜é¢ Eight-puzzle, which is also called \u0026ldquo;Nine grids\u0026rdquo;, comes from an old game. In this game, you are given a 3 by 3 board and 8 tiles. The tiles are numbered from 1 to 8 and each covers a grid. As you see, there is a blank grid which can be represented as an \u0026lsquo;X\u0026rsquo;. Tiles in grids having a common","title":"HDU-3567 Eight II"},{"content":"Eight (HDU - 1043) é¢˜é¢ The 15-puzzle has been around for over 100 years; even if you don\u0026rsquo;t know it by that name, you\u0026rsquo;ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let\u0026rsquo;s call the missing tile \u0026lsquo;x\u0026rsquo;; the object of the puzzle is to arrange the tiles so that they are ordered as:\n1 1 2 3 4 2 5 6 7 8 3 9 10 11 12 413 14 15 x where the only legal operation is to exchange \u0026lsquo;x\u0026rsquo; with one of the tiles with which it shares an edge. As an example, the following sequence of moves solves a slightly scrambled puzzle:\n1 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 2 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8 3 9 x 10 12 9 10 x 12 9 10 11 12 9 10 11 12 413 14 11 15 13 14 11 15 13 14 x 15 13 14 15 x 5 r-\u0026gt; d-\u0026gt; r-\u0026gt; The letters in the previous row indicate which neighbor of the \u0026lsquo;x\u0026rsquo; tile is swapped with the \u0026lsquo;x\u0026rsquo; tile at each step; legal values are \u0026lsquo;r\u0026rsquo;,\u0026rsquo;l\u0026rsquo;,\u0026lsquo;u\u0026rsquo; and \u0026rsquo;d\u0026rsquo;, for right, left, up, and down, respectively.\nNot all puzzles can be solved; in 1870, a man named Sam Loyd was famous for distributing an unsolvable version of the puzzle, and frustrating many people. In fact, all you have to do to make a regular puzzle into an unsolvable one is to swap two tiles (not counting the missing \u0026lsquo;x\u0026rsquo; tile, of course).\nIn this problem, you will write a program for solving the less well-known 8-puzzle, composed of tiles on a three by three arrangement.\nè¾“å…¥ You will receive, several descriptions of configuration of the 8 puzzle. One description is just a list of the tiles in their initial positions, with the rows listed from top to bottom, and the tiles listed from left to right within a row, where the tiles are represented by numbers 1 to 8, plus \u0026lsquo;x\u0026rsquo;. For example, this puzzle\n1 2 3 x 4 6 7 5 8\nis described by this list:\n1 2 3 x 4 6 7 5 8\nè¾“å‡º You will print to standard output either the word ``unsolvable\u0026rsquo;\u0026rsquo;, if the puzzle has no solution, or a string consisting entirely of the letters \u0026lsquo;r\u0026rsquo;, \u0026rsquo;l\u0026rsquo;, \u0026lsquo;u\u0026rsquo; and \u0026rsquo;d\u0026rsquo; that describes a series of moves that produce a solution. The string should include no spaces and start at the beginning of the line. Do not print a blank line between cases.\næ ·ä¾‹è¾“å…¥ 12 3 4 1 5 x 7 6 8 æ ·ä¾‹è¾“å‡º 1ullddrurdllurdruldr æç¤º æ— \næ€è·¯ è€ƒè™‘å¤šæ¬¡bfsä¼šTLEï¼Œè€Œç›®æ ‡çŠ¶æ€æ˜¯ç¡®å®šçš„ï¼Œä¸”ç”±æ­¤bfså‡ºçš„æ‰€æœ‰çŠ¶æ€ä¹Ÿæ˜¯æœ‰é™çš„(9!)ï¼Œæ‰€ä»¥è¿™é¢˜ä¸æ˜¯bfsç›´æ¥æœå‡ºæ¥çš„ï¼Œè€Œæ˜¯bfsæ‰“è¡¨ã€‚ æš‚æ—¶æ²¡ç”¨åº·æ‹“å±•å¼€ï¼Œä¸è¿‡æœ€å¥½å»çœ‹çœ‹ï¼ŒåŒæ—¶æ„Ÿå…´è¶£çš„åœ£é›„ç”˜åœ°å¯ä»¥äº†è§£ä¸€ä¸‹å…«æ•°ç å…«å¢ƒç•Œâ€¦\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6int n = 9; 7 8int dx[] = { 1, -1, 0, 0}; 9int dy[] = { 0, 0, 1, -1}; 10char dir[] = \u0026#34;udlr\u0026#34;; 11 12struct P { 13 string s, p; 14 int x; 15}; 16 17map\u0026lt;int, string\u0026gt; mp; 18 19void bfs() { 20 P sp; 21 sp.s = \u0026#34;123456789\u0026#34;; 22 sp.p = \u0026#34;\u0026#34;; 23 sp.x = n-1; 24 25 queue\u0026lt;P\u0026gt; q; 26 q.push(sp); 27 mp[123456789] = \u0026#34;\u0026#34;; 28 29 while(!q.empty()) { 30 P tp = q.front(); 31 q.pop(); 32 33 P np; 34 for(int i=0; i\u0026lt;4; i++) { 35 int x = tp.x/3+dx[i]; 36 int y = tp.x%3+dy[i]; 37 if(x\u0026lt;0 || x\u0026gt;=3 || y\u0026lt;0 || y\u0026gt;=3) { 38 continue; 39 } 40 np = tp; 41 np.x = x*3+y; 42 swap(np.s[np.x], np.s[tp.x]); 43 44 int d=0; 45 for(int i=0; i\u0026lt;n; i++) { 46 d = d*10+np.s[i]-\u0026#39;0\u0026#39;; 47 } 48 49 if(mp.find(d)==mp.end()) { 50 np.p += i+\u0026#39;0\u0026#39;; 51 q.push(np); 52 mp[d] = np.p; 53 }; 54 } 55 } 56} 57 58int main(void) { 59 bfs(); 60 61 char c; 62 while(scanf(\u0026#34; %c\u0026#34;, \u0026amp;c)==1) { 63 int d; 64 if(c==\u0026#39;x\u0026#39;) { 65 d = 9; 66 } else { 67 d = c-\u0026#39;0\u0026#39;; 68 } 69 for(int i=1; i\u0026lt;n; i++) { 70 scanf(\u0026#34; %c\u0026#34;, \u0026amp;c); 71 if(c==\u0026#39;x\u0026#39;) { 72 d = d*10+9; 73 } else { 74 d = d*10+c-\u0026#39;0\u0026#39;; 75 } 76 } 77 if(mp.find(d)==mp.end()) { 78 printf(\u0026#34;unsolvable\\n\u0026#34;); 79 } else { 80 string p = mp[d]; 81 for(int i=p.length()-1; i\u0026gt;=0; i--) 82 printf(\u0026#34;%c\u0026#34;, dir[p[i]-\u0026#39;0\u0026#39;]); 83 printf(\u0026#34;\\n\u0026#34;); 84 } 85 } 86 87 return 0; 88} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1043-eight/","summary":"Eight (HDU - 1043) é¢˜é¢ The 15-puzzle has been around for over 100 years; even if you don\u0026rsquo;t know it by that name, you\u0026rsquo;ve seen it. It is constructed with 15 sliding tiles, each with a number from 1 to 15 on it, and all packed into a 4 by 4 frame with one tile missing. Let\u0026rsquo;s call the missing tile \u0026lsquo;x\u0026rsquo;; the object of the puzzle is to","title":"HDU-1043 Eight"},{"content":"æ›´å¥½çš„ç›®å½•é“¾æ¥ï¼šhttps://vjudge.net/article/187 å¿«å»å…¨ç»¿å§\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜ä¸€ ç®€å•æœç´¢\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äºŒ æœç´¢è¿›é˜¶\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜ä¸‰ Dancing Links\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜å›› æœ€çŸ­è·¯ç»ƒä¹ \n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äº” å¹¶æŸ¥é›†\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜å…­ æœ€å°ç”Ÿæˆæ ‘\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜ä¸ƒ çº¿æ®µæ ‘\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜å…« ç”Ÿæˆæ ‘\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜ä¹ è¿é€šå›¾\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜å åŒ¹é…é—®é¢˜\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åä¸€ ç½‘ç»œæµ\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åäºŒ åŸºç¡€DP1\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åä¸‰ åŸºç¡€è®¡ç®—å‡ ä½•\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åå›› æ•°è®ºåŸºç¡€\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åäº” æ•°ä½DP\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åå…­ KMP \u0026amp; æ‰©å±•KMP \u0026amp; Manacher\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åä¸ƒ ACè‡ªåŠ¨æœº\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åå…« åç¼€æ•°ç»„\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜åä¹ çŸ©é˜µ\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äºŒå æ–œç‡DP\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äºŒåä¸€ æ¦‚ç‡\u0026amp;æœŸæœ›\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äºŒåäºŒ åŒºé—´DP\n[kuangbinå¸¦ä½ é£]ä¸“é¢˜äºŒåä¸‰ è®¡ç®—å‡ ä½•ä¹‹åŠå¹³é¢äº¤\n","permalink":"https://blog.lordash.de/posts/share/ffceaab471b9abf4/","summary":"æ›´å¥½çš„ç›®å½•é“¾æ¥ï¼šhttps://vjudge.net/article/187 å¿«å»å…¨ç»¿å§ [kuangbinå¸¦ä½ é£]ä¸“é¢˜ä¸€ ç®€å•æœç´¢ [kuangb","title":"kuangbinå¸¦ä½ é£ä¸“é¢˜ç›®å½•é“¾æ¥"},{"content":"Find a way (HDU - 2612) é¢˜é¢ Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki. Yifenfeiâ€™s home is at the countryside, but Mercekiâ€™s home is in the center of city. So yifenfei made arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they want to choose one that let the total time to it be most smallest. Now give you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to the adjacent road by cost 11 minutes.\nè¾“å…¥ The input contains multiple test cases. Each test case include, first two integers n, m. (2\u0026lt;=n,m\u0026lt;=200). Next n lines, each line included m character. â€˜Yâ€™ express yifenfei initial position. â€˜Mâ€™ express Merceki initial position. â€˜#â€™ forbid road; â€˜.â€™ Road. â€˜@â€™ KCF\nè¾“å‡º For each test case output the minimum total time that both yifenfei and Merceki to arrival one of KFC.You may sure there is always have a KFC that can let them meet.\næ ·ä¾‹è¾“å…¥ 14 4 2Y.#@ 3.... 4.#.. 5@..M 64 4 7Y.#@ 8.... 9.#.. 10@#.M 115 5 12Y..@. 13.#... 14.#... 15@..M. 16#...# æ ·ä¾‹è¾“å‡º 166 288 366 æç¤º æ— \næ€è·¯ è·‘ä¸¤ébfsè®°å½•Yå’ŒMåˆ°è¾¾kfcçš„æ—¶é—´å¹¶æ±‚å’Œï¼Œå†éå†æ€»æ—¶é—´å¯»æ‰¾æœ€çŸ­çš„ã€‚æ³¨æ„æœ‰çš„kfcå¯èƒ½æ— æ³•åˆ°è¾¾ï¼Œæ—¶é—´åˆå§‹åŒ–åº”ä¸ºinf\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6char b[N][N] = {{0}}; 7bool vis[N][N] = {{0}}; 8int t[N][N] = {{0}}; 9int n, m; 10 11int dx[] = { 1, -1, 0, 0}; 12int dy[] = { 0, 0, 1, -1}; 13 14struct P { 15 int x, y; 16 int step; 17}; 18 19void bfs(int x, int y) { 20 memset(vis, 0, sizeof(vis)); 21 22 P sp; 23 sp.x = x; 24 sp.y = y; 25 sp.step = 0; 26 27 queue\u0026lt;P\u0026gt; q; 28 q.push(sp); 29 vis[sp.x][sp.y] = 1; 30 31 while(!q.empty()) { 32 P tp = q.front(); 33 q.pop(); 34 35 P np = tp; 36 for(int i=0; i\u0026lt;4; i++) { 37 int x = np.x = tp.x+dx[i]; 38 int y = np.y = tp.y+dy[i]; 39 40 if(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=m) { 41 continue; 42 } 43 44 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]!=\u0026#39;#\u0026#39;) { 45 np.step = tp.step+1; 46 q.push(np); 47 vis[x][y] = 1; 48 if(t[x][y]==inf) 49 t[x][y] = np.step; 50 else 51 t[x][y] += np.step; 52 } 53 } 54 } 55} 56 57int main(void) { 58 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)==2) { 59 memset(t, inf, sizeof(t)); 60 for(int i=0; i\u0026lt;n; i++) { 61 for(int j=0; j\u0026lt;m; j++) { 62 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j]); 63 } 64 } 65 for(int i=0; i\u0026lt;n; i++) { 66 for(int j=0; j\u0026lt;m; j++) { 67 if(b[i][j]==\u0026#39;Y\u0026#39; || b[i][j]==\u0026#39;M\u0026#39;) { 68 bfs(i, j); 69 } 70 } 71 } 72 int mi = inf; 73 for(int i=0; i\u0026lt;n; i++) { 74 for(int j=0; j\u0026lt;m; j++) { 75 if(b[i][j]==\u0026#39;@\u0026#39;) 76 mi = min(mi, t[i][j]); 77 } 78 } 79 printf(\u0026#34;%d\\n\u0026#34;, mi*11); 80 } 81 return 0; 82} ","permalink":"https://blog.lordash.de/posts/solution/hdu-2612-find-a-way/","summary":"Find a way (HDU - 2612) é¢˜é¢ Pass a year learning in Hangzhou, yifenfei arrival hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to meet. Especially a good friend Merceki. Yifenfeiâ€™s home is at the countryside, but Mercekiâ€™s home is in the center of city. So yifenfei made","title":"HDU-2612 Find a way"},{"content":"éå¸¸å¯ä¹ (HDU - 1495) é¢˜é¢ å¤§å®¶ä¸€å®šè§‰çš„è¿åŠ¨ä»¥åå–å¯ä¹æ˜¯ä¸€ä»¶å¾ˆæƒ¬æ„çš„äº‹æƒ…ï¼Œä½†æ˜¯seeyouå´ä¸è¿™ä¹ˆè®¤ä¸ºã€‚å› ä¸ºæ¯æ¬¡å½“seeyouä¹°äº†å¯ä¹ä»¥åï¼Œé˜¿ç‰›å°±è¦æ±‚å’Œseeyouä¸€èµ·åˆ†äº«è¿™ä¸€ç“¶å¯ä¹ï¼Œè€Œä¸”ä¸€å®šè¦å–çš„å’Œseeyouä¸€æ ·å¤šã€‚ä½†seeyouçš„æ‰‹ä¸­åªæœ‰ä¸¤ä¸ªæ¯å­ï¼Œå®ƒä»¬çš„å®¹é‡åˆ†åˆ«æ˜¯N æ¯«å‡å’ŒM æ¯«å‡ å¯ä¹çš„ä½“ç§¯ä¸ºS ï¼ˆS\u0026lt;101ï¼‰æ¯«å‡ã€€(æ­£å¥½è£…æ»¡ä¸€ç“¶) ï¼Œå®ƒä»¬ä¸‰ä¸ªä¹‹é—´å¯ä»¥ç›¸äº’å€’å¯ä¹ (éƒ½æ˜¯æ²¡æœ‰åˆ»åº¦çš„ï¼Œä¸” S==N+Mï¼Œ101ï¼Sï¼0ï¼ŒNï¼0ï¼ŒMï¼0) ã€‚èªæ˜çš„ACMERä½ ä»¬è¯´ä»–ä»¬èƒ½å¹³åˆ†å—ï¼Ÿå¦‚æœèƒ½è¯·è¾“å‡ºå€’å¯ä¹çš„æœ€å°‘çš„æ¬¡æ•°ï¼Œå¦‚æœä¸èƒ½è¾“å‡º\u0026quot;NO\u0026quot;ã€‚\nè¾“å…¥ ä¸‰ä¸ªæ•´æ•° : S å¯ä¹çš„ä½“ç§¯ , N å’Œ Mæ˜¯ä¸¤ä¸ªæ¯å­çš„å®¹é‡ï¼Œä»¥\u0026quot;0 0 0\u0026quot;ç»“æŸã€‚\nè¾“å‡º å¦‚æœèƒ½å¹³åˆ†çš„è¯è¯·è¾“å‡ºæœ€å°‘è¦å€’çš„æ¬¡æ•°ï¼Œå¦åˆ™è¾“å‡º\u0026quot;NO\u0026quot;ã€‚\næ ·ä¾‹è¾“å…¥ 17 4 3 24 1 3 30 0 0 æ ·ä¾‹è¾“å‡º 1NO 23 æç¤º æ— \næ€è·¯ å€’æ°´é—®é¢˜ï¼Œå½“Sä¸ºå¥‡æ•°æ—¶æ— è§£ã€‚æ•°è®ºæœ‰ç®€ä¾¿è§£æ³•\nä»£ç  1using namespace std; 2 3#define out(a) (cout\u0026lt;\u0026lt;__LINE__\u0026lt;\u0026lt;\u0026#34; : \u0026#34;#a\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(a)\u0026lt;\u0026lt;endl) 4typedef long long ll; 5const int inf = 0x3f3f3f3f; 6const int N = 1e2+5; 7 8bool vis[N][N][N] = {{{0}}}; 9int s, n, m, ans = 0; 10 11struct P { 12 int n, m, s; 13 int step; 14}; 15 16bool bfs() { 17 memset(vis, 0, sizeof(vis)); 18 19 P sp; 20 sp.s = s; 21 sp.n = 0; 22 sp.m = 0; 23 sp.step = 0; 24 25 queue\u0026lt;P\u0026gt; q; 26 q.push(sp); 27 vis[sp.s][sp.n][sp.m] = 1; 28 29 while(!q.empty()) { 30 P tp = q.front(); 31 q.pop(); 32 33 if((!tp.n\u0026amp;\u0026amp;tp.m==tp.s) || (!tp.m\u0026amp;\u0026amp;tp.n==tp.s) || (!tp.s\u0026amp;\u0026amp;tp.n==tp.m)) { 34 ans = tp.step; 35 return true; 36 } 37 P np = tp; 38 int t; 39 40 if(tp.n) { 41 t = tp.n+tp.m; 42 if(t\u0026gt;m) { 43 np.m = m; 44 } else { 45 np.m = t; 46 } 47 np.n = t-np.m; 48 np.s = tp.s; 49 50 if(!vis[np.s][np.n][np.m]) { 51 np.step = tp.step+1; 52 q.push(np); 53 vis[np.s][np.n][np.m] = 1; 54 } 55 56 t = tp.n+tp.s; 57 if(t\u0026gt;s) { 58 np.s = s; 59 } else { 60 np.s = t; 61 } 62 np.n = t-np.s; 63 np.m = tp.m; 64 65 if(!vis[np.s][np.n][np.m]) { 66 np.step = tp.step+1; 67 q.push(np); 68 vis[np.s][np.n][np.m] = 1; 69 } 70 } 71 72 if(tp.m) { 73 t = tp.m+tp.n; 74 if(t\u0026gt;n) { 75 np.n = n; 76 } else { 77 np.n = t; 78 } 79 np.m = t-np.n; 80 np.s = tp.s; 81 82 if(!vis[np.s][np.n][np.m]) { 83 np.step = tp.step+1; 84 q.push(np); 85 vis[np.s][np.n][np.m] = 1; 86 } 87 88 t = tp.m+tp.s; 89 if(t\u0026gt;s) { 90 np.s = s; 91 } else { 92 np.s = t; 93 } 94 np.m = t-np.s; 95 np.n = tp.n; 96 97 if(!vis[np.s][np.n][np.m]) { 98 np.step = tp.step+1; 99 q.push(np); 100 vis[np.s][np.n][np.m] = 1; 101 } 102 } 103 104 if(tp.s) { 105 t = tp.s+tp.n; 106 if(t\u0026gt;n) { 107 np.n = n; 108 } else { 109 np.n = t; 110 } 111 np.s = t-np.n; 112 np.m = tp.m; 113 114 if(!vis[np.s][np.n][np.m]) { 115 np.step = tp.step+1; 116 q.push(np); 117 vis[np.s][np.n][np.m] = 1; 118 } 119 120 t = tp.s+tp.m; 121 if(t\u0026gt;m) { 122 np.m = m; 123 } else { 124 np.m = t; 125 } 126 np.s = t-np.m; 127 np.n = tp.n; 128 129 if(!vis[np.s][np.n][np.m]) { 130 np.step = tp.step+1; 131 q.push(np); 132 vis[np.s][np.n][np.m] = 1; 133 } 134 } 135 } 136 return false; 137} 138 139int main(void) { 140 while(scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;s, \u0026amp;n, \u0026amp;m)==3 \u0026amp;\u0026amp; s \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { 141 if(s%2==0 \u0026amp;\u0026amp; bfs()) { 142 printf(\u0026#34;%d\\n\u0026#34;, ans); 143 } else { 144 printf(\u0026#34;NO\\n\u0026#34;); 145 } 146 } 147 return 0; 148} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/","summary":"éå¸¸å¯ä¹ (HDU - 1495) é¢˜é¢ å¤§å®¶ä¸€å®šè§‰çš„è¿åŠ¨ä»¥åå–å¯ä¹æ˜¯ä¸€ä»¶å¾ˆæƒ¬æ„çš„äº‹æƒ…ï¼Œä½†æ˜¯seeyouå´ä¸è¿™ä¹ˆè®¤ä¸ºã€‚å› ä¸ºæ¯æ¬¡å½“seeyouä¹°äº†å¯ä¹ä»¥åï¼Œé˜¿ç‰›å°±è¦æ±‚","title":"HDU-1495 éå¸¸å¯ä¹"},{"content":"Oil Deposits (HDU - 1241) é¢˜é¢ The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.\nè¾“å…¥ The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 \u0026lt;= m \u0026lt;= 100 and 1 \u0026lt;= n \u0026lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either \u0026lsquo;*\u0026rsquo;, representing the absence of oil, or \u0026lsquo;@\u0026rsquo;, representing an oil pocket.\nè¾“å‡º For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.\næ ·ä¾‹è¾“å…¥ 11 1 2* 33 5 4*@*@* 5**@** 6*@*@* 71 8 8@@****@* 95 5 10****@ 11*@@*@ 12*@**@ 13@@@*@ 14@@**@ 150 0 æ ·ä¾‹è¾“å‡º 10 21 32 42 æç¤º æ— \næ€è·¯ bfsæ±‚è¿é€šå—\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6char b[N][N] = {{0}}; 7bool vis[N][N] = {{0}}; 8int n, m, ans = 0; 9 10int dx[] = { 1, -1, 0, 0, 1, 1, -1, -1}; 11int dy[] = { 0, 0, 1, -1, 1, -1, 1, -1}; 12 13struct P { 14 int x, y; 15}; 16 17void bfs(int x, int y) { 18 P sp; 19 sp.x = x; 20 sp.y = y; 21 22 queue\u0026lt;P\u0026gt; q; 23 q.push(sp); 24 vis[sp.x][sp.y] = 1; 25 26 while(!q.empty()) { 27 P tp = q.front(); 28 q.pop(); 29 30 P np = tp; 31 for(int i=0; i\u0026lt;8; i++) { 32 int x = np.x = tp.x+dx[i]; 33 int y = np.y = tp.y+dy[i]; 34 35 if(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=m) { 36 continue; 37 } 38 39 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]==\u0026#39;@\u0026#39;) { 40 q.push(np); 41 vis[x][y] = 1; 42 } 43 } 44 } 45} 46 47int main(void) { 48 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)==2 \u0026amp;\u0026amp; n \u0026amp;\u0026amp; m) { 49 memset(vis, 0, sizeof(vis)); 50 ans = 0; 51 for(int i=0; i\u0026lt;n; i++) { 52 for(int j=0; j\u0026lt;m; j++) { 53 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j]); 54 } 55 } 56 for(int i=0; i\u0026lt;n; i++) { 57 for(int j=0; j\u0026lt;m; j++) { 58 if(!vis[i][j] \u0026amp;\u0026amp; b[i][j]==\u0026#39;@\u0026#39;) { 59 bfs(i, j); 60 ans++; 61 } 62 } 63 } 64 printf(\u0026#34;%d\\n\u0026#34;, ans); 65 } 66 return 0; 67} ","permalink":"https://blog.lordash.de/posts/solution/hdu-1241-oil-deposits/","summary":"Oil Deposits (HDU - 1241) é¢˜é¢ The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If","title":"HDU-1241 Oil Deposits"},{"content":"è¿·å®«é—®é¢˜ (POJ - 3984) é¢˜é¢ å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼š\n1int maze[5][5] = { 2 0, 1, 0, 0, 0, 3 0, 1, 0, 1, 0, 4 0, 0, 0, 0, 0, 5 0, 1, 1, 1, 0, 6 0, 0, 0, 1, 0, 7}; å®ƒè¡¨ç¤ºä¸€ä¸ªè¿·å®«ï¼Œå…¶ä¸­çš„1è¡¨ç¤ºå¢™å£ï¼Œ0è¡¨ç¤ºå¯ä»¥èµ°çš„è·¯ï¼Œåªèƒ½æ¨ªç€èµ°æˆ–ç«–ç€èµ°ï¼Œä¸èƒ½æ–œç€èµ°ï¼Œè¦æ±‚ç¼–ç¨‹åºæ‰¾å‡ºä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„æœ€çŸ­è·¯çº¿ã€‚\nè¾“å…¥ ä¸€ä¸ª5 Ã— 5çš„äºŒç»´æ•°ç»„ï¼Œè¡¨ç¤ºä¸€ä¸ªè¿·å®«ã€‚æ•°æ®ä¿è¯æœ‰å”¯ä¸€è§£ã€‚\nè¾“å‡º å·¦ä¸Šè§’åˆ°å³ä¸‹è§’çš„æœ€çŸ­è·¯å¾„ï¼Œæ ¼å¼å¦‚æ ·ä¾‹æ‰€ç¤ºã€‚\næ ·ä¾‹è¾“å…¥ 10 1 0 0 0 20 1 0 1 0 30 0 0 0 0 40 1 1 1 0 50 0 0 1 0 æ ·ä¾‹è¾“å‡º 1(0, 0) 2(1, 0) 3(2, 0) 4(2, 1) 5(2, 2) 6(2, 3) 7(2, 4) 8(3, 4) 9(4, 4) æç¤º æ— \næ€è·¯ bfs+è·¯å¾„è¾“å‡ºï¼Œè®°å½•è·¯å¾„æœ‰å¤šç§æ–¹å¼ã€‚\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e1+5; 5 6int b[N][N] = {{0}}; 7bool vis[N][N] = {{0}}; 8int n, m; 9 10int dx[] = { 0, 1, -1, 0, 0}; 11int dy[] = { 0, 0, 0, 1, -1}; 12 13struct P { 14 int x, y; 15 int p[N]; 16 int step; 17}; 18 19P bfs() { 20 memset(vis, 0, sizeof(vis)); 21 22 P sp; 23 sp.x = 0; 24 sp.y = 0; 25 sp.step = 0; 26 memset(sp.p, 0, sizeof(sp.p)); 27 28 queue\u0026lt;P\u0026gt; q; 29 q.push(sp); 30 vis[sp.x][sp.y] = 1; 31 32 while(!q.empty()) { 33 P tp = q.front(); 34 q.pop(); 35 36 if(tp.x==n-1 \u0026amp;\u0026amp; tp.y==m-1) { 37 return tp; 38 } 39 40 P np = tp; 41 for(int i=1; i\u0026lt;=4; i++) { 42 int x = np.x = tp.x+dx[i]; 43 int y = np.y = tp.y+dy[i]; 44 45 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]==0) { 46 np.step = tp.step+1; 47 np.p[np.step] = i; 48 q.push(np); 49 vis[x][y] = 1; 50 } 51 } 52 } 53 return sp; 54} 55 56int main(void) { 57 n = m = 5; 58 for(int i=0; i\u0026lt;n; i++) { 59 for(int j=0; j\u0026lt;m; j++) { 60 scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i][j]); 61 } 62 } 63 P ans = bfs(); 64 if(ans.step) { 65 int x=0, y=0; 66 for(int i=0; i\u0026lt;=ans.step; i++) { 67 printf(\u0026#34;(%d, %d)\\n\u0026#34;, x+=dx[ans.p[i]], y+=dy[ans.p[i]]); 68 } 69 } 70 71 return 0; 72} ","permalink":"https://blog.lordash.de/posts/solution/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","summary":"è¿·å®«é—®é¢˜ (POJ - 3984) é¢˜é¢ å®šä¹‰ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼š 1int maze[5][5] = { 2 0, 1, 0, 0, 0, 3 0, 1, 0, 1, 0, 4 0, 0, 0, 0, 0, 5 0, 1, 1, 1, 0, 6 0, 0, 0, 1, 0, 7}; å®ƒè¡¨ç¤ºä¸€ä¸ªè¿·å®«ï¼Œå…¶ä¸­çš„1è¡¨ç¤ºå¢™å£ï¼Œ","title":"POJ-3984 è¿·å®«é—®é¢˜"},{"content":"Fire! (UVA - 11624) é¢˜é¢ æ€è·¯ å…ˆè·‘ä¸€æ¬¡bfsæ±‚å‡ºç«è”“å»¶åˆ°æ¯ä¸€æ ¼çš„æ—¶é—´ï¼Œå†ä»¥æ­¤ä¸ºé™åˆ¶å¯¹äººè·‘bfsæ±‚è§£ï¼Œæ³¨æ„æœ‰å¤šä¸ªèµ·ç«ç‚¹\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6char b[N][N] = {{0}}; 7bool vis[N][N] = {{0}}; 8int t[N][N] = {{0}}; 9int T, n, m, ans = 0; 10 11int dx[] = { 1, -1, 0, 0}; 12int dy[] = { 0, 0, 1, -1}; 13 14struct F { 15 int x, y; 16 int step; 17}; 18 19struct P { 20 int x, y; 21 int step; 22}; 23queue\u0026lt;F\u0026gt; f; 24 25void pre() { 26 memset(vis, 0, sizeof(vis)); 27 while(!f.empty()) { 28 F tf = f.front(); 29 f.pop(); 30 31 F nf = tf; 32 for(int i=0; i\u0026lt;4; i++) { 33 int x = nf.x = tf.x+dx[i]; 34 int y = nf.y = tf.y+dy[i]; 35 36 if(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=m) { 37 continue; 38 } 39 40 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]==\u0026#39;.\u0026#39;) { 41 nf.step = tf.step+1; 42 f.push(nf); 43 vis[x][y] = 1; 44 t[x][y] = nf.step; 45 } 46 } 47 } 48} 49 50bool bfs(int x, int y) { 51 memset(vis, 0, sizeof(vis)); 52 53 P sp; 54 sp.x = x; 55 sp.y = y; 56 sp.step = 0; 57 58 queue\u0026lt;P\u0026gt; q; 59 q.push(sp); 60 vis[x][y] = 1; 61 62 while(!q.empty()) { 63 P tp = q.front(); 64 q.pop(); 65 66 P np = tp; 67 for(int i=0; i\u0026lt;4; i++) { 68 int x = np.x = tp.x+dx[i]; 69 int y = np.y = tp.y+dy[i]; 70 71 if(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=m) { 72 ans = tp.step+1; 73 return true; 74 } 75 76 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]==\u0026#39;.\u0026#39; \u0026amp;\u0026amp; tp.step+1\u0026lt;t[x][y]) { 77 np.step = tp.step+1; 78 q.push(np); 79 vis[x][y] = 1; 80 } 81 } 82 } 83 return false; 84} 85 86int main(void) { 87 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 88 for(int cs=1; cs\u0026lt;=T; cs++) { 89 memset(t, inf, sizeof(t)); 90 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 91 int x, y; 92 for(int i=0; i\u0026lt;n; i++) { 93 for(int j=0; j\u0026lt;m; j++) { 94 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j]); 95 if(b[i][j]==\u0026#39;F\u0026#39;) { 96 F sf; 97 sf.x = i; 98 sf.y = j; 99 sf.step = 0; 100 t[i][j] = 0; 101 f.push(sf); 102 } else if(b[i][j]==\u0026#39;J\u0026#39;) { 103 x = i; 104 y = j; 105 } 106 } 107 } 108 pre(); 109 if(bfs(x, y)) 110 printf(\u0026#34;%d\\n\u0026#34;, ans); 111 else 112 printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); 113 } 114 return 0; 115} ","permalink":"https://blog.lordash.de/posts/solution/uva-11624-fire/","summary":"Fire! (UVA - 11624) é¢˜é¢ æ€è·¯ å…ˆè·‘ä¸€æ¬¡bfsæ±‚å‡ºç«è”“å»¶åˆ°æ¯ä¸€æ ¼çš„æ—¶é—´ï¼Œå†ä»¥æ­¤ä¸ºé™åˆ¶å¯¹äººè·‘bfsæ±‚è§£ï¼Œæ³¨æ„æœ‰å¤šä¸ªèµ·ç«ç‚¹ ä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5;","title":"UVA-11624 Fire!"},{"content":"Fire Game (FZU - 2150) é¢˜é¢ Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire can spread among the grass. If the grid (x, y) is firing at time t, the grid which is adjacent to this grid will fire at time t+1 which refers to the grid (x+1, y), (x-1, y), (x, y+1), (x, y-1). This process ends when no new grid get fire. If then all the grid which are consisting of grass is get fired, Fat brother and Maze will stand in the middle of the grid and playing a MORE special (hentai) game. (Maybe itâ€™s the OOXX game which decrypted in the last problem, who knows.)\nYou can assume that the grass in the board would never burn out and the empty grid would never get fire.\nNote that the two grids they choose can be the same.\nè¾“å…¥ The first line of the date is an integer T, which is the number of the text cases.\nThen T cases follow, each case contains two integers N and M indicate the size of the board. Then goes N line, each line with M character shows the board. â€œ#â€ Indicates the grass. You can assume that there is at least one grid which is consisting of grass in the board.\n1 \u0026lt;= T \u0026lt;=100, 1 \u0026lt;= n \u0026lt;=10, 1 \u0026lt;= m \u0026lt;=10\nè¾“å‡º For each case, output the case number first, if they can play the MORE special (hentai) game (fire all the grass), output the minimal time they need to wait after they set fire, otherwise just output -1. See the sample input and output for more details.\næ ·ä¾‹è¾“å…¥ 14 23 3 3.#. 4### 5.#. 63 3 7.#. 8#.# 9.#. 103 3 11... 12#.# 13... 143 3 15### 16..# 17#.# æ ·ä¾‹è¾“å‡º 1Case 1: 1 2Case 2: -1 3Case 3: 0 4Case 4: 2 æç¤º æ— \næ€è·¯ æš´åŠ›æšä¸¾ä¸¤ä¸ªèµ·ç«ç‚¹è·‘bfsï¼Œç»Ÿè®¡æœ€å°å€¼ï¼Œæ³¨æ„è‰çš„æ•°é‡å°‘äºç­‰äº2æ—¶å¯ä»¥ç‰¹åˆ¤\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6char b[N][N] = {{0}}; 7bool vis[N][N] = {{0}}; 8int T, n, m; 9 10int dx[] = { 1, -1, 0, 0}; 11int dy[] = { 0, 0, 1, -1}; 12 13struct P { 14 int x, y; 15 int step; 16} p[N]; 17 18int bfs(P sp1, P sp2) { 19 memset(vis, 0, sizeof(vis)); 20 21 queue\u0026lt;P\u0026gt; q; 22 q.push(sp1); 23 q.push(sp2); 24 vis[sp1.x][sp1.y] = 1; 25 vis[sp2.x][sp2.y] = 1; 26 27 int t = 0; 28 29 while(!q.empty()) { 30 P tp = q.front(); 31 q.pop(); 32 33 t = max(t, tp.step); 34 P np = tp; 35 36 for(int i=0; i\u0026lt;4; i++) { 37 int x = np.x = tp.x+dx[i]; 38 int y = np.y = tp.y+dy[i]; 39 40 if(x\u0026lt;0 || x\u0026gt;=n || y\u0026lt;0 || y\u0026gt;=m) { 41 continue; 42 } 43 44 if(!vis[x][y] \u0026amp;\u0026amp; b[x][y]==\u0026#39;#\u0026#39;) { 45 np.step = tp.step+1; 46 q.push(np); 47 vis[x][y] = 1; 48 } 49 } 50 } 51 return t; 52} 53 54bool ok(int n, int m) { 55 for(int i=0; i\u0026lt;n; i++) { 56 for(int j=0; j\u0026lt;m; j++) { 57 if(!vis[i][j] \u0026amp;\u0026amp; b[i][j]==\u0026#39;#\u0026#39;) { 58 return 0; 59 } 60 } 61 } 62 return 1; 63} 64 65int main(void) { 66 67 scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); 68 for(int cs=1; cs\u0026lt;=T; cs++) { 69 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); 70 int num = 0; 71 72 for(int i=0; i\u0026lt;n; i++) { 73 for(int j=0; j\u0026lt;m; j++) { 74 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j]); 75 if(b[i][j]==\u0026#39;#\u0026#39;) { 76 p[num].x = i; 77 p[num].y = j; 78 p[num].step = 0; 79 num++; 80 } 81 } 82 } 83 printf(\u0026#34;Case %d: \u0026#34;, cs); 84 if(num\u0026lt;=2) { 85 printf(\u0026#34;0\\n\u0026#34;); 86 } else { 87 int mi = inf; 88 for(int i=0; i\u0026lt;num; i++) { 89 for(int j=i+1; j\u0026lt;num; j++) { 90 int t = bfs(p[i], p[j]); 91 if(ok(n, m)) 92 mi = min(mi, t); 93 } 94 } 95 if(mi==inf) 96 printf(\u0026#34;-1\\n\u0026#34;); 97 else 98 printf(\u0026#34;%d\\n\u0026#34;, mi); 99 } 100 } 101 102 return 0; 103} ","permalink":"https://blog.lordash.de/posts/solution/fzu-2150-fire-game/","summary":"Fire Game (FZU - 2150) é¢˜é¢ Fat brother and Maze are playing a kind of special (hentai) game on an N*M board (N rows, M columns). At the beginning, each grid of this board is consisting of grass or just empty and then they start to fire all the grass. Firstly they choose two grids which are consisting of grass and set fire. As we all know, the fire","title":"FZU-2150 Fire Game"},{"content":"Pots (POJ - 3414) é¢˜é¢ You are given two pots, having the volume of A and B liters respectively. The following operations can be performed:\nFILL(i) fill the pot i (1 â‰¤ i â‰¤ 2) from the tap; DROP(i) empty the pot i to the drain; POUR(i,j) pour from pot i to pot j; after this operation either the pot j is full (and there may be some water left in the pot i), or the pot i is empty (and all its contents have been moved to the pot j). Write a program to find the shortest possible sequence of these operations that will yield exactly C liters of water in one of the pots.\nè¾“å…¥ On the first and only line are the numbers A, B, and C. These are all integers in the range from 1 to 100 and Câ‰¤max(A,B).\nè¾“å‡º The first line of the output must contain the length of the sequence of operations K. The following K lines must each describe one operation. If there are several sequences of minimal length, output any one of them. If the desired result canâ€™t be achieved, the first and only line of the file must contain the word â€˜impossibleâ€™.\næ ·ä¾‹è¾“å…¥ 13 5 4 æ ·ä¾‹è¾“å‡º 16 2FILL(2) 3POUR(2,1) 4DROP(1) 5POUR(2,1) 6FILL(2) 7POUR(2,1) æç¤º æ— \næ€è·¯ å€’æ°´é—®é¢˜ï¼Œbfs+è·¯å¾„è¾“å‡º\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e2+5; 5 6bool vis[N][N] = {{0}}; 7int A, B, C; 8 9const char* path[] = { 10 \u0026#34;FILL(1)\u0026#34;, 11 \u0026#34;FILL(2)\u0026#34;, 12 \u0026#34;DROP(1)\u0026#34;, 13 \u0026#34;DROP(2)\u0026#34;, 14 \u0026#34;POUR(1,2)\u0026#34;, 15 \u0026#34;POUR(2,1)\u0026#34; 16}; 17 18struct P { 19 int a, b; 20 int p[N]; 21 int n; 22}; 23 24P bfs() { 25 memset(vis, 0, sizeof(vis)); 26 27 P sp; 28 sp.a = 0; 29 sp.b = 0; 30 sp.n = 0; 31 memset(sp.p, 0, sizeof(sp.p)); 32 33 queue\u0026lt;P\u0026gt; q; 34 q.push(sp); 35 vis[sp.a][sp.b] = 1; 36 37 while(!q.empty()) { 38 P tp = q.front(); 39 q.pop(); 40 41 if(tp.a==C || tp.b==C) { 42 return tp; 43 } 44 45 P np = tp; 46 np.n = tp.n+1; 47 48 if(tp.a\u0026lt;A) { 49 np.a = A; 50 np.b = tp.b; 51 if(!vis[np.a][np.b]) { 52 np.p[tp.n] = 0; 53 q.push(np); 54 vis[np.a][np.b] = 1; 55 } 56 } 57 58 if(tp.b\u0026lt;B) { 59 np.a = tp.a; 60 np.b = B; 61 if(!vis[np.a][np.b]) { 62 np.p[tp.n] = 1; 63 q.push(np); 64 vis[np.a][np.b] = 1; 65 } 66 } 67 68 if(tp.a) { 69 np.a = 0; 70 np.b = tp.b; 71 if(!vis[np.a][np.b]) { 72 np.p[tp.n] = 2; 73 q.push(np); 74 vis[np.a][np.b] = 1; 75 } 76 } 77 78 if(tp.b) { 79 np.a = tp.a; 80 np.b = 0; 81 if(!vis[np.a][np.b]) { 82 np.p[tp.n] = 3; 83 q.push(np); 84 vis[np.a][np.b] = 1; 85 } 86 } 87 88 if(tp.a \u0026amp;\u0026amp; tp.b\u0026lt;B) { 89 if(tp.a \u0026gt; B-tp.b) { 90 np.a = tp.a-B+tp.b; 91 np.b = B; 92 } else { 93 np.a = 0; 94 np.b = tp.a+tp.b; 95 } 96 if(!vis[np.a][np.b]) { 97 np.p[tp.n] = 4; 98 q.push(np); 99 vis[np.a][np.b] = 1; 100 } 101 } 102 103 if(tp.b \u0026amp;\u0026amp; tp.a\u0026lt;A) { 104 if(tp.b \u0026gt; A-tp.a) { 105 np.a = A; 106 np.b = tp.b-A+tp.a; 107 } else { 108 np.a = tp.a+tp.b; 109 np.b = 0; 110 } 111 if(!vis[np.a][np.b]) { 112 np.p[tp.n] = 5; 113 q.push(np); 114 vis[np.a][np.b] = 1; 115 } 116 } 117 } 118 return sp; 119} 120 121int main(void) { 122 123 scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;A, \u0026amp;B, \u0026amp;C); 124 P ans = bfs(); 125 126 if(ans.n) { 127 printf(\u0026#34;%d\\n\u0026#34;, ans.n); 128 for(int i=0; i\u0026lt;ans.n; i++) { 129 int j = ans.p[i]; 130 printf(\u0026#34;%s\\n\u0026#34;, path[j]); 131 } 132 } else { 133 printf(\u0026#34;impossible\\n\u0026#34;); 134 } 135 136 return 0; 137} ","permalink":"https://blog.lordash.de/posts/solution/poj-3414-pots/","summary":"Pots (POJ - 3414) é¢˜é¢ You are given two pots, having the volume of A and B liters respectively. The following operations can be performed: FILL(i) fill the pot i (1 â‰¤ i â‰¤ 2) from the tap; DROP(i) empty the pot i to the drain; POUR(i,j) pour from pot i to pot j; after this operation either the pot j is full (and there may be some water","title":"POJ-3414 Pots"},{"content":"Shuffleâ€™m Up (POJ - 3087) é¢˜é¢ A common pastime for poker players at a poker table is to shuffle stacks of chips. Shuffling chips is performed by starting with two stacks of poker chips, S1 and S2, each stack containing C chips. Each stack may contain chips of several different colors.\nThe actual shuffle operation is performed by interleaving a chip from S1 with a chip from S2 as shown below for C = 5:\nâ€‹ The single resultant stack, S12, contains 2 Ã— C chips. The bottommost chip of S12 is the bottommost chip from S2. On top of that chip, is the bottommost chip from S1. The interleaving process continues taking the 2nd chip from the bottom of S2 and placing that on S12, followed by the 2nd chip from the bottom of S1 and so on until the topmost chip from S1 is placed on top of S12.\nAfter the shuffle operation, S12 is split into 2 new stacks by taking the bottommost C chips from S12 to form a new S1 and the topmost C chips from S12 to form a new S2. The shuffle operation may then be repeated to form a new S12.\nFor this problem, you will write a program to determine if a particular resultant stack S12 can be formed by shuffling two stacks some number of times.\nè¾“å…¥ The first line of input contains a single integer N, (1 â‰¤ N â‰¤ 1000) which is the number of datasets that follow.Each dataset consists of four lines of input. The first line of a dataset specifies an integer C, (1 â‰¤ C â‰¤ 100) which is the number of chips in each initial stack (S1 and S2). The second line of each dataset specifies the colors of each of the C chips in stack S1, starting with the bottommost chip. The third line of each dataset specifies the colors of each of the C chips in stack S2 starting with the bottommost chip. Colors are expressed as a single uppercase letter (A through H). There are no blanks or separators between the chip colors. The fourth line of each dataset contains 2 Ã— C uppercase letters (A through H), representing the colors of the desired result of the shuffling of S1 and S2 zero or more times. The bottommost chipâ€™s color is specified first.\nè¾“å‡º Output for each dataset consists of a single line that displays the dataset number (1 though N), a space, and an integer value which is the minimum number of shuffle operations required to get the desired resultant stack. If the desired result can not be reached using the input for the dataset, display the value negative 1 (âˆ’1) for the number of shuffle operations.\næ ·ä¾‹è¾“å…¥ 12 24 3AHAH 4HAHA 5HHAAAAHH 63 7CDE 8CDE 9EEDDCC æ ·ä¾‹è¾“å‡º 11 2 22 -1 æç¤º æ— \næ€è·¯ æ¨¡æ‹Ÿå³å¯ï¼Œå¦‚æœåºåˆ—é‡å¤åˆ™è¡¨æ˜è¿›å…¥å¾ªç¯\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e3+5; 5 6int n, c, step; 7char s1[N] = \u0026#34;\u0026#34;, s2[N] = \u0026#34;\u0026#34;, t[N] = \u0026#34;\u0026#34;, r[N] = \u0026#34;\u0026#34;; 8 9int main(void) { 10 11 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 12 for(int cs=1; cs\u0026lt;=n; i++) { 13 scanf(\u0026#34;%d %s %s %s\u0026#34;, \u0026amp;c, s1, s2, r); 14 map\u0026lt;string,bool\u0026gt; m; 15 step = 0; 16 17 while(1) { 18 for(int i=0; i\u0026lt;c; i++) { 19 t[i*2] = s2[i]; 20 t[i*2+1] = s1[i]; 21 } 22 t[c*2] = \u0026#39;\\0\u0026#39;; 23 step++; 24 if(strcmp(t, r)==0) { 25 break; 26 } 27 if(m[t]==true) { 28 step = -1; 29 break; 30 } 31 m[t] = true; 32 strncpy(s1, t, c); 33 strncpy(s2, t+c, c); 34 } 35 36 printf(\u0026#34;%d %d\\n\u0026#34;, cs, step); 37 } 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/poj-3087-shufflem-up/","summary":"Shuffleâ€™m Up (POJ - 3087) é¢˜é¢ A common pastime for poker players at a poker table is to shuffle stacks of chips. Shuffling chips is performed by starting with two stacks of poker chips, S1 and S2, each stack containing C chips. Each stack may contain chips of several different colors. The actual shuffle operation is performed by interleaving a chip","title":"POJ-3087 Shuffle'm Up"},{"content":"Prime Path (POJ - 3126) é¢˜é¢ The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. â€” It is a matter of security to change such things every now and then, to keep the enemy in the dark. â€” But look, I have chosen my number 1033 for good reasons. I am the Prime minister, you know! â€” I know, so therefore your new number 8179 is also a prime. You will just have to paste four new digits over the four old ones on your office door. â€” No, itâ€™s not that simple. Suppose that I change the first digit to an 8, then the number will read 8033 which is not a prime! â€” I see, being the prime minister you cannot stand having a non-prime number on your door even for a few seconds. â€” Correct! So I must invent a scheme for going from 1033 to 8179 by a path of prime numbers where only one digit is changed from one prime to the next prime.\nNow, the minister of finance, who had been eavesdropping, intervened. â€” No unnecessary expenditure, please! I happen to know that the price of a digit is one pound. â€” Hmm, in that case I need a computer program to minimize the cost. You don\u0026rsquo;t know some very cheap software gurus, do you? â€” In fact, I do. You see, there is this programming contest going on\u0026hellip; Help the prime minister to find the cheapest prime path between any two given four-digit primes! The first digit must be nonzero, of course. Here is a solution in the case above.\nâ€‹ 1033 â€‹ 1733 â€‹ 3733 â€‹ 3739 â€‹ 3779 â€‹ 8779 â€‹ 8179\nThe cost of this solution is 6 pounds. Note that the digit 1 which got pasted over in step 2 can not be reused in the last step â€“ a new 1 must be purchased.\nè¾“å…¥ One line with a positive number: the number of test cases (at most 100). Then for each test case, one line with two numbers separated by a blank. Both numbers are four-digit primes (without leading zeros).\nè¾“å‡º One line for each case, either with a number stating the minimal cost or containing the word Impossible.\næ ·ä¾‹è¾“å…¥ 13 21033 8179 31373 8017 41033 1033 æ ·ä¾‹è¾“å‡º 16 27 30 æç¤º æ— \næ€è·¯ æ¬§æ‹‰ç­›æ‰“è¡¨ï¼Œæšä¸¾æ¯ä¸€ä½çš„å˜åŒ–ï¼Œæ³¨æ„å¤§äº2çš„å¶æ•°ä¸æ˜¯è´¨æ•°\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e5+5; 5 6bool isp[N] = {0}; 7bool vis[N] = {0}; 8int n, s, e; 9 10struct P { 11 int x; 12 int step; 13}; 14 15void euler() { 16 int p[N], m=0; 17 for(int i=2; i\u0026lt;=N; i++) { 18 if(!isp[i]) 19 p[m++] = i; 20 for(int j=0; j\u0026lt;m; j++) { 21 if(p[j]*i\u0026gt;N) 22 break; 23 isp[p[j]*i] = 1; 24 if(i%p[j]==0) 25 break; 26 } 27 } 28} 29 30int bfs() { 31 memset(vis, 0, sizeof(vis)); 32 33 P sp; 34 sp.x = s; 35 sp.step = 0; 36 37 queue\u0026lt;P\u0026gt; q; 38 q.push(sp); 39 vis[sp.x] = 1; 40 41 while(!q.empty()) { 42 P tp = q.front(); 43 q.pop(); 44 45 if(tp.x==e) { 46 return tp.step; 47 } 48 P np = tp; 49 np.step = tp.step+1; 50 51 for(int i=1; i\u0026lt;=9; i+=2) { 52 np.x = tp.x/10*10 + i; 53 if(np.x!=tp.x \u0026amp;\u0026amp; !vis[np.x] \u0026amp;\u0026amp; !isp[np.x]) { 54 q.push(np); 55 vis[np.x] = 1; 56 } 57 } 58 for(int i=0; i\u0026lt;=9; i++) { 59 np.x = tp.x/100*100 + i*10 + tp.x%10; 60 if(np.x!=tp.x \u0026amp;\u0026amp; !vis[np.x] \u0026amp;\u0026amp; !isp[np.x]) { 61 q.push(np); 62 vis[np.x] = 1; 63 } 64 } 65 for(int i=0; i\u0026lt;=9; i++) { 66 np.x = tp.x/1000*1000 + i*100 + tp.x%100; 67 if(np.x!=tp.x \u0026amp;\u0026amp; !vis[np.x] \u0026amp;\u0026amp; !isp[np.x]) { 68 q.push(np); 69 vis[np.x] = 1; 70 } 71 } 72 for(int i=1; i\u0026lt;=9; i++) { 73 np.x = i*1000 + tp.x%1000; 74 if(np.x!=tp.x \u0026amp;\u0026amp; !vis[np.x] \u0026amp;\u0026amp; !isp[np.x]) { 75 q.push(np); 76 vis[np.x] = 1; 77 } 78 } 79 } 80 return 0; 81} 82 83int main(void) { 84 euler(); 85 scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); 86 for(int i=0; i\u0026lt;n; i++) { 87 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;s, \u0026amp;e); 88 printf(\u0026#34;%d\\n\u0026#34;, bfs()); 89 } 90 return 0; 91} ","permalink":"https://blog.lordash.de/posts/solution/poj-3126-prime-path/","summary":"Prime Path (POJ - 3126) é¢˜é¢ The ministers of the cabinet were quite upset by the message from the Chief of Security stating that they would all have to change the four-digit room numbers on their offices. â€” It is a matter of security to change such things every now and then, to keep the enemy in the dark. â€” But look, I have chosen my number 1033 for","title":"POJ-3126 Prime Path"},{"content":"Find The Multiple (POJ - 1426) é¢˜é¢ Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits.\nè¾“å…¥ The input file may contain multiple test cases. Each line contains a value of n (1 \u0026lt;= n \u0026lt;= 200). A line containing a zero terminates the input.\nè¾“å‡º For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable.\næ ·ä¾‹è¾“å…¥ 12 26 319 40 æ ·ä¾‹è¾“å‡º 110 2100100100100100100 3111111111111111111 æç¤º æ— \næ€è·¯ ä¸€ç»´bfs\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 15+5; 5 6int n; 7 8void bfs() { 9 queue\u0026lt;ll\u0026gt; q; 10 q.push(1); 11 while(!q.empty()) { 12 ll t = q.front(); 13 q.pop(); 14 if(t%n==0) { 15 printf(\u0026#34;%lld\\n\u0026#34;, t); 16 return ; 17 } 18 q.push(t*10); 19 q.push(t*10+1); 20 } 21} 22 23int main(void) { 24 25 while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)==1 \u0026amp;\u0026amp; n) { 26 bfs(); 27 } 28 return 0; 29} ","permalink":"https://blog.lordash.de/posts/solution/poj-1426-find-the-multiple/","summary":"Find The Multiple (POJ - 1426) é¢˜é¢ Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits. è¾“å…¥ The input file may contain multiple test cases. Each line","title":"POJ-1426 Find The Multiple"},{"content":"Fliptile (POJ - 3279) é¢˜é¢ Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M Ã— N grid (1 â‰¤ M â‰¤ 15; 1 â‰¤ N â‰¤ 15) of square tiles, each of which is colored black on one side and white on the other side.\nAs one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.\nHelp the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word \u0026ldquo;IMPOSSIBLE\u0026rdquo;.\nè¾“å…¥ Line 1: Two space-separated integers: M and N Lines 2.. M+1: Line i+1 describes the colors (left to right) of row i of the grid with N space-separated integers which are 1 for black and 0 for white\nè¾“å‡º Lines 1.. M: Each line contains N space-separated integers, each specifying how many times to flip that particular location.\næ ·ä¾‹è¾“å…¥ 14 4 21 0 0 1 30 1 1 0 40 1 1 0 51 0 0 1 æ ·ä¾‹è¾“å‡º 10 0 0 0 21 0 0 1 31 0 0 1 40 0 0 0 æç¤º æ— \næ€è·¯ å¼€å…³é—®é¢˜ï¼ŒäºŒè¿›åˆ¶æšä¸¾ç¬¬ä¸€è¡Œå¼€å…³æƒ…å†µ\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 15+5; 5 6int b[N][N] = {{0}}, c[N][N] = {{0}}, a[N][N] = {{0}}; 7int n, m, ans = inf; 8 9int dx[]= { 1, -1, 0, 0, 0}; 10int dy[]= { 0, 0, 1, -1, 0}; 11 12int isb(int x, int y) { 13 int t = b[x][y]; 14 for(int i=0; i\u0026lt;5; i++) { 15 int xi = x+dx[i]; 16 int yi = y+dy[i]; 17 18 if(xi\u0026lt;0 || xi\u0026gt;=n || yi\u0026lt;0 || yi\u0026gt;=m) { 19 continue; 20 } 21 t += c[xi][yi]; 22 } 23 return t%2; 24} 25 26int dfs() { 27 for(int i=1; i\u0026lt;n; i++) 28 for(int j=0; j\u0026lt;m; j++) 29 if(isb(i-1,j)) 30 c[i][j] = 1; 31 32 for(int i=0; i\u0026lt;m; i++) 33 if(isb(n-1,i)) 34 return -1; 35 36 int res=0; 37 for(int i=0; i\u0026lt;n; i++) 38 for(int j=0; j\u0026lt;m; j++) 39 res += c[i][j]; 40 41 return res; 42} 43 44int main(void) { 45 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m)==2) { 46 47 for(int i=0; i\u0026lt;n; i++) { 48 for(int j=0; j\u0026lt;m; j++) { 49 scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i][j]); 50 } 51 } 52 for(int i=0; i\u0026lt;(1\u0026lt;\u0026lt;m); i++) { 53 memset(c, 0, sizeof(c)); 54 for(int j=0; j\u0026lt;m; j++) { 55 c[0][m-j-1] = i\u0026gt;\u0026gt;j\u0026amp;1; 56 } 57 int res = dfs(); 58 if(res\u0026gt;=0 \u0026amp;\u0026amp; res\u0026lt;ans) { 59 ans = res; 60 memcpy(a, c, sizeof(c)); 61 } 62 } 63 if(ans==inf) { 64 printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); 65 } else { 66 for(int i=0; i\u0026lt;n; i++) { 67 for(int j=0; j\u0026lt;m; j++) { 68 printf(\u0026#34;%d \u0026#34;, a[i][j]); 69 } 70 printf(\u0026#34;\\n\u0026#34;); 71 } 72 } 73 } 74 return 0; 75} ","permalink":"https://blog.lordash.de/posts/solution/poj-3279-fliptile/","summary":"Fliptile (POJ - 3279) é¢˜é¢ Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an M Ã— N grid (1 â‰¤ M â‰¤ 15; 1 â‰¤ N â‰¤ 15) of square tiles, each of which is colored black on one side and white on the other side. As one","title":"POJ-3279 Fliptile"},{"content":"Catch That Cow (POJ - 3278) é¢˜é¢ Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 â‰¤ N â‰¤ 100,000) on a number line and the cow is at a point K (0 â‰¤ K â‰¤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.\n* Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute * Teleporting: FJ can move from any point X to the point 2 Ã— X in a single minute.\nIf the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?\nè¾“å…¥ Line 1: Two space-separated integers: N and K\nè¾“å‡º Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.\næ ·ä¾‹è¾“å…¥ 15 17 æ ·ä¾‹è¾“å‡º 14 æç¤º The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.\næ€è·¯ ä¸€ç»´bfsï¼Œæ³¨æ„å‰ªæ\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 1e5+5; 5 6bool vis[N] = {0}; 7int n, k, ans = 0; 8 9struct P { 10 int x; 11 int step; 12}; 13 14int bfs() { 15 memset(vis, 0, sizeof(vis)); 16 17 P sp; 18 sp.x = n; 19 sp.step = 0; 20 21 queue\u0026lt;P\u0026gt; q; 22 q.push(sp); 23 vis[sp.x] = 1; 24 25 while(!q.empty()) { 26 P tp = q.front(); 27 q.pop(); 28 29 if(tp.x==k) { 30 return tp.step; 31 } 32 33 P np = tp; 34 35 np.x = tp.x - 1; 36 if(np.x\u0026gt;=0 \u0026amp;\u0026amp; !vis[np.x]) { 37 np.step = tp.step+1; 38 q.push(np); 39 vis[np.x] = 1; 40 } 41 42 np.x = tp.x + 1; 43 if(np.x\u0026lt;=N \u0026amp;\u0026amp; !vis[np.x]) { 44 np.step = tp.step+1; 45 q.push(np); 46 vis[np.x] = 1; 47 } 48 49 np.x = tp.x * 2; 50 if(np.x\u0026lt;=N \u0026amp;\u0026amp; !vis[np.x]) { 51 np.step = tp.step+1; 52 q.push(np); 53 vis[np.x] = 1; 54 } 55 } 56 return 0; 57} 58 59int main(void) { 60 scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); 61 62 if(n\u0026gt;k) 63 ans = n-k; 64 else 65 ans = bfs(); 66 67 printf(\u0026#34;%d\\n\u0026#34;, ans); 68 return 0; 69} ","permalink":"https://blog.lordash.de/posts/solution/poj-3278-catch-that-cow/","summary":"Catch That Cow (POJ - 3278) é¢˜é¢ Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 â‰¤ N â‰¤ 100,000) on a number line and the cow is at a point K (0 â‰¤ K â‰¤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. *","title":"POJ-3278 Catch That Cow"},{"content":"Dungeon Master (POJ - 2251) é¢˜é¢ You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.\nIs an escape possible? If yes, how long will it take?\nè¾“å…¥ The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size). L is the number of levels making up the dungeon. R and C are the number of rows and columns making up the plan of each level. Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a \u0026lsquo;#\u0026rsquo; and empty cells are represented by a \u0026lsquo;.\u0026rsquo;. Your starting position is indicated by \u0026lsquo;S\u0026rsquo; and the exit by the letter \u0026lsquo;E\u0026rsquo;. There\u0026rsquo;s a single blank line after each level. Input is terminated by three zeroes for L, R and C.\nè¾“å‡º Each maze generates one line of output. If it is possible to reach the exit, print a line of the form\nEscaped in x minute(s). where x is replaced by the shortest time it takes to escape. If it is not possible to escape, print the line\nTrapped! æ ·ä¾‹è¾“å…¥ 13 4 5 2S.... 3.###. 4.##.. 5###.# 6 7##### 8##### 9##.## 10##... 11 12##### 13##### 14#.### 15####E 16 171 3 3 18S## 19#E# 20### 21 220 0 0 æ ·ä¾‹è¾“å‡º 1Escaped in 11 minute(s). 2Trapped! æç¤º æ— \næ€è·¯ å…­ä¸ªæ–¹å‘ï¼Œbfså³å¯\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 30+5; 5 6char b[N][N][N] = {{{0}}}; 7bool vis[N][N][N] = {{{0}}}; 8int l, r, c, ans = 0; 9 10int dx[] = { 1, -1, 0, 0, 0, 0}; 11int dy[] = { 0, 0, 1, -1, 0, 0}; 12int dz[] = { 0, 0, 0, 0, 1, -1}; 13 14struct P { 15 int z, x, y; 16 int step; 17}; 18P sp; 19 20bool bfs() { 21 memset(vis, 0, sizeof(vis)); 22 23 sp.step = 0; 24 25 queue\u0026lt;P\u0026gt; q; 26 q.push(sp); 27 vis[sp.z][sp.x][sp.y] = 1; 28 29 while(!q.empty()) { 30 P tp = q.front(); 31 q.pop(); 32 33 P np = tp; 34 35 for(int i=0; i\u0026lt;6; i++) { 36 int z = np.z = tp.z+dz[i]; 37 int x = np.x = tp.x+dx[i]; 38 int y = np.y = tp.y+dy[i]; 39 np.step = tp.step+1; 40 41 if(z\u0026lt;0 || z\u0026gt;=l || x\u0026lt;0 || x\u0026gt;=r || y\u0026lt;0 || y\u0026gt;=c) { 42 continue; 43 } 44 if(b[z][x][y]==\u0026#39;#\u0026#39;) { 45 continue; 46 } 47 if(b[z][x][y]==\u0026#39;E\u0026#39;) { 48 ans = np.step; 49 return true; 50 } 51 if(b[z][x][y]==\u0026#39;.\u0026#39; \u0026amp;\u0026amp; vis[z][x][y]==false) { 52 vis[z][x][y] = true; 53 q.push(np); 54 } 55 } 56 } 57 return false; 58} 59 60int main(void) { 61 while(scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;c)==3 \u0026amp;\u0026amp; l \u0026amp;\u0026amp; r \u0026amp;\u0026amp; c) { 62 ans = 0; 63 64 for(int i=0; i\u0026lt;l; i++) { 65 for(int j=0; j\u0026lt;r; j++) { 66 for(int k=0; k\u0026lt;c; k++) { 67 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j][k]); 68 if(b[i][j][k]==\u0026#39;S\u0026#39;) { 69 sp.z = i; 70 sp.x = j; 71 sp.y = k; 72 } 73 } 74 } 75 } 76 if(bfs()) 77 printf(\u0026#34;Escaped in %d minute(s).\\n\u0026#34;, ans); 78 else 79 printf(\u0026#34;Trapped!\\n\u0026#34;); 80 } 81 return 0; 82} ","permalink":"https://blog.lordash.de/posts/solution/poj-2251-dungeon-master/","summary":"Dungeon Master (POJ - 2251) é¢˜é¢ You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides. Is an","title":"POJ-2251 Dungeon Master"},{"content":"æ£‹ç›˜é—®é¢˜ (POJ - 1321) é¢˜é¢ åœ¨ä¸€ä¸ªç»™å®šå½¢çŠ¶çš„æ£‹ç›˜ï¼ˆå½¢çŠ¶å¯èƒ½æ˜¯ä¸è§„åˆ™çš„ï¼‰ä¸Šé¢æ‘†æ”¾æ£‹å­ï¼Œæ£‹å­æ²¡æœ‰åŒºåˆ«ã€‚è¦æ±‚æ‘†æ”¾æ—¶ä»»æ„çš„ä¸¤ä¸ªæ£‹å­ä¸èƒ½æ”¾åœ¨æ£‹ç›˜ä¸­çš„åŒä¸€è¡Œæˆ–è€…åŒä¸€åˆ—ï¼Œè¯·ç¼–ç¨‹æ±‚è§£å¯¹äºç»™å®šå½¢çŠ¶å’Œå¤§å°çš„æ£‹ç›˜ï¼Œæ‘†æ”¾kä¸ªæ£‹å­çš„æ‰€æœ‰å¯è¡Œçš„æ‘†æ”¾æ–¹æ¡ˆCã€‚\nè¾“å…¥ è¾“å…¥å«æœ‰å¤šç»„æµ‹è¯•æ•°æ®ã€‚ æ¯ç»„æ•°æ®çš„ç¬¬ä¸€è¡Œæ˜¯ä¸¤ä¸ªæ­£æ•´æ•°ï¼Œn kï¼Œç”¨ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œè¡¨ç¤ºäº†å°†åœ¨ä¸€ä¸ªn*nçš„çŸ©é˜µå†…æè¿°æ£‹ç›˜ï¼Œä»¥åŠæ‘†æ”¾æ£‹å­çš„æ•°ç›®ã€‚ n \u0026lt;= 8 , k \u0026lt;= n å½“ä¸º-1 -1æ—¶è¡¨ç¤ºè¾“å…¥ç»“æŸã€‚ éšåçš„nè¡Œæè¿°äº†æ£‹ç›˜çš„å½¢çŠ¶ï¼šæ¯è¡Œæœ‰nä¸ªå­—ç¬¦ï¼Œå…¶ä¸­ # è¡¨ç¤ºæ£‹ç›˜åŒºåŸŸï¼Œ . è¡¨ç¤ºç©ºç™½åŒºåŸŸï¼ˆæ•°æ®ä¿è¯ä¸å‡ºç°å¤šä½™çš„ç©ºç™½è¡Œæˆ–è€…ç©ºç™½åˆ—ï¼‰ã€‚\nè¾“å‡º å¯¹äºæ¯ä¸€ç»„æ•°æ®ï¼Œç»™å‡ºä¸€è¡Œè¾“å‡ºï¼Œè¾“å‡ºæ‘†æ”¾çš„æ–¹æ¡ˆæ•°ç›®C ï¼ˆæ•°æ®ä¿è¯C\u0026lt;2^31ï¼‰ã€‚\næ ·ä¾‹è¾“å…¥ 12 1 2#. 3.# 44 4 5...# 6..#. 7.#.. 8#... 9-1 -1 æ ·ä¾‹è¾“å‡º 12 21 æç¤º æ— \næ€è·¯ æŒ‰è¡Œè®¨è®ºï¼Œä¿å­˜åˆ—çš„è®¿é—®çŠ¶æ€\nä»£ç  1using namespace std; 2typedef long long ll; 3const int inf = 0x3f3f3f3f; 4const int N = 8; 5 6char b[N][N] = {0}; 7bool vis[N] = {0}; 8int n, k, ans = 0; 9 10void dfs(int x, int cnt) { 11 if(cnt\u0026gt;=k) { 12 ans++; 13 return ; 14 } 15 for(int i=x; i\u0026lt;n; i++) { 16 for(int j=0; j\u0026lt;n; j++) { 17 if(b[i][j]==\u0026#39;#\u0026#39; \u0026amp;\u0026amp; !vis[j]) { 18 vis[j] = true; 19 dfs(i+1, cnt+1); 20 vis[j] = false; 21 } 22 } 23 } 24} 25 26int main(void) { 27 while(scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k)==2 \u0026amp;\u0026amp; n!=-1 \u0026amp;\u0026amp; k!=-1) { 28 ans = 0; 29 memset(vis, 0, sizeof(vis)); 30 31 for(int i=0; i\u0026lt;n; i++) 32 for(int j=0; j\u0026lt;n; j++) 33 scanf(\u0026#34; %c\u0026#34;, \u0026amp;b[i][j]); 34 35 dfs(0, 0); 36 printf(\u0026#34;%d\\n\u0026#34;, ans); 37 } 38 return 0; 39} ","permalink":"https://blog.lordash.de/posts/solution/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98/","summary":"æ£‹ç›˜é—®é¢˜ (POJ - 1321) é¢˜é¢ åœ¨ä¸€ä¸ªç»™å®šå½¢çŠ¶çš„æ£‹ç›˜ï¼ˆå½¢çŠ¶å¯èƒ½æ˜¯ä¸è§„åˆ™çš„ï¼‰ä¸Šé¢æ‘†æ”¾æ£‹å­ï¼Œæ£‹å­æ²¡æœ‰åŒºåˆ«ã€‚è¦æ±‚æ‘†æ”¾æ—¶ä»»æ„çš„ä¸¤ä¸ªæ£‹å­ä¸èƒ½æ”¾åœ¨æ£‹ç›˜ä¸­çš„åŒä¸€è¡Œæˆ–è€…åŒ","title":"POJ-1321 æ£‹ç›˜é—®é¢˜"},{"content":"ä¸€ã€å‡†å¤‡ å¸è½½å·²å­˜åœ¨çš„MySQL\n1# rpm -qa | grep -i mysql 1# rpm -e --nodeps PackageName äºMySQLå®˜ç½‘æ ¹æ®éœ€è¦ä¸‹è½½ï¼Œå‚è€ƒé“¾æ¥ï¼š\nmysql80-community-release-el7-3.noarch.rpm mysql-connector-java-8.0.16-1.el7.noarch.rpm äºŒã€MySQL é…ç½® æ›´æ–°MySQLçš„yumæº\n1# rpm -ivh mysql80-community-release-el7-3.noarch.rpm yumå®‰è£…\n1# yum install mysql-community-server æµ‹è¯• å¯åŠ¨MySQLæœåŠ¡\n1# systemctl start mysqld.service æŸ¥çœ‹MySQLçš„åˆå§‹å¯†ç \n1# grep \u0026#39;password\u0026#39; /var/log/mysqld.log ç™»å½•\n1# mysql -uroot -p ä¿®æ”¹å¯†ç \n1mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;new password\u0026#39;; ä½¿ç”¨ç®€å•å¯†ç åˆ™éœ€è¦å…ˆæ‰§è¡Œä»¥ä¸‹ä¸¤æ¡\n1mysql\u0026gt; set global validate_password_policy=0; 2mysql\u0026gt; set global validate_password_length=1; exité€€å‡ºåå³å¯ä½¿ç”¨æ–°å¯†ç é‡æ–°ç™»å½•\né™„ä¸Š: å…³é—­MySQLæœåŠ¡\n1# systemctl stop mysqld.service MySQLçš„yumæºç§»é™¤\n1# yum remove mysql80-community-release-el7-3.noarch.rpm ä¸‰ã€JDBC é…ç½® å°† mysql-connector-java-8.0.16-1.el7.noarch.rpm è§£å‹ï¼Œæ‰¾åˆ° mysql-connector-java.jarï¼Œå°†jarç½®äºjavaçš„libç›®å½•ä¸‹/extä¸­ã€‚ä»¥æœ¬æœºä¸ºå‚è€ƒï¼Œç›®å½•æ˜¯ï¼š/usr/lib/jvm/jre/lib/ext/\næµ‹è¯• å†™ä¸€ä¸ªç®€å•æµ‹è¯• test.javaå¦‚ä¸‹ï¼Œç¼–è¯‘è¿è¡ŒæŸ¥çœ‹ç»“æœå³å¯ã€‚\n1import java.sql.*; 2public class test { 3 public static void main(String[] args) { 4 try { 5 //Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); 6 String url = \u0026#34;jdbc:mysql://localhost\u0026#34;; 7 Connection con = DriverManager.getConnection(url, \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34;); 8 if (con != null) { 9 System.out.println(\u0026#34;success...\u0026#34;); 10 con.close(); 11 } 12 else { 13 System.out.println(\u0026#34;failure!!!\u0026#34;); 14 } 15 } 16 catch (ClassNotFoundException e) { 17 e.printStackTrace(); 18 } 19 catch (SQLException e) { 20 e.printStackTrace(); 21 } 22 } 23} ","permalink":"https://blog.lordash.de/posts/configure/8f2d9aaab8294818/","summary":"ä¸€ã€å‡†å¤‡ å¸è½½å·²å­˜åœ¨çš„MySQL 1# rpm -qa | grep -i mysql 1# rpm -e --nodeps PackageName äºMySQLå®˜ç½‘æ ¹æ®éœ€è¦ä¸‹è½½ï¼Œå‚è€ƒé“¾æ¥ï¼š mysql80-community-release-el7-3.noarch.rpm mysql-connector-java-8.0.16-1.el7.noarch.rpm äºŒã€MySQL é…ç½® æ›´æ–°MySQLçš„yumæº","title":"CentOS7é…ç½®MySQLå’ŒJDBC"}]